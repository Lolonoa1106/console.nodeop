(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [8129],
  {
    83199: function (e, t, r) {
      "use strict";
      r.d(t, {
        V: function () {
          return d;
        },
      });
      var i = (function () {
          function e() {}
          return (
            (e.prototype.getApplicationContext = function () {
              return {
                versionName: this.versionName,
                language: n(),
                platform: "Web",
                os: void 0,
                deviceModel: void 0,
              };
            }),
            e
          );
        })(),
        n = function () {
          return (
            ("undefined" != typeof navigator &&
              ((navigator.languages && navigator.languages[0]) ||
                navigator.language)) ||
            ""
          );
        },
        s = (function () {
          function e() {
            this.queue = [];
          }
          return (
            (e.prototype.logEvent = function (e) {
              this.receiver
                ? this.receiver(e)
                : this.queue.length < 512 && this.queue.push(e);
            }),
            (e.prototype.setEventReceiver = function (e) {
              (this.receiver = e),
                this.queue.length > 0 &&
                  (this.queue.forEach(function (t) {
                    e(t);
                  }),
                  (this.queue = []));
            }),
            e
          );
        })(),
        a = function () {
          return (a =
            Object.assign ||
            function (e) {
              for (var t, r = 1, i = arguments.length; r < i; r++)
                for (var n in (t = arguments[r]))
                  Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
              return e;
            }).apply(this, arguments);
        };
      function o(e) {
        var t = "function" == typeof Symbol && Symbol.iterator,
          r = t && e[t],
          i = 0;
        if (r) return r.call(e);
        if (e && "number" == typeof e.length)
          return {
            next: function () {
              return (
                e && i >= e.length && (e = void 0),
                { value: e && e[i++], done: !e }
              );
            },
          };
        throw TypeError(
          t ? "Object is not iterable." : "Symbol.iterator is not defined."
        );
      }
      function l(e, t) {
        var r = "function" == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var i,
          n,
          s = r.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(i = s.next()).done; )
            a.push(i.value);
        } catch (e) {
          n = { error: e };
        } finally {
          try {
            i && !i.done && (r = s.return) && r.call(s);
          } finally {
            if (n) throw n.error;
          }
        }
        return a;
      }
      "function" == typeof SuppressedError && SuppressedError;
      var c = function (e, t) {
        var r,
          i,
          n = typeof e;
        if (n !== typeof t) return !1;
        try {
          for (
            var s = o(["string", "number", "boolean", "undefined"]),
              a = s.next();
            !a.done;
            a = s.next()
          )
            if (a.value === n) return e === t;
        } catch (e) {
          r = { error: e };
        } finally {
          try {
            a && !a.done && (i = s.return) && i.call(s);
          } finally {
            if (r) throw r.error;
          }
        }
        if (null == e && null == t) return !0;
        if (null == e || null == t || e.length !== t.length) return !1;
        var l = Array.isArray(e),
          u = Array.isArray(t);
        if (l !== u) return !1;
        if (l && u) {
          for (var h = 0; h < e.length; h++) if (!c(e[h], t[h])) return !1;
        } else {
          if (!c(Object.keys(e).sort(), Object.keys(t).sort())) return !1;
          var d = !0;
          return (
            Object.keys(e).forEach(function (r) {
              c(e[r], t[r]) || (d = !1);
            }),
            d
          );
        }
        return !0;
      };
      Object.entries ||
        (Object.entries = function (e) {
          for (var t = Object.keys(e), r = t.length, i = Array(r); r--; )
            i[r] = [t[r], e[t[r]]];
          return i;
        });
      var u = (function () {
          function e() {
            (this.identity = { userProperties: {} }),
              (this.listeners = new Set());
          }
          return (
            (e.prototype.editIdentity = function () {
              var e = this,
                t = a({}, this.identity.userProperties),
                r = a(a({}, this.identity), { userProperties: t });
              return {
                setUserId: function (e) {
                  return (r.userId = e), this;
                },
                setDeviceId: function (e) {
                  return (r.deviceId = e), this;
                },
                setUserProperties: function (e) {
                  return (r.userProperties = e), this;
                },
                setOptOut: function (e) {
                  return (r.optOut = e), this;
                },
                updateUserProperties: function (e) {
                  var t,
                    i,
                    n,
                    s,
                    a,
                    c,
                    u = r.userProperties || {};
                  try {
                    for (
                      var h = o(Object.entries(e)), d = h.next();
                      !d.done;
                      d = h.next()
                    ) {
                      var p = l(d.value, 2),
                        f = p[0],
                        g = p[1];
                      switch (f) {
                        case "$set":
                          try {
                            for (
                              var m = ((n = void 0), o(Object.entries(g))),
                                y = m.next();
                              !y.done;
                              y = m.next()
                            ) {
                              var w = l(y.value, 2),
                                b = w[0],
                                v = w[1];
                              u[b] = v;
                            }
                          } catch (e) {
                            n = { error: e };
                          } finally {
                            try {
                              y && !y.done && (s = m.return) && s.call(m);
                            } finally {
                              if (n) throw n.error;
                            }
                          }
                          break;
                        case "$unset":
                          try {
                            for (
                              var E = ((a = void 0), o(Object.keys(g))),
                                A = E.next();
                              !A.done;
                              A = E.next()
                            ) {
                              var b = A.value;
                              delete u[b];
                            }
                          } catch (e) {
                            a = { error: e };
                          } finally {
                            try {
                              A && !A.done && (c = E.return) && c.call(E);
                            } finally {
                              if (a) throw a.error;
                            }
                          }
                          break;
                        case "$clearAll":
                          u = {};
                      }
                    }
                  } catch (e) {
                    t = { error: e };
                  } finally {
                    try {
                      d && !d.done && (i = h.return) && i.call(h);
                    } finally {
                      if (t) throw t.error;
                    }
                  }
                  return (r.userProperties = u), this;
                },
                commit: function () {
                  return e.setIdentity(r), this;
                },
              };
            }),
            (e.prototype.getIdentity = function () {
              return a({}, this.identity);
            }),
            (e.prototype.setIdentity = function (e) {
              var t = a({}, this.identity);
              (this.identity = a({}, e)),
                c(t, this.identity) ||
                  this.listeners.forEach(function (t) {
                    t(e);
                  });
            }),
            (e.prototype.addIdentityListener = function (e) {
              this.listeners.add(e);
            }),
            (e.prototype.removeIdentityListener = function (e) {
              this.listeners.delete(e);
            }),
            e
          );
        })(),
        h =
          "undefined" != typeof globalThis
            ? globalThis
            : void 0 !== r.g
            ? r.g
            : self,
        d = (function () {
          function e() {
            (this.identityStore = new u()),
              (this.eventBridge = new s()),
              (this.applicationContextProvider = new i());
          }
          return (
            (e.getInstance = function (t) {
              return (
                h.analyticsConnectorInstances ||
                  (h.analyticsConnectorInstances = {}),
                h.analyticsConnectorInstances[t] ||
                  (h.analyticsConnectorInstances[t] = new e()),
                h.analyticsConnectorInstances[t]
              );
            }),
            e
          );
        })();
    },
    60915: function (e, t, r) {
      var i;
      !(function (n, s) {
        "use strict";
        var a = "function",
          o = "undefined",
          l = "object",
          c = "string",
          u = "model",
          h = "name",
          d = "type",
          p = "vendor",
          f = "version",
          g = "architecture",
          m = "console",
          y = "mobile",
          w = "tablet",
          b = "smarttv",
          v = "wearable",
          E = "embedded",
          A = "Amazon",
          C = "Apple",
          _ = "ASUS",
          I = "BlackBerry",
          N = "Browser",
          S = "Chrome",
          T = "Firefox",
          P = "Google",
          O = "Huawei",
          x = "Microsoft",
          k = "Motorola",
          R = "Opera",
          D = "Samsung",
          U = "Sharp",
          L = "Sony",
          M = "Xiaomi",
          B = "Zebra",
          j = "Facebook",
          F = function (e, t) {
            var r = {};
            for (var i in e)
              t[i] && t[i].length % 2 == 0
                ? (r[i] = t[i].concat(e[i]))
                : (r[i] = e[i]);
            return r;
          },
          $ = function (e) {
            for (var t = {}, r = 0; r < e.length; r++)
              t[e[r].toUpperCase()] = e[r];
            return t;
          },
          H = function (e, t) {
            return typeof e === c && -1 !== z(t).indexOf(z(e));
          },
          z = function (e) {
            return e.toLowerCase();
          },
          q = function (e, t) {
            if (typeof e === c)
              return (
                (e = e.replace(/^\s\s*/, "")),
                typeof t === o ? e : e.substring(0, 350)
              );
          },
          V = function (e, t) {
            for (var r, i, n, o, c, u, h = 0; h < t.length && !c; ) {
              var d = t[h],
                p = t[h + 1];
              for (r = i = 0; r < d.length && !c; )
                if ((c = d[r++].exec(e)))
                  for (n = 0; n < p.length; n++)
                    (u = c[++i]),
                      typeof (o = p[n]) === l && o.length > 0
                        ? 2 === o.length
                          ? typeof o[1] == a
                            ? (this[o[0]] = o[1].call(this, u))
                            : (this[o[0]] = o[1])
                          : 3 === o.length
                          ? typeof o[1] !== a || (o[1].exec && o[1].test)
                            ? (this[o[0]] = u ? u.replace(o[1], o[2]) : void 0)
                            : (this[o[0]] = u
                                ? o[1].call(this, u, o[2])
                                : void 0)
                          : 4 === o.length &&
                            (this[o[0]] = u
                              ? o[3].call(this, u.replace(o[1], o[2]))
                              : void 0)
                        : (this[o] = u || s);
              h += 2;
            }
          },
          G = function (e, t) {
            for (var r in t)
              if (typeof t[r] === l && t[r].length > 0) {
                for (var i = 0; i < t[r].length; i++)
                  if (H(t[r][i], e)) return "?" === r ? s : r;
              } else if (H(t[r], e)) return "?" === r ? s : r;
            return e;
          },
          W = {
            ME: "4.90",
            "NT 3.11": "NT3.51",
            "NT 4.0": "NT4.0",
            2e3: "NT 5.0",
            XP: ["NT 5.1", "NT 5.2"],
            Vista: "NT 6.0",
            7: "NT 6.1",
            8: "NT 6.2",
            8.1: "NT 6.3",
            10: ["NT 6.4", "NT 10.0"],
            RT: "ARM",
          },
          K = {
            browser: [
              [/\b(?:crmo|crios)\/([\w\.]+)/i],
              [f, [h, "Chrome"]],
              [/edg(?:e|ios|a)?\/([\w\.]+)/i],
              [f, [h, "Edge"]],
              [
                /(opera mini)\/([-\w\.]+)/i,
                /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
                /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i,
              ],
              [h, f],
              [/opios[\/ ]+([\w\.]+)/i],
              [f, [h, R + " Mini"]],
              [/\bopr\/([\w\.]+)/i],
              [f, [h, R]],
              [
                /(kindle)\/([\w\.]+)/i,
                /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
                /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,
                /(ba?idubrowser)[\/ ]?([\w\.]+)/i,
                /(?:ms|\()(ie) ([\w\.]+)/i,
                /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
                /(weibo)__([\d\.]+)/i,
              ],
              [h, f],
              [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i],
              [f, [h, "UC" + N]],
              [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i],
              [f, [h, "WeChat(Win) Desktop"]],
              [/micromessenger\/([\w\.]+)/i],
              [f, [h, "WeChat"]],
              [/konqueror\/([\w\.]+)/i],
              [f, [h, "Konqueror"]],
              [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i],
              [f, [h, "IE"]],
              [/yabrowser\/([\w\.]+)/i],
              [f, [h, "Yandex"]],
              [/(avast|avg)\/([\w\.]+)/i],
              [[h, /(.+)/, "$1 Secure " + N], f],
              [/\bfocus\/([\w\.]+)/i],
              [f, [h, T + " Focus"]],
              [/\bopt\/([\w\.]+)/i],
              [f, [h, R + " Touch"]],
              [/coc_coc\w+\/([\w\.]+)/i],
              [f, [h, "Coc Coc"]],
              [/dolfin\/([\w\.]+)/i],
              [f, [h, "Dolphin"]],
              [/coast\/([\w\.]+)/i],
              [f, [h, R + " Coast"]],
              [/miuibrowser\/([\w\.]+)/i],
              [f, [h, "MIUI " + N]],
              [/fxios\/([-\w\.]+)/i],
              [f, [h, T]],
              [/\bqihu|(qi?ho?o?|360)browser/i],
              [[h, "360 " + N]],
              [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i],
              [[h, /(.+)/, "$1 " + N], f],
              [/(comodo_dragon)\/([\w\.]+)/i],
              [[h, /_/g, " "], f],
              [
                /(electron)\/([\w\.]+) safari/i,
                /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
                /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i,
              ],
              [h, f],
              [
                /(metasr)[\/ ]?([\w\.]+)/i,
                /(lbbrowser)/i,
                /\[(linkedin)app\]/i,
              ],
              [h],
              [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i],
              [[h, j], f],
              [
                /safari (line)\/([\w\.]+)/i,
                /\b(line)\/([\w\.]+)\/iab/i,
                /(chromium|instagram)[\/ ]([-\w\.]+)/i,
              ],
              [h, f],
              [/\bgsa\/([\w\.]+) .*safari\//i],
              [f, [h, "GSA"]],
              [/headlesschrome(?:\/([\w\.]+)| )/i],
              [f, [h, S + " Headless"]],
              [/ wv\).+(chrome)\/([\w\.]+)/i],
              [[h, S + " WebView"], f],
              [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i],
              [f, [h, "Android " + N]],
              [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i],
              [h, f],
              [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i],
              [f, [h, "Mobile Safari"]],
              [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i],
              [f, h],
              [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i],
              [
                h,
                [
                  f,
                  G,
                  {
                    "1.0": "/8",
                    1.2: "/1",
                    1.3: "/3",
                    "2.0": "/412",
                    "2.0.2": "/416",
                    "2.0.3": "/417",
                    "2.0.4": "/419",
                    "?": "/",
                  },
                ],
              ],
              [/(webkit|khtml)\/([\w\.]+)/i],
              [h, f],
              [/(navigator|netscape\d?)\/([-\w\.]+)/i],
              [[h, "Netscape"], f],
              [/mobile vr; rv:([\w\.]+)\).+firefox/i],
              [f, [h, T + " Reality"]],
              [
                /ekiohf.+(flow)\/([\w\.]+)/i,
                /(swiftfox)/i,
                /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
                /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                /(firefox)\/([\w\.]+)/i,
                /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
                /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                /(links) \(([\w\.]+)/i,
              ],
              [h, f],
              [/(cobalt)\/([\w\.]+)/i],
              [h, [f, /master.|lts./, ""]],
            ],
            cpu: [
              [/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i],
              [[g, "amd64"]],
              [/(ia32(?=;))/i],
              [[g, z]],
              [/((?:i[346]|x)86)[;\)]/i],
              [[g, "ia32"]],
              [/\b(aarch64|arm(v?8e?l?|_?64))\b/i],
              [[g, "arm64"]],
              [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i],
              [[g, "armhf"]],
              [/windows (ce|mobile); ppc;/i],
              [[g, "arm"]],
              [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i],
              [[g, /ower/, "", z]],
              [/(sun4\w)[;\)]/i],
              [[g, "sparc"]],
              [
                /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i,
              ],
              [[g, z]],
            ],
            device: [
              [
                /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i,
              ],
              [u, [p, D], [d, w]],
              [
                /\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i,
                /samsung[- ]([-\w]+)/i,
                /sec-(sgh\w+)/i,
              ],
              [u, [p, D], [d, y]],
              [/((ipod|iphone)\d+,\d+)/i],
              [u, [p, C], [d, y]],
              [/(ipad\d+,\d+)/i],
              [u, [p, C], [d, w]],
              [/\((ip(?:hone|od)[\w ]*);/i],
              [u, [p, C], [d, y]],
              [
                /\((ipad);[-\w\),; ]+apple/i,
                /applecoremedia\/[\w\.]+ \((ipad)/i,
                /\b(ipad)\d\d?,\d\d?[;\]].+ios/i,
              ],
              [u, [p, C], [d, w]],
              [/(macintosh);/i],
              [u, [p, C]],
              [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i],
              [u, [p, O], [d, w]],
              [
                /(?:huawei|honor)([-\w ]+)[;\)]/i,
                /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i,
              ],
              [u, [p, O], [d, y]],
              [
                /\b(poco[\w ]+)(?: bui|\))/i,
                /\b; (\w+) build\/hm\1/i,
                /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
                /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
                /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i,
              ],
              [
                [u, /_/g, " "],
                [p, M],
                [d, y],
              ],
              [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i],
              [
                [u, /_/g, " "],
                [p, M],
                [d, w],
              ],
              [
                /; (\w+) bui.+ oppo/i,
                /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i,
              ],
              [u, [p, "OPPO"], [d, y]],
              [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i],
              [u, [p, "Vivo"], [d, y]],
              [/\b(rmx[12]\d{3})(?: bui|;|\))/i],
              [u, [p, "Realme"], [d, y]],
              [
                /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
                /\bmot(?:orola)?[- ](\w*)/i,
                /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i,
              ],
              [u, [p, k], [d, y]],
              [/\b(mz60\d|xoom[2 ]{0,2}) build\//i],
              [u, [p, k], [d, w]],
              [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i],
              [u, [p, "LG"], [d, w]],
              [
                /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
                /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
                /\blg-?([\d\w]+) bui/i,
              ],
              [u, [p, "LG"], [d, y]],
              [
                /(ideatab[-\w ]+)/i,
                /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i,
              ],
              [u, [p, "Lenovo"], [d, w]],
              [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i],
              [
                [u, /_/g, " "],
                [p, "Nokia"],
                [d, y],
              ],
              [/(pixel c)\b/i],
              [u, [p, P], [d, w]],
              [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i],
              [u, [p, P], [d, y]],
              [
                /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i,
              ],
              [u, [p, L], [d, y]],
              [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i],
              [
                [u, "Xperia Tablet"],
                [p, L],
                [d, w],
              ],
              [
                / (kb2005|in20[12]5|be20[12][59])\b/i,
                /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i,
              ],
              [u, [p, "OnePlus"], [d, y]],
              [
                /(alexa)webm/i,
                /(kf[a-z]{2}wi)( bui|\))/i,
                /(kf[a-z]+)( bui|\)).+silk\//i,
              ],
              [u, [p, A], [d, w]],
              [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i],
              [
                [u, /(.+)/g, "Fire Phone $1"],
                [p, A],
                [d, y],
              ],
              [/(playbook);[-\w\),; ]+(rim)/i],
              [u, p, [d, w]],
              [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i],
              [u, [p, I], [d, y]],
              [
                /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i,
              ],
              [u, [p, _], [d, w]],
              [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],
              [u, [p, _], [d, y]],
              [/(nexus 9)/i],
              [u, [p, "HTC"], [d, w]],
              [
                /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
                /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
                /(alcatel|geeksphone|nexian|panasonic|sony(?!-bra))[-_ ]?([-\w]*)/i,
              ],
              [p, [u, /_/g, " "], [d, y]],
              [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i],
              [u, [p, "Acer"], [d, w]],
              [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i],
              [u, [p, "Meizu"], [d, y]],
              [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i],
              [u, [p, U], [d, y]],
              [
                /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
                /(hp) ([\w ]+\w)/i,
                /(asus)-?(\w+)/i,
                /(microsoft); (lumia[\w ]+)/i,
                /(lenovo)[-_ ]?([-\w]+)/i,
                /(jolla)/i,
                /(oppo) ?([\w ]+) bui/i,
              ],
              [p, u, [d, y]],
              [
                /(archos) (gamepad2?)/i,
                /(hp).+(touchpad(?!.+tablet)|tablet)/i,
                /(kindle)\/([\w\.]+)/i,
                /(nook)[\w ]+build\/(\w+)/i,
                /(dell) (strea[kpr\d ]*[\dko])/i,
                /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
                /(trinity)[- ]*(t\d{3}) bui/i,
                /(gigaset)[- ]+(q\w{1,9}) bui/i,
                /(vodafone) ([\w ]+)(?:\)| bui)/i,
              ],
              [p, u, [d, w]],
              [/(surface duo)/i],
              [u, [p, x], [d, w]],
              [/droid [\d\.]+; (fp\du?)(?: b|\))/i],
              [u, [p, "Fairphone"], [d, y]],
              [/(u304aa)/i],
              [u, [p, "AT&T"], [d, y]],
              [/\bsie-(\w*)/i],
              [u, [p, "Siemens"], [d, y]],
              [/\b(rct\w+) b/i],
              [u, [p, "RCA"], [d, w]],
              [/\b(venue[\d ]{2,7}) b/i],
              [u, [p, "Dell"], [d, w]],
              [/\b(q(?:mv|ta)\w+) b/i],
              [u, [p, "Verizon"], [d, w]],
              [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i],
              [u, [p, "Barnes & Noble"], [d, w]],
              [/\b(tm\d{3}\w+) b/i],
              [u, [p, "NuVision"], [d, w]],
              [/\b(k88) b/i],
              [u, [p, "ZTE"], [d, w]],
              [/\b(nx\d{3}j) b/i],
              [u, [p, "ZTE"], [d, y]],
              [/\b(gen\d{3}) b.+49h/i],
              [u, [p, "Swiss"], [d, y]],
              [/\b(zur\d{3}) b/i],
              [u, [p, "Swiss"], [d, w]],
              [/\b((zeki)?tb.*\b) b/i],
              [u, [p, "Zeki"], [d, w]],
              [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i],
              [[p, "Dragon Touch"], u, [d, w]],
              [/\b(ns-?\w{0,9}) b/i],
              [u, [p, "Insignia"], [d, w]],
              [/\b((nxa|next)-?\w{0,9}) b/i],
              [u, [p, "NextBook"], [d, w]],
              [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i],
              [[p, "Voice"], u, [d, y]],
              [/\b(lvtel\-)?(v1[12]) b/i],
              [[p, "LvTel"], u, [d, y]],
              [/\b(ph-1) /i],
              [u, [p, "Essential"], [d, y]],
              [/\b(v(100md|700na|7011|917g).*\b) b/i],
              [u, [p, "Envizen"], [d, w]],
              [/\b(trio[-\w\. ]+) b/i],
              [u, [p, "MachSpeed"], [d, w]],
              [/\btu_(1491) b/i],
              [u, [p, "Rotor"], [d, w]],
              [/(shield[\w ]+) b/i],
              [u, [p, "Nvidia"], [d, w]],
              [/(sprint) (\w+)/i],
              [p, u, [d, y]],
              [/(kin\.[onetw]{3})/i],
              [
                [u, /\./g, " "],
                [p, x],
                [d, y],
              ],
              [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i],
              [u, [p, B], [d, w]],
              [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],
              [u, [p, B], [d, y]],
              [/(ouya)/i, /(nintendo) ([wids3utch]+)/i],
              [p, u, [d, m]],
              [/droid.+; (shield) bui/i],
              [u, [p, "Nvidia"], [d, m]],
              [/(playstation [345portablevi]+)/i],
              [u, [p, L], [d, m]],
              [/\b(xbox(?: one)?(?!; xbox))[\); ]/i],
              [u, [p, x], [d, m]],
              [/smart-tv.+(samsung)/i],
              [p, [d, b]],
              [/hbbtv.+maple;(\d+)/i],
              [
                [u, /^/, "SmartTV"],
                [p, D],
                [d, b],
              ],
              [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i],
              [
                [p, "LG"],
                [d, b],
              ],
              [/(apple) ?tv/i],
              [p, [u, C + " TV"], [d, b]],
              [/crkey/i],
              [
                [u, S + "cast"],
                [p, P],
                [d, b],
              ],
              [/droid.+aft(\w)( bui|\))/i],
              [u, [p, A], [d, b]],
              [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i],
              [u, [p, U], [d, b]],
              [/(bravia[\w ]+)( bui|\))/i],
              [u, [p, L], [d, b]],
              [/(mitv-\w{5}) bui/i],
              [u, [p, M], [d, b]],
              [
                /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
                /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i,
              ],
              [
                [p, q],
                [u, q],
                [d, b],
              ],
              [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i],
              [[d, b]],
              [/((pebble))app/i],
              [p, u, [d, v]],
              [/droid.+; (glass) \d/i],
              [u, [p, P], [d, v]],
              [/droid.+; (wt63?0{2,3})\)/i],
              [u, [p, B], [d, v]],
              [/(quest( 2)?)/i],
              [u, [p, j], [d, v]],
              [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i],
              [p, [d, E]],
              [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i],
              [u, [d, y]],
              [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i],
              [u, [d, w]],
              [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i],
              [[d, w]],
              [
                /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i,
              ],
              [[d, y]],
              [/(android[-\w\. ]{0,9});.+buil/i],
              [u, [p, "Generic"]],
            ],
            engine: [
              [/windows.+ edge\/([\w\.]+)/i],
              [f, [h, "EdgeHTML"]],
              [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],
              [f, [h, "Blink"]],
              [
                /(presto)\/([\w\.]+)/i,
                /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
                /ekioh(flow)\/([\w\.]+)/i,
                /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
                /(icab)[\/ ]([23]\.[\d\.]+)/i,
              ],
              [h, f],
              [/rv\:([\w\.]{1,9})\b.+(gecko)/i],
              [f, h],
            ],
            os: [
              [/microsoft (windows) (vista|xp)/i],
              [h, f],
              [
                /(windows) nt 6\.2; (arm)/i,
                /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,
                /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,
              ],
              [h, [f, G, W]],
              [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i],
              [
                [h, "Windows"],
                [f, G, W],
              ],
              [
                /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
                /cfnetwork\/.+darwin/i,
              ],
              [
                [f, /_/g, "."],
                [h, "iOS"],
              ],
              [
                /(mac os x) ?([\w\. ]*)/i,
                /(macintosh|mac_powerpc\b)(?!.+haiku)/i,
              ],
              [
                [h, "Mac OS"],
                [f, /_/g, "."],
              ],
              [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i],
              [f, h],
              [
                /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
                /(blackberry)\w*\/([\w\.]*)/i,
                /(tizen|kaios)[\/ ]([\w\.]+)/i,
                /\((series40);/i,
              ],
              [h, f],
              [/\(bb(10);/i],
              [f, [h, I]],
              [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i],
              [f, [h, "Symbian"]],
              [
                /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i,
              ],
              [f, [h, T + " OS"]],
              [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i],
              [f, [h, "webOS"]],
              [/crkey\/([\d\.]+)/i],
              [f, [h, S + "cast"]],
              [/(cros) [\w]+ ([\w\.]+\w)/i],
              [[h, "Chromium OS"], f],
              [
                /(nintendo|playstation) ([wids345portablevuch]+)/i,
                /(xbox); +xbox ([^\);]+)/i,
                /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
                /(mint)[\/\(\) ]?(\w*)/i,
                /(mageia|vectorlinux)[; ]/i,
                /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                /(hurd|linux) ?([\w\.]*)/i,
                /(gnu) ?([\w\.]*)/i,
                /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
                /(haiku) (\w+)/i,
              ],
              [h, f],
              [/(sunos) ?([\w\.\d]*)/i],
              [[h, "Solaris"], f],
              [
                /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
                /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
                /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i,
                /(unix) ?([\w\.]*)/i,
              ],
              [h, f],
            ],
          },
          Z = function (e, t) {
            if ((typeof e === l && ((t = e), (e = s)), !(this instanceof Z)))
              return new Z(e, t).getResult();
            var r =
                e ||
                (typeof n !== o && n.navigator && n.navigator.userAgent
                  ? n.navigator.userAgent
                  : ""),
              i = t ? F(K, t) : K;
            return (
              (this.getBrowser = function () {
                var e,
                  t = {};
                return (
                  (t[h] = s),
                  (t[f] = s),
                  V.call(t, r, i.browser),
                  (t.major =
                    typeof (e = t.version) === c
                      ? e.replace(/[^\d\.]/g, "").split(".")[0]
                      : s),
                  t
                );
              }),
              (this.getCPU = function () {
                var e = {};
                return (e[g] = s), V.call(e, r, i.cpu), e;
              }),
              (this.getDevice = function () {
                var e = {};
                return (
                  (e[p] = s), (e[u] = s), (e[d] = s), V.call(e, r, i.device), e
                );
              }),
              (this.getEngine = function () {
                var e = {};
                return (e[h] = s), (e[f] = s), V.call(e, r, i.engine), e;
              }),
              (this.getOS = function () {
                var e = {};
                return (e[h] = s), (e[f] = s), V.call(e, r, i.os), e;
              }),
              (this.getResult = function () {
                return {
                  ua: this.getUA(),
                  browser: this.getBrowser(),
                  engine: this.getEngine(),
                  os: this.getOS(),
                  device: this.getDevice(),
                  cpu: this.getCPU(),
                };
              }),
              (this.getUA = function () {
                return r;
              }),
              (this.setUA = function (e) {
                return (
                  (r = typeof e === c && e.length > 350 ? q(e, 350) : e), this
                );
              }),
              this.setUA(r),
              this
            );
          };
        (Z.VERSION = "0.7.33"),
          (Z.BROWSER = $([h, f, "major"])),
          (Z.CPU = $([g])),
          (Z.DEVICE = $([u, p, d, m, y, b, w, v, E])),
          (Z.ENGINE = Z.OS = $([h, f])),
          typeof t !== o
            ? (e.exports && (t = e.exports = Z), (t.UAParser = Z))
            : r.amdO
            ? s !==
                (i = function () {
                  return Z;
                }.call(t, r, t, e)) && (e.exports = i)
            : typeof n !== o && (n.UAParser = Z);
        var J = typeof n !== o && (n.jQuery || n.Zepto);
        if (J && !J.ua) {
          var Q = new Z();
          (J.ua = Q.getResult()),
            (J.ua.get = function () {
              return Q.getUA();
            }),
            (J.ua.set = function (e) {
              Q.setUA(e);
              var t = Q.getResult();
              for (var r in t) J.ua[r] = t[r];
            });
        }
      })("object" == typeof window ? window : this);
    },
    25617: function (e, t, r) {
      "use strict";
      function i() {
        return (
          "object" == typeof window &&
          (null == window ? void 0 : window.document) !== void 0
        );
      }
      r.d(t, {
        XQ: function () {
          return n;
        },
        kP: function () {
          return i;
        },
      }),
        r(40257);
      var n = function () {
        var e;
        if (i()) {
          var t = Array;
          if (
            void 0 !== window.Prototype &&
            (null === (e = t.prototype) || void 0 === e ? void 0 : e.toJSON) !==
              void 0
          )
            return delete t.prototype.toJSON, !0;
        }
        return !1;
      };
    },
    12238: function (e, t, r) {
      "use strict";
      function i() {
        return (
          (null === r.g || void 0 === r.g ? void 0 : r.g.crypto) ||
          (null === r.g || void 0 === r.g ? void 0 : r.g.msCrypto) ||
          {}
        );
      }
      function n() {
        let e = i();
        return e.subtle || e.webkitSubtle;
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.isBrowserCryptoAvailable =
          t.getSubtleCrypto =
          t.getBrowerCrypto =
            void 0),
        (t.getBrowerCrypto = i),
        (t.getSubtleCrypto = n),
        (t.isBrowserCryptoAvailable = function () {
          return !!i() && !!n();
        });
    },
    33531: function (e, t, r) {
      "use strict";
      var i = r(40257);
      function n() {
        return (
          "undefined" == typeof document &&
          "undefined" != typeof navigator &&
          "ReactNative" === navigator.product
        );
      }
      function s() {
        return (
          void 0 !== i && void 0 !== i.versions && void 0 !== i.versions.node
        );
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.isBrowser = t.isNode = t.isReactNative = void 0),
        (t.isReactNative = n),
        (t.isNode = s),
        (t.isBrowser = function () {
          return !n() && !s();
        });
    },
    13303: function (e, t, r) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      let i = r(45161);
      i.__exportStar(r(12238), t), i.__exportStar(r(33531), t);
    },
    45161: function (e, t, r) {
      "use strict";
      r.r(t),
        r.d(t, {
          __assign: function () {
            return s;
          },
          __asyncDelegator: function () {
            return v;
          },
          __asyncGenerator: function () {
            return b;
          },
          __asyncValues: function () {
            return E;
          },
          __await: function () {
            return w;
          },
          __awaiter: function () {
            return u;
          },
          __classPrivateFieldGet: function () {
            return I;
          },
          __classPrivateFieldSet: function () {
            return N;
          },
          __createBinding: function () {
            return d;
          },
          __decorate: function () {
            return o;
          },
          __exportStar: function () {
            return p;
          },
          __extends: function () {
            return n;
          },
          __generator: function () {
            return h;
          },
          __importDefault: function () {
            return _;
          },
          __importStar: function () {
            return C;
          },
          __makeTemplateObject: function () {
            return A;
          },
          __metadata: function () {
            return c;
          },
          __param: function () {
            return l;
          },
          __read: function () {
            return g;
          },
          __rest: function () {
            return a;
          },
          __spread: function () {
            return m;
          },
          __spreadArrays: function () {
            return y;
          },
          __values: function () {
            return f;
          },
        });
      var i = function (e, t) {
        return (i =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (e, t) {
              e.__proto__ = t;
            }) ||
          function (e, t) {
            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r]);
          })(e, t);
      };
      function n(e, t) {
        function r() {
          this.constructor = e;
        }
        i(e, t),
          (e.prototype =
            null === t
              ? Object.create(t)
              : ((r.prototype = t.prototype), new r()));
      }
      var s = function () {
        return (s =
          Object.assign ||
          function (e) {
            for (var t, r = 1, i = arguments.length; r < i; r++)
              for (var n in (t = arguments[r]))
                Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            return e;
          }).apply(this, arguments);
      };
      function a(e, t) {
        var r = {};
        for (var i in e)
          Object.prototype.hasOwnProperty.call(e, i) &&
            0 > t.indexOf(i) &&
            (r[i] = e[i]);
        if (null != e && "function" == typeof Object.getOwnPropertySymbols)
          for (
            var n = 0, i = Object.getOwnPropertySymbols(e);
            n < i.length;
            n++
          )
            0 > t.indexOf(i[n]) &&
              Object.prototype.propertyIsEnumerable.call(e, i[n]) &&
              (r[i[n]] = e[i[n]]);
        return r;
      }
      function o(e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      }
      function l(e, t) {
        return function (r, i) {
          t(r, i, e);
        };
      }
      function c(e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
          return Reflect.metadata(e, t);
      }
      function u(e, t, r, i) {
        return new (r || (r = Promise))(function (n, s) {
          function a(e) {
            try {
              l(i.next(e));
            } catch (e) {
              s(e);
            }
          }
          function o(e) {
            try {
              l(i.throw(e));
            } catch (e) {
              s(e);
            }
          }
          function l(e) {
            var t;
            e.done
              ? n(e.value)
              : ((t = e.value) instanceof r
                  ? t
                  : new r(function (e) {
                      e(t);
                    })
                ).then(a, o);
          }
          l((i = i.apply(e, t || [])).next());
        });
      }
      function h(e, t) {
        var r,
          i,
          n,
          s,
          a = {
            label: 0,
            sent: function () {
              if (1 & n[0]) throw n[1];
              return n[1];
            },
            trys: [],
            ops: [],
          };
        return (
          (s = { next: o(0), throw: o(1), return: o(2) }),
          "function" == typeof Symbol &&
            (s[Symbol.iterator] = function () {
              return this;
            }),
          s
        );
        function o(s) {
          return function (o) {
            return (function (s) {
              if (r) throw TypeError("Generator is already executing.");
              for (; a; )
                try {
                  if (
                    ((r = 1),
                    i &&
                      (n =
                        2 & s[0]
                          ? i.return
                          : s[0]
                          ? i.throw || ((n = i.return) && n.call(i), 0)
                          : i.next) &&
                      !(n = n.call(i, s[1])).done)
                  )
                    return n;
                  switch (((i = 0), n && (s = [2 & s[0], n.value]), s[0])) {
                    case 0:
                    case 1:
                      n = s;
                      break;
                    case 4:
                      return a.label++, { value: s[1], done: !1 };
                    case 5:
                      a.label++, (i = s[1]), (s = [0]);
                      continue;
                    case 7:
                      (s = a.ops.pop()), a.trys.pop();
                      continue;
                    default:
                      if (
                        !(n = (n = a.trys).length > 0 && n[n.length - 1]) &&
                        (6 === s[0] || 2 === s[0])
                      ) {
                        a = 0;
                        continue;
                      }
                      if (3 === s[0] && (!n || (s[1] > n[0] && s[1] < n[3]))) {
                        a.label = s[1];
                        break;
                      }
                      if (6 === s[0] && a.label < n[1]) {
                        (a.label = n[1]), (n = s);
                        break;
                      }
                      if (n && a.label < n[2]) {
                        (a.label = n[2]), a.ops.push(s);
                        break;
                      }
                      n[2] && a.ops.pop(), a.trys.pop();
                      continue;
                  }
                  s = t.call(e, a);
                } catch (e) {
                  (s = [6, e]), (i = 0);
                } finally {
                  r = n = 0;
                }
              if (5 & s[0]) throw s[1];
              return { value: s[0] ? s[1] : void 0, done: !0 };
            })([s, o]);
          };
        }
      }
      function d(e, t, r, i) {
        void 0 === i && (i = r), (e[i] = t[r]);
      }
      function p(e, t) {
        for (var r in e)
          "default" === r || t.hasOwnProperty(r) || (t[r] = e[r]);
      }
      function f(e) {
        var t = "function" == typeof Symbol && Symbol.iterator,
          r = t && e[t],
          i = 0;
        if (r) return r.call(e);
        if (e && "number" == typeof e.length)
          return {
            next: function () {
              return (
                e && i >= e.length && (e = void 0),
                { value: e && e[i++], done: !e }
              );
            },
          };
        throw TypeError(
          t ? "Object is not iterable." : "Symbol.iterator is not defined."
        );
      }
      function g(e, t) {
        var r = "function" == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var i,
          n,
          s = r.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(i = s.next()).done; )
            a.push(i.value);
        } catch (e) {
          n = { error: e };
        } finally {
          try {
            i && !i.done && (r = s.return) && r.call(s);
          } finally {
            if (n) throw n.error;
          }
        }
        return a;
      }
      function m() {
        for (var e = [], t = 0; t < arguments.length; t++)
          e = e.concat(g(arguments[t]));
        return e;
      }
      function y() {
        for (var e = 0, t = 0, r = arguments.length; t < r; t++)
          e += arguments[t].length;
        for (var i = Array(e), n = 0, t = 0; t < r; t++)
          for (var s = arguments[t], a = 0, o = s.length; a < o; a++, n++)
            i[n] = s[a];
        return i;
      }
      function w(e) {
        return this instanceof w ? ((this.v = e), this) : new w(e);
      }
      function b(e, t, r) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var i,
          n = r.apply(e, t || []),
          s = [];
        return (
          (i = {}),
          a("next"),
          a("throw"),
          a("return"),
          (i[Symbol.asyncIterator] = function () {
            return this;
          }),
          i
        );
        function a(e) {
          n[e] &&
            (i[e] = function (t) {
              return new Promise(function (r, i) {
                s.push([e, t, r, i]) > 1 || o(e, t);
              });
            });
        }
        function o(e, t) {
          try {
            var r;
            (r = n[e](t)).value instanceof w
              ? Promise.resolve(r.value.v).then(l, c)
              : u(s[0][2], r);
          } catch (e) {
            u(s[0][3], e);
          }
        }
        function l(e) {
          o("next", e);
        }
        function c(e) {
          o("throw", e);
        }
        function u(e, t) {
          e(t), s.shift(), s.length && o(s[0][0], s[0][1]);
        }
      }
      function v(e) {
        var t, r;
        return (
          (t = {}),
          i("next"),
          i("throw", function (e) {
            throw e;
          }),
          i("return"),
          (t[Symbol.iterator] = function () {
            return this;
          }),
          t
        );
        function i(i, n) {
          t[i] = e[i]
            ? function (t) {
                return (r = !r)
                  ? { value: w(e[i](t)), done: "return" === i }
                  : n
                  ? n(t)
                  : t;
              }
            : n;
        }
      }
      function E(e) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var t,
          r = e[Symbol.asyncIterator];
        return r
          ? r.call(e)
          : ((e = f(e)),
            (t = {}),
            i("next"),
            i("throw"),
            i("return"),
            (t[Symbol.asyncIterator] = function () {
              return this;
            }),
            t);
        function i(r) {
          t[r] =
            e[r] &&
            function (t) {
              return new Promise(function (i, n) {
                !(function (e, t, r, i) {
                  Promise.resolve(i).then(function (t) {
                    e({ value: t, done: r });
                  }, t);
                })(i, n, (t = e[r](t)).done, t.value);
              });
            };
        }
      }
      function A(e, t) {
        return (
          Object.defineProperty
            ? Object.defineProperty(e, "raw", { value: t })
            : (e.raw = t),
          e
        );
      }
      function C(e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var r in e) Object.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return (t.default = e), t;
      }
      function _(e) {
        return e && e.__esModule ? e : { default: e };
      }
      function I(e, t) {
        if (!t.has(e))
          throw TypeError("attempted to get private field on non-instance");
        return t.get(e);
      }
      function N(e, t, r) {
        if (!t.has(e))
          throw TypeError("attempted to set private field on non-instance");
        return t.set(e, r), r;
      }
    },
    15133: function (e, t, r) {
      "use strict";
      r.d(t, {
        Ep: function () {
          return _;
        },
        Fd: function () {
          return C;
        },
        Rt: function () {
          return I;
        },
        gw: function () {
          return n.a;
        },
        jI: function () {
          return A;
        },
      });
      var i = r(97435),
        n = r.n(i),
        s = r(80577);
      let a = { level: "info" },
        o = "custom_context";
      class l {
        constructor(e) {
          (this.nodeValue = e),
            (this.sizeInBytes = new TextEncoder().encode(
              this.nodeValue
            ).length),
            (this.next = null);
        }
        get value() {
          return this.nodeValue;
        }
        get size() {
          return this.sizeInBytes;
        }
      }
      class c {
        constructor(e) {
          (this.head = null),
            (this.tail = null),
            (this.lengthInNodes = 0),
            (this.maxSizeInBytes = e),
            (this.sizeInBytes = 0);
        }
        append(e) {
          let t = new l(e);
          if (t.size > this.maxSizeInBytes)
            throw Error(
              `[LinkedList] Value too big to insert into list: ${e} with size ${t.size}`
            );
          for (; this.size + t.size > this.maxSizeInBytes; ) this.shift();
          this.head ? this.tail && (this.tail.next = t) : (this.head = t),
            (this.tail = t),
            this.lengthInNodes++,
            (this.sizeInBytes += t.size);
        }
        shift() {
          if (!this.head) return;
          let e = this.head;
          (this.head = this.head.next),
            this.head || (this.tail = null),
            this.lengthInNodes--,
            (this.sizeInBytes -= e.size);
        }
        toArray() {
          let e = [],
            t = this.head;
          for (; null !== t; ) e.push(t.value), (t = t.next);
          return e;
        }
        get length() {
          return this.lengthInNodes;
        }
        get size() {
          return this.sizeInBytes;
        }
        toOrderedArray() {
          return Array.from(this);
        }
        [Symbol.iterator]() {
          let e = this.head;
          return {
            next: () => {
              if (!e) return { done: !0, value: null };
              let t = e.value;
              return (e = e.next), { done: !1, value: t };
            },
          };
        }
      }
      class u {
        constructor(e, t = 1024e3) {
          (this.level = e ?? "error"),
            (this.levelValue = i.levels.values[this.level]),
            (this.MAX_LOG_SIZE_IN_BYTES = t),
            (this.logs = new c(this.MAX_LOG_SIZE_IN_BYTES));
        }
        forwardToConsole(e, t) {
          t === i.levels.values.error
            ? console.error(e)
            : t === i.levels.values.warn
            ? console.warn(e)
            : t === i.levels.values.debug
            ? console.debug(e)
            : t === i.levels.values.trace
            ? console.trace(e)
            : console.log(e);
        }
        appendToLogs(e) {
          this.logs.append(
            (0, s.u)({ timestamp: new Date().toISOString(), log: e })
          );
          let t = "string" == typeof e ? JSON.parse(e).level : e.level;
          t >= this.levelValue && this.forwardToConsole(e, t);
        }
        getLogs() {
          return this.logs;
        }
        clearLogs() {
          this.logs = new c(this.MAX_LOG_SIZE_IN_BYTES);
        }
        getLogArray() {
          return Array.from(this.logs);
        }
        logsToBlob(e) {
          let t = this.getLogArray();
          return (
            t.push((0, s.u)({ extraMetadata: e })),
            new Blob(t, { type: "application/json" })
          );
        }
      }
      class h {
        constructor(e, t = 1024e3) {
          this.baseChunkLogger = new u(e, t);
        }
        write(e) {
          this.baseChunkLogger.appendToLogs(e);
        }
        getLogs() {
          return this.baseChunkLogger.getLogs();
        }
        clearLogs() {
          this.baseChunkLogger.clearLogs();
        }
        getLogArray() {
          return this.baseChunkLogger.getLogArray();
        }
        logsToBlob(e) {
          return this.baseChunkLogger.logsToBlob(e);
        }
        downloadLogsBlobInBrowser(e) {
          let t = URL.createObjectURL(this.logsToBlob(e)),
            r = document.createElement("a");
          (r.href = t),
            (r.download = `walletconnect-logs-${new Date().toISOString()}.txt`),
            document.body.appendChild(r),
            r.click(),
            document.body.removeChild(r),
            URL.revokeObjectURL(t);
        }
      }
      class d {
        constructor(e, t = 1024e3) {
          this.baseChunkLogger = new u(e, t);
        }
        write(e) {
          this.baseChunkLogger.appendToLogs(e);
        }
        getLogs() {
          return this.baseChunkLogger.getLogs();
        }
        clearLogs() {
          this.baseChunkLogger.clearLogs();
        }
        getLogArray() {
          return this.baseChunkLogger.getLogArray();
        }
        logsToBlob(e) {
          return this.baseChunkLogger.logsToBlob(e);
        }
      }
      var p = Object.defineProperty,
        f = Object.defineProperties,
        g = Object.getOwnPropertyDescriptors,
        m = Object.getOwnPropertySymbols,
        y = Object.prototype.hasOwnProperty,
        w = Object.prototype.propertyIsEnumerable,
        b = (e, t, r) =>
          t in e
            ? p(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        v = (e, t) => {
          for (var r in t || (t = {})) y.call(t, r) && b(e, r, t[r]);
          if (m) for (var r of m(t)) w.call(t, r) && b(e, r, t[r]);
          return e;
        },
        E = (e, t) => f(e, g(t));
      function A(e) {
        return E(v({}, e), { level: e?.level || a.level });
      }
      function C(e, t = o) {
        return typeof e.bindings > "u"
          ? (function (e, t = o) {
              return e[t] || "";
            })(e, t)
          : e.bindings().context || "";
      }
      function _(e, t, r = o) {
        let i = (function (e, t, r = o) {
          let i = C(e, r);
          return i.trim() ? `${i}/${t}` : t;
        })(e, t, r);
        return (function (e, t, r = o) {
          return (e[r] = t), e;
        })(e.child({ context: i }), i, r);
      }
      function I(e) {
        return "u" > typeof e.loggerOverride &&
          "string" != typeof e.loggerOverride
          ? { logger: e.loggerOverride, chunkLoggerController: null }
          : "u" > typeof window
          ? (function (e) {
              var t, r;
              let i = new h(
                null == (t = e.opts) ? void 0 : t.level,
                e.maxSizeInBytes
              );
              return {
                logger: n()(
                  E(v({}, e.opts), {
                    level: "trace",
                    browser: E(
                      v({}, null == (r = e.opts) ? void 0 : r.browser),
                      { write: (e) => i.write(e) }
                    ),
                  })
                ),
                chunkLoggerController: i,
              };
            })(e)
          : (function (e) {
              var t;
              let r = new d(
                null == (t = e.opts) ? void 0 : t.level,
                e.maxSizeInBytes
              );
              return {
                logger: n()(E(v({}, e.opts), { level: "trace" }), r),
                chunkLoggerController: r,
              };
            })(e);
      }
    },
    80577: function (e, t, r) {
      "use strict";
      r.d(t, {
        D: function () {
          return s;
        },
        u: function () {
          return a;
        },
      });
      let i = (e) =>
          JSON.stringify(e, (e, t) =>
            "bigint" == typeof t ? t.toString() + "n" : t
          ),
        n = (e) =>
          JSON.parse(
            e.replace(
              /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g,
              '$1"$2n"$3'
            ),
            (e, t) =>
              "string" == typeof t && t.match(/^\d+n$/)
                ? BigInt(t.substring(0, t.length - 1))
                : t
          );
      function s(e) {
        if ("string" != typeof e)
          throw Error(`Cannot safe json parse value of type ${typeof e}`);
        try {
          return n(e);
        } catch (t) {
          return e;
        }
      }
      function a(e) {
        return "string" == typeof e ? e : i(e) || "";
      }
    },
    70213: function (e, t, r) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      let i = r(62494);
      i.__exportStar(r(12658), t), i.__exportStar(r(75127), t);
    },
    12658: function (e, t) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ONE_THOUSAND = t.ONE_HUNDRED = void 0),
        (t.ONE_HUNDRED = 100),
        (t.ONE_THOUSAND = 1e3);
    },
    75127: function (e, t) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ONE_YEAR =
          t.FOUR_WEEKS =
          t.THREE_WEEKS =
          t.TWO_WEEKS =
          t.ONE_WEEK =
          t.THIRTY_DAYS =
          t.SEVEN_DAYS =
          t.FIVE_DAYS =
          t.THREE_DAYS =
          t.ONE_DAY =
          t.TWENTY_FOUR_HOURS =
          t.TWELVE_HOURS =
          t.SIX_HOURS =
          t.THREE_HOURS =
          t.ONE_HOUR =
          t.SIXTY_MINUTES =
          t.THIRTY_MINUTES =
          t.TEN_MINUTES =
          t.FIVE_MINUTES =
          t.ONE_MINUTE =
          t.SIXTY_SECONDS =
          t.THIRTY_SECONDS =
          t.TEN_SECONDS =
          t.FIVE_SECONDS =
          t.ONE_SECOND =
            void 0),
        (t.ONE_SECOND = 1),
        (t.FIVE_SECONDS = 5),
        (t.TEN_SECONDS = 10),
        (t.THIRTY_SECONDS = 30),
        (t.SIXTY_SECONDS = 60),
        (t.ONE_MINUTE = t.SIXTY_SECONDS),
        (t.FIVE_MINUTES = 5 * t.ONE_MINUTE),
        (t.TEN_MINUTES = 10 * t.ONE_MINUTE),
        (t.THIRTY_MINUTES = 30 * t.ONE_MINUTE),
        (t.SIXTY_MINUTES = 60 * t.ONE_MINUTE),
        (t.ONE_HOUR = t.SIXTY_MINUTES),
        (t.THREE_HOURS = 3 * t.ONE_HOUR),
        (t.SIX_HOURS = 6 * t.ONE_HOUR),
        (t.TWELVE_HOURS = 12 * t.ONE_HOUR),
        (t.TWENTY_FOUR_HOURS = 24 * t.ONE_HOUR),
        (t.ONE_DAY = t.TWENTY_FOUR_HOURS),
        (t.THREE_DAYS = 3 * t.ONE_DAY),
        (t.FIVE_DAYS = 5 * t.ONE_DAY),
        (t.SEVEN_DAYS = 7 * t.ONE_DAY),
        (t.THIRTY_DAYS = 30 * t.ONE_DAY),
        (t.ONE_WEEK = t.SEVEN_DAYS),
        (t.TWO_WEEKS = 2 * t.ONE_WEEK),
        (t.THREE_WEEKS = 3 * t.ONE_WEEK),
        (t.FOUR_WEEKS = 4 * t.ONE_WEEK),
        (t.ONE_YEAR = 365 * t.ONE_DAY);
    },
    40537: function (e, t, r) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      let i = r(62494);
      i.__exportStar(r(78627), t),
        i.__exportStar(r(59854), t),
        i.__exportStar(r(3205), t),
        i.__exportStar(r(70213), t);
    },
    3205: function (e, t, r) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        r(62494).__exportStar(r(71146), t);
    },
    71146: function (e, t) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.IWatch = void 0);
      class r {}
      t.IWatch = r;
    },
    68353: function (e, t, r) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.fromMiliseconds = t.toMiliseconds = void 0);
      let i = r(70213);
      (t.toMiliseconds = function (e) {
        return e * i.ONE_THOUSAND;
      }),
        (t.fromMiliseconds = function (e) {
          return Math.floor(e / i.ONE_THOUSAND);
        });
    },
    86029: function (e, t) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.delay = void 0),
        (t.delay = function (e) {
          return new Promise((t) => {
            setTimeout(() => {
              t(!0);
            }, e);
          });
        });
    },
    78627: function (e, t, r) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      let i = r(62494);
      i.__exportStar(r(86029), t), i.__exportStar(r(68353), t);
    },
    59854: function (e, t) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.Watch = void 0);
      class r {
        constructor() {
          this.timestamps = new Map();
        }
        start(e) {
          if (this.timestamps.has(e))
            throw Error(`Watch already started for label: ${e}`);
          this.timestamps.set(e, { started: Date.now() });
        }
        stop(e) {
          let t = this.get(e);
          if (void 0 !== t.elapsed)
            throw Error(`Watch already stopped for label: ${e}`);
          let r = Date.now() - t.started;
          this.timestamps.set(e, { started: t.started, elapsed: r });
        }
        get(e) {
          let t = this.timestamps.get(e);
          if (void 0 === t) throw Error(`No timestamp found for label: ${e}`);
          return t;
        }
        elapsed(e) {
          let t = this.get(e);
          return t.elapsed || Date.now() - t.started;
        }
      }
      (t.Watch = r), (t.default = r);
    },
    62494: function (e, t, r) {
      "use strict";
      r.r(t),
        r.d(t, {
          __assign: function () {
            return s;
          },
          __asyncDelegator: function () {
            return v;
          },
          __asyncGenerator: function () {
            return b;
          },
          __asyncValues: function () {
            return E;
          },
          __await: function () {
            return w;
          },
          __awaiter: function () {
            return u;
          },
          __classPrivateFieldGet: function () {
            return I;
          },
          __classPrivateFieldSet: function () {
            return N;
          },
          __createBinding: function () {
            return d;
          },
          __decorate: function () {
            return o;
          },
          __exportStar: function () {
            return p;
          },
          __extends: function () {
            return n;
          },
          __generator: function () {
            return h;
          },
          __importDefault: function () {
            return _;
          },
          __importStar: function () {
            return C;
          },
          __makeTemplateObject: function () {
            return A;
          },
          __metadata: function () {
            return c;
          },
          __param: function () {
            return l;
          },
          __read: function () {
            return g;
          },
          __rest: function () {
            return a;
          },
          __spread: function () {
            return m;
          },
          __spreadArrays: function () {
            return y;
          },
          __values: function () {
            return f;
          },
        });
      var i = function (e, t) {
        return (i =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (e, t) {
              e.__proto__ = t;
            }) ||
          function (e, t) {
            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r]);
          })(e, t);
      };
      function n(e, t) {
        function r() {
          this.constructor = e;
        }
        i(e, t),
          (e.prototype =
            null === t
              ? Object.create(t)
              : ((r.prototype = t.prototype), new r()));
      }
      var s = function () {
        return (s =
          Object.assign ||
          function (e) {
            for (var t, r = 1, i = arguments.length; r < i; r++)
              for (var n in (t = arguments[r]))
                Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            return e;
          }).apply(this, arguments);
      };
      function a(e, t) {
        var r = {};
        for (var i in e)
          Object.prototype.hasOwnProperty.call(e, i) &&
            0 > t.indexOf(i) &&
            (r[i] = e[i]);
        if (null != e && "function" == typeof Object.getOwnPropertySymbols)
          for (
            var n = 0, i = Object.getOwnPropertySymbols(e);
            n < i.length;
            n++
          )
            0 > t.indexOf(i[n]) &&
              Object.prototype.propertyIsEnumerable.call(e, i[n]) &&
              (r[i[n]] = e[i[n]]);
        return r;
      }
      function o(e, t, r, i) {
        var n,
          s = arguments.length,
          a =
            s < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (n = e[o]) &&
              (a = (s < 3 ? n(a) : s > 3 ? n(t, r, a) : n(t, r)) || a);
        return s > 3 && a && Object.defineProperty(t, r, a), a;
      }
      function l(e, t) {
        return function (r, i) {
          t(r, i, e);
        };
      }
      function c(e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
          return Reflect.metadata(e, t);
      }
      function u(e, t, r, i) {
        return new (r || (r = Promise))(function (n, s) {
          function a(e) {
            try {
              l(i.next(e));
            } catch (e) {
              s(e);
            }
          }
          function o(e) {
            try {
              l(i.throw(e));
            } catch (e) {
              s(e);
            }
          }
          function l(e) {
            var t;
            e.done
              ? n(e.value)
              : ((t = e.value) instanceof r
                  ? t
                  : new r(function (e) {
                      e(t);
                    })
                ).then(a, o);
          }
          l((i = i.apply(e, t || [])).next());
        });
      }
      function h(e, t) {
        var r,
          i,
          n,
          s,
          a = {
            label: 0,
            sent: function () {
              if (1 & n[0]) throw n[1];
              return n[1];
            },
            trys: [],
            ops: [],
          };
        return (
          (s = { next: o(0), throw: o(1), return: o(2) }),
          "function" == typeof Symbol &&
            (s[Symbol.iterator] = function () {
              return this;
            }),
          s
        );
        function o(s) {
          return function (o) {
            return (function (s) {
              if (r) throw TypeError("Generator is already executing.");
              for (; a; )
                try {
                  if (
                    ((r = 1),
                    i &&
                      (n =
                        2 & s[0]
                          ? i.return
                          : s[0]
                          ? i.throw || ((n = i.return) && n.call(i), 0)
                          : i.next) &&
                      !(n = n.call(i, s[1])).done)
                  )
                    return n;
                  switch (((i = 0), n && (s = [2 & s[0], n.value]), s[0])) {
                    case 0:
                    case 1:
                      n = s;
                      break;
                    case 4:
                      return a.label++, { value: s[1], done: !1 };
                    case 5:
                      a.label++, (i = s[1]), (s = [0]);
                      continue;
                    case 7:
                      (s = a.ops.pop()), a.trys.pop();
                      continue;
                    default:
                      if (
                        !(n = (n = a.trys).length > 0 && n[n.length - 1]) &&
                        (6 === s[0] || 2 === s[0])
                      ) {
                        a = 0;
                        continue;
                      }
                      if (3 === s[0] && (!n || (s[1] > n[0] && s[1] < n[3]))) {
                        a.label = s[1];
                        break;
                      }
                      if (6 === s[0] && a.label < n[1]) {
                        (a.label = n[1]), (n = s);
                        break;
                      }
                      if (n && a.label < n[2]) {
                        (a.label = n[2]), a.ops.push(s);
                        break;
                      }
                      n[2] && a.ops.pop(), a.trys.pop();
                      continue;
                  }
                  s = t.call(e, a);
                } catch (e) {
                  (s = [6, e]), (i = 0);
                } finally {
                  r = n = 0;
                }
              if (5 & s[0]) throw s[1];
              return { value: s[0] ? s[1] : void 0, done: !0 };
            })([s, o]);
          };
        }
      }
      function d(e, t, r, i) {
        void 0 === i && (i = r), (e[i] = t[r]);
      }
      function p(e, t) {
        for (var r in e)
          "default" === r || t.hasOwnProperty(r) || (t[r] = e[r]);
      }
      function f(e) {
        var t = "function" == typeof Symbol && Symbol.iterator,
          r = t && e[t],
          i = 0;
        if (r) return r.call(e);
        if (e && "number" == typeof e.length)
          return {
            next: function () {
              return (
                e && i >= e.length && (e = void 0),
                { value: e && e[i++], done: !e }
              );
            },
          };
        throw TypeError(
          t ? "Object is not iterable." : "Symbol.iterator is not defined."
        );
      }
      function g(e, t) {
        var r = "function" == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var i,
          n,
          s = r.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(i = s.next()).done; )
            a.push(i.value);
        } catch (e) {
          n = { error: e };
        } finally {
          try {
            i && !i.done && (r = s.return) && r.call(s);
          } finally {
            if (n) throw n.error;
          }
        }
        return a;
      }
      function m() {
        for (var e = [], t = 0; t < arguments.length; t++)
          e = e.concat(g(arguments[t]));
        return e;
      }
      function y() {
        for (var e = 0, t = 0, r = arguments.length; t < r; t++)
          e += arguments[t].length;
        for (var i = Array(e), n = 0, t = 0; t < r; t++)
          for (var s = arguments[t], a = 0, o = s.length; a < o; a++, n++)
            i[n] = s[a];
        return i;
      }
      function w(e) {
        return this instanceof w ? ((this.v = e), this) : new w(e);
      }
      function b(e, t, r) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var i,
          n = r.apply(e, t || []),
          s = [];
        return (
          (i = {}),
          a("next"),
          a("throw"),
          a("return"),
          (i[Symbol.asyncIterator] = function () {
            return this;
          }),
          i
        );
        function a(e) {
          n[e] &&
            (i[e] = function (t) {
              return new Promise(function (r, i) {
                s.push([e, t, r, i]) > 1 || o(e, t);
              });
            });
        }
        function o(e, t) {
          try {
            var r;
            (r = n[e](t)).value instanceof w
              ? Promise.resolve(r.value.v).then(l, c)
              : u(s[0][2], r);
          } catch (e) {
            u(s[0][3], e);
          }
        }
        function l(e) {
          o("next", e);
        }
        function c(e) {
          o("throw", e);
        }
        function u(e, t) {
          e(t), s.shift(), s.length && o(s[0][0], s[0][1]);
        }
      }
      function v(e) {
        var t, r;
        return (
          (t = {}),
          i("next"),
          i("throw", function (e) {
            throw e;
          }),
          i("return"),
          (t[Symbol.iterator] = function () {
            return this;
          }),
          t
        );
        function i(i, n) {
          t[i] = e[i]
            ? function (t) {
                return (r = !r)
                  ? { value: w(e[i](t)), done: "return" === i }
                  : n
                  ? n(t)
                  : t;
              }
            : n;
        }
      }
      function E(e) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var t,
          r = e[Symbol.asyncIterator];
        return r
          ? r.call(e)
          : ((e = f(e)),
            (t = {}),
            i("next"),
            i("throw"),
            i("return"),
            (t[Symbol.asyncIterator] = function () {
              return this;
            }),
            t);
        function i(r) {
          t[r] =
            e[r] &&
            function (t) {
              return new Promise(function (i, n) {
                !(function (e, t, r, i) {
                  Promise.resolve(i).then(function (t) {
                    e({ value: t, done: r });
                  }, t);
                })(i, n, (t = e[r](t)).done, t.value);
              });
            };
        }
      }
      function A(e, t) {
        return (
          Object.defineProperty
            ? Object.defineProperty(e, "raw", { value: t })
            : (e.raw = t),
          e
        );
      }
      function C(e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var r in e) Object.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return (t.default = e), t;
      }
      function _(e) {
        return e && e.__esModule ? e : { default: e };
      }
      function I(e, t) {
        if (!t.has(e))
          throw TypeError("attempted to get private field on non-instance");
        return t.get(e);
      }
      function N(e, t, r) {
        if (!t.has(e))
          throw TypeError("attempted to set private field on non-instance");
        return t.set(e, r), r;
      }
    },
    76356: function (e, t, r) {
      "use strict";
      let i;
      r.d(t, {
        Z: function () {
          return pN;
        },
      });
      var n = {};
      r.r(n),
        r.d(n, {
          identity: function () {
            return ix;
          },
        });
      var s = {};
      r.r(s),
        r.d(s, {
          base2: function () {
            return ik;
          },
        });
      var a = {};
      r.r(a),
        r.d(a, {
          base8: function () {
            return iR;
          },
        });
      var o = {};
      r.r(o),
        r.d(o, {
          base10: function () {
            return iD;
          },
        });
      var l = {};
      r.r(l),
        r.d(l, {
          base16: function () {
            return iU;
          },
          base16upper: function () {
            return iL;
          },
        });
      var c = {};
      r.r(c),
        r.d(c, {
          base32: function () {
            return iM;
          },
          base32hex: function () {
            return i$;
          },
          base32hexpad: function () {
            return iz;
          },
          base32hexpadupper: function () {
            return iq;
          },
          base32hexupper: function () {
            return iH;
          },
          base32pad: function () {
            return ij;
          },
          base32padupper: function () {
            return iF;
          },
          base32upper: function () {
            return iB;
          },
          base32z: function () {
            return iV;
          },
        });
      var u = {};
      r.r(u),
        r.d(u, {
          base36: function () {
            return iG;
          },
          base36upper: function () {
            return iW;
          },
        });
      var h = {};
      r.r(h),
        r.d(h, {
          base58btc: function () {
            return iK;
          },
          base58flickr: function () {
            return iZ;
          },
        });
      var d = {};
      r.r(d),
        r.d(d, {
          base64: function () {
            return iJ;
          },
          base64pad: function () {
            return iQ;
          },
          base64url: function () {
            return iY;
          },
          base64urlpad: function () {
            return iX;
          },
        });
      var p = {};
      r.r(p),
        r.d(p, {
          base256emoji: function () {
            return i3;
          },
        });
      var f = {};
      r.r(f),
        r.d(f, {
          sha256: function () {
            return na;
          },
          sha512: function () {
            return no;
          },
        });
      var g = {};
      r.r(g),
        r.d(g, {
          identity: function () {
            return nl;
          },
        });
      var m = {};
      r.r(m),
        r.d(m, {
          code: function () {
            return nu;
          },
          decode: function () {
            return nd;
          },
          encode: function () {
            return nh;
          },
          name: function () {
            return nc;
          },
        });
      var y = {};
      r.r(y),
        r.d(y, {
          code: function () {
            return nm;
          },
          decode: function () {
            return nw;
          },
          encode: function () {
            return ny;
          },
          name: function () {
            return ng;
          },
        });
      var w = r(55445),
        b = r.n(w),
        v = r(40537);
      class E {}
      class A extends E {
        constructor(e) {
          super();
        }
      }
      let C = v.FIVE_SECONDS,
        _ = "heartbeat_pulse";
      class I extends A {
        constructor(e) {
          super(e),
            (this.events = new w.EventEmitter()),
            (this.interval = C),
            (this.interval = e?.interval || C);
        }
        static async init(e) {
          let t = new I(e);
          return await t.init(), t;
        }
        async init() {
          await this.initialize();
        }
        stop() {
          clearInterval(this.intervalRef);
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async initialize() {
          this.intervalRef = setInterval(
            () => this.pulse(),
            (0, v.toMiliseconds)(this.interval)
          );
        }
        pulse() {
          this.events.emit(_);
        }
      }
      let N =
          /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
        S =
          /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
        T = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
      function P(e, t) {
        if (
          "__proto__" === e ||
          ("constructor" === e && t && "object" == typeof t && "prototype" in t)
        ) {
          console.warn(
            `[destr] Dropping "${e}" key to prevent prototype pollution.`
          );
          return;
        }
        return t;
      }
      function O(e, t = {}) {
        if ("string" != typeof e) return e;
        let r = e.trim();
        if ('"' === e[0] && e.endsWith('"') && !e.includes("\\"))
          return r.slice(1, -1);
        if (r.length <= 9) {
          let e = r.toLowerCase();
          if ("true" === e) return !0;
          if ("false" === e) return !1;
          if ("undefined" === e) return;
          if ("null" === e) return null;
          if ("nan" === e) return Number.NaN;
          if ("infinity" === e) return Number.POSITIVE_INFINITY;
          if ("-infinity" === e) return Number.NEGATIVE_INFINITY;
        }
        if (!T.test(e)) {
          if (t.strict) throw SyntaxError("[destr] Invalid JSON");
          return e;
        }
        try {
          if (N.test(e) || S.test(e)) {
            if (t.strict) throw Error("[destr] Possible prototype pollution");
            return JSON.parse(e, P);
          }
          return JSON.parse(e);
        } catch (r) {
          if (t.strict) throw r;
          return e;
        }
      }
      var x = r(82957).Buffer;
      function k(e, ...t) {
        try {
          var r;
          return (r = e(...t)) && "function" == typeof r.then
            ? r
            : Promise.resolve(r);
        } catch (e) {
          return Promise.reject(e);
        }
      }
      function R(e) {
        if (
          (function (e) {
            let t = typeof e;
            return null === e || ("object" !== t && "function" !== t);
          })(e)
        )
          return String(e);
        if (
          (function (e) {
            let t = Object.getPrototypeOf(e);
            return !t || t.isPrototypeOf(Object);
          })(e) ||
          Array.isArray(e)
        )
          return JSON.stringify(e);
        if ("function" == typeof e.toJSON) return R(e.toJSON());
        throw Error("[unstorage] Cannot stringify value!");
      }
      let D = "base64:";
      function U(e) {
        return (
          (e &&
            e
              .split("?")[0]
              ?.replace(/[/\\]/g, ":")
              .replace(/:+/g, ":")
              .replace(/^:|:$/g, "")) ||
          ""
        );
      }
      function L(e) {
        return (e = U(e)) ? e + ":" : "";
      }
      let M = () => {
        let e = new Map();
        return {
          name: "memory",
          getInstance: () => e,
          hasItem: (t) => e.has(t),
          getItem: (t) => e.get(t) ?? null,
          getItemRaw: (t) => e.get(t) ?? null,
          setItem(t, r) {
            e.set(t, r);
          },
          setItemRaw(t, r) {
            e.set(t, r);
          },
          removeItem(t) {
            e.delete(t);
          },
          getKeys: () => [...e.keys()],
          clear() {
            e.clear();
          },
          dispose() {
            e.clear();
          },
        };
      };
      function B(e, t, r) {
        return e.watch ? e.watch((e, i) => t(e, r + i)) : () => {};
      }
      async function j(e) {
        "function" == typeof e.dispose && (await k(e.dispose));
      }
      function F(e) {
        return new Promise((t, r) => {
          (e.oncomplete = e.onsuccess = () => t(e.result)),
            (e.onabort = e.onerror = () => r(e.error));
        });
      }
      function $(e, t) {
        let r = indexedDB.open(e);
        r.onupgradeneeded = () => r.result.createObjectStore(t);
        let i = F(r);
        return (e, r) => i.then((i) => r(i.transaction(t, e).objectStore(t)));
      }
      function H() {
        return i || (i = $("keyval-store", "keyval")), i;
      }
      function z(e, t = H()) {
        return t("readonly", (t) => F(t.get(e)));
      }
      var q = r(80577),
        V = (e = {}) => {
          let t;
          let r = e.base && e.base.length > 0 ? `${e.base}:` : "",
            i = (e) => r + e;
          return (
            e.dbName && e.storeName && (t = $(e.dbName, e.storeName)),
            {
              name: "idb-keyval",
              options: e,
              hasItem: async (e) => !(typeof (await z(i(e), t)) > "u"),
              getItem: async (e) => (await z(i(e), t)) ?? null,
              setItem: (e, r) =>
                (function (e, t, r = H()) {
                  return r("readwrite", (r) => (r.put(t, e), F(r.transaction)));
                })(i(e), r, t),
              removeItem: (e) =>
                (function (e, t = H()) {
                  return t("readwrite", (t) => (t.delete(e), F(t.transaction)));
                })(i(e), t),
              getKeys: () =>
                (function (e = H()) {
                  return e("readonly", (e) => {
                    var t;
                    if (e.getAllKeys) return F(e.getAllKeys());
                    let r = [];
                    return ((t = (e) => r.push(e.key)),
                    (e.openCursor().onsuccess = function () {
                      this.result && (t(this.result), this.result.continue());
                    }),
                    F(e.transaction)).then(() => r);
                  });
                })(t),
              clear: () =>
                (function (e = H()) {
                  return e("readwrite", (e) => (e.clear(), F(e.transaction)));
                })(t),
            }
          );
        };
      class G {
        constructor() {
          this.indexedDb = (function (e = {}) {
            let t = {
                mounts: { "": e.driver || M() },
                mountpoints: [""],
                watching: !1,
                watchListeners: [],
                unwatch: {},
              },
              r = (e) => {
                for (let r of t.mountpoints)
                  if (e.startsWith(r))
                    return {
                      base: r,
                      relativeKey: e.slice(r.length),
                      driver: t.mounts[r],
                    };
                return { base: "", relativeKey: e, driver: t.mounts[""] };
              },
              i = (e, r) =>
                t.mountpoints
                  .filter((t) => t.startsWith(e) || (r && e.startsWith(t)))
                  .map((r) => ({
                    relativeBase:
                      e.length > r.length ? e.slice(r.length) : void 0,
                    mountpoint: r,
                    driver: t.mounts[r],
                  })),
              n = (e, r) => {
                if (t.watching)
                  for (let i of ((r = U(r)), t.watchListeners)) i(e, r);
              },
              s = async () => {
                if (!t.watching)
                  for (let e in ((t.watching = !0), t.mounts))
                    t.unwatch[e] = await B(t.mounts[e], n, e);
              },
              a = async () => {
                if (t.watching) {
                  for (let e in t.unwatch) await t.unwatch[e]();
                  (t.unwatch = {}), (t.watching = !1);
                }
              },
              o = (e, t, i) => {
                let n = new Map(),
                  s = (e) => {
                    let t = n.get(e.base);
                    return (
                      t ||
                        ((t = { driver: e.driver, base: e.base, items: [] }),
                        n.set(e.base, t)),
                      t
                    );
                  };
                for (let i of e) {
                  let e = "string" == typeof i,
                    n = U(e ? i : i.key),
                    a = e ? void 0 : i.value,
                    o = e || !i.options ? t : { ...t, ...i.options },
                    l = r(n);
                  s(l).items.push({
                    key: n,
                    value: a,
                    relativeKey: l.relativeKey,
                    options: o,
                  });
                }
                return Promise.all([...n.values()].map((e) => i(e))).then((e) =>
                  e.flat()
                );
              },
              l = {
                hasItem(e, t = {}) {
                  let { relativeKey: i, driver: n } = r((e = U(e)));
                  return k(n.hasItem, i, t);
                },
                getItem(e, t = {}) {
                  let { relativeKey: i, driver: n } = r((e = U(e)));
                  return k(n.getItem, i, t).then((e) => O(e));
                },
                getItems: (e, t = {}) =>
                  o(e, t, (e) =>
                    e.driver.getItems
                      ? k(
                          e.driver.getItems,
                          e.items.map((e) => ({
                            key: e.relativeKey,
                            options: e.options,
                          })),
                          t
                        ).then((t) =>
                          t.map((t) => ({
                            key: (function (...e) {
                              return U(e.join(":"));
                            })(e.base, t.key),
                            value: O(t.value),
                          }))
                        )
                      : Promise.all(
                          e.items.map((t) =>
                            k(e.driver.getItem, t.relativeKey, t.options).then(
                              (e) => ({ key: t.key, value: O(e) })
                            )
                          )
                        )
                  ),
                getItemRaw(e, t = {}) {
                  let { relativeKey: i, driver: n } = r((e = U(e)));
                  return n.getItemRaw
                    ? k(n.getItemRaw, i, t)
                    : k(n.getItem, i, t).then((e) => {
                        var t;
                        return "string" == typeof e && e.startsWith(D)
                          ? ((t = e.slice(D.length)),
                            globalThis.Buffer
                              ? x.from(t, "base64")
                              : Uint8Array.from(globalThis.atob(t), (e) =>
                                  e.codePointAt(0)
                                ))
                          : e;
                      });
                },
                async setItem(e, t, i = {}) {
                  if (void 0 === t) return l.removeItem(e);
                  let { relativeKey: s, driver: a } = r((e = U(e)));
                  a.setItem &&
                    (await k(a.setItem, s, R(t), i), a.watch || n("update", e));
                },
                async setItems(e, t) {
                  await o(e, t, async (e) => {
                    if (e.driver.setItems)
                      return k(
                        e.driver.setItems,
                        e.items.map((e) => ({
                          key: e.relativeKey,
                          value: R(e.value),
                          options: e.options,
                        })),
                        t
                      );
                    e.driver.setItem &&
                      (await Promise.all(
                        e.items.map((t) =>
                          k(
                            e.driver.setItem,
                            t.relativeKey,
                            R(t.value),
                            t.options
                          )
                        )
                      ));
                  });
                },
                async setItemRaw(e, t, i = {}) {
                  if (void 0 === t) return l.removeItem(e, i);
                  let { relativeKey: s, driver: a } = r((e = U(e)));
                  if (a.setItemRaw) await k(a.setItemRaw, s, t, i);
                  else {
                    if (!a.setItem) return;
                    await k(
                      a.setItem,
                      s,
                      "string" == typeof t
                        ? t
                        : D +
                            (globalThis.Buffer
                              ? x.from(t).toString("base64")
                              : globalThis.btoa(String.fromCodePoint(...t))),
                      i
                    );
                  }
                  a.watch || n("update", e);
                },
                async removeItem(e, t = {}) {
                  "boolean" == typeof t && (t = { removeMeta: t });
                  let { relativeKey: i, driver: s } = r((e = U(e)));
                  s.removeItem &&
                    (await k(s.removeItem, i, t),
                    (t.removeMeta || t.removeMata) &&
                      (await k(s.removeItem, i + "$", t)),
                    s.watch || n("remove", e));
                },
                async getMeta(e, t = {}) {
                  "boolean" == typeof t && (t = { nativeOnly: t });
                  let { relativeKey: i, driver: n } = r((e = U(e))),
                    s = Object.create(null);
                  if (
                    (n.getMeta && Object.assign(s, await k(n.getMeta, i, t)),
                    !t.nativeOnly)
                  ) {
                    let e = await k(n.getItem, i + "$", t).then((e) => O(e));
                    e &&
                      "object" == typeof e &&
                      ("string" == typeof e.atime &&
                        (e.atime = new Date(e.atime)),
                      "string" == typeof e.mtime &&
                        (e.mtime = new Date(e.mtime)),
                      Object.assign(s, e));
                  }
                  return s;
                },
                setMeta(e, t, r = {}) {
                  return this.setItem(e + "$", t, r);
                },
                removeMeta(e, t = {}) {
                  return this.removeItem(e + "$", t);
                },
                async getKeys(e, t = {}) {
                  let r = i((e = L(e)), !0),
                    n = [],
                    s = [],
                    a = !0;
                  for (let e of r) {
                    for (let r of (e.driver.flags?.maxDepth || (a = !1),
                    await k(e.driver.getKeys, e.relativeBase, t))) {
                      let t = e.mountpoint + U(r);
                      n.some((e) => t.startsWith(e)) || s.push(t);
                    }
                    n = [
                      e.mountpoint,
                      ...n.filter((t) => !t.startsWith(e.mountpoint)),
                    ];
                  }
                  let o = void 0 !== t.maxDepth && !a;
                  return s.filter((r) => {
                    var i;
                    return (
                      (!o ||
                        (function (e, t) {
                          if (void 0 === t) return !0;
                          let r = 0,
                            i = e.indexOf(":");
                          for (; i > -1; ) r++, (i = e.indexOf(":", i + 1));
                          return r <= t;
                        })(r, t.maxDepth)) &&
                      ((i = e)
                        ? r.startsWith(i) && "$" !== r[r.length - 1]
                        : "$" !== r[r.length - 1])
                    );
                  });
                },
                async clear(e, t = {}) {
                  (e = L(e)),
                    await Promise.all(
                      i(e, !1).map(async (e) =>
                        e.driver.clear
                          ? k(e.driver.clear, e.relativeBase, t)
                          : e.driver.removeItem
                          ? Promise.all(
                              (
                                await e.driver.getKeys(e.relativeBase || "", t)
                              ).map((r) => e.driver.removeItem(r, t))
                            )
                          : void 0
                      )
                    );
                },
                async dispose() {
                  await Promise.all(Object.values(t.mounts).map((e) => j(e)));
                },
                watch: async (e) => (
                  await s(),
                  t.watchListeners.push(e),
                  async () => {
                    (t.watchListeners = t.watchListeners.filter(
                      (t) => t !== e
                    )),
                      0 === t.watchListeners.length && (await a());
                  }
                ),
                async unwatch() {
                  (t.watchListeners = []), await a();
                },
                mount(e, r) {
                  if ((e = L(e)) && t.mounts[e])
                    throw Error(`already mounted at ${e}`);
                  return (
                    e &&
                      (t.mountpoints.push(e),
                      t.mountpoints.sort((e, t) => t.length - e.length)),
                    (t.mounts[e] = r),
                    t.watching &&
                      Promise.resolve(B(r, n, e))
                        .then((r) => {
                          t.unwatch[e] = r;
                        })
                        .catch(console.error),
                    l
                  );
                },
                async unmount(e, r = !0) {
                  (e = L(e)) &&
                    t.mounts[e] &&
                    (t.watching &&
                      e in t.unwatch &&
                      (t.unwatch[e]?.(), delete t.unwatch[e]),
                    r && (await j(t.mounts[e])),
                    (t.mountpoints = t.mountpoints.filter((t) => t !== e)),
                    delete t.mounts[e]);
                },
                getMount(e = "") {
                  let t = r((e = U(e) + ":"));
                  return { driver: t.driver, base: t.base };
                },
                getMounts: (e = "", t = {}) =>
                  i((e = U(e)), t.parents).map((e) => ({
                    driver: e.driver,
                    base: e.mountpoint,
                  })),
                keys: (e, t = {}) => l.getKeys(e, t),
                get: (e, t = {}) => l.getItem(e, t),
                set: (e, t, r = {}) => l.setItem(e, t, r),
                has: (e, t = {}) => l.hasItem(e, t),
                del: (e, t = {}) => l.removeItem(e, t),
                remove: (e, t = {}) => l.removeItem(e, t),
              };
            return l;
          })({
            driver: V({
              dbName: "WALLET_CONNECT_V2_INDEXED_DB",
              storeName: "keyvaluestorage",
            }),
          });
        }
        async getKeys() {
          return this.indexedDb.getKeys();
        }
        async getEntries() {
          return (
            await this.indexedDb.getItems(await this.indexedDb.getKeys())
          ).map((e) => [e.key, e.value]);
        }
        async getItem(e) {
          let t = await this.indexedDb.getItem(e);
          if (null !== t) return t;
        }
        async setItem(e, t) {
          await this.indexedDb.setItem(e, (0, q.u)(t));
        }
        async removeItem(e) {
          await this.indexedDb.removeItem(e);
        }
      }
      var W =
          "u" > typeof globalThis
            ? globalThis
            : "u" > typeof window
            ? window
            : "u" > typeof r.g
            ? r.g
            : "u" > typeof self
            ? self
            : {},
        K = { exports: {} };
      function Z(e) {
        var t;
        return [e[0], (0, q.D)(null != (t = e[1]) ? t : "")];
      }
      !(function () {
        function e() {}
        (e.prototype.getItem = function (e) {
          return this.hasOwnProperty(e) ? String(this[e]) : null;
        }),
          (e.prototype.setItem = function (e, t) {
            this[e] = String(t);
          }),
          (e.prototype.removeItem = function (e) {
            delete this[e];
          }),
          (e.prototype.clear = function () {
            let e = this;
            Object.keys(e).forEach(function (t) {
              (e[t] = void 0), delete e[t];
            });
          }),
          (e.prototype.key = function (e) {
            return (e = e || 0), Object.keys(this)[e];
          }),
          e.prototype.__defineGetter__("length", function () {
            return Object.keys(this).length;
          }),
          "u" > typeof W && W.localStorage
            ? (K.exports = W.localStorage)
            : "u" > typeof window && window.localStorage
            ? (K.exports = window.localStorage)
            : (K.exports = new e());
      })();
      class J {
        constructor() {
          this.localStorage = K.exports;
        }
        async getKeys() {
          return Object.keys(this.localStorage);
        }
        async getEntries() {
          return Object.entries(this.localStorage).map(Z);
        }
        async getItem(e) {
          let t = this.localStorage.getItem(e);
          if (null !== t) return (0, q.D)(t);
        }
        async setItem(e, t) {
          this.localStorage.setItem(e, (0, q.u)(t));
        }
        async removeItem(e) {
          this.localStorage.removeItem(e);
        }
      }
      let Q = async (e, t, r) => {
          let i = "wc_storage_version",
            n = await t.getItem(i);
          if (n && n >= 1) {
            r(t);
            return;
          }
          let s = await e.getKeys();
          if (!s.length) {
            r(t);
            return;
          }
          let a = [];
          for (; s.length; ) {
            let r = s.shift();
            if (!r) continue;
            let i = r.toLowerCase();
            if (
              i.includes("wc@") ||
              i.includes("walletconnect") ||
              i.includes("wc_") ||
              i.includes("wallet_connect")
            ) {
              let i = await e.getItem(r);
              await t.setItem(r, i), a.push(r);
            }
          }
          await t.setItem(i, 1), r(t), Y(e, a);
        },
        Y = async (e, t) => {
          t.length &&
            t.forEach(async (t) => {
              await e.removeItem(t);
            });
        };
      class X {
        constructor() {
          (this.initialized = !1),
            (this.setInitialized = (e) => {
              (this.storage = e), (this.initialized = !0);
            });
          let e = new J();
          this.storage = e;
          try {
            let t = new G();
            Q(e, t, this.setInitialized);
          } catch {
            this.initialized = !0;
          }
        }
        async getKeys() {
          return await this.initialize(), this.storage.getKeys();
        }
        async getEntries() {
          return await this.initialize(), this.storage.getEntries();
        }
        async getItem(e) {
          return await this.initialize(), this.storage.getItem(e);
        }
        async setItem(e, t) {
          return await this.initialize(), this.storage.setItem(e, t);
        }
        async removeItem(e) {
          return await this.initialize(), this.storage.removeItem(e);
        }
        async initialize() {
          this.initialized ||
            (await new Promise((e) => {
              let t = setInterval(() => {
                this.initialized && (clearInterval(t), e());
              }, 20);
            }));
        }
      }
      var ee = r(15133),
        et = Object.defineProperty,
        er = (e, t, r) =>
          t in e
            ? et(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        ei = (e, t, r) => er(e, "symbol" != typeof t ? t + "" : t, r);
      class en extends E {
        constructor(e) {
          super(),
            (this.opts = e),
            ei(this, "protocol", "wc"),
            ei(this, "version", 2);
        }
      }
      var es = Object.defineProperty,
        ea = (e, t, r) =>
          t in e
            ? es(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        eo = (e, t, r) => ea(e, "symbol" != typeof t ? t + "" : t, r);
      class el extends E {
        constructor(e, t) {
          super(),
            (this.core = e),
            (this.logger = t),
            eo(this, "records", new Map());
        }
      }
      class ec {
        constructor(e, t) {
          (this.logger = e), (this.core = t);
        }
      }
      class eu extends E {
        constructor(e, t) {
          super(), (this.relayer = e), (this.logger = t);
        }
      }
      class eh extends E {
        constructor(e) {
          super();
        }
      }
      class ed {
        constructor(e, t, r, i) {
          (this.core = e), (this.logger = t), (this.name = r);
        }
      }
      class ep extends E {
        constructor(e, t) {
          super(), (this.relayer = e), (this.logger = t);
        }
      }
      class ef extends E {
        constructor(e, t) {
          super(), (this.core = e), (this.logger = t);
        }
      }
      class eg {
        constructor(e, t, r) {
          (this.core = e), (this.logger = t), (this.store = r);
        }
      }
      class em {
        constructor(e, t) {
          (this.projectId = e), (this.logger = t);
        }
      }
      class ey {
        constructor(e, t, r) {
          (this.core = e), (this.logger = t), (this.telemetryEnabled = r);
        }
      }
      var ew = Object.defineProperty,
        eb = (e, t, r) =>
          t in e
            ? ew(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        ev = (e, t, r) => eb(e, "symbol" != typeof t ? t + "" : t, r);
      class eE {
        constructor(e) {
          (this.opts = e), ev(this, "protocol", "wc"), ev(this, "version", 2);
        }
      }
      class eA {
        constructor(e) {
          this.client = e;
        }
      }
      function eC(e, ...t) {
        if (
          !(
            e instanceof Uint8Array ||
            (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
          )
        )
          throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function e_(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      let eI =
          "object" == typeof globalThis && "crypto" in globalThis
            ? globalThis.crypto
            : void 0,
        eN = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
      function eS(e) {
        return (
          "string" == typeof e &&
            (e = (function (e) {
              if ("string" != typeof e)
                throw Error("utf8ToBytes expected string, got " + typeof e);
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          eC(e),
          e
        );
      }
      class eT {
        clone() {
          return this._cloneInto();
        }
      }
      function eP(e = 32) {
        if (eI && "function" == typeof eI.getRandomValues)
          return eI.getRandomValues(new Uint8Array(e));
        if (eI && "function" == typeof eI.randomBytes) return eI.randomBytes(e);
        throw Error("crypto.getRandomValues must be defined");
      }
      class eO extends eT {
        constructor(e, t, r, i) {
          super(),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.padOffset = r),
            (this.isLE = i),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.buffer = new Uint8Array(e)),
            (this.view = eN(this.buffer));
        }
        update(e) {
          e_(this);
          let { view: t, buffer: r, blockLen: i } = this,
            n = (e = eS(e)).length;
          for (let s = 0; s < n; ) {
            let a = Math.min(i - this.pos, n - s);
            if (a === i) {
              let t = eN(e);
              for (; i <= n - s; s += i) this.process(t, s);
              continue;
            }
            r.set(e.subarray(s, s + a), this.pos),
              (this.pos += a),
              (s += a),
              this.pos === i && (this.process(t, 0), (this.pos = 0));
          }
          return (this.length += e.length), this.roundClean(), this;
        }
        digestInto(e) {
          e_(this),
            (function (e, t) {
              eC(e);
              let r = t.outputLen;
              if (e.length < r)
                throw Error(
                  "digestInto() expects output buffer of length at least " + r
                );
            })(e, this),
            (this.finished = !0);
          let { buffer: t, view: r, blockLen: i, isLE: n } = this,
            { pos: s } = this;
          (t[s++] = 128),
            this.buffer.subarray(s).fill(0),
            this.padOffset > i - s && (this.process(r, 0), (s = 0));
          for (let e = s; e < i; e++) t[e] = 0;
          (function (e, t, r, i) {
            if ("function" == typeof e.setBigUint64)
              return e.setBigUint64(t, r, i);
            let n = BigInt(32),
              s = BigInt(4294967295),
              a = Number((r >> n) & s),
              o = Number(r & s),
              l = i ? 4 : 0,
              c = i ? 0 : 4;
            e.setUint32(t + l, a, i), e.setUint32(t + c, o, i);
          })(r, i - 8, BigInt(8 * this.length), n),
            this.process(r, 0);
          let a = eN(e),
            o = this.outputLen;
          if (o % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
          let l = o / 4,
            c = this.get();
          if (l > c.length) throw Error("_sha2: outputLen bigger than state");
          for (let e = 0; e < l; e++) a.setUint32(4 * e, c[e], n);
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          let {
            blockLen: t,
            buffer: r,
            length: i,
            finished: n,
            destroyed: s,
            pos: a,
          } = this;
          return (
            (e.length = i),
            (e.pos = a),
            (e.finished = n),
            (e.destroyed = s),
            i % t && e.buffer.set(r),
            e
          );
        }
      }
      let ex = BigInt(4294967296 - 1),
        ek = BigInt(32),
        eR = {
          split: function (e, t = !1) {
            let r = new Uint32Array(e.length),
              i = new Uint32Array(e.length);
            for (let n = 0; n < e.length; n++) {
              let { h: s, l: a } = (function (e, t = !1) {
                return t
                  ? { h: Number(e & ex), l: Number((e >> ek) & ex) }
                  : { h: 0 | Number((e >> ek) & ex), l: 0 | Number(e & ex) };
              })(e[n], t);
              [r[n], i[n]] = [s, a];
            }
            return [r, i];
          },
          shrSH: (e, t, r) => e >>> r,
          shrSL: (e, t, r) => (e << (32 - r)) | (t >>> r),
          rotrSH: (e, t, r) => (e >>> r) | (t << (32 - r)),
          rotrSL: (e, t, r) => (e << (32 - r)) | (t >>> r),
          rotrBH: (e, t, r) => (e << (64 - r)) | (t >>> (r - 32)),
          rotrBL: (e, t, r) => (e >>> (r - 32)) | (t << (64 - r)),
          add: function (e, t, r, i) {
            let n = (t >>> 0) + (i >>> 0);
            return { h: (e + r + ((n / 4294967296) | 0)) | 0, l: 0 | n };
          },
          add3L: (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0),
          add3H: (e, t, r, i) => (t + r + i + ((e / 4294967296) | 0)) | 0,
          add4L: (e, t, r, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0),
          add4H: (e, t, r, i, n) =>
            (t + r + i + n + ((e / 4294967296) | 0)) | 0,
          add5H: (e, t, r, i, n, s) =>
            (t + r + i + n + s + ((e / 4294967296) | 0)) | 0,
          add5L: (e, t, r, i, n) =>
            (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0) + (n >>> 0),
        },
        [eD, eU] = eR.split(
          [
            "0x428a2f98d728ae22",
            "0x7137449123ef65cd",
            "0xb5c0fbcfec4d3b2f",
            "0xe9b5dba58189dbbc",
            "0x3956c25bf348b538",
            "0x59f111f1b605d019",
            "0x923f82a4af194f9b",
            "0xab1c5ed5da6d8118",
            "0xd807aa98a3030242",
            "0x12835b0145706fbe",
            "0x243185be4ee4b28c",
            "0x550c7dc3d5ffb4e2",
            "0x72be5d74f27b896f",
            "0x80deb1fe3b1696b1",
            "0x9bdc06a725c71235",
            "0xc19bf174cf692694",
            "0xe49b69c19ef14ad2",
            "0xefbe4786384f25e3",
            "0x0fc19dc68b8cd5b5",
            "0x240ca1cc77ac9c65",
            "0x2de92c6f592b0275",
            "0x4a7484aa6ea6e483",
            "0x5cb0a9dcbd41fbd4",
            "0x76f988da831153b5",
            "0x983e5152ee66dfab",
            "0xa831c66d2db43210",
            "0xb00327c898fb213f",
            "0xbf597fc7beef0ee4",
            "0xc6e00bf33da88fc2",
            "0xd5a79147930aa725",
            "0x06ca6351e003826f",
            "0x142929670a0e6e70",
            "0x27b70a8546d22ffc",
            "0x2e1b21385c26c926",
            "0x4d2c6dfc5ac42aed",
            "0x53380d139d95b3df",
            "0x650a73548baf63de",
            "0x766a0abb3c77b2a8",
            "0x81c2c92e47edaee6",
            "0x92722c851482353b",
            "0xa2bfe8a14cf10364",
            "0xa81a664bbc423001",
            "0xc24b8b70d0f89791",
            "0xc76c51a30654be30",
            "0xd192e819d6ef5218",
            "0xd69906245565a910",
            "0xf40e35855771202a",
            "0x106aa07032bbd1b8",
            "0x19a4c116b8d2d0c8",
            "0x1e376c085141ab53",
            "0x2748774cdf8eeb99",
            "0x34b0bcb5e19b48a8",
            "0x391c0cb3c5c95a63",
            "0x4ed8aa4ae3418acb",
            "0x5b9cca4f7763e373",
            "0x682e6ff3d6b2b8a3",
            "0x748f82ee5defb2fc",
            "0x78a5636f43172f60",
            "0x84c87814a1f0ab72",
            "0x8cc702081a6439ec",
            "0x90befffa23631e28",
            "0xa4506cebde82bde9",
            "0xbef9a3f7b2c67915",
            "0xc67178f2e372532b",
            "0xca273eceea26619c",
            "0xd186b8c721c0c207",
            "0xeada7dd6cde0eb1e",
            "0xf57d4f7fee6ed178",
            "0x06f067aa72176fba",
            "0x0a637dc5a2c898a6",
            "0x113f9804bef90dae",
            "0x1b710b35131c471b",
            "0x28db77f523047d84",
            "0x32caab7b40c72493",
            "0x3c9ebe0a15c9bebc",
            "0x431d67c49c100d4c",
            "0x4cc5d4becb3e42b6",
            "0x597f299cfc657e2a",
            "0x5fcb6fab3ad6faec",
            "0x6c44198c4a475817",
          ].map((e) => BigInt(e))
        ),
        eL = new Uint32Array(80),
        eM = new Uint32Array(80);
      class eB extends eO {
        constructor() {
          super(128, 64, 16, !1),
            (this.Ah = 1779033703),
            (this.Al = -205731576),
            (this.Bh = -1150833019),
            (this.Bl = -2067093701),
            (this.Ch = 1013904242),
            (this.Cl = -23791573),
            (this.Dh = -1521486534),
            (this.Dl = 1595750129),
            (this.Eh = 1359893119),
            (this.El = -1377402159),
            (this.Fh = -1694144372),
            (this.Fl = 725511199),
            (this.Gh = 528734635),
            (this.Gl = -79577749),
            (this.Hh = 1541459225),
            (this.Hl = 327033209);
        }
        get() {
          let {
            Ah: e,
            Al: t,
            Bh: r,
            Bl: i,
            Ch: n,
            Cl: s,
            Dh: a,
            Dl: o,
            Eh: l,
            El: c,
            Fh: u,
            Fl: h,
            Gh: d,
            Gl: p,
            Hh: f,
            Hl: g,
          } = this;
          return [e, t, r, i, n, s, a, o, l, c, u, h, d, p, f, g];
        }
        set(e, t, r, i, n, s, a, o, l, c, u, h, d, p, f, g) {
          (this.Ah = 0 | e),
            (this.Al = 0 | t),
            (this.Bh = 0 | r),
            (this.Bl = 0 | i),
            (this.Ch = 0 | n),
            (this.Cl = 0 | s),
            (this.Dh = 0 | a),
            (this.Dl = 0 | o),
            (this.Eh = 0 | l),
            (this.El = 0 | c),
            (this.Fh = 0 | u),
            (this.Fl = 0 | h),
            (this.Gh = 0 | d),
            (this.Gl = 0 | p),
            (this.Hh = 0 | f),
            (this.Hl = 0 | g);
        }
        process(e, t) {
          for (let r = 0; r < 16; r++, t += 4)
            (eL[r] = e.getUint32(t)), (eM[r] = e.getUint32((t += 4)));
          for (let e = 16; e < 80; e++) {
            let t = 0 | eL[e - 15],
              r = 0 | eM[e - 15],
              i = eR.rotrSH(t, r, 1) ^ eR.rotrSH(t, r, 8) ^ eR.shrSH(t, r, 7),
              n = eR.rotrSL(t, r, 1) ^ eR.rotrSL(t, r, 8) ^ eR.shrSL(t, r, 7),
              s = 0 | eL[e - 2],
              a = 0 | eM[e - 2],
              o = eR.rotrSH(s, a, 19) ^ eR.rotrBH(s, a, 61) ^ eR.shrSH(s, a, 6),
              l = eR.rotrSL(s, a, 19) ^ eR.rotrBL(s, a, 61) ^ eR.shrSL(s, a, 6),
              c = eR.add4L(n, l, eM[e - 7], eM[e - 16]),
              u = eR.add4H(c, i, o, eL[e - 7], eL[e - 16]);
            (eL[e] = 0 | u), (eM[e] = 0 | c);
          }
          let {
            Ah: r,
            Al: i,
            Bh: n,
            Bl: s,
            Ch: a,
            Cl: o,
            Dh: l,
            Dl: c,
            Eh: u,
            El: h,
            Fh: d,
            Fl: p,
            Gh: f,
            Gl: g,
            Hh: m,
            Hl: y,
          } = this;
          for (let e = 0; e < 80; e++) {
            let t =
                eR.rotrSH(u, h, 14) ^ eR.rotrSH(u, h, 18) ^ eR.rotrBH(u, h, 41),
              w =
                eR.rotrSL(u, h, 14) ^ eR.rotrSL(u, h, 18) ^ eR.rotrBL(u, h, 41),
              b = (u & d) ^ (~u & f),
              v = (h & p) ^ (~h & g),
              E = eR.add5L(y, w, v, eU[e], eM[e]),
              A = eR.add5H(E, m, t, b, eD[e], eL[e]),
              C = 0 | E,
              _ =
                eR.rotrSH(r, i, 28) ^ eR.rotrBH(r, i, 34) ^ eR.rotrBH(r, i, 39),
              I =
                eR.rotrSL(r, i, 28) ^ eR.rotrBL(r, i, 34) ^ eR.rotrBL(r, i, 39),
              N = (r & n) ^ (r & a) ^ (n & a),
              S = (i & s) ^ (i & o) ^ (s & o);
            (m = 0 | f),
              (y = 0 | g),
              (f = 0 | d),
              (g = 0 | p),
              (d = 0 | u),
              (p = 0 | h),
              ({ h: u, l: h } = eR.add(0 | l, 0 | c, 0 | A, 0 | C)),
              (l = 0 | a),
              (c = 0 | o),
              (a = 0 | n),
              (o = 0 | s),
              (n = 0 | r),
              (s = 0 | i);
            let T = eR.add3L(C, I, S);
            (r = eR.add3H(T, A, _, N)), (i = 0 | T);
          }
          ({ h: r, l: i } = eR.add(0 | this.Ah, 0 | this.Al, 0 | r, 0 | i)),
            ({ h: n, l: s } = eR.add(0 | this.Bh, 0 | this.Bl, 0 | n, 0 | s)),
            ({ h: a, l: o } = eR.add(0 | this.Ch, 0 | this.Cl, 0 | a, 0 | o)),
            ({ h: l, l: c } = eR.add(0 | this.Dh, 0 | this.Dl, 0 | l, 0 | c)),
            ({ h: u, l: h } = eR.add(0 | this.Eh, 0 | this.El, 0 | u, 0 | h)),
            ({ h: d, l: p } = eR.add(0 | this.Fh, 0 | this.Fl, 0 | d, 0 | p)),
            ({ h: f, l: g } = eR.add(0 | this.Gh, 0 | this.Gl, 0 | f, 0 | g)),
            ({ h: m, l: y } = eR.add(0 | this.Hh, 0 | this.Hl, 0 | m, 0 | y)),
            this.set(r, i, n, s, a, o, l, c, u, h, d, p, f, g, m, y);
        }
        roundClean() {
          eL.fill(0), eM.fill(0);
        }
        destroy() {
          this.buffer.fill(0),
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      }
      let ej = (function (e) {
          let t = (t) => e().update(eS(t)).digest(),
            r = e();
          return (
            (t.outputLen = r.outputLen),
            (t.blockLen = r.blockLen),
            (t.create = () => e()),
            t
          );
        })(() => new eB()),
        eF = BigInt(0),
        e$ = BigInt(1),
        eH = BigInt(2);
      function ez(e) {
        return (
          e instanceof Uint8Array ||
          (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
        );
      }
      function eq(e) {
        if (!ez(e)) throw Error("Uint8Array expected");
      }
      function eV(e, t) {
        if ("boolean" != typeof t)
          throw Error(e + " boolean expected, got " + t);
      }
      let eG = Array.from({ length: 256 }, (e, t) =>
        t.toString(16).padStart(2, "0")
      );
      function eW(e) {
        eq(e);
        let t = "";
        for (let r = 0; r < e.length; r++) t += eG[e[r]];
        return t;
      }
      function eK(e) {
        if ("string" != typeof e)
          throw Error("hex string expected, got " + typeof e);
        return "" === e ? eF : BigInt("0x" + e);
      }
      let eZ = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function eJ(e) {
        return e >= eZ._0 && e <= eZ._9
          ? e - eZ._0
          : e >= eZ.A && e <= eZ.F
          ? e - (eZ.A - 10)
          : e >= eZ.a && e <= eZ.f
          ? e - (eZ.a - 10)
          : void 0;
      }
      function eQ(e) {
        if ("string" != typeof e)
          throw Error("hex string expected, got " + typeof e);
        let t = e.length,
          r = t / 2;
        if (t % 2)
          throw Error("hex string expected, got unpadded hex of length " + t);
        let i = new Uint8Array(r);
        for (let t = 0, n = 0; t < r; t++, n += 2) {
          let r = eJ(e.charCodeAt(n)),
            s = eJ(e.charCodeAt(n + 1));
          if (void 0 === r || void 0 === s)
            throw Error(
              'hex string expected, got non-hex character "' +
                (e[n] + e[n + 1]) +
                '" at index ' +
                n
            );
          i[t] = 16 * r + s;
        }
        return i;
      }
      function eY(e) {
        return eq(e), eK(eW(Uint8Array.from(e).reverse()));
      }
      function eX(e, t) {
        return eQ(e.toString(16).padStart(2 * t, "0"));
      }
      function e0(e, t) {
        return eX(e, t).reverse();
      }
      function e1(e, t, r) {
        let i;
        if ("string" == typeof t)
          try {
            i = eQ(t);
          } catch (t) {
            throw Error(e + " must be hex string or Uint8Array, cause: " + t);
          }
        else if (ez(t)) i = Uint8Array.from(t);
        else throw Error(e + " must be hex string or Uint8Array");
        let n = i.length;
        if ("number" == typeof r && n !== r)
          throw Error(e + " of length " + r + " expected, got " + n);
        return i;
      }
      function e2(...e) {
        let t = 0;
        for (let r = 0; r < e.length; r++) {
          let i = e[r];
          eq(i), (t += i.length);
        }
        let r = new Uint8Array(t);
        for (let t = 0, i = 0; t < e.length; t++) {
          let n = e[t];
          r.set(n, i), (i += n.length);
        }
        return r;
      }
      let e3 = (e) => "bigint" == typeof e && eF <= e;
      function e5(e, t, r, i) {
        if (!(e3(t) && e3(r) && e3(i)) || !(r <= t) || !(t < i))
          throw Error(
            "expected valid " + e + ": " + r + " <= n < " + i + ", got " + t
          );
      }
      let e8 = (e) => (eH << BigInt(e - 1)) - e$,
        e4 = {
          bigint: (e) => "bigint" == typeof e,
          function: (e) => "function" == typeof e,
          boolean: (e) => "boolean" == typeof e,
          string: (e) => "string" == typeof e,
          stringOrUint8Array: (e) => "string" == typeof e || ez(e),
          isSafeInteger: (e) => Number.isSafeInteger(e),
          array: (e) => Array.isArray(e),
          field: (e, t) => t.Fp.isValid(e),
          hash: (e) =>
            "function" == typeof e && Number.isSafeInteger(e.outputLen),
        };
      function e6(e, t, r = {}) {
        let i = (t, r, i) => {
          let n = e4[r];
          if ("function" != typeof n) throw Error("invalid validator function");
          let s = e[t];
          if (!(i && void 0 === s) && !n(s, e))
            throw Error(
              "param " + String(t) + " is invalid. Expected " + r + ", got " + s
            );
        };
        for (let [e, r] of Object.entries(t)) i(e, r, !1);
        for (let [e, t] of Object.entries(r)) i(e, t, !0);
        return e;
      }
      function e9(e) {
        let t = new WeakMap();
        return (r, ...i) => {
          let n = t.get(r);
          if (void 0 !== n) return n;
          let s = e(r, ...i);
          return t.set(r, s), s;
        };
      }
      let e7 = BigInt(0),
        te = BigInt(1),
        tt = BigInt(2),
        tr = BigInt(3),
        ti = BigInt(4),
        tn = BigInt(5),
        ts = BigInt(8);
      function ta(e, t) {
        let r = e % t;
        return r >= e7 ? r : t + r;
      }
      function to(e, t, r) {
        let i = e;
        for (; t-- > e7; ) (i *= i), (i %= r);
        return i;
      }
      function tl(e, t) {
        if (e === e7) throw Error("invert: expected non-zero number");
        if (t <= e7) throw Error("invert: expected positive modulus, got " + t);
        let r = ta(e, t),
          i = t,
          n = e7,
          s = te;
        for (; r !== e7; ) {
          let e = i / r,
            t = i % r,
            a = n - s * e;
          (i = r), (r = t), (n = s), (s = a);
        }
        if (i !== te) throw Error("invert: does not exist");
        return ta(n, t);
      }
      let tc = (e, t) => (ta(e, t) & te) === te,
        tu = [
          "create",
          "isValid",
          "is0",
          "neg",
          "inv",
          "sqrt",
          "sqr",
          "eql",
          "add",
          "sub",
          "mul",
          "pow",
          "div",
          "addN",
          "subN",
          "mulN",
          "sqrN",
        ];
      function th(e, t) {
        let r = void 0 !== t ? t : e.toString(2).length;
        return { nBitLength: r, nByteLength: Math.ceil(r / 8) };
      }
      function td(e, t, r = !1, i = {}) {
        let n;
        if (e <= e7) throw Error("invalid field: expected ORDER > 0, got " + e);
        let { nBitLength: s, nByteLength: a } = th(e, t);
        if (a > 2048)
          throw Error("invalid field: expected ORDER of <= 2048 bytes");
        let o = Object.freeze({
          ORDER: e,
          isLE: r,
          BITS: s,
          BYTES: a,
          MASK: e8(s),
          ZERO: e7,
          ONE: te,
          create: (t) => ta(t, e),
          isValid: (t) => {
            if ("bigint" != typeof t)
              throw Error(
                "invalid field element: expected bigint, got " + typeof t
              );
            return e7 <= t && t < e;
          },
          is0: (e) => e === e7,
          isOdd: (e) => (e & te) === te,
          neg: (t) => ta(-t, e),
          eql: (e, t) => e === t,
          sqr: (t) => ta(t * t, e),
          add: (t, r) => ta(t + r, e),
          sub: (t, r) => ta(t - r, e),
          mul: (t, r) => ta(t * r, e),
          pow: (e, t) =>
            (function (e, t, r) {
              if (r < e7)
                throw Error("invalid exponent, negatives unsupported");
              if (r === e7) return e.ONE;
              if (r === te) return t;
              let i = e.ONE,
                n = t;
              for (; r > e7; )
                r & te && (i = e.mul(i, n)), (n = e.sqr(n)), (r >>= te);
              return i;
            })(o, e, t),
          div: (t, r) => ta(t * tl(r, e), e),
          sqrN: (e) => e * e,
          addN: (e, t) => e + t,
          subN: (e, t) => e - t,
          mulN: (e, t) => e * t,
          inv: (t) => tl(t, e),
          sqrt:
            i.sqrt ||
            ((t) => (
              n ||
                (n = (function (e) {
                  if (e % ti === tr) {
                    let t = (e + te) / ti;
                    return function (e, r) {
                      let i = e.pow(r, t);
                      if (!e.eql(e.sqr(i), r))
                        throw Error("Cannot find square root");
                      return i;
                    };
                  }
                  if (e % ts === tn) {
                    let t = (e - tn) / ts;
                    return function (e, r) {
                      let i = e.mul(r, tt),
                        n = e.pow(i, t),
                        s = e.mul(r, n),
                        a = e.mul(e.mul(s, tt), n),
                        o = e.mul(s, e.sub(a, e.ONE));
                      if (!e.eql(e.sqr(o), r))
                        throw Error("Cannot find square root");
                      return o;
                    };
                  }
                  return (function (e) {
                    let t, r, i;
                    let n = (e - te) / tt;
                    for (t = e - te, r = 0; t % tt === e7; t /= tt, r++);
                    for (
                      i = tt;
                      i < e &&
                      (function (e, t, r) {
                        if (t < e7)
                          throw Error(
                            "invalid exponent, negatives unsupported"
                          );
                        if (r <= e7) throw Error("invalid modulus");
                        if (r === te) return e7;
                        let i = te;
                        for (; t > e7; )
                          t & te && (i = (i * e) % r),
                            (e = (e * e) % r),
                            (t >>= te);
                        return i;
                      })(i, n, e) !==
                        e - te;
                      i++
                    )
                      if (i > 1e3)
                        throw Error(
                          "Cannot find square root: likely non-prime P"
                        );
                    if (1 === r) {
                      let t = (e + te) / ti;
                      return function (e, r) {
                        let i = e.pow(r, t);
                        if (!e.eql(e.sqr(i), r))
                          throw Error("Cannot find square root");
                        return i;
                      };
                    }
                    let s = (t + te) / tt;
                    return function (e, a) {
                      if (e.pow(a, n) === e.neg(e.ONE))
                        throw Error("Cannot find square root");
                      let o = r,
                        l = e.pow(e.mul(e.ONE, i), t),
                        c = e.pow(a, s),
                        u = e.pow(a, t);
                      for (; !e.eql(u, e.ONE); ) {
                        if (e.eql(u, e.ZERO)) return e.ZERO;
                        let t = 1;
                        for (let r = e.sqr(u); t < o && !e.eql(r, e.ONE); t++)
                          r = e.sqr(r);
                        let r = e.pow(l, te << BigInt(o - t - 1));
                        (l = e.sqr(r)),
                          (c = e.mul(c, r)),
                          (u = e.mul(u, l)),
                          (o = t);
                      }
                      return c;
                    };
                  })(e);
                })(e)),
              n(o, t)
            )),
          invertBatch: (e) =>
            (function (e, t) {
              let r = Array(t.length),
                i = t.reduce(
                  (t, i, n) => (e.is0(i) ? t : ((r[n] = t), e.mul(t, i))),
                  e.ONE
                ),
                n = e.inv(i);
              return (
                t.reduceRight(
                  (t, i, n) =>
                    e.is0(i) ? t : ((r[n] = e.mul(t, r[n])), e.mul(t, i)),
                  n
                ),
                r
              );
            })(o, e),
          cmov: (e, t, r) => (r ? t : e),
          toBytes: (e) => (r ? e0(e, a) : eX(e, a)),
          fromBytes: (e) => {
            if (e.length !== a)
              throw Error(
                "Field.fromBytes: expected " + a + " bytes, got " + e.length
              );
            return r ? eY(e) : eK(eW(e));
          },
        });
        return Object.freeze(o);
      }
      let tp = BigInt(0),
        tf = BigInt(1);
      function tg(e, t) {
        let r = t.negate();
        return e ? r : t;
      }
      function tm(e, t) {
        if (!Number.isSafeInteger(e) || e <= 0 || e > t)
          throw Error(
            "invalid window size, expected [1.." + t + "], got W=" + e
          );
      }
      function ty(e, t) {
        return (
          tm(e, t), { windows: Math.ceil(t / e) + 1, windowSize: 2 ** (e - 1) }
        );
      }
      let tw = new WeakMap(),
        tb = new WeakMap();
      function tv(e) {
        return tb.get(e) || 1;
      }
      let tE = BigInt(0),
        tA = BigInt(1),
        tC = BigInt(2),
        t_ = BigInt(8),
        tI = { zip215: !0 };
      BigInt(0), BigInt(1);
      let tN = BigInt(
          "57896044618658097711785492504343953926634992332820282019728792003956564819949"
        ),
        tS = BigInt(
          "19681161376707505956807079304988542015446066515923890162744021073123829784752"
        );
      BigInt(0);
      let tT = BigInt(1),
        tP = BigInt(2);
      BigInt(3);
      let tO = BigInt(5),
        tx = BigInt(8),
        tk = td(tN, void 0, !0),
        tR = (function (e) {
          var t;
          let r = (function (e) {
              let t =
                (e6(
                  e.Fp,
                  tu.reduce((e, t) => ((e[t] = "function"), e), {
                    ORDER: "bigint",
                    MASK: "bigint",
                    BYTES: "isSafeInteger",
                    BITS: "isSafeInteger",
                  })
                ),
                e6(
                  e,
                  { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
                  { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
                ),
                Object.freeze({
                  ...th(e.n, e.nBitLength),
                  ...e,
                  p: e.Fp.ORDER,
                }));
              return (
                e6(
                  e,
                  {
                    hash: "function",
                    a: "bigint",
                    d: "bigint",
                    randomBytes: "function",
                  },
                  {
                    adjustScalarBytes: "function",
                    domain: "function",
                    uvRatio: "function",
                    mapToCurve: "function",
                  }
                ),
                Object.freeze({ ...t })
              );
            })(e),
            {
              Fp: i,
              n: n,
              prehash: s,
              hash: a,
              randomBytes: o,
              nByteLength: l,
              h: c,
            } = r,
            u = tC << (BigInt(8 * l) - tA),
            h = i.create,
            d = td(r.n, r.nBitLength),
            p =
              r.uvRatio ||
              ((e, t) => {
                try {
                  return { isValid: !0, value: i.sqrt(e * i.inv(t)) };
                } catch {
                  return { isValid: !1, value: tE };
                }
              }),
            f = r.adjustScalarBytes || ((e) => e),
            g =
              r.domain ||
              ((e, t, r) => {
                if ((eV("phflag", r), t.length || r))
                  throw Error("Contexts/pre-hash are not supported");
                return e;
              });
          function m(e, t) {
            e5("coordinate " + e, t, tE, u);
          }
          function y(e) {
            if (!(e instanceof v)) throw Error("ExtendedPoint expected");
          }
          let w = e9((e, t) => {
              let { ex: r, ey: n, ez: s } = e,
                a = e.is0();
              null == t && (t = a ? t_ : i.inv(s));
              let o = h(r * t),
                l = h(n * t),
                c = h(s * t);
              if (a) return { x: tE, y: tA };
              if (c !== tA) throw Error("invZ was invalid");
              return { x: o, y: l };
            }),
            b = e9((e) => {
              let { a: t, d: i } = r;
              if (e.is0()) throw Error("bad point: ZERO");
              let { ex: n, ey: s, ez: a, et: o } = e,
                l = h(n * n),
                c = h(s * s),
                u = h(a * a),
                d = h(u * u),
                p = h(l * t);
              if (h(u * h(p + c)) !== h(d + h(i * h(l * c))))
                throw Error("bad point: equation left != right (1)");
              if (h(n * s) !== h(a * o))
                throw Error("bad point: equation left != right (2)");
              return !0;
            });
          class v {
            constructor(e, t, r, i) {
              (this.ex = e),
                (this.ey = t),
                (this.ez = r),
                (this.et = i),
                m("x", e),
                m("y", t),
                m("z", r),
                m("t", i),
                Object.freeze(this);
            }
            get x() {
              return this.toAffine().x;
            }
            get y() {
              return this.toAffine().y;
            }
            static fromAffine(e) {
              if (e instanceof v) throw Error("extended point not allowed");
              let { x: t, y: r } = e || {};
              return m("x", t), m("y", r), new v(t, r, tA, h(t * r));
            }
            static normalizeZ(e) {
              let t = i.invertBatch(e.map((e) => e.ez));
              return e.map((e, r) => e.toAffine(t[r])).map(v.fromAffine);
            }
            static msm(e, t) {
              return (function (e, t, r, i) {
                if (
                  ((function (e, t) {
                    if (!Array.isArray(e)) throw Error("array expected");
                    e.forEach((e, r) => {
                      if (!(e instanceof t))
                        throw Error("invalid point at index " + r);
                    });
                  })(r, e),
                  (function (e, t) {
                    if (!Array.isArray(e))
                      throw Error("array of scalars expected");
                    e.forEach((e, r) => {
                      if (!t.isValid(e))
                        throw Error("invalid scalar at index " + r);
                    });
                  })(i, t),
                  r.length !== i.length)
                )
                  throw Error(
                    "arrays of points and scalars must have equal length"
                  );
                let n = e.ZERO,
                  s = (function (e) {
                    let t;
                    for (t = 0; e > eF; e >>= e$, t += 1);
                    return t;
                  })(BigInt(r.length)),
                  a = s > 12 ? s - 3 : s > 4 ? s - 2 : s ? 2 : 1,
                  o = (1 << a) - 1,
                  l = Array(o + 1).fill(n),
                  c = Math.floor((t.BITS - 1) / a) * a,
                  u = n;
                for (let e = c; e >= 0; e -= a) {
                  l.fill(n);
                  for (let t = 0; t < i.length; t++) {
                    let n = Number((i[t] >> BigInt(e)) & BigInt(o));
                    l[n] = l[n].add(r[t]);
                  }
                  let t = n;
                  for (let e = l.length - 1, r = n; e > 0; e--)
                    (r = r.add(l[e])), (t = t.add(r));
                  if (((u = u.add(t)), 0 !== e))
                    for (let e = 0; e < a; e++) u = u.double();
                }
                return u;
              })(v, d, e, t);
            }
            _setWindowSize(e) {
              C.setWindowSize(this, e);
            }
            assertValidity() {
              b(this);
            }
            equals(e) {
              y(e);
              let { ex: t, ey: r, ez: i } = this,
                { ex: n, ey: s, ez: a } = e,
                o = h(t * a),
                l = h(n * i),
                c = h(r * a),
                u = h(s * i);
              return o === l && c === u;
            }
            is0() {
              return this.equals(v.ZERO);
            }
            negate() {
              return new v(h(-this.ex), this.ey, this.ez, h(-this.et));
            }
            double() {
              let { a: e } = r,
                { ex: t, ey: i, ez: n } = this,
                s = h(t * t),
                a = h(i * i),
                o = h(tC * h(n * n)),
                l = h(e * s),
                c = t + i,
                u = h(h(c * c) - s - a),
                d = l + a,
                p = d - o,
                f = l - a,
                g = h(u * p),
                m = h(d * f),
                y = h(u * f);
              return new v(g, m, h(p * d), y);
            }
            add(e) {
              y(e);
              let { a: t, d: i } = r,
                { ex: n, ey: s, ez: a, et: o } = this,
                { ex: l, ey: c, ez: u, et: d } = e;
              if (t === BigInt(-1)) {
                let e = h((s - n) * (c + l)),
                  t = h((s + n) * (c - l)),
                  r = h(t - e);
                if (r === tE) return this.double();
                let i = h(a * tC * d),
                  p = h(o * tC * u),
                  f = p + i,
                  g = t + e,
                  m = p - i,
                  y = h(f * r),
                  w = h(g * m),
                  b = h(f * m);
                return new v(y, w, h(r * g), b);
              }
              let p = h(n * l),
                f = h(s * c),
                g = h(o * i * d),
                m = h(a * u),
                w = h((n + s) * (l + c) - p - f),
                b = m - g,
                E = m + g,
                A = h(f - t * p),
                C = h(w * b),
                _ = h(E * A),
                I = h(w * A);
              return new v(C, _, h(b * E), I);
            }
            subtract(e) {
              return this.add(e.negate());
            }
            wNAF(e) {
              return C.wNAFCached(this, e, v.normalizeZ);
            }
            multiply(e) {
              e5("scalar", e, tA, n);
              let { p: t, f: r } = this.wNAF(e);
              return v.normalizeZ([t, r])[0];
            }
            multiplyUnsafe(e, t = v.ZERO) {
              return (
                e5("scalar", e, tE, n),
                e === tE
                  ? A
                  : this.is0() || e === tA
                  ? this
                  : C.wNAFCachedUnsafe(this, e, v.normalizeZ, t)
              );
            }
            isSmallOrder() {
              return this.multiplyUnsafe(c).is0();
            }
            isTorsionFree() {
              return C.unsafeLadder(this, n).is0();
            }
            toAffine(e) {
              return w(this, e);
            }
            clearCofactor() {
              let { h: e } = r;
              return e === tA ? this : this.multiplyUnsafe(e);
            }
            static fromHex(e, t = !1) {
              let { d: n, a: s } = r,
                a = i.BYTES;
              (e = e1("pointHex", e, a)), eV("zip215", t);
              let o = e.slice(),
                l = e[a - 1];
              o[a - 1] = -129 & l;
              let c = eY(o);
              e5("pointHex.y", c, tE, t ? u : i.ORDER);
              let d = h(c * c),
                { isValid: f, value: g } = p(h(d - tA), h(n * d - s));
              if (!f) throw Error("Point.fromHex: invalid y coordinate");
              let m = (g & tA) === tA,
                y = (128 & l) != 0;
              if (!t && g === tE && y)
                throw Error("Point.fromHex: x=0 and x_0=1");
              return y !== m && (g = h(-g)), v.fromAffine({ x: g, y: c });
            }
            static fromPrivateKey(e) {
              return _(e).point;
            }
            toRawBytes() {
              let { x: e, y: t } = this.toAffine(),
                r = e0(t, i.BYTES);
              return (r[r.length - 1] |= e & tA ? 128 : 0), r;
            }
            toHex() {
              return eW(this.toRawBytes());
            }
          }
          (v.BASE = new v(r.Gx, r.Gy, tA, h(r.Gx * r.Gy))),
            (v.ZERO = new v(tE, tA, tA, tE));
          let { BASE: E, ZERO: A } = v,
            C =
              ((t = 8 * l),
              {
                constTimeNegate: tg,
                hasPrecomputes: (e) => 1 !== tv(e),
                unsafeLadder(e, t, r = v.ZERO) {
                  let i = e;
                  for (; t > tp; )
                    t & tf && (r = r.add(i)), (i = i.double()), (t >>= tf);
                  return r;
                },
                precomputeWindow(e, r) {
                  let { windows: i, windowSize: n } = ty(r, t),
                    s = [],
                    a = e,
                    o = a;
                  for (let e = 0; e < i; e++) {
                    (o = a), s.push(o);
                    for (let e = 1; e < n; e++) (o = o.add(a)), s.push(o);
                    a = o.double();
                  }
                  return s;
                },
                wNAF(e, r, i) {
                  let { windows: n, windowSize: s } = ty(e, t),
                    a = v.ZERO,
                    o = v.BASE,
                    l = BigInt(2 ** e - 1),
                    c = 2 ** e,
                    u = BigInt(e);
                  for (let e = 0; e < n; e++) {
                    let t = e * s,
                      n = Number(i & l);
                    (i >>= u), n > s && ((n -= c), (i += tf));
                    let h = t + Math.abs(n) - 1,
                      d = e % 2 != 0,
                      p = n < 0;
                    0 === n
                      ? (o = o.add(tg(d, r[t])))
                      : (a = a.add(tg(p, r[h])));
                  }
                  return { p: a, f: o };
                },
                wNAFUnsafe(e, r, i, n = v.ZERO) {
                  let { windows: s, windowSize: a } = ty(e, t),
                    o = BigInt(2 ** e - 1),
                    l = 2 ** e,
                    c = BigInt(e);
                  for (let e = 0; e < s; e++) {
                    let t = e * a;
                    if (i === tp) break;
                    let s = Number(i & o);
                    if (((i >>= c), s > a && ((s -= l), (i += tf)), 0 === s))
                      continue;
                    let u = r[t + Math.abs(s) - 1];
                    s < 0 && (u = u.negate()), (n = n.add(u));
                  }
                  return n;
                },
                getPrecomputes(e, t, r) {
                  let i = tw.get(t);
                  return (
                    i ||
                      ((i = this.precomputeWindow(t, e)),
                      1 !== e && tw.set(t, r(i))),
                    i
                  );
                },
                wNAFCached(e, t, r) {
                  let i = tv(e);
                  return this.wNAF(i, this.getPrecomputes(i, e, r), t);
                },
                wNAFCachedUnsafe(e, t, r, i) {
                  let n = tv(e);
                  return 1 === n
                    ? this.unsafeLadder(e, t, i)
                    : this.wNAFUnsafe(n, this.getPrecomputes(n, e, r), t, i);
                },
                setWindowSize(e, r) {
                  tm(r, t), tb.set(e, r), tw.delete(e);
                },
              });
          function _(e) {
            let t = i.BYTES;
            e = e1("private key", e, t);
            let r = e1("hashed private key", a(e), 2 * t),
              s = f(r.slice(0, t)),
              o = r.slice(t, 2 * t),
              l = ta(eY(s), n),
              c = E.multiply(l),
              u = c.toRawBytes();
            return { head: s, prefix: o, scalar: l, point: c, pointBytes: u };
          }
          function I(e = new Uint8Array(), ...t) {
            return ta(eY(a(g(e2(...t), e1("context", e), !!s))), n);
          }
          return (
            E._setWindowSize(8),
            {
              CURVE: r,
              getPublicKey: function (e) {
                return _(e).pointBytes;
              },
              sign: function (e, t, r = {}) {
                (e = e1("message", e)), s && (e = s(e));
                let { prefix: a, scalar: o, pointBytes: l } = _(t),
                  c = I(r.context, a, e),
                  u = E.multiply(c).toRawBytes(),
                  h = ta(c + I(r.context, u, l, e) * o, n);
                return (
                  e5("signature.s", h, tE, n),
                  e1("result", e2(u, e0(h, i.BYTES)), 2 * i.BYTES)
                );
              },
              verify: function (e, t, r, n = tI) {
                let a, o, l;
                let { context: c, zip215: u } = n,
                  h = i.BYTES;
                (e = e1("signature", e, 2 * h)),
                  (t = e1("message", t)),
                  (r = e1("publicKey", r, h)),
                  void 0 !== u && eV("zip215", u),
                  s && (t = s(t));
                let d = eY(e.slice(h, 2 * h));
                try {
                  (a = v.fromHex(r, u)),
                    (o = v.fromHex(e.slice(0, h), u)),
                    (l = E.multiplyUnsafe(d));
                } catch {
                  return !1;
                }
                if (!u && a.isSmallOrder()) return !1;
                let p = I(c, o.toRawBytes(), a.toRawBytes(), t);
                return o
                  .add(a.multiplyUnsafe(p))
                  .subtract(l)
                  .clearCofactor()
                  .equals(v.ZERO);
              },
              ExtendedPoint: v,
              utils: {
                getExtendedPublicKey: _,
                randomPrivateKey: () => o(i.BYTES),
                precompute: (e = 8, t = v.BASE) => (
                  t._setWindowSize(e), t.multiply(BigInt(3)), t
                ),
              },
            }
          );
        })({
          a: BigInt(-1),
          d: BigInt(
            "37095705934669439343138083508754565189542113879843219016388785533085940283555"
          ),
          Fp: tk,
          n: BigInt(
            "7237005577332262213973186563042994240857116359379907606001950938285454250989"
          ),
          h: tx,
          Gx: BigInt(
            "15112221349535400772501151409588531511454012693041857206046113283949847762202"
          ),
          Gy: BigInt(
            "46316835694926478169428394003475163141307993866256225615783033603165251855960"
          ),
          hash: ej,
          randomBytes: eP,
          adjustScalarBytes: function (e) {
            return (e[0] &= 248), (e[31] &= 127), (e[31] |= 64), e;
          },
          uvRatio: function (e, t) {
            let r = ta(t * t * t, tN),
              i = (function (e) {
                let t = BigInt(10),
                  r = BigInt(20),
                  i = BigInt(40),
                  n = BigInt(80),
                  s = (((e * e) % tN) * e) % tN,
                  a = (to(s, tP, tN) * s) % tN,
                  o = (to(a, tT, tN) * e) % tN,
                  l = (to(o, tO, tN) * o) % tN,
                  c = (to(l, t, tN) * l) % tN,
                  u = (to(c, r, tN) * c) % tN,
                  h = (to(u, i, tN) * u) % tN,
                  d = (to(h, n, tN) * h) % tN,
                  p = (to(d, n, tN) * h) % tN,
                  f = (to(p, t, tN) * l) % tN;
                return { pow_p_5_8: (to(f, tP, tN) * e) % tN, b2: s };
              })(e * ta(r * r * t, tN)).pow_p_5_8,
              n = ta(e * r * i, tN),
              s = ta(t * n * n, tN),
              a = n,
              o = ta(n * tS, tN),
              l = s === e,
              c = s === ta(-e, tN),
              u = s === ta(-e * tS, tN);
            return (
              l && (n = a),
              (c || u) && (n = o),
              tc(n, tN) && (n = ta(-n, tN)),
              { isValid: l || c, value: n }
            );
          },
        }),
        tD = "base64url",
        tU = "utf8",
        tL = "utf8",
        tM = "base58btc";
      function tB(e) {
        return null != globalThis.Buffer
          ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
          : e;
      }
      function tj(e = 0) {
        return null != globalThis.Buffer &&
          null != globalThis.Buffer.allocUnsafe
          ? tB(globalThis.Buffer.allocUnsafe(e))
          : new Uint8Array(e);
      }
      function tF(e, t) {
        t || (t = e.reduce((e, t) => e + t.length, 0));
        let r = tj(t),
          i = 0;
        for (let t of e) r.set(t, i), (i += t.length);
        return tB(r);
      }
      var t$ = function (e, t) {
        if (e.length >= 255) throw TypeError("Alphabet too long");
        for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
        for (var n = 0; n < e.length; n++) {
          var s = e.charAt(n),
            a = s.charCodeAt(0);
          if (255 !== r[a]) throw TypeError(s + " is ambiguous");
          r[a] = n;
        }
        var o = e.length,
          l = e.charAt(0),
          c = Math.log(o) / Math.log(256),
          u = Math.log(256) / Math.log(o);
        function h(e) {
          if ("string" != typeof e) throw TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          var t = 0;
          if (" " !== e[0]) {
            for (var i = 0, n = 0; e[t] === l; ) i++, t++;
            for (
              var s = ((e.length - t) * c + 1) >>> 0, a = new Uint8Array(s);
              e[t];

            ) {
              var u = r[e.charCodeAt(t)];
              if (255 === u) return;
              for (
                var h = 0, d = s - 1;
                (0 !== u || h < n) && -1 !== d;
                d--, h++
              )
                (u += (o * a[d]) >>> 0),
                  (a[d] = u % 256 >>> 0),
                  (u = (u / 256) >>> 0);
              if (0 !== u) throw Error("Non-zero carry");
              (n = h), t++;
            }
            if (" " !== e[t]) {
              for (var p = s - n; p !== s && 0 === a[p]; ) p++;
              for (var f = new Uint8Array(i + (s - p)), g = i; p !== s; )
                f[g++] = a[p++];
              return f;
            }
          }
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError("Expected Uint8Array");
            if (0 === t.length) return "";
            for (var r = 0, i = 0, n = 0, s = t.length; n !== s && 0 === t[n]; )
              n++, r++;
            for (
              var a = ((s - n) * u + 1) >>> 0, c = new Uint8Array(a);
              n !== s;

            ) {
              for (
                var h = t[n], d = 0, p = a - 1;
                (0 !== h || d < i) && -1 !== p;
                p--, d++
              )
                (h += (256 * c[p]) >>> 0),
                  (c[p] = h % o >>> 0),
                  (h = (h / o) >>> 0);
              if (0 !== h) throw Error("Non-zero carry");
              (i = d), n++;
            }
            for (var f = a - i; f !== a && 0 === c[f]; ) f++;
            for (var g = l.repeat(r); f < a; ++f) g += e.charAt(c[f]);
            return g;
          },
          decodeUnsafe: h,
          decode: function (e) {
            var r = h(e);
            if (r) return r;
            throw Error(`Non-${t} character`);
          },
        };
      };
      let tH = (e) => {
          if (e instanceof Uint8Array && "Uint8Array" === e.constructor.name)
            return e;
          if (e instanceof ArrayBuffer) return new Uint8Array(e);
          if (ArrayBuffer.isView(e))
            return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
          throw Error("Unknown type, must be binary type");
        },
        tz = (e) => new TextEncoder().encode(e),
        tq = (e) => new TextDecoder().decode(e);
      class tV {
        constructor(e, t, r) {
          (this.name = e), (this.prefix = t), (this.baseEncode = r);
        }
        encode(e) {
          if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
          throw Error("Unknown type, must be binary type");
        }
      }
      class tG {
        constructor(e, t, r) {
          if (((this.name = e), (this.prefix = t), void 0 === t.codePointAt(0)))
            throw Error("Invalid prefix character");
          (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = r);
        }
        decode(e) {
          if ("string" == typeof e) {
            if (e.codePointAt(0) !== this.prefixCodePoint)
              throw Error(
                `Unable to decode multibase string ${JSON.stringify(e)}, ${
                  this.name
                } decoder only supports inputs prefixed with ${this.prefix}`
              );
            return this.baseDecode(e.slice(this.prefix.length));
          }
          throw Error("Can only multibase decode strings");
        }
        or(e) {
          return tK(this, e);
        }
      }
      class tW {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          return tK(this, e);
        }
        decode(e) {
          let t = e[0],
            r = this.decoders[t];
          if (r) return r.decode(e);
          throw RangeError(
            `Unable to decode multibase string ${JSON.stringify(
              e
            )}, only inputs prefixed with ${Object.keys(
              this.decoders
            )} are supported`
          );
        }
      }
      let tK = (e, t) =>
        new tW({
          ...(e.decoders || { [e.prefix]: e }),
          ...(t.decoders || { [t.prefix]: t }),
        });
      class tZ {
        constructor(e, t, r, i) {
          (this.name = e),
            (this.prefix = t),
            (this.baseEncode = r),
            (this.baseDecode = i),
            (this.encoder = new tV(e, t, r)),
            (this.decoder = new tG(e, t, i));
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }
      let tJ = ({ name: e, prefix: t, encode: r, decode: i }) =>
          new tZ(e, t, r, i),
        tQ = ({ prefix: e, name: t, alphabet: r }) => {
          let { encode: i, decode: n } = t$(r, t);
          return tJ({ prefix: e, name: t, encode: i, decode: (e) => tH(n(e)) });
        },
        tY = (e, t, r, i) => {
          let n = {};
          for (let e = 0; e < t.length; ++e) n[t[e]] = e;
          let s = e.length;
          for (; "=" === e[s - 1]; ) --s;
          let a = new Uint8Array(((s * r) / 8) | 0),
            o = 0,
            l = 0,
            c = 0;
          for (let t = 0; t < s; ++t) {
            let s = n[e[t]];
            if (void 0 === s) throw SyntaxError(`Non-${i} character`);
            (l = (l << r) | s),
              (o += r) >= 8 && ((o -= 8), (a[c++] = 255 & (l >> o)));
          }
          if (o >= r || 255 & (l << (8 - o)))
            throw SyntaxError("Unexpected end of data");
          return a;
        },
        tX = (e, t, r) => {
          let i = "=" === t[t.length - 1],
            n = (1 << r) - 1,
            s = "",
            a = 0,
            o = 0;
          for (let i = 0; i < e.length; ++i)
            for (o = (o << 8) | e[i], a += 8; a > r; )
              (a -= r), (s += t[n & (o >> a)]);
          if ((a && (s += t[n & (o << (r - a))]), i))
            for (; (s.length * r) & 7; ) s += "=";
          return s;
        },
        t0 = ({ name: e, prefix: t, bitsPerChar: r, alphabet: i }) =>
          tJ({
            prefix: t,
            name: e,
            encode: (e) => tX(e, i, r),
            decode: (t) => tY(t, i, r, e),
          });
      var t1 = Object.freeze({
          __proto__: null,
          identity: tJ({
            prefix: "\0",
            name: "identity",
            encode: (e) => tq(e),
            decode: (e) => tz(e),
          }),
        }),
        t2 = Object.freeze({
          __proto__: null,
          base2: t0({
            prefix: "0",
            name: "base2",
            alphabet: "01",
            bitsPerChar: 1,
          }),
        }),
        t3 = Object.freeze({
          __proto__: null,
          base8: t0({
            prefix: "7",
            name: "base8",
            alphabet: "01234567",
            bitsPerChar: 3,
          }),
        }),
        t5 = Object.freeze({
          __proto__: null,
          base10: tQ({ prefix: "9", name: "base10", alphabet: "0123456789" }),
        }),
        t8 = Object.freeze({
          __proto__: null,
          base16: t0({
            prefix: "f",
            name: "base16",
            alphabet: "0123456789abcdef",
            bitsPerChar: 4,
          }),
          base16upper: t0({
            prefix: "F",
            name: "base16upper",
            alphabet: "0123456789ABCDEF",
            bitsPerChar: 4,
          }),
        });
      let t4 = t0({
          prefix: "b",
          name: "base32",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567",
          bitsPerChar: 5,
        }),
        t6 = t0({
          prefix: "B",
          name: "base32upper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
          bitsPerChar: 5,
        }),
        t9 = t0({
          prefix: "c",
          name: "base32pad",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
          bitsPerChar: 5,
        }),
        t7 = t0({
          prefix: "C",
          name: "base32padupper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
          bitsPerChar: 5,
        }),
        re = t0({
          prefix: "v",
          name: "base32hex",
          alphabet: "0123456789abcdefghijklmnopqrstuv",
          bitsPerChar: 5,
        }),
        rt = t0({
          prefix: "V",
          name: "base32hexupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
          bitsPerChar: 5,
        });
      var rr = Object.freeze({
          __proto__: null,
          base32: t4,
          base32upper: t6,
          base32pad: t9,
          base32padupper: t7,
          base32hex: re,
          base32hexupper: rt,
          base32hexpad: t0({
            prefix: "t",
            name: "base32hexpad",
            alphabet: "0123456789abcdefghijklmnopqrstuv=",
            bitsPerChar: 5,
          }),
          base32hexpadupper: t0({
            prefix: "T",
            name: "base32hexpadupper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
            bitsPerChar: 5,
          }),
          base32z: t0({
            prefix: "h",
            name: "base32z",
            alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
            bitsPerChar: 5,
          }),
        }),
        ri = Object.freeze({
          __proto__: null,
          base36: tQ({
            prefix: "k",
            name: "base36",
            alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
          }),
          base36upper: tQ({
            prefix: "K",
            name: "base36upper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          }),
        }),
        rn = Object.freeze({
          __proto__: null,
          base58btc: tQ({
            name: "base58btc",
            prefix: "z",
            alphabet:
              "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
          }),
          base58flickr: tQ({
            name: "base58flickr",
            prefix: "Z",
            alphabet:
              "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
          }),
        });
      let rs = t0({
        prefix: "m",
        name: "base64",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6,
      });
      var ra = Object.freeze({
        __proto__: null,
        base64: rs,
        base64pad: t0({
          prefix: "M",
          name: "base64pad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          bitsPerChar: 6,
        }),
        base64url: t0({
          prefix: "u",
          name: "base64url",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          bitsPerChar: 6,
        }),
        base64urlpad: t0({
          prefix: "U",
          name: "base64urlpad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
          bitsPerChar: 6,
        }),
      });
      let ro = Array.from(
          "\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"
        ),
        rl = ro.reduce((e, t, r) => ((e[r] = t), e), []),
        rc = ro.reduce((e, t, r) => ((e[t.codePointAt(0)] = r), e), []);
      var ru = Object.freeze({
        __proto__: null,
        base256emoji: tJ({
          prefix: "\uD83D\uDE80",
          name: "base256emoji",
          encode: function (e) {
            return e.reduce((e, t) => (e += rl[t]), "");
          },
          decode: function (e) {
            let t = [];
            for (let r of e) {
              let e = rc[r.codePointAt(0)];
              if (void 0 === e) throw Error(`Non-base256emoji character: ${r}`);
              t.push(e);
            }
            return new Uint8Array(t);
          },
        }),
      });
      function rh(e, t) {
        var r,
          i = 0,
          t = t || 0,
          n = 0,
          s = t,
          a = e.length;
        do {
          if (s >= a)
            throw ((rh.bytes = 0), RangeError("Could not decode varint"));
          (r = e[s++]),
            (i += n < 28 ? (127 & r) << n : (127 & r) * Math.pow(2, n)),
            (n += 7);
        } while (r >= 128);
        return (rh.bytes = s - t), i;
      }
      var rd = function e(t, r, i) {
        (r = r || []), (i = i || 0);
        for (var n = i; t >= 2147483648; )
          (r[i++] = (255 & t) | 128), (t /= 128);
        for (; -128 & t; ) (r[i++] = (255 & t) | 128), (t >>>= 7);
        return (r[i] = 0 | t), (e.bytes = i - n + 1), r;
      };
      let rp = (e, t, r = 0) => (rd(e, t, r), t),
        rf = (e) =>
          e < 128
            ? 1
            : e < 16384
            ? 2
            : e < 2097152
            ? 3
            : e < 268435456
            ? 4
            : e < 34359738368
            ? 5
            : e < 4398046511104
            ? 6
            : e < 562949953421312
            ? 7
            : e < 72057594037927940
            ? 8
            : e < 0x7fffffffffffffff
            ? 9
            : 10,
        rg = (e, t) => {
          let r = t.byteLength,
            i = rf(e),
            n = i + rf(r),
            s = new Uint8Array(n + r);
          return rp(e, s, 0), rp(r, s, i), s.set(t, n), new rm(e, r, t, s);
        };
      class rm {
        constructor(e, t, r, i) {
          (this.code = e), (this.size = t), (this.digest = r), (this.bytes = i);
        }
      }
      let ry = ({ name: e, code: t, encode: r }) => new rw(e, t, r);
      class rw {
        constructor(e, t, r) {
          (this.name = e), (this.code = t), (this.encode = r);
        }
        digest(e) {
          if (e instanceof Uint8Array) {
            let t = this.encode(e);
            return t instanceof Uint8Array
              ? rg(this.code, t)
              : t.then((e) => rg(this.code, e));
          }
          throw Error("Unknown type, must be binary type");
        }
      }
      let rb = (e) => async (t) =>
        new Uint8Array(await crypto.subtle.digest(e, t));
      var rv = Object.freeze({
          __proto__: null,
          sha256: ry({ name: "sha2-256", code: 18, encode: rb("SHA-256") }),
          sha512: ry({ name: "sha2-512", code: 19, encode: rb("SHA-512") }),
        }),
        rE = Object.freeze({
          __proto__: null,
          identity: {
            code: 0,
            name: "identity",
            encode: tH,
            digest: (e) => rg(0, tH(e)),
          },
        });
      new TextEncoder(), new TextDecoder();
      let rA = {
        ...t1,
        ...t2,
        ...t3,
        ...t5,
        ...t8,
        ...rr,
        ...ri,
        ...rn,
        ...ra,
        ...ru,
      };
      function rC(e, t, r, i) {
        return {
          name: e,
          prefix: t,
          encoder: { name: e, prefix: t, encode: r },
          decoder: { decode: i },
        };
      }
      ({ ...rv, ...rE });
      let r_ = rC(
          "utf8",
          "u",
          (e) => "u" + new TextDecoder("utf8").decode(e),
          (e) => new TextEncoder().encode(e.substring(1))
        ),
        rI = rC(
          "ascii",
          "a",
          (e) => {
            let t = "a";
            for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
            return t;
          },
          (e) => {
            let t = tj((e = e.substring(1)).length);
            for (let r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);
            return t;
          }
        ),
        rN = {
          utf8: r_,
          "utf-8": r_,
          hex: rA.base16,
          latin1: rI,
          ascii: rI,
          binary: rI,
          ...rA,
        };
      function rS(e, t = "utf8") {
        let r = rN[t];
        if (!r) throw Error(`Unsupported encoding "${t}"`);
        return ("utf8" === t || "utf-8" === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? globalThis.Buffer.from(
              e.buffer,
              e.byteOffset,
              e.byteLength
            ).toString("utf8")
          : r.encoder.encode(e).substring(1);
      }
      function rT(e, t = "utf8") {
        let r = rN[t];
        if (!r) throw Error(`Unsupported encoding "${t}"`);
        return ("utf8" === t || "utf-8" === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? tB(globalThis.Buffer.from(e, "utf-8"))
          : r.decoder.decode(`${r.prefix}${e}`);
      }
      function rP(e) {
        return (0, q.D)(rS(rT(e, tD), tU));
      }
      function rO(e) {
        return rS(rT((0, q.u)(e), tU), tD);
      }
      function rx(e) {
        return ["did", "key", "z" + rS(tF([rT("K36", tM), e]), tM)].join(":");
      }
      function rk(e) {
        let t = e.split("."),
          r = rP(t[0]);
        return {
          header: r,
          payload: rP(t[1]),
          signature: rT(t[2], tD),
          data: rT(t.slice(0, 2).join("."), tL),
        };
      }
      function rR(e = eP(32)) {
        let t = tR.getPublicKey(e);
        return { secretKey: tF([e, t]), publicKey: t };
      }
      async function rD(e, t, r, i, n = (0, v.fromMiliseconds)(Date.now())) {
        var s, a;
        let o = { alg: "EdDSA", typ: "JWT" },
          l = { iss: rx(i.publicKey), sub: e, aud: t, iat: n, exp: n + r },
          c = rT(
            [rO((s = { header: o, payload: l }).header), rO(s.payload)].join(
              "."
            ),
            tL
          );
        return [
          rO(
            (a = {
              header: o,
              payload: l,
              signature: tR.sign(c, i.secretKey.slice(0, 32)),
            }).header
          ),
          rO(a.payload),
          rS(a.signature, tD),
        ].join(".");
      }
      var rU = r(40257),
        rL = function (e, t, r) {
          if (r || 2 == arguments.length)
            for (var i, n = 0, s = t.length; n < s; n++)
              (!i && n in t) ||
                (i || (i = Array.prototype.slice.call(t, 0, n)), (i[n] = t[n]));
          return e.concat(i || Array.prototype.slice.call(t));
        },
        rM = function (e, t, r) {
          (this.name = e),
            (this.version = t),
            (this.os = r),
            (this.type = "browser");
        },
        rB = function (e) {
          (this.version = e),
            (this.type = "node"),
            (this.name = "node"),
            (this.os = rU.platform);
        },
        rj = function (e, t, r, i) {
          (this.name = e),
            (this.version = t),
            (this.os = r),
            (this.bot = i),
            (this.type = "bot-device");
        },
        rF = function () {
          (this.type = "bot"),
            (this.bot = !0),
            (this.name = "bot"),
            (this.version = null),
            (this.os = null);
        },
        r$ = function () {
          (this.type = "react-native"),
            (this.name = "react-native"),
            (this.version = null),
            (this.os = null);
        },
        rH =
          /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
        rz = [
          ["aol", /AOLShield\/([0-9\._]+)/],
          ["edge", /Edge\/([0-9\._]+)/],
          ["edge-ios", /EdgiOS\/([0-9\._]+)/],
          ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
          ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
          ["samsung", /SamsungBrowser\/([0-9\.]+)/],
          ["silk", /\bSilk\/([0-9._-]+)\b/],
          ["miui", /MiuiBrowser\/([0-9\.]+)$/],
          ["beaker", /BeakerBrowser\/([0-9\.]+)/],
          ["edge-chromium", /EdgA?\/([0-9\.]+)/],
          [
            "chromium-webview",
            /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
          ],
          ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
          ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
          ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
          ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
          ["fxios", /FxiOS\/([0-9\.]+)/],
          ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
          ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
          ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
          ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
          [
            "pie",
            /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/,
          ],
          ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
          ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
          ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
          ["ie", /MSIE\s(7\.0)/],
          ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
          ["android", /Android\s([0-9\.]+)/],
          ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
          ["safari", /Version\/([0-9\._]+).*Safari/],
          ["facebook", /FB[AS]V\/([0-9\.]+)/],
          ["instagram", /Instagram\s([0-9\.]+)/],
          ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
          ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
          ["curl", /^curl\/([0-9\.]+)$/],
          [
            "searchbot",
            /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
          ],
        ],
        rq = [
          ["iOS", /iP(hone|od|ad)/],
          ["Android OS", /Android/],
          ["BlackBerry OS", /BlackBerry|BB10/],
          ["Windows Mobile", /IEMobile/],
          ["Amazon OS", /Kindle/],
          ["Windows 3.11", /Win16/],
          ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
          ["Windows 98", /(Windows 98)|(Win98)/],
          ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
          ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
          ["Windows Server 2003", /(Windows NT 5.2)/],
          ["Windows Vista", /(Windows NT 6.0)/],
          ["Windows 7", /(Windows NT 6.1)/],
          ["Windows 8", /(Windows NT 6.2)/],
          ["Windows 8.1", /(Windows NT 6.3)/],
          ["Windows 10", /(Windows NT 10.0)/],
          ["Windows ME", /Windows ME/],
          ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
          ["Open BSD", /OpenBSD/],
          ["Sun OS", /SunOS/],
          ["Chrome OS", /CrOS/],
          ["Linux", /(Linux)|(X11)/],
          ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
          ["QNX", /QNX/],
          ["BeOS", /BeOS/],
          ["OS/2", /OS\/2/],
        ],
        rV = r(93611),
        rG = r(3897);
      let rW = "2.23.2",
        rK = {
          getDocsUrl: ({ docsBaseUrl: e, docsPath: t = "", docsSlug: r }) =>
            t ? `${e ?? "https://viem.sh"}${t}${r ? `#${r}` : ""}` : void 0,
          version: `viem@${rW}`,
        };
      class rZ extends Error {
        constructor(e, t = {}) {
          let r =
              t.cause instanceof rZ
                ? t.cause.details
                : t.cause?.message
                ? t.cause.message
                : t.details,
            i = (t.cause instanceof rZ && t.cause.docsPath) || t.docsPath,
            n = rK.getDocsUrl?.({ ...t, docsPath: i });
          super(
            [
              e || "An error occurred.",
              "",
              ...(t.metaMessages ? [...t.metaMessages, ""] : []),
              ...(n ? [`Docs: ${n}`] : []),
              ...(r ? [`Details: ${r}`] : []),
              ...(rK.version ? [`Version: ${rK.version}`] : []),
            ].join("\n"),
            t.cause ? { cause: t.cause } : void 0
          ),
            Object.defineProperty(this, "details", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "docsPath", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "metaMessages", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "shortMessage", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "version", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "BaseError",
            }),
            (this.details = r),
            (this.docsPath = i),
            (this.metaMessages = t.metaMessages),
            (this.name = t.name ?? this.name),
            (this.shortMessage = e),
            (this.version = rW);
        }
        walk(e) {
          return (function e(t, r) {
            return r?.(t)
              ? t
              : t && "object" == typeof t && "cause" in t && void 0 !== t.cause
              ? e(t.cause, r)
              : r
              ? null
              : t;
          })(this, e);
        }
      }
      function rJ(e, { strict: t = !0 } = {}) {
        return (
          !!e &&
          "string" == typeof e &&
          (t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x"))
        );
      }
      class rQ extends rZ {
        constructor({ size: e, targetSize: t, type: r }) {
          super(
            `${r.charAt(0).toUpperCase()}${r
              .slice(1)
              .toLowerCase()} size (${e}) exceeds padding size (${t}).`,
            { name: "SizeExceedsPaddingSizeError" }
          );
        }
      }
      function rY(e, { dir: t, size: r = 32 } = {}) {
        return "string" == typeof e
          ? (function (e, { dir: t, size: r = 32 } = {}) {
              if (null === r) return e;
              let i = e.replace("0x", "");
              if (i.length > 2 * r)
                throw new rQ({
                  size: Math.ceil(i.length / 2),
                  targetSize: r,
                  type: "hex",
                });
              return `0x${i["right" === t ? "padEnd" : "padStart"](
                2 * r,
                "0"
              )}`;
            })(e, { dir: t, size: r })
          : (function (e, { dir: t, size: r = 32 } = {}) {
              if (null === r) return e;
              if (e.length > r)
                throw new rQ({ size: e.length, targetSize: r, type: "bytes" });
              let i = new Uint8Array(r);
              for (let n = 0; n < r; n++) {
                let s = "right" === t;
                i[s ? n : r - n - 1] = e[s ? n : e.length - n - 1];
              }
              return i;
            })(e, { dir: t, size: r });
      }
      class rX extends rZ {
        constructor({ max: e, min: t, signed: r, size: i, value: n }) {
          super(
            `Number "${n}" is not in safe ${
              i ? `${8 * i}-bit ${r ? "signed" : "unsigned"} ` : ""
            }integer range ${e ? `(${t} to ${e})` : `(above ${t})`}`,
            { name: "IntegerOutOfRangeError" }
          );
        }
      }
      class r0 extends rZ {
        constructor({ givenSize: e, maxSize: t }) {
          super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`, {
            name: "SizeOverflowError",
          });
        }
      }
      function r1(e) {
        return rJ(e, { strict: !1 }) ? Math.ceil((e.length - 2) / 2) : e.length;
      }
      function r2(e, { size: t }) {
        if (r1(e) > t) throw new r0({ givenSize: r1(e), maxSize: t });
      }
      function r3(e, t = {}) {
        let { signed: r } = t;
        t.size && r2(e, { size: t.size });
        let i = BigInt(e);
        if (!r) return i;
        let n = (e.length - 2) / 2;
        return i <= (1n << (8n * BigInt(n) - 1n)) - 1n
          ? i
          : i - BigInt(`0x${"f".padStart(2 * n, "f")}`) - 1n;
      }
      let r5 = Array.from({ length: 256 }, (e, t) =>
        t.toString(16).padStart(2, "0")
      );
      function r8(e, t = {}) {
        return "number" == typeof e || "bigint" == typeof e
          ? r6(e, t)
          : "string" == typeof e
          ? (function (e, t = {}) {
              return r4(r9.encode(e), t);
            })(e, t)
          : "boolean" == typeof e
          ? (function (e, t = {}) {
              let r = `0x${Number(e)}`;
              return "number" == typeof t.size
                ? (r2(r, { size: t.size }), rY(r, { size: t.size }))
                : r;
            })(e, t)
          : r4(e, t);
      }
      function r4(e, t = {}) {
        let r = "";
        for (let t = 0; t < e.length; t++) r += r5[e[t]];
        let i = `0x${r}`;
        return "number" == typeof t.size
          ? (r2(i, { size: t.size }), rY(i, { dir: "right", size: t.size }))
          : i;
      }
      function r6(e, t = {}) {
        let r;
        let { signed: i, size: n } = t,
          s = BigInt(e);
        n
          ? (r = i
              ? (1n << (8n * BigInt(n) - 1n)) - 1n
              : 2n ** (8n * BigInt(n)) - 1n)
          : "number" == typeof e && (r = BigInt(Number.MAX_SAFE_INTEGER));
        let a = "bigint" == typeof r && i ? -r - 1n : 0;
        if ((r && s > r) || s < a) {
          let t = "bigint" == typeof e ? "n" : "";
          throw new rX({
            max: r ? `${r}${t}` : void 0,
            min: `${a}${t}`,
            signed: i,
            size: n,
            value: `${e}${t}`,
          });
        }
        let o = `0x${(i && s < 0
          ? (1n << BigInt(8 * n)) + BigInt(s)
          : s
        ).toString(16)}`;
        return n ? rY(o, { size: n }) : o;
      }
      let r9 = new TextEncoder(),
        r7 = new TextEncoder(),
        ie = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
      function it(e) {
        return e >= ie.zero && e <= ie.nine
          ? e - ie.zero
          : e >= ie.A && e <= ie.F
          ? e - (ie.A - 10)
          : e >= ie.a && e <= ie.f
          ? e - (ie.a - 10)
          : void 0;
      }
      function ir(e, t = {}) {
        let r = e;
        t.size &&
          (r2(r, { size: t.size }),
          (r = rY(r, { dir: "right", size: t.size })));
        let i = r.slice(2);
        i.length % 2 && (i = `0${i}`);
        let n = i.length / 2,
          s = new Uint8Array(n);
        for (let e = 0, t = 0; e < n; e++) {
          let r = it(i.charCodeAt(t++)),
            n = it(i.charCodeAt(t++));
          if (void 0 === r || void 0 === n)
            throw new rZ(
              `Invalid byte sequence ("${i[t - 2]}${i[t - 1]}" in "${i}").`
            );
          s[e] = 16 * r + n;
        }
        return s;
      }
      function ii(e, t = {}) {
        let r = r7.encode(e);
        return "number" == typeof t.size
          ? (r2(r, { size: t.size }), rY(r, { dir: "right", size: t.size }))
          : r;
      }
      var is = r(86691);
      function ia(e, t) {
        let r = (0, is.fr)(
          rJ(e, { strict: !1 })
            ? (function (e, t = {}) {
                return "number" == typeof e || "bigint" == typeof e
                  ? ir(r6(e, t))
                  : "boolean" == typeof e
                  ? (function (e, t = {}) {
                      let r = new Uint8Array(1);
                      return ((r[0] = Number(e)), "number" == typeof t.size)
                        ? (r2(r, { size: t.size }), rY(r, { size: t.size }))
                        : r;
                    })(e, t)
                  : rJ(e)
                  ? ir(e, t)
                  : ii(e, t);
              })(e)
            : e
        );
        return "bytes" === (t || "hex") ? r : r8(r);
      }
      class io extends Map {
        constructor(e) {
          super(),
            Object.defineProperty(this, "maxSize", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.maxSize = e);
        }
        get(e) {
          let t = super.get(e);
          return (
            super.has(e) && void 0 !== t && (this.delete(e), super.set(e, t)), t
          );
        }
        set(e, t) {
          if ((super.set(e, t), this.maxSize && this.size > this.maxSize)) {
            let e = this.keys().next().value;
            e && this.delete(e);
          }
          return this;
        }
      }
      let il = new io(8192);
      async function ic({ hash: e, signature: t }) {
        let i = rJ(e) ? e : r8(e),
          { secp256k1: n } = await r.e(6678).then(r.bind(r, 76678)),
          s = (() => {
            if ("object" == typeof t && "r" in t && "s" in t) {
              let { r: e, s: r, v: i, yParity: s } = t,
                a = iu(Number(s ?? i));
              return new n.Signature(r3(e), r3(r)).addRecoveryBit(a);
            }
            let e = rJ(t) ? t : r8(t),
              r = iu(
                (function (e, t = {}) {
                  return Number(r3(e, t));
                })(`0x${e.slice(130)}`)
              );
            return n.Signature.fromCompact(e.substring(2, 130)).addRecoveryBit(
              r
            );
          })()
            .recoverPublicKey(i.substring(2))
            .toHex(!1);
        return `0x${s}`;
      }
      function iu(e) {
        if (0 === e || 1 === e) return e;
        if (27 === e) return 0;
        if (28 === e) return 1;
        throw Error("Invalid yParityOrV value");
      }
      async function ih({ hash: e, signature: t }) {
        return (function (e) {
          let t = ia(`0x${e.substring(4)}`).substring(26);
          return (function (e, t) {
            if (il.has(`${e}.undefined`)) return il.get(`${e}.undefined`);
            let r = e.substring(2).toLowerCase(),
              i = ia(ii(r), "bytes"),
              n = (t ? r.substring(`${t}0x`.length) : r).split("");
            for (let e = 0; e < 40; e += 2)
              i[e >> 1] >> 4 >= 8 && n[e] && (n[e] = n[e].toUpperCase()),
                (15 & i[e >> 1]) >= 8 &&
                  n[e + 1] &&
                  (n[e + 1] = n[e + 1].toUpperCase());
            let s = `0x${n.join("")}`;
            return il.set(`${e}.${t}`, s), s;
          })(`0x${t}`);
        })(await ic({ hash: e, signature: t }));
      }
      var id = r(13057);
      function ip(e = 0) {
        return null != globalThis.Buffer &&
          null != globalThis.Buffer.allocUnsafe
          ? globalThis.Buffer.allocUnsafe(e)
          : new Uint8Array(e);
      }
      function ig(e, t) {
        t || (t = e.reduce((e, t) => e + t.length, 0));
        let r = ip(t),
          i = 0;
        for (let t of e) r.set(t, i), (i += t.length);
        return r;
      }
      var im = function (e, t) {
        if (e.length >= 255) throw TypeError("Alphabet too long");
        for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
        for (var n = 0; n < e.length; n++) {
          var s = e.charAt(n),
            a = s.charCodeAt(0);
          if (255 !== r[a]) throw TypeError(s + " is ambiguous");
          r[a] = n;
        }
        var o = e.length,
          l = e.charAt(0),
          c = Math.log(o) / Math.log(256),
          u = Math.log(256) / Math.log(o);
        function h(e) {
          if ("string" != typeof e) throw TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          var t = 0;
          if (" " !== e[0]) {
            for (var i = 0, n = 0; e[t] === l; ) i++, t++;
            for (
              var s = ((e.length - t) * c + 1) >>> 0, a = new Uint8Array(s);
              e[t];

            ) {
              var u = r[e.charCodeAt(t)];
              if (255 === u) return;
              for (
                var h = 0, d = s - 1;
                (0 !== u || h < n) && -1 !== d;
                d--, h++
              )
                (u += (o * a[d]) >>> 0),
                  (a[d] = u % 256 >>> 0),
                  (u = (u / 256) >>> 0);
              if (0 !== u) throw Error("Non-zero carry");
              (n = h), t++;
            }
            if (" " !== e[t]) {
              for (var p = s - n; p !== s && 0 === a[p]; ) p++;
              for (var f = new Uint8Array(i + (s - p)), g = i; p !== s; )
                f[g++] = a[p++];
              return f;
            }
          }
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError("Expected Uint8Array");
            if (0 === t.length) return "";
            for (var r = 0, i = 0, n = 0, s = t.length; n !== s && 0 === t[n]; )
              n++, r++;
            for (
              var a = ((s - n) * u + 1) >>> 0, c = new Uint8Array(a);
              n !== s;

            ) {
              for (
                var h = t[n], d = 0, p = a - 1;
                (0 !== h || d < i) && -1 !== p;
                p--, d++
              )
                (h += (256 * c[p]) >>> 0),
                  (c[p] = h % o >>> 0),
                  (h = (h / o) >>> 0);
              if (0 !== h) throw Error("Non-zero carry");
              (i = d), n++;
            }
            for (var f = a - i; f !== a && 0 === c[f]; ) f++;
            for (var g = l.repeat(r); f < a; ++f) g += e.charAt(c[f]);
            return g;
          },
          decodeUnsafe: h,
          decode: function (e) {
            var r = h(e);
            if (r) return r;
            throw Error(`Non-${t} character`);
          },
        };
      };
      new Uint8Array(0);
      let iy = (e, t) => {
          if (e === t) return !0;
          if (e.byteLength !== t.byteLength) return !1;
          for (let r = 0; r < e.byteLength; r++) if (e[r] !== t[r]) return !1;
          return !0;
        },
        iw = (e) => {
          if (e instanceof Uint8Array && "Uint8Array" === e.constructor.name)
            return e;
          if (e instanceof ArrayBuffer) return new Uint8Array(e);
          if (ArrayBuffer.isView(e))
            return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
          throw Error("Unknown type, must be binary type");
        },
        ib = (e) => new TextEncoder().encode(e),
        iv = (e) => new TextDecoder().decode(e);
      class iE {
        constructor(e, t, r) {
          (this.name = e), (this.prefix = t), (this.baseEncode = r);
        }
        encode(e) {
          if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
          throw Error("Unknown type, must be binary type");
        }
      }
      class iA {
        constructor(e, t, r) {
          if (((this.name = e), (this.prefix = t), void 0 === t.codePointAt(0)))
            throw Error("Invalid prefix character");
          (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = r);
        }
        decode(e) {
          if ("string" == typeof e) {
            if (e.codePointAt(0) !== this.prefixCodePoint)
              throw Error(
                `Unable to decode multibase string ${JSON.stringify(e)}, ${
                  this.name
                } decoder only supports inputs prefixed with ${this.prefix}`
              );
            return this.baseDecode(e.slice(this.prefix.length));
          }
          throw Error("Can only multibase decode strings");
        }
        or(e) {
          return i_(this, e);
        }
      }
      class iC {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          return i_(this, e);
        }
        decode(e) {
          let t = e[0],
            r = this.decoders[t];
          if (r) return r.decode(e);
          throw RangeError(
            `Unable to decode multibase string ${JSON.stringify(
              e
            )}, only inputs prefixed with ${Object.keys(
              this.decoders
            )} are supported`
          );
        }
      }
      let i_ = (e, t) =>
        new iC({
          ...(e.decoders || { [e.prefix]: e }),
          ...(t.decoders || { [t.prefix]: t }),
        });
      class iI {
        constructor(e, t, r, i) {
          (this.name = e),
            (this.prefix = t),
            (this.baseEncode = r),
            (this.baseDecode = i),
            (this.encoder = new iE(e, t, r)),
            (this.decoder = new iA(e, t, i));
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }
      let iN = ({ name: e, prefix: t, encode: r, decode: i }) =>
          new iI(e, t, r, i),
        iS = ({ prefix: e, name: t, alphabet: r }) => {
          let { encode: i, decode: n } = im(r, t);
          return iN({ prefix: e, name: t, encode: i, decode: (e) => iw(n(e)) });
        },
        iT = (e, t, r, i) => {
          let n = {};
          for (let e = 0; e < t.length; ++e) n[t[e]] = e;
          let s = e.length;
          for (; "=" === e[s - 1]; ) --s;
          let a = new Uint8Array(((s * r) / 8) | 0),
            o = 0,
            l = 0,
            c = 0;
          for (let t = 0; t < s; ++t) {
            let s = n[e[t]];
            if (void 0 === s) throw SyntaxError(`Non-${i} character`);
            (l = (l << r) | s),
              (o += r) >= 8 && ((o -= 8), (a[c++] = 255 & (l >> o)));
          }
          if (o >= r || 255 & (l << (8 - o)))
            throw SyntaxError("Unexpected end of data");
          return a;
        },
        iP = (e, t, r) => {
          let i = "=" === t[t.length - 1],
            n = (1 << r) - 1,
            s = "",
            a = 0,
            o = 0;
          for (let i = 0; i < e.length; ++i)
            for (o = (o << 8) | e[i], a += 8; a > r; )
              (a -= r), (s += t[n & (o >> a)]);
          if ((a && (s += t[n & (o << (r - a))]), i))
            for (; (s.length * r) & 7; ) s += "=";
          return s;
        },
        iO = ({ name: e, prefix: t, bitsPerChar: r, alphabet: i }) =>
          iN({
            prefix: t,
            name: e,
            encode: (e) => iP(e, i, r),
            decode: (t) => iT(t, i, r, e),
          }),
        ix = iN({
          prefix: "\0",
          name: "identity",
          encode: (e) => iv(e),
          decode: (e) => ib(e),
        }),
        ik = iO({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 }),
        iR = iO({
          prefix: "7",
          name: "base8",
          alphabet: "01234567",
          bitsPerChar: 3,
        }),
        iD = iS({ prefix: "9", name: "base10", alphabet: "0123456789" }),
        iU = iO({
          prefix: "f",
          name: "base16",
          alphabet: "0123456789abcdef",
          bitsPerChar: 4,
        }),
        iL = iO({
          prefix: "F",
          name: "base16upper",
          alphabet: "0123456789ABCDEF",
          bitsPerChar: 4,
        }),
        iM = iO({
          prefix: "b",
          name: "base32",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567",
          bitsPerChar: 5,
        }),
        iB = iO({
          prefix: "B",
          name: "base32upper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
          bitsPerChar: 5,
        }),
        ij = iO({
          prefix: "c",
          name: "base32pad",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
          bitsPerChar: 5,
        }),
        iF = iO({
          prefix: "C",
          name: "base32padupper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
          bitsPerChar: 5,
        }),
        i$ = iO({
          prefix: "v",
          name: "base32hex",
          alphabet: "0123456789abcdefghijklmnopqrstuv",
          bitsPerChar: 5,
        }),
        iH = iO({
          prefix: "V",
          name: "base32hexupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
          bitsPerChar: 5,
        }),
        iz = iO({
          prefix: "t",
          name: "base32hexpad",
          alphabet: "0123456789abcdefghijklmnopqrstuv=",
          bitsPerChar: 5,
        }),
        iq = iO({
          prefix: "T",
          name: "base32hexpadupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
          bitsPerChar: 5,
        }),
        iV = iO({
          prefix: "h",
          name: "base32z",
          alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
          bitsPerChar: 5,
        }),
        iG = iS({
          prefix: "k",
          name: "base36",
          alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
        }),
        iW = iS({
          prefix: "K",
          name: "base36upper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        }),
        iK = iS({
          name: "base58btc",
          prefix: "z",
          alphabet:
            "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
        }),
        iZ = iS({
          name: "base58flickr",
          prefix: "Z",
          alphabet:
            "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
        }),
        iJ = iO({
          prefix: "m",
          name: "base64",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          bitsPerChar: 6,
        }),
        iQ = iO({
          prefix: "M",
          name: "base64pad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          bitsPerChar: 6,
        }),
        iY = iO({
          prefix: "u",
          name: "base64url",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          bitsPerChar: 6,
        }),
        iX = iO({
          prefix: "U",
          name: "base64urlpad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
          bitsPerChar: 6,
        }),
        i0 = Array.from(
          "\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"
        ),
        i1 = i0.reduce((e, t, r) => ((e[r] = t), e), []),
        i2 = i0.reduce((e, t, r) => ((e[t.codePointAt(0)] = r), e), []),
        i3 = iN({
          prefix: "\uD83D\uDE80",
          name: "base256emoji",
          encode: function (e) {
            return e.reduce((e, t) => (e += i1[t]), "");
          },
          decode: function (e) {
            let t = [];
            for (let r of e) {
              let e = i2[r.codePointAt(0)];
              if (void 0 === e) throw Error(`Non-base256emoji character: ${r}`);
              t.push(e);
            }
            return new Uint8Array(t);
          },
        });
      var i5 = function e(t, r, i) {
          r = r || [];
          for (var n = (i = i || 0); t >= 2147483648; )
            (r[i++] = (255 & t) | 128), (t /= 128);
          for (; -128 & t; ) (r[i++] = (255 & t) | 128), (t >>>= 7);
          return (r[i] = 0 | t), (e.bytes = i - n + 1), r;
        },
        i8 = function e(t, r) {
          var i,
            n = 0,
            r = r || 0,
            s = 0,
            a = r,
            o = t.length;
          do {
            if (a >= o)
              throw ((e.bytes = 0), RangeError("Could not decode varint"));
            (i = t[a++]),
              (n += s < 28 ? (127 & i) << s : (127 & i) * Math.pow(2, s)),
              (s += 7);
          } while (i >= 128);
          return (e.bytes = a - r), n;
        };
      let i4 = (e, t = 0) => [i8(e, t), i8.bytes],
        i6 = (e, t, r = 0) => (i5(e, t, r), t),
        i9 = (e) =>
          e < 128
            ? 1
            : e < 16384
            ? 2
            : e < 2097152
            ? 3
            : e < 268435456
            ? 4
            : e < 34359738368
            ? 5
            : e < 4398046511104
            ? 6
            : e < 562949953421312
            ? 7
            : e < 72057594037927940
            ? 8
            : e < 0x7fffffffffffffff
            ? 9
            : 10,
        i7 = (e, t) => {
          let r = t.byteLength,
            i = i9(e),
            n = i + i9(r),
            s = new Uint8Array(n + r);
          return i6(e, s, 0), i6(r, s, i), s.set(t, n), new nr(e, r, t, s);
        },
        ne = (e) => {
          let t = iw(e),
            [r, i] = i4(t),
            [n, s] = i4(t.subarray(i)),
            a = t.subarray(i + s);
          if (a.byteLength !== n) throw Error("Incorrect length");
          return new nr(r, n, a, t);
        },
        nt = (e, t) =>
          e === t ||
          (e.code === t.code && e.size === t.size && iy(e.bytes, t.bytes));
      class nr {
        constructor(e, t, r, i) {
          (this.code = e), (this.size = t), (this.digest = r), (this.bytes = i);
        }
      }
      let ni = ({ name: e, code: t, encode: r }) => new nn(e, t, r);
      class nn {
        constructor(e, t, r) {
          (this.name = e), (this.code = t), (this.encode = r);
        }
        digest(e) {
          if (e instanceof Uint8Array) {
            let t = this.encode(e);
            return t instanceof Uint8Array
              ? i7(this.code, t)
              : t.then((e) => i7(this.code, e));
          }
          throw Error("Unknown type, must be binary type");
        }
      }
      let ns = (e) => async (t) =>
          new Uint8Array(await crypto.subtle.digest(e, t)),
        na = ni({ name: "sha2-256", code: 18, encode: ns("SHA-256") }),
        no = ni({ name: "sha2-512", code: 19, encode: ns("SHA-512") }),
        nl = {
          code: 0,
          name: "identity",
          encode: iw,
          digest: (e) => i7(0, iw(e)),
        },
        nc = "raw",
        nu = 85,
        nh = (e) => iw(e),
        nd = (e) => iw(e),
        np = new TextEncoder(),
        nf = new TextDecoder(),
        ng = "json",
        nm = 512,
        ny = (e) => np.encode(JSON.stringify(e)),
        nw = (e) => JSON.parse(nf.decode(e));
      class nb {
        constructor(e, t, r, i) {
          (this.code = t),
            (this.version = e),
            (this.multihash = r),
            (this.bytes = i),
            (this.byteOffset = i.byteOffset),
            (this.byteLength = i.byteLength),
            (this.asCID = this),
            (this._baseCache = new Map()),
            Object.defineProperties(this, {
              byteOffset: nT,
              byteLength: nT,
              code: nS,
              version: nS,
              multihash: nS,
              bytes: nS,
              _baseCache: nT,
              asCID: nT,
            });
        }
        toV0() {
          if (0 === this.version) return this;
          {
            let { code: e, multihash: t } = this;
            if (e !== nC)
              throw Error("Cannot convert a non dag-pb CID to CIDv0");
            if (t.code !== n_)
              throw Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            return nb.createV0(t);
          }
        }
        toV1() {
          switch (this.version) {
            case 0: {
              let { code: e, digest: t } = this.multihash,
                r = i7(e, t);
              return nb.createV1(this.code, r);
            }
            case 1:
              return this;
            default:
              throw Error(
                `Can not convert CID version ${this.version} to version 0. This is a bug please report`
              );
          }
        }
        equals(e) {
          return (
            e &&
            this.code === e.code &&
            this.version === e.version &&
            nt(this.multihash, e.multihash)
          );
        }
        toString(e) {
          let { bytes: t, version: r, _baseCache: i } = this;
          return 0 === r
            ? nE(t, i, e || iK.encoder)
            : nA(t, i, e || iM.encoder);
        }
        toJSON() {
          return {
            code: this.code,
            version: this.version,
            hash: this.multihash.bytes,
          };
        }
        get [Symbol.toStringTag]() {
          return "CID";
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return "CID(" + this.toString() + ")";
        }
        static isCID(e) {
          return nP(/^0\.0/, nO), !!(e && (e[nN] || e.asCID === e));
        }
        get toBaseEncodedString() {
          throw Error("Deprecated, use .toString()");
        }
        get codec() {
          throw Error(
            '"codec" property is deprecated, use integer "code" property instead'
          );
        }
        get buffer() {
          throw Error(
            "Deprecated .buffer property, use .bytes to get Uint8Array instead"
          );
        }
        get multibaseName() {
          throw Error('"multibaseName" property is deprecated');
        }
        get prefix() {
          throw Error('"prefix" property is deprecated');
        }
        static asCID(e) {
          if (e instanceof nb) return e;
          if (null != e && e.asCID === e) {
            let { version: t, code: r, multihash: i, bytes: n } = e;
            return new nb(t, r, i, n || nI(t, r, i.bytes));
          }
          if (null == e || !0 !== e[nN]) return null;
          {
            let { version: t, multihash: r, code: i } = e,
              n = ne(r);
            return nb.create(t, i, n);
          }
        }
        static create(e, t, r) {
          if ("number" != typeof t)
            throw Error("String codecs are no longer supported");
          switch (e) {
            case 0:
              if (t === nC) return new nb(e, t, r, r.bytes);
              throw Error(
                `Version 0 CID must use dag-pb (code: ${nC}) block encoding`
              );
            case 1: {
              let i = nI(e, t, r.bytes);
              return new nb(e, t, r, i);
            }
            default:
              throw Error("Invalid version");
          }
        }
        static createV0(e) {
          return nb.create(0, nC, e);
        }
        static createV1(e, t) {
          return nb.create(1, e, t);
        }
        static decode(e) {
          let [t, r] = nb.decodeFirst(e);
          if (r.length) throw Error("Incorrect length");
          return t;
        }
        static decodeFirst(e) {
          let t = nb.inspectBytes(e),
            r = t.size - t.multihashSize,
            i = iw(e.subarray(r, r + t.multihashSize));
          if (i.byteLength !== t.multihashSize) throw Error("Incorrect length");
          let n = i.subarray(t.multihashSize - t.digestSize),
            s = new nr(t.multihashCode, t.digestSize, n, i);
          return [
            0 === t.version ? nb.createV0(s) : nb.createV1(t.codec, s),
            e.subarray(t.size),
          ];
        }
        static inspectBytes(e) {
          let t = 0,
            r = () => {
              let [r, i] = i4(e.subarray(t));
              return (t += i), r;
            },
            i = r(),
            n = nC;
          if (
            (18 === i ? ((i = 0), (t = 0)) : 1 === i && (n = r()),
            0 !== i && 1 !== i)
          )
            throw RangeError(`Invalid CID version ${i}`);
          let s = t,
            a = r(),
            o = r(),
            l = t + o;
          return {
            version: i,
            codec: n,
            multihashCode: a,
            digestSize: o,
            multihashSize: l - s,
            size: l,
          };
        }
        static parse(e, t) {
          let [r, i] = nv(e, t),
            n = nb.decode(i);
          return n._baseCache.set(r, e), n;
        }
      }
      let nv = (e, t) => {
          switch (e[0]) {
            case "Q":
              return [iK.prefix, (t || iK).decode(`${iK.prefix}${e}`)];
            case iK.prefix:
              return [iK.prefix, (t || iK).decode(e)];
            case iM.prefix:
              return [iM.prefix, (t || iM).decode(e)];
            default:
              if (null == t)
                throw Error(
                  "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
                );
              return [e[0], t.decode(e)];
          }
        },
        nE = (e, t, r) => {
          let { prefix: i } = r;
          if (i !== iK.prefix)
            throw Error(`Cannot string encode V0 in ${r.name} encoding`);
          let n = t.get(i);
          if (null != n) return n;
          {
            let n = r.encode(e).slice(1);
            return t.set(i, n), n;
          }
        },
        nA = (e, t, r) => {
          let { prefix: i } = r,
            n = t.get(i);
          if (null != n) return n;
          {
            let n = r.encode(e);
            return t.set(i, n), n;
          }
        },
        nC = 112,
        n_ = 18,
        nI = (e, t, r) => {
          let i = i9(e),
            n = i + i9(t),
            s = new Uint8Array(n + r.byteLength);
          return i6(e, s, 0), i6(t, s, i), s.set(r, n), s;
        },
        nN = Symbol.for("@ipld/js-cid/CID"),
        nS = { writable: !1, configurable: !1, enumerable: !0 },
        nT = { writable: !1, enumerable: !1, configurable: !1 },
        nP = (e, t) => {
          if (e.test("0.0.0-dev")) console.warn(t);
          else throw Error(t);
        },
        nO = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`,
        nx = { ...n, ...s, ...a, ...o, ...l, ...c, ...u, ...h, ...d, ...p };
      function nk(e, t, r, i) {
        return {
          name: e,
          prefix: t,
          encoder: { name: e, prefix: t, encode: r },
          decoder: { decode: i },
        };
      }
      ({ ...f, ...g });
      let nR = nk(
          "utf8",
          "u",
          (e) => "u" + new TextDecoder("utf8").decode(e),
          (e) => new TextEncoder().encode(e.substring(1))
        ),
        nD = nk(
          "ascii",
          "a",
          (e) => {
            let t = "a";
            for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
            return t;
          },
          (e) => {
            let t = ip((e = e.substring(1)).length);
            for (let r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);
            return t;
          }
        ),
        nU = {
          utf8: nR,
          "utf-8": nR,
          hex: nx.base16,
          latin1: nD,
          ascii: nD,
          binary: nD,
          ...nx,
        };
      function nL(e, t = "utf8") {
        let r = nU[t];
        if (!r) throw Error(`Unsupported encoding "${t}"`);
        return ("utf8" === t || "utf-8" === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? globalThis.Buffer.from(e, "utf8")
          : r.decoder.decode(`${r.prefix}${e}`);
      }
      function nM(e, t = "utf8") {
        let r = nU[t];
        if (!r) throw Error(`Unsupported encoding "${t}"`);
        return ("utf8" === t || "utf-8" === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? globalThis.Buffer.from(
              e.buffer,
              e.byteOffset,
              e.byteLength
            ).toString("utf8")
          : r.encoder.encode(e).substring(1);
      }
      var nB = r(61984);
      let nj = {
        waku: {
          publish: "waku_publish",
          batchPublish: "waku_batchPublish",
          subscribe: "waku_subscribe",
          batchSubscribe: "waku_batchSubscribe",
          subscription: "waku_subscription",
          unsubscribe: "waku_unsubscribe",
          batchUnsubscribe: "waku_batchUnsubscribe",
          batchFetchMessages: "waku_batchFetchMessages",
        },
        irn: {
          publish: "irn_publish",
          batchPublish: "irn_batchPublish",
          subscribe: "irn_subscribe",
          batchSubscribe: "irn_batchSubscribe",
          subscription: "irn_subscription",
          unsubscribe: "irn_unsubscribe",
          batchUnsubscribe: "irn_batchUnsubscribe",
          batchFetchMessages: "irn_batchFetchMessages",
        },
        iridium: {
          publish: "iridium_publish",
          batchPublish: "iridium_batchPublish",
          subscribe: "iridium_subscribe",
          batchSubscribe: "iridium_batchSubscribe",
          subscription: "iridium_subscription",
          unsubscribe: "iridium_unsubscribe",
          batchUnsubscribe: "iridium_batchUnsubscribe",
          batchFetchMessages: "iridium_batchFetchMessages",
        },
      };
      var nF = r(40257),
        n$ = r(82957).Buffer;
      function nH(e) {
        let [t, r] = e.split(":");
        return { namespace: t, reference: r };
      }
      function nz(e, t) {
        return e.includes(":") ? [e] : t.chains || [];
      }
      let nq = {
        reactNative: "react-native",
        node: "node",
        browser: "browser",
        unknown: "unknown",
      };
      function nV() {
        return (
          "u" > typeof nF &&
          "u" > typeof nF.versions &&
          "u" > typeof nF.versions.node
        );
      }
      function nG() {
        return (
          !(0, rV.getDocument)() &&
          !!(0, rV.getNavigator)() &&
          "ReactNative" === navigator.product
        );
      }
      function nW() {
        return !nV() && !!(0, rV.getNavigator)() && !!(0, rV.getDocument)();
      }
      function nK() {
        return nG()
          ? nq.reactNative
          : nV()
          ? nq.node
          : nW()
          ? nq.browser
          : nq.unknown;
      }
      function nZ() {
        var e;
        try {
          return nG() &&
            "u" > typeof r.g &&
            "u" > typeof (null == r.g ? void 0 : r.g.Application)
            ? null == (e = r.g.Application)
              ? void 0
              : e.applicationId
            : void 0;
        } catch {
          return;
        }
      }
      function nJ() {
        return (
          (0, rG.D)() || { name: "", description: "", url: "", icons: [""] }
        );
      }
      function nQ(e, t, i) {
        let n = (function () {
            if (
              nK() === nq.reactNative &&
              "u" > typeof r.g &&
              "u" > typeof (null == r.g ? void 0 : r.g.Platform)
            ) {
              let { OS: e, Version: t } = r.g.Platform;
              return [e, t].join("-");
            }
            let e =
              "undefined" == typeof document &&
              "undefined" != typeof navigator &&
              "ReactNative" === navigator.product
                ? new r$()
                : "undefined" != typeof navigator
                ? (function (e) {
                    var t =
                      "" !== e &&
                      rz.reduce(function (t, r) {
                        var i = r[0],
                          n = r[1];
                        if (t) return t;
                        var s = n.exec(e);
                        return !!s && [i, s];
                      }, !1);
                    if (!t) return null;
                    var r = t[0],
                      i = t[1];
                    if ("searchbot" === r) return new rF();
                    var n =
                      i[1] && i[1].split(".").join("_").split("_").slice(0, 3);
                    n
                      ? n.length < 3 &&
                        (n = rL(
                          rL([], n, !0),
                          (function (e) {
                            for (var t = [], r = 0; r < e; r++) t.push("0");
                            return t;
                          })(3 - n.length),
                          !0
                        ))
                      : (n = []);
                    var s = n.join("."),
                      a = (function (e) {
                        for (var t = 0, r = rq.length; t < r; t++) {
                          var i = rq[t],
                            n = i[0];
                          if (i[1].exec(e)) return n;
                        }
                        return null;
                      })(e),
                      o = rH.exec(e);
                    return o && o[1] ? new rj(r, s, a, o[1]) : new rM(r, s, a);
                  })(navigator.userAgent)
                : void 0 !== rU && rU.version
                ? new rB(rU.version.slice(1))
                : null;
            if (null === e) return "unknown";
            let t = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
            return "browser" === e.type
              ? [t, e.name, e.version].join("-")
              : [t, e.version].join("-");
          })(),
          s = (function () {
            var e;
            let t = nK();
            return t === nq.browser
              ? [
                  t,
                  (null == (e = (0, rV.getLocation)()) ? void 0 : e.host) ||
                    "unknown",
                ].join(":")
              : t;
          })();
        return [[e, t].join("-"), ["js", i].join("-"), n, s].join("/");
      }
      function nY(e, t) {
        return e.filter((e) => t.includes(e)).length === e.length;
      }
      function nX(e) {
        return Object.fromEntries(e.entries());
      }
      function n0(e) {
        return new Map(Object.entries(e));
      }
      function n1(e = v.FIVE_MINUTES, t) {
        let r, i, n, s;
        let a = (0, v.toMiliseconds)(e || v.FIVE_MINUTES);
        return {
          resolve: (e) => {
            n && r && (clearTimeout(n), r(e), (s = Promise.resolve(e)));
          },
          reject: (e) => {
            n && i && (clearTimeout(n), i(e));
          },
          done: () =>
            new Promise((e, o) => {
              if (s) return e(s);
              (n = setTimeout(() => {
                let e = Error(t);
                (s = Promise.reject(e)), o(e);
              }, a)),
                (r = e),
                (i = o);
            }),
        };
      }
      function n2(e, t, r) {
        return new Promise(async (i, n) => {
          let s = setTimeout(() => n(Error(r)), t);
          try {
            let t = await e;
            i(t);
          } catch (e) {
            n(e);
          }
          clearTimeout(s);
        });
      }
      function n3(e, t) {
        if ("string" == typeof t && t.startsWith(`${e}:`)) return t;
        if ("topic" === e.toLowerCase()) {
          if ("string" != typeof t)
            throw Error(
              'Value must be "string" for expirer target type: topic'
            );
          return `topic:${t}`;
        }
        if ("id" === e.toLowerCase()) {
          if ("number" != typeof t)
            throw Error('Value must be "number" for expirer target type: id');
          return `id:${t}`;
        }
        throw Error(`Unknown expirer target type: ${e}`);
      }
      function n5(e) {
        let [t, r] = e.split(":"),
          i = { id: void 0, topic: void 0 };
        if ("topic" === t && "string" == typeof r) i.topic = r;
        else if ("id" === t && Number.isInteger(Number(r))) i.id = Number(r);
        else
          throw Error(
            `Invalid target, expected id:number or topic:string, got ${t}:${r}`
          );
        return i;
      }
      function n8(e, t) {
        return (0, v.fromMiliseconds)(
          (t || Date.now()) + (0, v.toMiliseconds)(e)
        );
      }
      function n4(e) {
        return Date.now() >= (0, v.toMiliseconds)(e);
      }
      function n6(e, t) {
        return `${e}${t ? `:${t}` : ""}`;
      }
      function n9(e = [], t = []) {
        return [...new Set([...e, ...t])];
      }
      async function n7({ id: e, topic: t, wcDeepLink: i }) {
        var n;
        try {
          if (!i) return;
          let s = "string" == typeof i ? JSON.parse(i) : i,
            a = s?.href;
          if ("string" != typeof a) return;
          let o = (function (e, t, r) {
              let i = `requestId=${t}&sessionTopic=${r}`;
              e.endsWith("/") && (e = e.slice(0, -1));
              let n = `${e}`;
              if (e.startsWith("https://t.me")) {
                let t = e.includes("?") ? "&startapp=" : "?startapp=";
                n = `${n}${t}${(function (e, t = !1) {
                  let r = n$.from(e).toString("base64");
                  return t ? r.replace(/[=]/g, "") : r;
                })(i, !0)}`;
              } else n = `${n}/wc?${i}`;
              return n;
            })(a, e, t),
            l = nK();
          if (l === nq.browser) {
            let e;
            if (!(null != (n = (0, rV.getDocument)()) && n.hasFocus())) {
              console.warn("Document does not have focus, skipping deeplink.");
              return;
            }
            (e = "_self"),
              (function () {
                try {
                  return window.self !== window.top;
                } catch {
                  return !1;
                }
              })()
                ? (e = "_top")
                : (("u" > typeof window &&
                    (!!window.TelegramWebviewProxy ||
                      !!window.Telegram ||
                      !!window.TelegramWebviewProxyProto)) ||
                    o.startsWith("https://") ||
                    o.startsWith("http://")) &&
                  (e = "_blank"),
              window.open(o, e, "noreferrer noopener");
          } else
            l === nq.reactNative &&
              "u" > typeof (null == r.g ? void 0 : r.g.Linking) &&
              (await r.g.Linking.openURL(o));
        } catch (e) {
          console.error(e);
        }
      }
      async function se(e, t) {
        let r = "";
        try {
          if (nW() && (r = localStorage.getItem(t))) return r;
          r = await e.getItem(t);
        } catch (e) {
          console.error(e);
        }
        return r;
      }
      function st(e, t) {
        if (!e.includes(t)) return null;
        let r = e.split(/([&,?,=])/),
          i = r.indexOf(t);
        return r[i + 2];
      }
      function sr() {
        return "u" > typeof crypto && null != crypto && crypto.randomUUID
          ? crypto.randomUUID()
          : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
              let t = (16 * Math.random()) | 0;
              return ("x" === e ? t : (3 & t) | 8).toString(16);
            });
      }
      function si() {
        return "u" > typeof nF && "true" === nF.env.IS_VITEST;
      }
      function sn(e) {
        return n$.from(e, "base64").toString("utf-8");
      }
      function ss(e) {
        if (!Number.isSafeInteger(e) || e < 0)
          throw Error("positive integer expected, got " + e);
      }
      function sa(e, ...t) {
        if (
          !(
            e instanceof Uint8Array ||
            (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
          )
        )
          throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function so(e) {
        if ("function" != typeof e || "function" != typeof e.create)
          throw Error("Hash should be wrapped by utils.wrapConstructor");
        ss(e.outputLen), ss(e.blockLen);
      }
      function sl(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      function sc(e, t) {
        sa(e);
        let r = t.outputLen;
        if (e.length < r)
          throw Error(
            "digestInto() expects output buffer of length at least " + r
          );
      }
      let su = BigInt(4294967296 - 1),
        sh = BigInt(32),
        sd = (e, t, r) => (e << r) | (t >>> (32 - r)),
        sp = (e, t, r) => (t << r) | (e >>> (32 - r)),
        sf = (e, t, r) => (t << (r - 32)) | (e >>> (64 - r)),
        sg = (e, t, r) => (e << (r - 32)) | (t >>> (64 - r)),
        sm =
          "object" == typeof globalThis && "crypto" in globalThis
            ? globalThis.crypto
            : void 0;
      function sy(e) {
        return new DataView(e.buffer, e.byteOffset, e.byteLength);
      }
      function sw(e, t) {
        return (e << (32 - t)) | (e >>> t);
      }
      let sb = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0];
      function sv(e) {
        for (let r = 0; r < e.length; r++) {
          var t;
          e[r] =
            (((t = e[r]) << 24) & 4278190080) |
            ((t << 8) & 16711680) |
            ((t >>> 8) & 65280) |
            ((t >>> 24) & 255);
        }
      }
      function sE(e) {
        return (
          "string" == typeof e &&
            (e = (function (e) {
              if ("string" != typeof e)
                throw Error("utf8ToBytes expected string, got " + typeof e);
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          sa(e),
          e
        );
      }
      class sA {
        clone() {
          return this._cloneInto();
        }
      }
      function sC(e) {
        let t = (t) => e().update(sE(t)).digest(),
          r = e();
        return (
          (t.outputLen = r.outputLen),
          (t.blockLen = r.blockLen),
          (t.create = () => e()),
          t
        );
      }
      function s_(e = 32) {
        if (sm && "function" == typeof sm.getRandomValues)
          return sm.getRandomValues(new Uint8Array(e));
        if (sm && "function" == typeof sm.randomBytes) return sm.randomBytes(e);
        throw Error("crypto.getRandomValues must be defined");
      }
      let sI = [],
        sN = [],
        sS = [],
        sT = BigInt(0),
        sP = BigInt(1),
        sO = BigInt(2),
        sx = BigInt(7),
        sk = BigInt(256),
        sR = BigInt(113);
      for (let e = 0, t = sP, r = 1, i = 0; e < 24; e++) {
        ([r, i] = [i, (2 * r + 3 * i) % 5]),
          sI.push(2 * (5 * i + r)),
          sN.push((((e + 1) * (e + 2)) / 2) % 64);
        let n = sT;
        for (let e = 0; e < 7; e++)
          (t = ((t << sP) ^ ((t >> sx) * sR)) % sk) & sO &&
            (n ^= sP << ((sP << BigInt(e)) - sP));
        sS.push(n);
      }
      let [sD, sU] = (function (e, t = !1) {
          let r = new Uint32Array(e.length),
            i = new Uint32Array(e.length);
          for (let n = 0; n < e.length; n++) {
            let { h: s, l: a } = (function (e, t = !1) {
              return t
                ? { h: Number(e & su), l: Number((e >> sh) & su) }
                : { h: 0 | Number((e >> sh) & su), l: 0 | Number(e & su) };
            })(e[n], t);
            [r[n], i[n]] = [s, a];
          }
          return [r, i];
        })(sS, !0),
        sL = (e, t, r) => (r > 32 ? sf(e, t, r) : sd(e, t, r)),
        sM = (e, t, r) => (r > 32 ? sg(e, t, r) : sp(e, t, r));
      class sB extends sA {
        constructor(e, t, r, i = !1, n = 24) {
          var s;
          if (
            (super(),
            (this.blockLen = e),
            (this.suffix = t),
            (this.outputLen = r),
            (this.enableXOF = i),
            (this.rounds = n),
            (this.pos = 0),
            (this.posOut = 0),
            (this.finished = !1),
            (this.destroyed = !1),
            ss(r),
            0 >= this.blockLen || this.blockLen >= 200)
          )
            throw Error("Sha3 supports only keccak-f1600 function");
          (this.state = new Uint8Array(200)),
            (this.state32 = new Uint32Array(
              (s = this.state).buffer,
              s.byteOffset,
              Math.floor(s.byteLength / 4)
            ));
        }
        keccak() {
          sb || sv(this.state32),
            (function (e, t = 24) {
              let r = new Uint32Array(10);
              for (let i = 24 - t; i < 24; i++) {
                for (let t = 0; t < 10; t++)
                  r[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];
                for (let t = 0; t < 10; t += 2) {
                  let i = (t + 8) % 10,
                    n = (t + 2) % 10,
                    s = r[n],
                    a = r[n + 1],
                    o = sL(s, a, 1) ^ r[i],
                    l = sM(s, a, 1) ^ r[i + 1];
                  for (let r = 0; r < 50; r += 10)
                    (e[t + r] ^= o), (e[t + r + 1] ^= l);
                }
                let t = e[2],
                  n = e[3];
                for (let r = 0; r < 24; r++) {
                  let i = sN[r],
                    s = sL(t, n, i),
                    a = sM(t, n, i),
                    o = sI[r];
                  (t = e[o]), (n = e[o + 1]), (e[o] = s), (e[o + 1] = a);
                }
                for (let t = 0; t < 50; t += 10) {
                  for (let i = 0; i < 10; i++) r[i] = e[t + i];
                  for (let i = 0; i < 10; i++)
                    e[t + i] ^= ~r[(i + 2) % 10] & r[(i + 4) % 10];
                }
                (e[0] ^= sD[i]), (e[1] ^= sU[i]);
              }
              r.fill(0);
            })(this.state32, this.rounds),
            sb || sv(this.state32),
            (this.posOut = 0),
            (this.pos = 0);
        }
        update(e) {
          sl(this);
          let { blockLen: t, state: r } = this,
            i = (e = sE(e)).length;
          for (let n = 0; n < i; ) {
            let s = Math.min(t - this.pos, i - n);
            for (let t = 0; t < s; t++) r[this.pos++] ^= e[n++];
            this.pos === t && this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished) return;
          this.finished = !0;
          let { state: e, suffix: t, pos: r, blockLen: i } = this;
          (e[r] ^= t),
            (128 & t) != 0 && r === i - 1 && this.keccak(),
            (e[i - 1] ^= 128),
            this.keccak();
        }
        writeInto(e) {
          sl(this, !1), sa(e), this.finish();
          let t = this.state,
            { blockLen: r } = this;
          for (let i = 0, n = e.length; i < n; ) {
            this.posOut >= r && this.keccak();
            let s = Math.min(r - this.posOut, n - i);
            e.set(t.subarray(this.posOut, this.posOut + s), i),
              (this.posOut += s),
              (i += s);
          }
          return e;
        }
        xofInto(e) {
          if (!this.enableXOF)
            throw Error("XOF is not possible for this instance");
          return this.writeInto(e);
        }
        xof(e) {
          return ss(e), this.xofInto(new Uint8Array(e));
        }
        digestInto(e) {
          if ((sc(e, this), this.finished))
            throw Error("digest() was already called");
          return this.writeInto(e), this.destroy(), e;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          (this.destroyed = !0), this.state.fill(0);
        }
        _cloneInto(e) {
          let {
            blockLen: t,
            suffix: r,
            outputLen: i,
            rounds: n,
            enableXOF: s,
          } = this;
          return (
            e || (e = new sB(t, r, i, s, n)),
            e.state32.set(this.state32),
            (e.pos = this.pos),
            (e.posOut = this.posOut),
            (e.finished = this.finished),
            (e.rounds = n),
            (e.suffix = r),
            (e.outputLen = i),
            (e.enableXOF = s),
            (e.destroyed = this.destroyed),
            e
          );
        }
      }
      let sj = sC(() => new sB(136, 1, 32));
      function sF(e) {
        let t = `Ethereum Signed Message:
${e.length}`,
          r = new TextEncoder().encode(t + e);
        return "0x" + n$.from(sj(r)).toString("hex");
      }
      async function s$(e, t, r, i, n, s) {
        switch (r.t) {
          case "eip191":
            return await sH(e, t, r.s);
          case "eip1271":
            return await sz(e, t, r.s, i, n, s);
          default:
            throw Error(
              `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${r.t}`
            );
        }
      }
      async function sH(e, t, r) {
        return (
          (await ih({ hash: sF(t), signature: r })).toLowerCase() ===
          e.toLowerCase()
        );
      }
      async function sz(e, t, r, i, n, s) {
        let a = nH(i);
        if (!a.namespace || !a.reference)
          throw Error(
            `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${i}`
          );
        try {
          let a = "0x1626ba7e",
            o = r.substring(2),
            l = sF(t).substring(2),
            c = await fetch(
              `${
                s || "https://rpc.walletconnect.org/v1"
              }/?chainId=${i}&projectId=${n}`,
              {
                method: "POST",
                body: JSON.stringify({
                  id: Date.now() + Math.floor(1e3 * Math.random()),
                  jsonrpc: "2.0",
                  method: "eth_call",
                  params: [
                    {
                      to: e,
                      data:
                        a +
                        l +
                        "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000041" +
                        o,
                    },
                    "latest",
                  ],
                }),
              }
            ),
            { result: u } = await c.json();
          return !!u && u.slice(0, a.length).toLowerCase() === a.toLowerCase();
        } catch (e) {
          return console.error("isValidEip1271Signature: ", e), !1;
        }
      }
      var sq = Object.defineProperty,
        sV = Object.defineProperties,
        sG = Object.getOwnPropertyDescriptors,
        sW = Object.getOwnPropertySymbols,
        sK = Object.prototype.hasOwnProperty,
        sZ = Object.prototype.propertyIsEnumerable,
        sJ = (e, t, r) =>
          t in e
            ? sq(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        sQ = (e, t) => {
          for (var r in t || (t = {})) sK.call(t, r) && sJ(e, r, t[r]);
          if (sW) for (var r of sW(t)) sZ.call(t, r) && sJ(e, r, t[r]);
          return e;
        },
        sY = (e, t) => sV(e, sG(t));
      let sX = (e) => e?.split(":"),
        s0 = (e) => {
          let t = e && sX(e);
          if (t) return e.includes("did:pkh:") ? t[3] : t[1];
        },
        s1 = (e) => {
          let t = e && sX(e);
          if (t) return t[2] + ":" + t[3];
        },
        s2 = (e) => {
          let t = e && sX(e);
          if (t) return t.pop();
        };
      async function s3(e) {
        let { cacao: t, projectId: r } = e,
          { s: i, p: n } = t,
          s = s5(n, n.iss),
          a = s2(n.iss);
        return await s$(a, s, i, s1(n.iss), r);
      }
      let s5 = (e, t) => {
        let r = `${e.domain} wants you to sign in with your Ethereum account:`,
          i = s2(t);
        if (!e.aud && !e.uri)
          throw Error(
            "Either `aud` or `uri` is required to construct the message"
          );
        let n = e.statement || void 0,
          s = `URI: ${e.aud || e.uri}`,
          a = `Version: ${e.version}`,
          o = `Chain ID: ${s0(t)}`,
          l = `Nonce: ${e.nonce}`,
          c = `Issued At: ${e.iat}`,
          u = e.exp ? `Expiration Time: ${e.exp}` : void 0,
          h = e.nbf ? `Not Before: ${e.nbf}` : void 0,
          d = e.requestId ? `Request ID: ${e.requestId}` : void 0,
          p = e.resources
            ? `Resources:${e.resources
                .map(
                  (e) => `
- ${e}`
                )
                .join("")}`
            : void 0,
          f = ae(e.resources);
        return (
          f &&
            (n = (function (e = "", t) {
              s8(t);
              let r =
                "I further authorize the stated URI to perform the following actions on my behalf: ";
              if (e.includes(r)) return e;
              let i = [],
                n = 0;
              Object.keys(t.att).forEach((e) => {
                let r = Object.keys(t.att[e]).map((e) => ({
                  ability: e.split("/")[0],
                  action: e.split("/")[1],
                }));
                r.sort((e, t) => e.action.localeCompare(t.action));
                let s = {};
                r.forEach((e) => {
                  s[e.ability] || (s[e.ability] = []),
                    s[e.ability].push(e.action);
                });
                let a = Object.keys(s).map(
                  (t) => (
                    n++, `(${n}) '${t}': '${s[t].join("', '")}' for '${e}'.`
                  )
                );
                i.push(a.join(", ").replace(".,", "."));
              });
              let s = i.join(" "),
                a = `${r}${s}`;
              return `${e ? e + " " : ""}${a}`;
            })(n, s6(f))),
          [r, i, "", n, "", s, a, o, l, c, u, h, d, p].filter((e) => null != e)
            .join(`
`)
        );
      };
      function s8(e) {
        if (!e) throw Error("No recap provided, value is undefined");
        if (!e.att) throw Error("No `att` property found");
        let t = Object.keys(e.att);
        if (!(null != t && t.length))
          throw Error("No resources found in `att` property");
        t.forEach((t) => {
          let r = e.att[t];
          if (Array.isArray(r) || "object" != typeof r)
            throw Error(`Resource must be an object: ${t}`);
          if (!Object.keys(r).length)
            throw Error(`Resource object is empty: ${t}`);
          Object.keys(r).forEach((e) => {
            let t = r[e];
            if (!Array.isArray(t))
              throw Error(
                `Ability limits ${e} must be an array of objects, found: ${t}`
              );
            if (!t.length)
              throw Error(
                `Value of ${e} is empty array, must be an array with objects`
              );
            t.forEach((t) => {
              if ("object" != typeof t)
                throw Error(
                  `Ability limits (${e}) must be an array of objects, found: ${t}`
                );
            });
          });
        });
      }
      function s4(e) {
        return (
          s8(e),
          `urn:recap:${n$
            .from(JSON.stringify(e))
            .toString("base64")
            .replace(/=/g, "")}`
        );
      }
      function s6(e) {
        var t;
        let r =
          ((t = e.replace("urn:recap:", "")),
          JSON.parse(n$.from(t, "base64").toString("utf-8")));
        return s8(r), r;
      }
      function s9(e) {
        var t;
        let r = s6(e);
        s8(r);
        let i = null == (t = r.att) ? void 0 : t.eip155;
        return i ? Object.keys(i).map((e) => e.split("/")[1]) : [];
      }
      function s7(e) {
        let t = s6(e);
        s8(t);
        let r = [];
        return (
          Object.values(t.att).forEach((e) => {
            Object.values(e).forEach((e) => {
              var t;
              null != (t = e?.[0]) && t.chains && r.push(e[0].chains);
            });
          }),
          [...new Set(r.flat())]
        );
      }
      function ae(e) {
        if (!e) return;
        let t = e?.[e.length - 1];
        return t && t.includes("urn:recap:") ? t : void 0;
      }
      function at(e) {
        if (!Number.isSafeInteger(e) || e < 0)
          throw Error("positive integer expected, got " + e);
      }
      function ar(e) {
        return (
          e instanceof Uint8Array ||
          (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
        );
      }
      function ai(e, ...t) {
        if (!ar(e)) throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function an(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      function as(e) {
        if ("boolean" != typeof e) throw Error(`boolean expected, not ${e}`);
      }
      let aa = (e) =>
          new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
        ao = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
      if (68 !== new Uint8Array(new Uint32Array([287454020]).buffer)[0])
        throw Error("Non little-endian hardware is not supported");
      function al(e) {
        if ("string" == typeof e)
          e = (function (e) {
            if ("string" != typeof e) throw Error("string expected");
            return new Uint8Array(new TextEncoder().encode(e));
          })(e);
        else if (ar(e)) e = ah(e);
        else throw Error("Uint8Array expected, got " + typeof e);
        return e;
      }
      function ac(e, t, r = !0) {
        if (void 0 === t) return new Uint8Array(e);
        if (t.length !== e)
          throw Error(
            "invalid output length, expected " + e + ", got: " + t.length
          );
        if (r && t.byteOffset % 4 != 0)
          throw Error("invalid output, must be aligned");
        return t;
      }
      function au(e, t, r, i) {
        if ("function" == typeof e.setBigUint64) return e.setBigUint64(t, r, i);
        let n = BigInt(32),
          s = BigInt(4294967295),
          a = Number((r >> n) & s),
          o = Number(r & s),
          l = i ? 4 : 0,
          c = i ? 0 : 4;
        e.setUint32(t + l, a, i), e.setUint32(t + c, o, i);
      }
      function ah(e) {
        return Uint8Array.from(e);
      }
      function ad(...e) {
        for (let t = 0; t < e.length; t++) e[t].fill(0);
      }
      let ap = (e) => Uint8Array.from(e.split("").map((e) => e.charCodeAt(0))),
        af = ap("expand 16-byte k"),
        ag = ap("expand 32-byte k"),
        am = aa(af),
        ay = aa(ag);
      function aw(e, t) {
        return (e << t) | (e >>> (32 - t));
      }
      function ab(e) {
        return e.byteOffset % 4 == 0;
      }
      let av = 4294967296 - 1,
        aE = new Uint32Array(),
        aA = (e, t) => (255 & e[t++]) | ((255 & e[t++]) << 8);
      class aC {
        constructor(e) {
          (this.blockLen = 16),
            (this.outputLen = 16),
            (this.buffer = new Uint8Array(16)),
            (this.r = new Uint16Array(10)),
            (this.h = new Uint16Array(10)),
            (this.pad = new Uint16Array(8)),
            (this.pos = 0),
            (this.finished = !1),
            ai((e = al(e)), 32);
          let t = aA(e, 0),
            r = aA(e, 2),
            i = aA(e, 4),
            n = aA(e, 6),
            s = aA(e, 8),
            a = aA(e, 10),
            o = aA(e, 12),
            l = aA(e, 14);
          (this.r[0] = 8191 & t),
            (this.r[1] = ((t >>> 13) | (r << 3)) & 8191),
            (this.r[2] = ((r >>> 10) | (i << 6)) & 7939),
            (this.r[3] = ((i >>> 7) | (n << 9)) & 8191),
            (this.r[4] = ((n >>> 4) | (s << 12)) & 255),
            (this.r[5] = (s >>> 1) & 8190),
            (this.r[6] = ((s >>> 14) | (a << 2)) & 8191),
            (this.r[7] = ((a >>> 11) | (o << 5)) & 8065),
            (this.r[8] = ((o >>> 8) | (l << 8)) & 8191),
            (this.r[9] = (l >>> 5) & 127);
          for (let t = 0; t < 8; t++) this.pad[t] = aA(e, 16 + 2 * t);
        }
        process(e, t, r = !1) {
          let { h: i, r: n } = this,
            s = n[0],
            a = n[1],
            o = n[2],
            l = n[3],
            c = n[4],
            u = n[5],
            h = n[6],
            d = n[7],
            p = n[8],
            f = n[9],
            g = aA(e, t + 0),
            m = aA(e, t + 2),
            y = aA(e, t + 4),
            w = aA(e, t + 6),
            b = aA(e, t + 8),
            v = aA(e, t + 10),
            E = aA(e, t + 12),
            A = aA(e, t + 14),
            C = i[0] + (8191 & g),
            _ = i[1] + (((g >>> 13) | (m << 3)) & 8191),
            I = i[2] + (((m >>> 10) | (y << 6)) & 8191),
            N = i[3] + (((y >>> 7) | (w << 9)) & 8191),
            S = i[4] + (((w >>> 4) | (b << 12)) & 8191),
            T = i[5] + ((b >>> 1) & 8191),
            P = i[6] + (((b >>> 14) | (v << 2)) & 8191),
            O = i[7] + (((v >>> 11) | (E << 5)) & 8191),
            x = i[8] + (((E >>> 8) | (A << 8)) & 8191),
            k = i[9] + ((A >>> 5) | (r ? 0 : 2048)),
            R = 0,
            D = 0 + C * s + 5 * f * _ + 5 * p * I + 5 * d * N + 5 * h * S;
          (R = D >>> 13),
            (D &= 8191),
            (D += 5 * u * T + 5 * c * P + 5 * l * O + 5 * o * x + 5 * a * k),
            (R += D >>> 13),
            (D &= 8191);
          let U = R + C * a + _ * s + 5 * f * I + 5 * p * N + 5 * d * S;
          (R = U >>> 13),
            (U &= 8191),
            (U += 5 * h * T + 5 * u * P + 5 * c * O + 5 * l * x + 5 * o * k),
            (R += U >>> 13),
            (U &= 8191);
          let L = R + C * o + _ * a + I * s + 5 * f * N + 5 * p * S;
          (R = L >>> 13),
            (L &= 8191),
            (L += 5 * d * T + 5 * h * P + 5 * u * O + 5 * c * x + 5 * l * k),
            (R += L >>> 13),
            (L &= 8191);
          let M = R + C * l + _ * o + I * a + N * s + 5 * f * S;
          (R = M >>> 13),
            (M &= 8191),
            (M += 5 * p * T + 5 * d * P + 5 * h * O + 5 * u * x + 5 * c * k),
            (R += M >>> 13),
            (M &= 8191);
          let B = R + C * c + _ * l + I * o + N * a + S * s;
          (R = B >>> 13),
            (B &= 8191),
            (B += 5 * f * T + 5 * p * P + 5 * d * O + 5 * h * x + 5 * u * k),
            (R += B >>> 13),
            (B &= 8191);
          let j = R + C * u + _ * c + I * l + N * o + S * a;
          (R = j >>> 13),
            (j &= 8191),
            (j += T * s + 5 * f * P + 5 * p * O + 5 * d * x + 5 * h * k),
            (R += j >>> 13),
            (j &= 8191);
          let F = R + C * h + _ * u + I * c + N * l + S * o;
          (R = F >>> 13),
            (F &= 8191),
            (F += T * a + P * s + 5 * f * O + 5 * p * x + 5 * d * k),
            (R += F >>> 13),
            (F &= 8191);
          let $ = R + C * d + _ * h + I * u + N * c + S * l;
          (R = $ >>> 13),
            ($ &= 8191),
            ($ += T * o + P * a + O * s + 5 * f * x + 5 * p * k),
            (R += $ >>> 13),
            ($ &= 8191);
          let H = R + C * p + _ * d + I * h + N * u + S * c;
          (R = H >>> 13),
            (H &= 8191),
            (H += T * l + P * o + O * a + x * s + 5 * f * k),
            (R += H >>> 13),
            (H &= 8191);
          let z = R + C * f + _ * p + I * d + N * h + S * u;
          (R = z >>> 13),
            (z &= 8191),
            (z += T * c + P * l + O * o + x * a + k * s),
            (R += z >>> 13),
            (z &= 8191),
            (D = 8191 & (R = ((R = ((R << 2) + R) | 0) + D) | 0)),
            (R >>>= 13),
            (U += R),
            (i[0] = D),
            (i[1] = U),
            (i[2] = L),
            (i[3] = M),
            (i[4] = B),
            (i[5] = j),
            (i[6] = F),
            (i[7] = $),
            (i[8] = H),
            (i[9] = z);
        }
        finalize() {
          let { h: e, pad: t } = this,
            r = new Uint16Array(10),
            i = e[1] >>> 13;
          e[1] &= 8191;
          for (let t = 2; t < 10; t++)
            (e[t] += i), (i = e[t] >>> 13), (e[t] &= 8191);
          (e[0] += 5 * i),
            (i = e[0] >>> 13),
            (e[0] &= 8191),
            (e[1] += i),
            (i = e[1] >>> 13),
            (e[1] &= 8191),
            (e[2] += i),
            (r[0] = e[0] + 5),
            (i = r[0] >>> 13),
            (r[0] &= 8191);
          for (let t = 1; t < 10; t++)
            (r[t] = e[t] + i), (i = r[t] >>> 13), (r[t] &= 8191);
          r[9] -= 8192;
          let n = (1 ^ i) - 1;
          for (let e = 0; e < 10; e++) r[e] &= n;
          n = ~n;
          for (let t = 0; t < 10; t++) e[t] = (e[t] & n) | r[t];
          (e[0] = (e[0] | (e[1] << 13)) & 65535),
            (e[1] = ((e[1] >>> 3) | (e[2] << 10)) & 65535),
            (e[2] = ((e[2] >>> 6) | (e[3] << 7)) & 65535),
            (e[3] = ((e[3] >>> 9) | (e[4] << 4)) & 65535),
            (e[4] = ((e[4] >>> 12) | (e[5] << 1) | (e[6] << 14)) & 65535),
            (e[5] = ((e[6] >>> 2) | (e[7] << 11)) & 65535),
            (e[6] = ((e[7] >>> 5) | (e[8] << 8)) & 65535),
            (e[7] = ((e[8] >>> 8) | (e[9] << 5)) & 65535);
          let s = e[0] + t[0];
          e[0] = 65535 & s;
          for (let r = 1; r < 8; r++)
            (s = (((e[r] + t[r]) | 0) + (s >>> 16)) | 0), (e[r] = 65535 & s);
          ad(r);
        }
        update(e) {
          an(this);
          let { buffer: t, blockLen: r } = this,
            i = (e = al(e)).length;
          for (let n = 0; n < i; ) {
            let s = Math.min(r - this.pos, i - n);
            if (s === r) {
              for (; r <= i - n; n += r) this.process(e, n);
              continue;
            }
            t.set(e.subarray(n, n + s), this.pos),
              (this.pos += s),
              (n += s),
              this.pos === r && (this.process(t, 0, !1), (this.pos = 0));
          }
          return this;
        }
        destroy() {
          ad(this.h, this.r, this.buffer, this.pad);
        }
        digestInto(e) {
          an(this),
            (function (e, t) {
              ai(e);
              let r = t.outputLen;
              if (e.length < r)
                throw Error(
                  "digestInto() expects output buffer of length at least " + r
                );
            })(e, this),
            (this.finished = !0);
          let { buffer: t, h: r } = this,
            { pos: i } = this;
          if (i) {
            for (t[i++] = 1; i < 16; i++) t[i] = 0;
            this.process(t, 0, !0);
          }
          this.finalize();
          let n = 0;
          for (let t = 0; t < 8; t++)
            (e[n++] = r[t] >>> 0), (e[n++] = r[t] >>> 8);
          return e;
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
      }
      let a_ = (function (e) {
          let t = (t, r) => e(r).update(al(t)).digest(),
            r = e(new Uint8Array(32));
          return (
            (t.outputLen = r.outputLen),
            (t.blockLen = r.blockLen),
            (t.create = (t) => e(t)),
            t
          );
        })((e) => new aC(e)),
        aI = (function (e, t) {
          let {
            allowShortKeys: r,
            extendNonceFn: i,
            counterLength: n,
            counterRight: s,
            rounds: a,
          } = (function (e, t) {
            if (null == t || "object" != typeof t)
              throw Error("options must be defined");
            return Object.assign(e, t);
          })(
            {
              allowShortKeys: !1,
              counterLength: 8,
              counterRight: !1,
              rounds: 20,
            },
            t
          );
          if ("function" != typeof e) throw Error("core must be a function");
          return (
            at(n),
            at(a),
            as(s),
            as(r),
            (t, o, l, c, u = 0) => {
              ai(t), ai(o), ai(l);
              let h = l.length;
              if (
                (void 0 === c && (c = new Uint8Array(h)),
                ai(c),
                at(u),
                u < 0 || u >= av)
              )
                throw Error("arx: counter overflow");
              if (c.length < h)
                throw Error(
                  `arx: output (${c.length}) is shorter than data (${h})`
                );
              let d = [],
                p = t.length,
                f,
                g;
              if (32 === p) d.push((f = ah(t))), (g = ay);
              else if (16 === p && r)
                (f = new Uint8Array(32)).set(t),
                  f.set(t, 16),
                  (g = am),
                  d.push(f);
              else throw Error(`arx: invalid 32-byte key, got length=${p}`);
              ab(o) || d.push((o = ah(o)));
              let m = aa(f);
              if (i) {
                if (24 !== o.length)
                  throw Error("arx: extended nonce must be 24 bytes");
                i(g, m, aa(o.subarray(0, 16)), m), (o = o.subarray(16));
              }
              let y = 16 - n;
              if (y !== o.length)
                throw Error(`arx: nonce must be ${y} or 16 bytes`);
              if (12 !== y) {
                let e = new Uint8Array(12);
                e.set(o, s ? 0 : 12 - o.length), (o = e), d.push(o);
              }
              return (
                (function (e, t, r, i, n, s, a, o) {
                  let l = n.length,
                    c = new Uint8Array(64),
                    u = aa(c),
                    h = ab(n) && ab(s),
                    d = h ? aa(n) : aE,
                    p = h ? aa(s) : aE;
                  for (let f = 0; f < l; a++) {
                    if ((e(t, r, i, u, a, o), a >= av))
                      throw Error("arx: counter overflow");
                    let g = Math.min(64, l - f);
                    if (h && 64 === g) {
                      let e = f / 4;
                      if (f % 4 != 0)
                        throw Error("arx: invalid block position");
                      for (let t = 0, r; t < 16; t++)
                        p[(r = e + t)] = d[r] ^ u[t];
                      f += 64;
                      continue;
                    }
                    for (let e = 0, t; e < g; e++) s[(t = f + e)] = n[t] ^ c[e];
                    f += g;
                  }
                })(e, g, m, aa(o), l, c, u, a),
                ad(...d),
                c
              );
            }
          );
        })(
          function (e, t, r, i, n, s = 20) {
            let a = e[0],
              o = e[1],
              l = e[2],
              c = e[3],
              u = t[0],
              h = t[1],
              d = t[2],
              p = t[3],
              f = t[4],
              g = t[5],
              m = t[6],
              y = t[7],
              w = r[0],
              b = r[1],
              v = r[2],
              E = a,
              A = o,
              C = l,
              _ = c,
              I = u,
              N = h,
              S = d,
              T = p,
              P = f,
              O = g,
              x = m,
              k = y,
              R = n,
              D = w,
              U = b,
              L = v;
            for (let e = 0; e < s; e += 2)
              (P = (P + (R = aw(R ^ (E = (E + I) | 0), 16))) | 0),
                (E = (E + (I = aw(I ^ P, 12))) | 0),
                (P = (P + (R = aw(R ^ E, 8))) | 0),
                (I = aw(I ^ P, 7)),
                (O = (O + (D = aw(D ^ (A = (A + N) | 0), 16))) | 0),
                (A = (A + (N = aw(N ^ O, 12))) | 0),
                (O = (O + (D = aw(D ^ A, 8))) | 0),
                (N = aw(N ^ O, 7)),
                (x = (x + (U = aw(U ^ (C = (C + S) | 0), 16))) | 0),
                (C = (C + (S = aw(S ^ x, 12))) | 0),
                (x = (x + (U = aw(U ^ C, 8))) | 0),
                (S = aw(S ^ x, 7)),
                (k = (k + (L = aw(L ^ (_ = (_ + T) | 0), 16))) | 0),
                (_ = (_ + (T = aw(T ^ k, 12))) | 0),
                (k = (k + (L = aw(L ^ _, 8))) | 0),
                (T = aw(T ^ k, 7)),
                (x = (x + (L = aw(L ^ (E = (E + N) | 0), 16))) | 0),
                (E = (E + (N = aw(N ^ x, 12))) | 0),
                (x = (x + (L = aw(L ^ E, 8))) | 0),
                (N = aw(N ^ x, 7)),
                (k = (k + (R = aw(R ^ (A = (A + S) | 0), 16))) | 0),
                (A = (A + (S = aw(S ^ k, 12))) | 0),
                (k = (k + (R = aw(R ^ A, 8))) | 0),
                (S = aw(S ^ k, 7)),
                (P = (P + (D = aw(D ^ (C = (C + T) | 0), 16))) | 0),
                (C = (C + (T = aw(T ^ P, 12))) | 0),
                (P = (P + (D = aw(D ^ C, 8))) | 0),
                (T = aw(T ^ P, 7)),
                (O = (O + (U = aw(U ^ (_ = (_ + I) | 0), 16))) | 0),
                (_ = (_ + (I = aw(I ^ O, 12))) | 0),
                (O = (O + (U = aw(U ^ _, 8))) | 0),
                (I = aw(I ^ O, 7));
            let M = 0;
            (i[M++] = (a + E) | 0),
              (i[M++] = (o + A) | 0),
              (i[M++] = (l + C) | 0),
              (i[M++] = (c + _) | 0),
              (i[M++] = (u + I) | 0),
              (i[M++] = (h + N) | 0),
              (i[M++] = (d + S) | 0),
              (i[M++] = (p + T) | 0),
              (i[M++] = (f + P) | 0),
              (i[M++] = (g + O) | 0),
              (i[M++] = (m + x) | 0),
              (i[M++] = (y + k) | 0),
              (i[M++] = (n + R) | 0),
              (i[M++] = (w + D) | 0),
              (i[M++] = (b + U) | 0),
              (i[M++] = (v + L) | 0);
          },
          { counterRight: !1, counterLength: 4, allowShortKeys: !1 }
        ),
        aN = new Uint8Array(16),
        aS = (e, t) => {
          e.update(t);
          let r = t.length % 16;
          r && e.update(aN.subarray(r));
        },
        aT = new Uint8Array(32);
      function aP(e, t, r, i, n) {
        let s = e(t, r, aT),
          a = a_.create(s);
        n && aS(a, n), aS(a, i);
        let o = new Uint8Array(16),
          l = ao(o);
        au(l, 0, BigInt(n ? n.length : 0), !0),
          au(l, 8, BigInt(i.length), !0),
          a.update(o);
        let c = a.digest();
        return ad(s, o), c;
      }
      let aO = ((e, t) => {
        function r(i, ...n) {
          if ((ai(i), void 0 !== e.nonceLength)) {
            let t = n[0];
            if (!t) throw Error("nonce / iv required");
            e.varSizeNonce ? ai(t) : ai(t, e.nonceLength);
          }
          let s = e.tagLength;
          s && void 0 !== n[1] && ai(n[1]);
          let a = t(i, ...n),
            o = (e, t) => {
              if (void 0 !== t) {
                if (2 !== e) throw Error("cipher output not supported");
                ai(t);
              }
            },
            l = !1;
          return {
            encrypt(e, t) {
              if (l)
                throw Error("cannot encrypt() twice with same key + nonce");
              return (l = !0), ai(e), o(a.encrypt.length, t), a.encrypt(e, t);
            },
            decrypt(e, t) {
              if ((ai(e), s && e.length < s))
                throw Error(
                  "invalid ciphertext length: smaller than tagLength=" + s
                );
              return o(a.decrypt.length, t), a.decrypt(e, t);
            },
          };
        }
        return Object.assign(r, e), r;
      })({ blockSize: 64, nonceLength: 12, tagLength: 16 }, (e, t, r) => ({
        encrypt(i, n) {
          let s = i.length;
          (n = ac(s + 16, n, !1)).set(i);
          let a = n.subarray(0, -16);
          aI(e, t, a, a, 1);
          let o = aP(aI, e, t, a, r);
          return n.set(o, s), ad(o), n;
        },
        decrypt(i, n) {
          n = ac(i.length - 16, n, !1);
          let s = i.subarray(0, -16),
            a = i.subarray(-16),
            o = aP(aI, e, t, s, r);
          if (
            !(function (e, t) {
              if (e.length !== t.length) return !1;
              let r = 0;
              for (let i = 0; i < e.length; i++) r |= e[i] ^ t[i];
              return 0 === r;
            })(a, o)
          )
            throw Error("invalid tag");
          return n.set(i.subarray(0, -16)), aI(e, t, n, n, 1), ad(o), n;
        },
      }));
      class ax extends sA {
        constructor(e, t) {
          super(), (this.finished = !1), (this.destroyed = !1), so(e);
          let r = sE(t);
          if (
            ((this.iHash = e.create()), "function" != typeof this.iHash.update)
          )
            throw Error("Expected instance of class which extends utils.Hash");
          (this.blockLen = this.iHash.blockLen),
            (this.outputLen = this.iHash.outputLen);
          let i = this.blockLen,
            n = new Uint8Array(i);
          n.set(r.length > i ? e.create().update(r).digest() : r);
          for (let e = 0; e < n.length; e++) n[e] ^= 54;
          this.iHash.update(n), (this.oHash = e.create());
          for (let e = 0; e < n.length; e++) n[e] ^= 106;
          this.oHash.update(n), n.fill(0);
        }
        update(e) {
          return sl(this), this.iHash.update(e), this;
        }
        digestInto(e) {
          sl(this),
            sa(e, this.outputLen),
            (this.finished = !0),
            this.iHash.digestInto(e),
            this.oHash.update(e),
            this.oHash.digestInto(e),
            this.destroy();
        }
        digest() {
          let e = new Uint8Array(this.oHash.outputLen);
          return this.digestInto(e), e;
        }
        _cloneInto(e) {
          e || (e = Object.create(Object.getPrototypeOf(this), {}));
          let {
            oHash: t,
            iHash: r,
            finished: i,
            destroyed: n,
            blockLen: s,
            outputLen: a,
          } = this;
          return (
            (e.finished = i),
            (e.destroyed = n),
            (e.blockLen = s),
            (e.outputLen = a),
            (e.oHash = t._cloneInto(e.oHash)),
            (e.iHash = r._cloneInto(e.iHash)),
            e
          );
        }
        destroy() {
          (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
        }
      }
      let ak = (e, t, r) => new ax(e, t).update(r).digest();
      ak.create = (e, t) => new ax(e, t);
      let aR = new Uint8Array([0]),
        aD = new Uint8Array(),
        aU = (e, t, r, i, n) => {
          var s;
          return (function (e, t, r, i = 32) {
            if ((so(e), ss(i), i > 255 * e.outputLen))
              throw Error("Length should be <= 255*HashLen");
            let n = Math.ceil(i / e.outputLen);
            void 0 === r && (r = aD);
            let s = new Uint8Array(n * e.outputLen),
              a = ak.create(e, t),
              o = a._cloneInto(),
              l = new Uint8Array(a.outputLen);
            for (let t = 0; t < n; t++)
              (aR[0] = t + 1),
                o
                  .update(0 === t ? aD : l)
                  .update(r)
                  .update(aR)
                  .digestInto(l),
                s.set(l, e.outputLen * t),
                a._cloneInto(o);
            return (
              a.destroy(), o.destroy(), l.fill(0), aR.fill(0), s.slice(0, i)
            );
          })(
            e,
            ((s = r),
            so(e),
            void 0 === s && (s = new Uint8Array(e.outputLen)),
            ak(e, sE(s), sE(t))),
            i,
            n
          );
        };
      class aL extends sA {
        constructor(e, t, r, i) {
          super(),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.padOffset = r),
            (this.isLE = i),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.buffer = new Uint8Array(e)),
            (this.view = sy(this.buffer));
        }
        update(e) {
          sl(this);
          let { view: t, buffer: r, blockLen: i } = this,
            n = (e = sE(e)).length;
          for (let s = 0; s < n; ) {
            let a = Math.min(i - this.pos, n - s);
            if (a === i) {
              let t = sy(e);
              for (; i <= n - s; s += i) this.process(t, s);
              continue;
            }
            r.set(e.subarray(s, s + a), this.pos),
              (this.pos += a),
              (s += a),
              this.pos === i && (this.process(t, 0), (this.pos = 0));
          }
          return (this.length += e.length), this.roundClean(), this;
        }
        digestInto(e) {
          sl(this), sc(e, this), (this.finished = !0);
          let { buffer: t, view: r, blockLen: i, isLE: n } = this,
            { pos: s } = this;
          (t[s++] = 128),
            this.buffer.subarray(s).fill(0),
            this.padOffset > i - s && (this.process(r, 0), (s = 0));
          for (let e = s; e < i; e++) t[e] = 0;
          (function (e, t, r, i) {
            if ("function" == typeof e.setBigUint64)
              return e.setBigUint64(t, r, i);
            let n = BigInt(32),
              s = BigInt(4294967295),
              a = Number((r >> n) & s),
              o = Number(r & s),
              l = i ? 4 : 0,
              c = i ? 0 : 4;
            e.setUint32(t + l, a, i), e.setUint32(t + c, o, i);
          })(r, i - 8, BigInt(8 * this.length), n),
            this.process(r, 0);
          let a = sy(e),
            o = this.outputLen;
          if (o % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
          let l = o / 4,
            c = this.get();
          if (l > c.length) throw Error("_sha2: outputLen bigger than state");
          for (let e = 0; e < l; e++) a.setUint32(4 * e, c[e], n);
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          let {
            blockLen: t,
            buffer: r,
            length: i,
            finished: n,
            destroyed: s,
            pos: a,
          } = this;
          return (
            (e.length = i),
            (e.pos = a),
            (e.finished = n),
            (e.destroyed = s),
            i % t && e.buffer.set(r),
            e
          );
        }
      }
      let aM = new Uint32Array([
          1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
          2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
          1925078388, 2162078206, 2614888103, 3248222580, 3835390401,
          4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692,
          1996064986, 2554220882, 2821834349, 2952996808, 3210313671,
          3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912,
          1294757372, 1396182291, 1695183700, 1986661051, 2177026350,
          2456956037, 2730485921, 2820302411, 3259730800, 3345764771,
          3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616,
          659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
          1955562222, 2024104815, 2227730452, 2361852424, 2428436474,
          2756734187, 3204031479, 3329325298,
        ]),
        aB = new Uint32Array([
          1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
          2600822924, 528734635, 1541459225,
        ]),
        aj = new Uint32Array(64);
      class aF extends aL {
        constructor() {
          super(64, 32, 8, !1),
            (this.A = 0 | aB[0]),
            (this.B = 0 | aB[1]),
            (this.C = 0 | aB[2]),
            (this.D = 0 | aB[3]),
            (this.E = 0 | aB[4]),
            (this.F = 0 | aB[5]),
            (this.G = 0 | aB[6]),
            (this.H = 0 | aB[7]);
        }
        get() {
          let { A: e, B: t, C: r, D: i, E: n, F: s, G: a, H: o } = this;
          return [e, t, r, i, n, s, a, o];
        }
        set(e, t, r, i, n, s, a, o) {
          (this.A = 0 | e),
            (this.B = 0 | t),
            (this.C = 0 | r),
            (this.D = 0 | i),
            (this.E = 0 | n),
            (this.F = 0 | s),
            (this.G = 0 | a),
            (this.H = 0 | o);
        }
        process(e, t) {
          for (let r = 0; r < 16; r++, t += 4) aj[r] = e.getUint32(t, !1);
          for (let e = 16; e < 64; e++) {
            let t = aj[e - 15],
              r = aj[e - 2],
              i = sw(t, 7) ^ sw(t, 18) ^ (t >>> 3),
              n = sw(r, 17) ^ sw(r, 19) ^ (r >>> 10);
            aj[e] = (n + aj[e - 7] + i + aj[e - 16]) | 0;
          }
          let { A: r, B: i, C: n, D: s, E: a, F: o, G: l, H: c } = this;
          for (let e = 0; e < 64; e++) {
            var u, h, d, p;
            let t =
                (c +
                  (sw(a, 6) ^ sw(a, 11) ^ sw(a, 25)) +
                  (((u = a) & o) ^ (~u & l)) +
                  aM[e] +
                  aj[e]) |
                0,
              f =
                ((sw(r, 2) ^ sw(r, 13) ^ sw(r, 22)) +
                  (((h = r) & (d = i)) ^ (h & (p = n)) ^ (d & p))) |
                0;
            (c = l),
              (l = o),
              (o = a),
              (a = (s + t) | 0),
              (s = n),
              (n = i),
              (i = r),
              (r = (t + f) | 0);
          }
          (r = (r + this.A) | 0),
            (i = (i + this.B) | 0),
            (n = (n + this.C) | 0),
            (s = (s + this.D) | 0),
            (a = (a + this.E) | 0),
            (o = (o + this.F) | 0),
            (l = (l + this.G) | 0),
            (c = (c + this.H) | 0),
            this.set(r, i, n, s, a, o, l, c);
        }
        roundClean() {
          aj.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
        }
      }
      let a$ = sC(() => new aF()),
        aH = BigInt(0);
      function az(e) {
        return (
          e instanceof Uint8Array ||
          (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
        );
      }
      function aq(e) {
        if (!az(e)) throw Error("Uint8Array expected");
      }
      let aV = Array.from({ length: 256 }, (e, t) =>
          t.toString(16).padStart(2, "0")
        ),
        aG = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function aW(e) {
        return e >= aG._0 && e <= aG._9
          ? e - aG._0
          : e >= aG.A && e <= aG.F
          ? e - (aG.A - 10)
          : e >= aG.a && e <= aG.f
          ? e - (aG.a - 10)
          : void 0;
      }
      function aK(e) {
        if ("string" != typeof e)
          throw Error("hex string expected, got " + typeof e);
        let t = e.length,
          r = t / 2;
        if (t % 2)
          throw Error("hex string expected, got unpadded hex of length " + t);
        let i = new Uint8Array(r);
        for (let t = 0, n = 0; t < r; t++, n += 2) {
          let r = aW(e.charCodeAt(n)),
            s = aW(e.charCodeAt(n + 1));
          if (void 0 === r || void 0 === s)
            throw Error(
              'hex string expected, got non-hex character "' +
                (e[n] + e[n + 1]) +
                '" at index ' +
                n
            );
          i[t] = 16 * r + s;
        }
        return i;
      }
      function aZ(e) {
        return (
          aq(e),
          (function (e) {
            if ("string" != typeof e)
              throw Error("hex string expected, got " + typeof e);
            return "" === e ? aH : BigInt("0x" + e);
          })(
            (function (e) {
              aq(e);
              let t = "";
              for (let r = 0; r < e.length; r++) t += aV[e[r]];
              return t;
            })(Uint8Array.from(e).reverse())
          )
        );
      }
      function aJ(e, t, r) {
        let i;
        if ("string" == typeof t)
          try {
            i = aK(t);
          } catch (t) {
            throw Error(e + " must be hex string or Uint8Array, cause: " + t);
          }
        else if (az(t)) i = Uint8Array.from(t);
        else throw Error(e + " must be hex string or Uint8Array");
        let n = i.length;
        if ("number" == typeof r && n !== r)
          throw Error(e + " of length " + r + " expected, got " + n);
        return i;
      }
      let aQ = (e) => "bigint" == typeof e && aH <= e;
      function aY(e, t, r, i) {
        if (!(aQ(t) && aQ(r) && aQ(i)) || !(r <= t) || !(t < i))
          throw Error(
            "expected valid " + e + ": " + r + " <= n < " + i + ", got " + t
          );
      }
      let aX = {
          bigint: (e) => "bigint" == typeof e,
          function: (e) => "function" == typeof e,
          boolean: (e) => "boolean" == typeof e,
          string: (e) => "string" == typeof e,
          stringOrUint8Array: (e) => "string" == typeof e || az(e),
          isSafeInteger: (e) => Number.isSafeInteger(e),
          array: (e) => Array.isArray(e),
          field: (e, t) => t.Fp.isValid(e),
          hash: (e) =>
            "function" == typeof e && Number.isSafeInteger(e.outputLen),
        },
        a0 = BigInt(0),
        a1 = BigInt(1);
      function a2(e, t) {
        let r = e % t;
        return r >= a0 ? r : t + r;
      }
      function a3(e, t, r) {
        let i = e;
        for (; t-- > a0; ) (i *= i), (i %= r);
        return i;
      }
      BigInt(0), BigInt(1), BigInt(0), BigInt(1), BigInt(2), BigInt(8);
      let a5 = BigInt(0),
        a8 = BigInt(1),
        a4 = BigInt(
          "57896044618658097711785492504343953926634992332820282019728792003956564819949"
        );
      BigInt(0);
      let a6 = BigInt(1),
        a9 = BigInt(2),
        a7 = BigInt(3),
        oe = BigInt(5);
      BigInt(8);
      let ot = (function (e) {
          let t =
              ((function (e, t, r = {}) {
                let i = (t, r, i) => {
                  let n = aX[r];
                  if ("function" != typeof n)
                    throw Error("invalid validator function");
                  let s = e[t];
                  if (!(i && void 0 === s) && !n(s, e))
                    throw Error(
                      "param " +
                        String(t) +
                        " is invalid. Expected " +
                        r +
                        ", got " +
                        s
                    );
                };
                for (let [e, r] of Object.entries(t)) i(e, r, !1);
                for (let [e, t] of Object.entries(r)) i(e, t, !0);
              })(
                e,
                { a: "bigint" },
                {
                  montgomeryBits: "isSafeInteger",
                  nByteLength: "isSafeInteger",
                  adjustScalarBytes: "function",
                  domain: "function",
                  powPminus2: "function",
                  Gu: "bigint",
                }
              ),
              Object.freeze({ ...e })),
            { P: r } = t,
            i = (e) => a2(e, r),
            n = t.montgomeryBits,
            s = Math.ceil(n / 8),
            a = t.nByteLength,
            o = t.adjustScalarBytes || ((e) => e),
            l =
              t.powPminus2 ||
              ((e) =>
                (function (e, t, r) {
                  if (t < a0)
                    throw Error("invalid exponent, negatives unsupported");
                  if (r <= a0) throw Error("invalid modulus");
                  if (r === a1) return a0;
                  let i = a1;
                  for (; t > a0; )
                    t & a1 && (i = (i * e) % r), (e = (e * e) % r), (t >>= a1);
                  return i;
                })(e, r - BigInt(2), r));
          function c(e, t, r) {
            let n = i(e * (t - r));
            return [(t = i(t - n)), (r = i(r + n))];
          }
          let u = (t.a - BigInt(2)) / BigInt(4);
          function h(e) {
            var t;
            return aK(
              i(e)
                .toString(16)
                .padStart(2 * s, "0")
            ).reverse();
          }
          function d(e, t) {
            let d = (function (e, t) {
              aY("u", e, a5, r), aY("scalar", t, a5, r);
              let s = a8,
                a = a5,
                o = e,
                h = a8,
                d = a5,
                p;
              for (let r = BigInt(n - 1); r >= a5; r--) {
                let n = (t >> r) & a8;
                (d ^= n),
                  (s = (p = c(d, s, o))[0]),
                  (o = p[1]),
                  (a = (p = c(d, a, h))[0]),
                  (h = p[1]),
                  (d = n);
                let l = s + a,
                  f = i(l * l),
                  g = s - a,
                  m = i(g * g),
                  y = f - m,
                  w = o + h,
                  b = i((o - h) * l),
                  v = i(w * g),
                  E = b + v,
                  A = b - v;
                (o = i(E * E)),
                  (h = i(e * i(A * A))),
                  (s = i(f * m)),
                  (a = i(y * (f + i(u * y))));
              }
              return (
                (s = (p = c(d, s, o))[0]),
                (o = p[1]),
                (a = (p = c(d, a, h))[0]),
                (h = p[1]),
                i(s * l(a))
              );
            })(
              (function (e) {
                let t = aJ("u coordinate", e, s);
                return 32 === a && (t[31] &= 127), aZ(t);
              })(t),
              (function (e) {
                let t = aJ("scalar", e),
                  r = t.length;
                if (r !== s && r !== a)
                  throw Error(
                    "invalid scalar, expected " +
                      s +
                      " or " +
                      a +
                      " bytes, got " +
                      r
                  );
                return aZ(o(t));
              })(e)
            );
            if (d === a5) throw Error("invalid private or public key received");
            return h(d);
          }
          let p = h(t.Gu);
          function f(e) {
            return d(e, p);
          }
          return {
            scalarMult: d,
            scalarMultBase: f,
            getSharedSecret: (e, t) => d(e, t),
            getPublicKey: (e) => f(e),
            utils: { randomPrivateKey: () => t.randomBytes(t.nByteLength) },
            GuBytes: p,
          };
        })({
          P: a4,
          a: BigInt(486662),
          montgomeryBits: 255,
          nByteLength: 32,
          Gu: BigInt(9),
          powPminus2: (e) => {
            let { pow_p_5_8: t, b2: r } = (function (e) {
              let t = BigInt(10),
                r = BigInt(20),
                i = BigInt(40),
                n = BigInt(80),
                s = (((e * e) % a4) * e) % a4,
                a = (a3(s, a9, a4) * s) % a4,
                o = (a3(a, a6, a4) * e) % a4,
                l = (a3(o, oe, a4) * o) % a4,
                c = (a3(l, t, a4) * l) % a4,
                u = (a3(c, r, a4) * c) % a4,
                h = (a3(u, i, a4) * u) % a4,
                d = (a3(h, n, a4) * h) % a4,
                p = (a3(d, n, a4) * h) % a4,
                f = (a3(p, t, a4) * l) % a4;
              return { pow_p_5_8: (a3(f, a9, a4) * e) % a4, b2: s };
            })(e);
            return a2(a3(t, a7, a4) * r, a4);
          },
          adjustScalarBytes: function (e) {
            return (e[0] &= 248), (e[31] &= 127), (e[31] |= 64), e;
          },
          randomBytes: s_,
        }),
        or = "base10",
        oi = "base16",
        on = "base64pad",
        os = "base64url",
        oa = "utf8";
      function oo() {
        return nM(s_(32), oi);
      }
      function ol(e) {
        return nM(a$(nL(e, oi)), oi);
      }
      function oc(e) {
        return nM(a$(nL(e, oa)), oi);
      }
      function ou(e) {
        return Number(nM(e, or));
      }
      function oh(e) {
        let { encoding: t = on } = e;
        if (2 === ou(e.type)) return nM(ig([e.type, e.sealed]), t);
        if (1 === ou(e.type)) {
          if (typeof e.senderPublicKey > "u")
            throw Error("Missing sender public key for type 1 envelope");
          return nM(ig([e.type, e.senderPublicKey, e.iv, e.sealed]), t);
        }
        return nM(ig([e.type, e.iv, e.sealed]), t);
      }
      function od(e) {
        let { encoded: t, encoding: r = on } = e,
          i = nL(t, r),
          n = i.slice(0, 1);
        if (1 === ou(n)) {
          let e = i.slice(1, 33),
            t = i.slice(33, 45);
          return { type: n, sealed: i.slice(45), iv: t, senderPublicKey: e };
        }
        if (2 === ou(n)) return { type: n, sealed: i.slice(1), iv: s_(12) };
        let s = i.slice(1, 13);
        return { type: n, sealed: i.slice(13), iv: s };
      }
      function op(e) {
        let t = e?.type || 0;
        if (1 === t) {
          if (typeof e?.senderPublicKey > "u")
            throw Error("missing sender public key");
          if (typeof e?.receiverPublicKey > "u")
            throw Error("missing receiver public key");
        }
        return {
          type: t,
          senderPublicKey: e?.senderPublicKey,
          receiverPublicKey: e?.receiverPublicKey,
        };
      }
      function of(e) {
        return (
          1 === e.type &&
          "string" == typeof e.senderPublicKey &&
          "string" == typeof e.receiverPublicKey
        );
      }
      function og(e) {
        return e?.relay || { protocol: "irn" };
      }
      function om(e) {
        let t = nj[e];
        if (typeof t > "u") throw Error(`Relay Protocol not supported: ${e}`);
        return t;
      }
      function oy(e) {
        var t;
        if (!e.includes("wc:")) {
          let t = sn(e);
          null != t && t.includes("wc:") && (e = t);
        }
        let r = (e = (e = e.includes("wc://")
            ? e.replace("wc://", "")
            : e).includes("wc:")
            ? e.replace("wc:", "")
            : e).indexOf(":"),
          i = -1 !== e.indexOf("?") ? e.indexOf("?") : void 0,
          n = e.substring(0, r),
          s = e.substring(r + 1, i).split("@"),
          a = new URLSearchParams("u" > typeof i ? e.substring(i) : ""),
          o = {};
        a.forEach((e, t) => {
          o[t] = e;
        });
        let l = "string" == typeof o.methods ? o.methods.split(",") : void 0;
        return {
          protocol: n,
          topic: (t = s[0]).startsWith("//") ? t.substring(2) : t,
          version: parseInt(s[1], 10),
          symKey: o.symKey,
          relay: (function (e, t = "-") {
            let r = {},
              i = "relay" + t;
            return (
              Object.keys(e).forEach((t) => {
                if (t.startsWith(i)) {
                  let n = t.replace(i, ""),
                    s = e[t];
                  r[n] = s;
                }
              }),
              r
            );
          })(o),
          methods: l,
          expiryTimestamp: o.expiryTimestamp
            ? parseInt(o.expiryTimestamp, 10)
            : void 0,
        };
      }
      function ow(e) {
        let t = new URLSearchParams(),
          r = (function (e, t = "-") {
            let r = {};
            return (
              Object.keys(e).forEach((i) => {
                e[i] && (r["relay" + t + i] = e[i]);
              }),
              r
            );
          })(e.relay);
        Object.keys(r)
          .sort()
          .forEach((e) => {
            t.set(e, r[e]);
          }),
          t.set("symKey", e.symKey),
          e.expiryTimestamp &&
            t.set("expiryTimestamp", e.expiryTimestamp.toString()),
          e.methods && t.set("methods", e.methods.join(","));
        let i = t.toString();
        return `${e.protocol}:${e.topic}@${e.version}?${i}`;
      }
      function ob(e, t, r) {
        return `${e}?wc_ev=${r}&topic=${t}`;
      }
      function ov(e) {
        let t = [];
        return (
          e.forEach((e) => {
            let [r, i] = e.split(":");
            t.push(`${r}:${i}`);
          }),
          t
        );
      }
      function oE(e) {
        return e.includes(":");
      }
      function oA(e) {
        return oE(e) ? e.split(":")[0] : e;
      }
      function oC(e, t) {
        let r = (function (e) {
          let t = {};
          return (
            e?.forEach((e) => {
              var r;
              let [i, n] = e.split(":");
              t[i] ||
                (t[i] = { accounts: [], chains: [], events: [], methods: [] }),
                t[i].accounts.push(e),
                null == (r = t[i].chains) || r.push(`${i}:${n}`);
            }),
            t
          );
        })((t = t.map((e) => e.replace("did:pkh:", ""))));
        for (let [t, i] of Object.entries(r))
          i.methods ? (i.methods = n9(i.methods, e)) : (i.methods = e),
            (i.events = ["chainChanged", "accountsChanged"]);
        return r;
      }
      Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable;
      let o_ = {
          INVALID_METHOD: { message: "Invalid method.", code: 1001 },
          INVALID_EVENT: { message: "Invalid event.", code: 1002 },
          INVALID_UPDATE_REQUEST: {
            message: "Invalid update request.",
            code: 1003,
          },
          INVALID_EXTEND_REQUEST: {
            message: "Invalid extend request.",
            code: 1004,
          },
          INVALID_SESSION_SETTLE_REQUEST: {
            message: "Invalid session settle request.",
            code: 1005,
          },
          UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 },
          UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 },
          UNAUTHORIZED_UPDATE_REQUEST: {
            message: "Unauthorized update request.",
            code: 3003,
          },
          UNAUTHORIZED_EXTEND_REQUEST: {
            message: "Unauthorized extend request.",
            code: 3004,
          },
          USER_REJECTED: { message: "User rejected.", code: 5e3 },
          USER_REJECTED_CHAINS: {
            message: "User rejected chains.",
            code: 5001,
          },
          USER_REJECTED_METHODS: {
            message: "User rejected methods.",
            code: 5002,
          },
          USER_REJECTED_EVENTS: {
            message: "User rejected events.",
            code: 5003,
          },
          UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 },
          UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 },
          UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 },
          UNSUPPORTED_ACCOUNTS: {
            message: "Unsupported accounts.",
            code: 5103,
          },
          UNSUPPORTED_NAMESPACE_KEY: {
            message: "Unsupported namespace key.",
            code: 5104,
          },
          USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 },
          SESSION_SETTLEMENT_FAILED: {
            message: "Session settlement failed.",
            code: 7e3,
          },
          WC_METHOD_UNSUPPORTED: {
            message: "Unsupported wc_ method.",
            code: 10001,
          },
        },
        oI = {
          NOT_INITIALIZED: { message: "Not initialized.", code: 1 },
          NO_MATCHING_KEY: { message: "No matching key.", code: 2 },
          RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 },
          RESUBSCRIBED: { message: "Resubscribed.", code: 4 },
          MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 },
          EXPIRED: { message: "Expired.", code: 6 },
          UNKNOWN_TYPE: { message: "Unknown type.", code: 7 },
          MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 },
          NON_CONFORMING_NAMESPACES: {
            message: "Non conforming namespaces.",
            code: 9,
          },
        };
      function oN(e, t) {
        let { message: r, code: i } = oI[e];
        return { message: t ? `${r} ${t}` : r, code: i };
      }
      function oS(e, t) {
        let { message: r, code: i } = o_[e];
        return { message: t ? `${r} ${t}` : r, code: i };
      }
      function oT(e, t) {
        return (
          !!Array.isArray(e) && (!("u" > typeof t) || !e.length || e.every(t))
        );
      }
      function oP(e) {
        return (
          Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length
        );
      }
      function oO(e) {
        return typeof e > "u";
      }
      function ox(e, t) {
        return !!(t && oO(e)) || ("string" == typeof e && !!e.trim().length);
      }
      function ok(e, t) {
        return !!(t && oO(e)) || ("number" == typeof e && !isNaN(e));
      }
      function oR(e) {
        return !!(ox(e, !1) && e.includes(":")) && 2 === e.split(":").length;
      }
      function oD(e) {
        let t = !0;
        return (
          oT(e) ? e.length && (t = e.every((e) => ox(e, !1))) : (t = !1), t
        );
      }
      function oU(e, t) {
        let r = null;
        return (
          Object.values(e).forEach((e) => {
            var i;
            let n;
            if (r) return;
            let s =
              ((i = `${t}, namespace`),
              (n = null),
              oD(e?.methods)
                ? oD(e?.events) ||
                  (n = oS(
                    "UNSUPPORTED_EVENTS",
                    `${i}, events should be an array of strings or empty array for no events`
                  ))
                : (n = oS(
                    "UNSUPPORTED_METHODS",
                    `${i}, methods should be an array of strings or empty array for no methods`
                  )),
              n);
            s && (r = s);
          }),
          r
        );
      }
      function oL(e, t) {
        let r = null;
        if (e && oP(e)) {
          let i;
          let n = oU(e, t);
          n && (r = n);
          let s =
            ((i = null),
            Object.values(e).forEach((e) => {
              var r, n;
              let s;
              if (i) return;
              let a =
                ((r = e?.accounts),
                (n = `${t} namespace`),
                (s = null),
                oT(r)
                  ? r.forEach((e) => {
                      s ||
                        (function (e) {
                          if (ox(e, !1) && e.includes(":")) {
                            let t = e.split(":");
                            if (3 === t.length) {
                              let e = t[0] + ":" + t[1];
                              return !!t[2] && oR(e);
                            }
                          }
                          return !1;
                        })(e) ||
                        (s = oS(
                          "UNSUPPORTED_ACCOUNTS",
                          `${n}, account ${e} should be a string and conform to "namespace:chainId:address" format`
                        ));
                    })
                  : (s = oS(
                      "UNSUPPORTED_ACCOUNTS",
                      `${n}, accounts should be an array of strings conforming to "namespace:chainId:address" format`
                    )),
                s);
              a && (i = a);
            }),
            i);
          s && (r = s);
        } else
          r = oN(
            "MISSING_OR_INVALID",
            `${t}, namespaces should be an object with data`
          );
        return r;
      }
      function oM(e) {
        return ox(e.protocol, !0);
      }
      function oB(e) {
        return "u" > typeof e;
      }
      function oj(e, t) {
        return !(
          !oR(t) ||
          !(function (e) {
            let t = [];
            return (
              Object.values(e).forEach((e) => {
                t.push(...ov(e.accounts));
              }),
              t
            );
          })(e).includes(t)
        );
      }
      function oF(e, t, r) {
        let i = null,
          n = (function (e) {
            let t = {};
            return (
              Object.keys(e).forEach((r) => {
                var i;
                r.includes(":")
                  ? (t[r] = e[r])
                  : null == (i = e[r].chains) ||
                    i.forEach((i) => {
                      t[i] = { methods: e[r].methods, events: e[r].events };
                    });
              }),
              t
            );
          })(e),
          s = (function (e) {
            let t = {};
            return (
              Object.keys(e).forEach((r) => {
                if (r.includes(":")) t[r] = e[r];
                else {
                  let i = ov(e[r].accounts);
                  i?.forEach((i) => {
                    t[i] = {
                      accounts: e[r].accounts.filter((e) =>
                        e.includes(`${i}:`)
                      ),
                      methods: e[r].methods,
                      events: e[r].events,
                    };
                  });
                }
              }),
              t
            );
          })(t),
          a = Object.keys(n),
          o = Object.keys(s),
          l = o$(Object.keys(e)),
          c = o$(Object.keys(t)),
          u = l.filter((e) => !c.includes(e));
        return (
          u.length &&
            (i = oN(
              "NON_CONFORMING_NAMESPACES",
              `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u.toString()}
      Received: ${Object.keys(t).toString()}`
            )),
          nY(a, o) ||
            (i = oN(
              "NON_CONFORMING_NAMESPACES",
              `${r} namespaces chains don't satisfy required namespaces.
      Required: ${a.toString()}
      Approved: ${o.toString()}`
            )),
          Object.keys(t).forEach((e) => {
            if (!e.includes(":") || i) return;
            let n = ov(t[e].accounts);
            n.includes(e) ||
              (i = oN(
                "NON_CONFORMING_NAMESPACES",
                `${r} namespaces accounts don't satisfy namespace accounts for ${e}
        Required: ${e}
        Approved: ${n.toString()}`
              ));
          }),
          a.forEach((e) => {
            i ||
              (nY(n[e].methods, s[e].methods)
                ? nY(n[e].events, s[e].events) ||
                  (i = oN(
                    "NON_CONFORMING_NAMESPACES",
                    `${r} namespaces events don't satisfy namespace events for ${e}`
                  ))
                : (i = oN(
                    "NON_CONFORMING_NAMESPACES",
                    `${r} namespaces methods don't satisfy namespace methods for ${e}`
                  )));
          }),
          i
        );
      }
      function o$(e) {
        return [
          ...new Set(e.map((e) => (e.includes(":") ? e.split(":")[0] : e))),
        ];
      }
      function oH() {
        let e = nK();
        return new Promise((t) => {
          switch (e) {
            case nq.browser:
              t(nW() && navigator?.onLine);
              break;
            case nq.reactNative:
              t(oz());
              break;
            case nq.node:
            default:
              t(!0);
          }
        });
      }
      async function oz() {
        if (nG() && "u" > typeof r.g && null != r.g && r.g.NetInfo) {
          let e = await (null == r.g ? void 0 : r.g.NetInfo.fetch());
          return e?.isConnected;
        }
        return !0;
      }
      let oq = {};
      class oV {
        static get(e) {
          return oq[e];
        }
        static set(e, t) {
          oq[e] = t;
        }
        static delete(e) {
          delete oq[e];
        }
      }
      let oG = "INTERNAL_ERROR",
        oW = "SERVER_ERROR",
        oK = [-32700, -32600, -32601, -32602, -32603],
        oZ = {
          PARSE_ERROR: { code: -32700, message: "Parse error" },
          INVALID_REQUEST: { code: -32600, message: "Invalid Request" },
          METHOD_NOT_FOUND: { code: -32601, message: "Method not found" },
          INVALID_PARAMS: { code: -32602, message: "Invalid params" },
          [oG]: { code: -32603, message: "Internal error" },
          [oW]: { code: -32e3, message: "Server error" },
        };
      function oJ(e) {
        return Object.keys(oZ).includes(e) ? oZ[e] : oZ[oW];
      }
      function oQ(e, t, r) {
        return e.message.includes("getaddrinfo ENOTFOUND") ||
          e.message.includes("connect ECONNREFUSED")
          ? Error(`Unavailable ${r} RPC url at ${t}`)
          : e;
      }
      var oY = r(13303);
      function oX(e = 3) {
        return (
          Date.now() * Math.pow(10, e) +
          Math.floor(Math.random() * Math.pow(10, e))
        );
      }
      function o0(e = 6) {
        return BigInt(oX(e));
      }
      function o1(e, t, r) {
        return { id: r || oX(), jsonrpc: "2.0", method: e, params: t };
      }
      function o2(e, t) {
        return { id: e, jsonrpc: "2.0", result: t };
      }
      function o3(e, t, r) {
        var i, n, s;
        return {
          id: e,
          jsonrpc: "2.0",
          error:
            void 0 === (i = t)
              ? oJ(oG)
              : ("string" == typeof i &&
                  (i = Object.assign(Object.assign({}, oJ(oW)), {
                    message: i,
                  })),
                void 0 !== r && (i.data = r),
                (n = i.code),
                oK.includes(n) &&
                  ((s = i.code),
                  (i = Object.values(oZ).find((e) => e.code === s) || oZ[oW])),
                i),
        };
      }
      class o5 {}
      class o8 extends o5 {
        constructor() {
          super();
        }
      }
      class o4 extends o8 {
        constructor(e) {
          super();
        }
      }
      function o6(e, t) {
        let r = (function (e) {
          let t = e.match(RegExp(/^\w+:/, "gi"));
          if (t && t.length) return t[0];
        })(e);
        return void 0 !== r && new RegExp(t).test(r);
      }
      function o9(e) {
        return o6(e, "^https?:");
      }
      function o7(e) {
        return o6(e, "^wss?:");
      }
      function le(e) {
        return (
          "object" == typeof e &&
          "id" in e &&
          "jsonrpc" in e &&
          "2.0" === e.jsonrpc
        );
      }
      function lt(e) {
        return le(e) && "method" in e;
      }
      function lr(e) {
        return le(e) && (li(e) || ln(e));
      }
      function li(e) {
        return "result" in e;
      }
      function ln(e) {
        return "error" in e;
      }
      class ls extends o4 {
        constructor(e) {
          super(e),
            (this.events = new w.EventEmitter()),
            (this.hasRegisteredEventListeners = !1),
            (this.connection = this.setConnection(e)),
            this.connection.connected && this.registerEventListeners();
        }
        async connect(e = this.connection) {
          await this.open(e);
        }
        async disconnect() {
          await this.close();
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async request(e, t) {
          return this.requestStrict(
            o1(e.method, e.params || [], e.id || o0().toString()),
            t
          );
        }
        async requestStrict(e, t) {
          return new Promise(async (r, i) => {
            if (!this.connection.connected)
              try {
                await this.open();
              } catch (e) {
                i(e);
              }
            this.events.on(`${e.id}`, (e) => {
              ln(e) ? i(e.error) : r(e.result);
            });
            try {
              await this.connection.send(e, t);
            } catch (e) {
              i(e);
            }
          });
        }
        setConnection(e = this.connection) {
          return e;
        }
        onPayload(e) {
          this.events.emit("payload", e),
            lr(e)
              ? this.events.emit(`${e.id}`, e)
              : this.events.emit("message", { type: e.method, data: e.params });
        }
        onClose(e) {
          e &&
            3e3 === e.code &&
            this.events.emit(
              "error",
              Error(
                `WebSocket connection closed abnormally with code: ${e.code} ${
                  e.reason ? `(${e.reason})` : ""
                }`
              )
            ),
            this.events.emit("disconnect");
        }
        async open(e = this.connection) {
          (this.connection === e && this.connection.connected) ||
            (this.connection.connected && this.close(),
            "string" == typeof e &&
              (await this.connection.open(e), (e = this.connection)),
            (this.connection = this.setConnection(e)),
            await this.connection.open(),
            this.registerEventListeners(),
            this.events.emit("connect"));
        }
        async close() {
          await this.connection.close();
        }
        registerEventListeners() {
          this.hasRegisteredEventListeners ||
            (this.connection.on("payload", (e) => this.onPayload(e)),
            this.connection.on("close", (e) => this.onClose(e)),
            this.connection.on("error", (e) => this.events.emit("error", e)),
            this.connection.on("register_error", (e) => this.onClose()),
            (this.hasRegisteredEventListeners = !0));
        }
      }
      let la = () =>
          "u" > typeof WebSocket ||
          ("u" > typeof r.g && "u" > typeof r.g.WebSocket) ||
          ("u" > typeof window && "u" > typeof window.WebSocket) ||
          ("u" > typeof self && "u" > typeof self.WebSocket),
        lo = (e) => e.split("?")[0],
        ll =
          "u" > typeof WebSocket
            ? WebSocket
            : "u" > typeof r.g && "u" > typeof r.g.WebSocket
            ? r.g.WebSocket
            : "u" > typeof window && "u" > typeof window.WebSocket
            ? window.WebSocket
            : "u" > typeof self && "u" > typeof self.WebSocket
            ? self.WebSocket
            : r(55223);
      class lc {
        constructor(e) {
          if (
            ((this.url = e),
            (this.events = new w.EventEmitter()),
            (this.registering = !1),
            !o7(e))
          )
            throw Error(
              `Provided URL is not compatible with WebSocket connection: ${e}`
            );
          this.url = e;
        }
        get connected() {
          return "u" > typeof this.socket;
        }
        get connecting() {
          return this.registering;
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async open(e = this.url) {
          await this.register(e);
        }
        async close() {
          return new Promise((e, t) => {
            if (typeof this.socket > "u") {
              t(Error("Connection already closed"));
              return;
            }
            (this.socket.onclose = (t) => {
              this.onClose(t), e();
            }),
              this.socket.close();
          });
        }
        async send(e) {
          typeof this.socket > "u" && (this.socket = await this.register());
          try {
            this.socket.send((0, q.u)(e));
          } catch (t) {
            this.onError(e.id, t);
          }
        }
        register(e = this.url) {
          if (!o7(e))
            throw Error(
              `Provided URL is not compatible with WebSocket connection: ${e}`
            );
          if (this.registering) {
            let e = this.events.getMaxListeners();
            return (
              (this.events.listenerCount("register_error") >= e ||
                this.events.listenerCount("open") >= e) &&
                this.events.setMaxListeners(e + 1),
              new Promise((e, t) => {
                this.events.once("register_error", (e) => {
                  this.resetMaxListeners(), t(e);
                }),
                  this.events.once("open", () => {
                    if ((this.resetMaxListeners(), typeof this.socket > "u"))
                      return t(
                        Error("WebSocket connection is missing or invalid")
                      );
                    e(this.socket);
                  });
              })
            );
          }
          return (
            (this.url = e),
            (this.registering = !0),
            new Promise((t, r) => {
              let i = (0, oY.isReactNative)()
                  ? void 0
                  : {
                      rejectUnauthorized: !RegExp(
                        "wss?://localhost(:d{2,5})?"
                      ).test(e),
                    },
                n = new ll(e, [], i);
              la()
                ? (n.onerror = (e) => {
                    r(this.emitError(e.error));
                  })
                : n.on("error", (e) => {
                    r(this.emitError(e));
                  }),
                (n.onopen = () => {
                  this.onOpen(n), t(n);
                });
            })
          );
        }
        onOpen(e) {
          (e.onmessage = (e) => this.onPayload(e)),
            (e.onclose = (e) => this.onClose(e)),
            (this.socket = e),
            (this.registering = !1),
            this.events.emit("open");
        }
        onClose(e) {
          (this.socket = void 0),
            (this.registering = !1),
            this.events.emit("close", e);
        }
        onPayload(e) {
          if (typeof e.data > "u") return;
          let t = "string" == typeof e.data ? (0, q.D)(e.data) : e.data;
          this.events.emit("payload", t);
        }
        onError(e, t) {
          let r = this.parseError(t),
            i = o3(e, r.message || r.toString());
          this.events.emit("payload", i);
        }
        parseError(e, t = this.url) {
          return oQ(e, lo(t), "WS");
        }
        resetMaxListeners() {
          this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10);
        }
        emitError(e) {
          let t = this.parseError(
            Error(
              e?.message ||
                `WebSocket connection failed for host: ${lo(this.url)}`
            )
          );
          return this.events.emit("register_error", t), t;
        }
      }
      var lu = r(82957).Buffer;
      let lh = "core",
        ld = `wc@2:${lh}:`,
        lp = { logger: "error" },
        lf = { database: ":memory:" },
        lg = "client_ed25519_seed",
        lm = v.ONE_DAY,
        ly = v.SIX_HOURS,
        lw = "wss://relay.walletconnect.org",
        lb = {
          message: "relayer_message",
          message_ack: "relayer_message_ack",
          connect: "relayer_connect",
          disconnect: "relayer_disconnect",
          error: "relayer_error",
          connection_stalled: "relayer_connection_stalled",
          publish: "relayer_publish",
        },
        lv = {
          payload: "payload",
          connect: "connect",
          disconnect: "disconnect",
          error: "error",
        },
        lE = "2.19.1",
        lA = { link_mode: "link_mode", relay: "relay" },
        lC = { inbound: "inbound", outbound: "outbound" },
        l_ = "WALLETCONNECT_LINK_MODE_APPS",
        lI = {
          created: "subscription_created",
          deleted: "subscription_deleted",
          sync: "subscription_sync",
          resubscribed: "subscription_resubscribed",
        },
        lN =
          (v.FIVE_SECONDS,
          {
            wc_pairingDelete: {
              req: { ttl: v.ONE_DAY, prompt: !1, tag: 1e3 },
              res: { ttl: v.ONE_DAY, prompt: !1, tag: 1001 },
            },
            wc_pairingPing: {
              req: { ttl: v.THIRTY_SECONDS, prompt: !1, tag: 1002 },
              res: { ttl: v.THIRTY_SECONDS, prompt: !1, tag: 1003 },
            },
            unregistered_method: {
              req: { ttl: v.ONE_DAY, prompt: !1, tag: 0 },
              res: { ttl: v.ONE_DAY, prompt: !1, tag: 0 },
            },
          }),
        lS = {
          create: "pairing_create",
          expire: "pairing_expire",
          delete: "pairing_delete",
          ping: "pairing_ping",
        },
        lT = {
          created: "history_created",
          updated: "history_updated",
          deleted: "history_deleted",
          sync: "history_sync",
        },
        lP = {
          created: "expirer_created",
          deleted: "expirer_deleted",
          expired: "expirer_expired",
          sync: "expirer_sync",
        },
        lO = "https://verify.walletconnect.org",
        lx = `${lO}/v3`,
        lk = ["https://verify.walletconnect.com", lO],
        lR = {
          pairing_started: "pairing_started",
          pairing_uri_validation_success: "pairing_uri_validation_success",
          pairing_uri_not_expired: "pairing_uri_not_expired",
          store_new_pairing: "store_new_pairing",
          subscribing_pairing_topic: "subscribing_pairing_topic",
          subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
          existing_pairing: "existing_pairing",
          pairing_not_expired: "pairing_not_expired",
          emit_inactive_pairing: "emit_inactive_pairing",
          emit_session_proposal: "emit_session_proposal",
        },
        lD = {
          no_internet_connection: "no_internet_connection",
          malformed_pairing_uri: "malformed_pairing_uri",
          active_pairing_already_exists: "active_pairing_already_exists",
          subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
          pairing_expired: "pairing_expired",
          proposal_listener_not_found: "proposal_listener_not_found",
        },
        lU = {
          session_approve_started: "session_approve_started",
          session_namespaces_validation_success:
            "session_namespaces_validation_success",
          subscribing_session_topic: "subscribing_session_topic",
          subscribe_session_topic_success: "subscribe_session_topic_success",
          publishing_session_approve: "publishing_session_approve",
          session_approve_publish_success: "session_approve_publish_success",
          store_session: "store_session",
          publishing_session_settle: "publishing_session_settle",
          session_settle_publish_success: "session_settle_publish_success",
        },
        lL = {
          no_internet_connection: "no_internet_connection",
          proposal_expired: "proposal_expired",
          subscribe_session_topic_failure: "subscribe_session_topic_failure",
          session_approve_publish_failure: "session_approve_publish_failure",
          session_settle_publish_failure: "session_settle_publish_failure",
          session_approve_namespace_validation_failure:
            "session_approve_namespace_validation_failure",
          proposal_not_found: "proposal_not_found",
        },
        lM = {
          authenticated_session_approve_started:
            "authenticated_session_approve_started",
          create_authenticated_session_topic:
            "create_authenticated_session_topic",
          cacaos_verified: "cacaos_verified",
          store_authenticated_session: "store_authenticated_session",
          subscribing_authenticated_session_topic:
            "subscribing_authenticated_session_topic",
          subscribe_authenticated_session_topic_success:
            "subscribe_authenticated_session_topic_success",
          publishing_authenticated_session_approve:
            "publishing_authenticated_session_approve",
        },
        lB = {
          no_internet_connection: "no_internet_connection",
          invalid_cacao: "invalid_cacao",
          subscribe_authenticated_session_topic_failure:
            "subscribe_authenticated_session_topic_failure",
          authenticated_session_approve_publish_failure:
            "authenticated_session_approve_publish_failure",
          authenticated_session_pending_request_not_found:
            "authenticated_session_pending_request_not_found",
        };
      var lj = function (e, t) {
        if (e.length >= 255) throw TypeError("Alphabet too long");
        for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
        for (var n = 0; n < e.length; n++) {
          var s = e.charAt(n),
            a = s.charCodeAt(0);
          if (255 !== r[a]) throw TypeError(s + " is ambiguous");
          r[a] = n;
        }
        var o = e.length,
          l = e.charAt(0),
          c = Math.log(o) / Math.log(256),
          u = Math.log(256) / Math.log(o);
        function h(e) {
          if ("string" != typeof e) throw TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          var t = 0;
          if (" " !== e[0]) {
            for (var i = 0, n = 0; e[t] === l; ) i++, t++;
            for (
              var s = ((e.length - t) * c + 1) >>> 0, a = new Uint8Array(s);
              e[t];

            ) {
              var u = r[e.charCodeAt(t)];
              if (255 === u) return;
              for (
                var h = 0, d = s - 1;
                (0 !== u || h < n) && -1 !== d;
                d--, h++
              )
                (u += (o * a[d]) >>> 0),
                  (a[d] = u % 256 >>> 0),
                  (u = (u / 256) >>> 0);
              if (0 !== u) throw Error("Non-zero carry");
              (n = h), t++;
            }
            if (" " !== e[t]) {
              for (var p = s - n; p !== s && 0 === a[p]; ) p++;
              for (var f = new Uint8Array(i + (s - p)), g = i; p !== s; )
                f[g++] = a[p++];
              return f;
            }
          }
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError("Expected Uint8Array");
            if (0 === t.length) return "";
            for (var r = 0, i = 0, n = 0, s = t.length; n !== s && 0 === t[n]; )
              n++, r++;
            for (
              var a = ((s - n) * u + 1) >>> 0, c = new Uint8Array(a);
              n !== s;

            ) {
              for (
                var h = t[n], d = 0, p = a - 1;
                (0 !== h || d < i) && -1 !== p;
                p--, d++
              )
                (h += (256 * c[p]) >>> 0),
                  (c[p] = h % o >>> 0),
                  (h = (h / o) >>> 0);
              if (0 !== h) throw Error("Non-zero carry");
              (i = d), n++;
            }
            for (var f = a - i; f !== a && 0 === c[f]; ) f++;
            for (var g = l.repeat(r); f < a; ++f) g += e.charAt(c[f]);
            return g;
          },
          decodeUnsafe: h,
          decode: function (e) {
            var r = h(e);
            if (r) return r;
            throw Error(`Non-${t} character`);
          },
        };
      };
      let lF = (e) => {
          if (e instanceof Uint8Array && "Uint8Array" === e.constructor.name)
            return e;
          if (e instanceof ArrayBuffer) return new Uint8Array(e);
          if (ArrayBuffer.isView(e))
            return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
          throw Error("Unknown type, must be binary type");
        },
        l$ = (e) => new TextEncoder().encode(e),
        lH = (e) => new TextDecoder().decode(e);
      class lz {
        constructor(e, t, r) {
          (this.name = e), (this.prefix = t), (this.baseEncode = r);
        }
        encode(e) {
          if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
          throw Error("Unknown type, must be binary type");
        }
      }
      class lq {
        constructor(e, t, r) {
          if (((this.name = e), (this.prefix = t), void 0 === t.codePointAt(0)))
            throw Error("Invalid prefix character");
          (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = r);
        }
        decode(e) {
          if ("string" == typeof e) {
            if (e.codePointAt(0) !== this.prefixCodePoint)
              throw Error(
                `Unable to decode multibase string ${JSON.stringify(e)}, ${
                  this.name
                } decoder only supports inputs prefixed with ${this.prefix}`
              );
            return this.baseDecode(e.slice(this.prefix.length));
          }
          throw Error("Can only multibase decode strings");
        }
        or(e) {
          return lG(this, e);
        }
      }
      class lV {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          return lG(this, e);
        }
        decode(e) {
          let t = e[0],
            r = this.decoders[t];
          if (r) return r.decode(e);
          throw RangeError(
            `Unable to decode multibase string ${JSON.stringify(
              e
            )}, only inputs prefixed with ${Object.keys(
              this.decoders
            )} are supported`
          );
        }
      }
      let lG = (e, t) =>
        new lV({
          ...(e.decoders || { [e.prefix]: e }),
          ...(t.decoders || { [t.prefix]: t }),
        });
      class lW {
        constructor(e, t, r, i) {
          (this.name = e),
            (this.prefix = t),
            (this.baseEncode = r),
            (this.baseDecode = i),
            (this.encoder = new lz(e, t, r)),
            (this.decoder = new lq(e, t, i));
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }
      let lK = ({ name: e, prefix: t, encode: r, decode: i }) =>
          new lW(e, t, r, i),
        lZ = ({ prefix: e, name: t, alphabet: r }) => {
          let { encode: i, decode: n } = lj(r, t);
          return lK({ prefix: e, name: t, encode: i, decode: (e) => lF(n(e)) });
        },
        lJ = (e, t, r, i) => {
          let n = {};
          for (let e = 0; e < t.length; ++e) n[t[e]] = e;
          let s = e.length;
          for (; "=" === e[s - 1]; ) --s;
          let a = new Uint8Array(((s * r) / 8) | 0),
            o = 0,
            l = 0,
            c = 0;
          for (let t = 0; t < s; ++t) {
            let s = n[e[t]];
            if (void 0 === s) throw SyntaxError(`Non-${i} character`);
            (l = (l << r) | s),
              (o += r) >= 8 && ((o -= 8), (a[c++] = 255 & (l >> o)));
          }
          if (o >= r || 255 & (l << (8 - o)))
            throw SyntaxError("Unexpected end of data");
          return a;
        },
        lQ = (e, t, r) => {
          let i = "=" === t[t.length - 1],
            n = (1 << r) - 1,
            s = "",
            a = 0,
            o = 0;
          for (let i = 0; i < e.length; ++i)
            for (o = (o << 8) | e[i], a += 8; a > r; )
              (a -= r), (s += t[n & (o >> a)]);
          if ((a && (s += t[n & (o << (r - a))]), i))
            for (; (s.length * r) & 7; ) s += "=";
          return s;
        },
        lY = ({ name: e, prefix: t, bitsPerChar: r, alphabet: i }) =>
          lK({
            prefix: t,
            name: e,
            encode: (e) => lQ(e, i, r),
            decode: (t) => lJ(t, i, r, e),
          });
      var lX = Object.freeze({
          __proto__: null,
          identity: lK({
            prefix: "\0",
            name: "identity",
            encode: (e) => lH(e),
            decode: (e) => l$(e),
          }),
        }),
        l0 = Object.freeze({
          __proto__: null,
          base2: lY({
            prefix: "0",
            name: "base2",
            alphabet: "01",
            bitsPerChar: 1,
          }),
        }),
        l1 = Object.freeze({
          __proto__: null,
          base8: lY({
            prefix: "7",
            name: "base8",
            alphabet: "01234567",
            bitsPerChar: 3,
          }),
        }),
        l2 = Object.freeze({
          __proto__: null,
          base10: lZ({ prefix: "9", name: "base10", alphabet: "0123456789" }),
        }),
        l3 = Object.freeze({
          __proto__: null,
          base16: lY({
            prefix: "f",
            name: "base16",
            alphabet: "0123456789abcdef",
            bitsPerChar: 4,
          }),
          base16upper: lY({
            prefix: "F",
            name: "base16upper",
            alphabet: "0123456789ABCDEF",
            bitsPerChar: 4,
          }),
        });
      let l5 = lY({
          prefix: "b",
          name: "base32",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567",
          bitsPerChar: 5,
        }),
        l8 = lY({
          prefix: "B",
          name: "base32upper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
          bitsPerChar: 5,
        }),
        l4 = lY({
          prefix: "c",
          name: "base32pad",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
          bitsPerChar: 5,
        }),
        l6 = lY({
          prefix: "C",
          name: "base32padupper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
          bitsPerChar: 5,
        }),
        l9 = lY({
          prefix: "v",
          name: "base32hex",
          alphabet: "0123456789abcdefghijklmnopqrstuv",
          bitsPerChar: 5,
        }),
        l7 = lY({
          prefix: "V",
          name: "base32hexupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
          bitsPerChar: 5,
        });
      var ce = Object.freeze({
          __proto__: null,
          base32: l5,
          base32upper: l8,
          base32pad: l4,
          base32padupper: l6,
          base32hex: l9,
          base32hexupper: l7,
          base32hexpad: lY({
            prefix: "t",
            name: "base32hexpad",
            alphabet: "0123456789abcdefghijklmnopqrstuv=",
            bitsPerChar: 5,
          }),
          base32hexpadupper: lY({
            prefix: "T",
            name: "base32hexpadupper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
            bitsPerChar: 5,
          }),
          base32z: lY({
            prefix: "h",
            name: "base32z",
            alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
            bitsPerChar: 5,
          }),
        }),
        ct = Object.freeze({
          __proto__: null,
          base36: lZ({
            prefix: "k",
            name: "base36",
            alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
          }),
          base36upper: lZ({
            prefix: "K",
            name: "base36upper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          }),
        }),
        cr = Object.freeze({
          __proto__: null,
          base58btc: lZ({
            name: "base58btc",
            prefix: "z",
            alphabet:
              "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
          }),
          base58flickr: lZ({
            name: "base58flickr",
            prefix: "Z",
            alphabet:
              "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
          }),
        });
      let ci = lY({
        prefix: "m",
        name: "base64",
        alphabet:
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6,
      });
      var cn = Object.freeze({
        __proto__: null,
        base64: ci,
        base64pad: lY({
          prefix: "M",
          name: "base64pad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          bitsPerChar: 6,
        }),
        base64url: lY({
          prefix: "u",
          name: "base64url",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          bitsPerChar: 6,
        }),
        base64urlpad: lY({
          prefix: "U",
          name: "base64urlpad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
          bitsPerChar: 6,
        }),
      });
      let cs = Array.from(
          "\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"
        ),
        ca = cs.reduce((e, t, r) => ((e[r] = t), e), []),
        co = cs.reduce((e, t, r) => ((e[t.codePointAt(0)] = r), e), []);
      var cl = Object.freeze({
        __proto__: null,
        base256emoji: lK({
          prefix: "\uD83D\uDE80",
          name: "base256emoji",
          encode: function (e) {
            return e.reduce((e, t) => (e += ca[t]), "");
          },
          decode: function (e) {
            let t = [];
            for (let r of e) {
              let e = co[r.codePointAt(0)];
              if (void 0 === e) throw Error(`Non-base256emoji character: ${r}`);
              t.push(e);
            }
            return new Uint8Array(t);
          },
        }),
      });
      function cc(e, t) {
        var r,
          i = 0,
          t = t || 0,
          n = 0,
          s = t,
          a = e.length;
        do {
          if (s >= a)
            throw ((cc.bytes = 0), RangeError("Could not decode varint"));
          (r = e[s++]),
            (i += n < 28 ? (127 & r) << n : (127 & r) * Math.pow(2, n)),
            (n += 7);
        } while (r >= 128);
        return (cc.bytes = s - t), i;
      }
      var cu = function e(t, r, i) {
        (r = r || []), (i = i || 0);
        for (var n = i; t >= 2147483648; )
          (r[i++] = (255 & t) | 128), (t /= 128);
        for (; -128 & t; ) (r[i++] = (255 & t) | 128), (t >>>= 7);
        return (r[i] = 0 | t), (e.bytes = i - n + 1), r;
      };
      let ch = (e, t, r = 0) => (cu(e, t, r), t),
        cd = (e) =>
          e < 128
            ? 1
            : e < 16384
            ? 2
            : e < 2097152
            ? 3
            : e < 268435456
            ? 4
            : e < 34359738368
            ? 5
            : e < 4398046511104
            ? 6
            : e < 562949953421312
            ? 7
            : e < 72057594037927940
            ? 8
            : e < 0x7fffffffffffffff
            ? 9
            : 10,
        cp = (e, t) => {
          let r = t.byteLength,
            i = cd(e),
            n = i + cd(r),
            s = new Uint8Array(n + r);
          return ch(e, s, 0), ch(r, s, i), s.set(t, n), new cf(e, r, t, s);
        };
      class cf {
        constructor(e, t, r, i) {
          (this.code = e), (this.size = t), (this.digest = r), (this.bytes = i);
        }
      }
      let cg = ({ name: e, code: t, encode: r }) => new cm(e, t, r);
      class cm {
        constructor(e, t, r) {
          (this.name = e), (this.code = t), (this.encode = r);
        }
        digest(e) {
          if (e instanceof Uint8Array) {
            let t = this.encode(e);
            return t instanceof Uint8Array
              ? cp(this.code, t)
              : t.then((e) => cp(this.code, e));
          }
          throw Error("Unknown type, must be binary type");
        }
      }
      let cy = (e) => async (t) =>
        new Uint8Array(await crypto.subtle.digest(e, t));
      var cw = Object.freeze({
          __proto__: null,
          sha256: cg({ name: "sha2-256", code: 18, encode: cy("SHA-256") }),
          sha512: cg({ name: "sha2-512", code: 19, encode: cy("SHA-512") }),
        }),
        cb = Object.freeze({
          __proto__: null,
          identity: {
            code: 0,
            name: "identity",
            encode: lF,
            digest: (e) => cp(0, lF(e)),
          },
        });
      new TextEncoder(), new TextDecoder();
      let cv = {
        ...lX,
        ...l0,
        ...l1,
        ...l2,
        ...l3,
        ...ce,
        ...ct,
        ...cr,
        ...cn,
        ...cl,
      };
      function cE(e, t, r, i) {
        return {
          name: e,
          prefix: t,
          encoder: { name: e, prefix: t, encode: r },
          decoder: { decode: i },
        };
      }
      ({ ...cw, ...cb });
      let cA = cE(
          "utf8",
          "u",
          (e) => "u" + new TextDecoder("utf8").decode(e),
          (e) => new TextEncoder().encode(e.substring(1))
        ),
        cC = cE(
          "ascii",
          "a",
          (e) => {
            let t = "a";
            for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
            return t;
          },
          (e) => {
            let t = (function (e = 0) {
              return null != globalThis.Buffer &&
                null != globalThis.Buffer.allocUnsafe
                ? globalThis.Buffer.allocUnsafe(e)
                : new Uint8Array(e);
            })((e = e.substring(1)).length);
            for (let r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);
            return t;
          }
        ),
        c_ = {
          utf8: cA,
          "utf-8": cA,
          hex: cv.base16,
          latin1: cC,
          ascii: cC,
          binary: cC,
          ...cv,
        };
      var cI = Object.defineProperty,
        cN = (e, t, r) =>
          t in e
            ? cI(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        cS = (e, t, r) => cN(e, "symbol" != typeof t ? t + "" : t, r);
      class cT {
        constructor(e, t) {
          (this.core = e),
            (this.logger = t),
            cS(this, "keychain", new Map()),
            cS(this, "name", "keychain"),
            cS(this, "version", "0.3"),
            cS(this, "initialized", !1),
            cS(this, "storagePrefix", ld),
            cS(this, "init", async () => {
              if (!this.initialized) {
                let e = await this.getKeyChain();
                "u" > typeof e && (this.keychain = e), (this.initialized = !0);
              }
            }),
            cS(
              this,
              "has",
              (e) => (this.isInitialized(), this.keychain.has(e))
            ),
            cS(this, "set", async (e, t) => {
              this.isInitialized(),
                this.keychain.set(e, t),
                await this.persist();
            }),
            cS(this, "get", (e) => {
              this.isInitialized();
              let t = this.keychain.get(e);
              if (typeof t > "u") {
                let { message: t } = oN(
                  "NO_MATCHING_KEY",
                  `${this.name}: ${e}`
                );
                throw Error(t);
              }
              return t;
            }),
            cS(this, "del", async (e) => {
              this.isInitialized(),
                this.keychain.delete(e),
                await this.persist();
            }),
            (this.core = e),
            (this.logger = (0, ee.Ep)(t, this.name));
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        async setKeyChain(e) {
          await this.core.storage.setItem(this.storageKey, nX(e));
        }
        async getKeyChain() {
          let e = await this.core.storage.getItem(this.storageKey);
          return "u" > typeof e ? n0(e) : void 0;
        }
        async persist() {
          await this.setKeyChain(this.keychain);
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = oN("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var cP = Object.defineProperty,
        cO = (e, t, r) =>
          t in e
            ? cP(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        cx = (e, t, r) => cO(e, "symbol" != typeof t ? t + "" : t, r);
      class ck {
        constructor(e, t, r) {
          (this.core = e),
            (this.logger = t),
            cx(this, "name", "crypto"),
            cx(this, "keychain"),
            cx(this, "randomSessionIdentifier", oo()),
            cx(this, "initialized", !1),
            cx(this, "init", async () => {
              this.initialized ||
                (await this.keychain.init(), (this.initialized = !0));
            }),
            cx(
              this,
              "hasKeys",
              (e) => (this.isInitialized(), this.keychain.has(e))
            ),
            cx(
              this,
              "getClientId",
              async () => (
                this.isInitialized(),
                rx(rR(await this.getClientSeed()).publicKey)
              )
            ),
            cx(this, "generateKeyPair", () => {
              this.isInitialized();
              let e = (function () {
                let e = ot.utils.randomPrivateKey(),
                  t = ot.getPublicKey(e);
                return { privateKey: nM(e, oi), publicKey: nM(t, oi) };
              })();
              return this.setPrivateKey(e.publicKey, e.privateKey);
            }),
            cx(this, "signJWT", async (e) => {
              this.isInitialized();
              let t = rR(await this.getClientSeed()),
                r = this.randomSessionIdentifier;
              return await rD(r, e, lm, t);
            }),
            cx(this, "generateSharedKey", (e, t, r) => {
              var i;
              this.isInitialized();
              let n =
                ((i = this.getPrivateKey(e)),
                nM(
                  aU(
                    a$,
                    ot.getSharedSecret(nL(i, oi), nL(t, oi)),
                    void 0,
                    void 0,
                    32
                  ),
                  oi
                ));
              return this.setSymKey(n, r);
            }),
            cx(this, "setSymKey", async (e, t) => {
              this.isInitialized();
              let r = t || ol(e);
              return await this.keychain.set(r, e), r;
            }),
            cx(this, "deleteKeyPair", async (e) => {
              this.isInitialized(), await this.keychain.del(e);
            }),
            cx(this, "deleteSymKey", async (e) => {
              this.isInitialized(), await this.keychain.del(e);
            }),
            cx(this, "encode", async (e, t, r) => {
              this.isInitialized();
              let i = op(r),
                n = (0, q.u)(t);
              if (2 === i.type)
                return (function (e, t) {
                  let r = nL("2", or),
                    i = s_(12);
                  return oh({ type: r, sealed: nL(e, oa), iv: i, encoding: t });
                })(n, r?.encoding);
              if (of(i)) {
                let t = i.senderPublicKey,
                  r = i.receiverPublicKey;
                e = await this.generateSharedKey(t, r);
              }
              let s = this.getSymKey(e),
                { type: a, senderPublicKey: o } = i;
              return (function (e) {
                var t;
                let r =
                  ((t = "u" > typeof e.type ? e.type : 0), nL(`${t}`, or));
                if (1 === ou(r) && typeof e.senderPublicKey > "u")
                  throw Error("Missing sender public key for type 1 envelope");
                let i =
                    "u" > typeof e.senderPublicKey
                      ? nL(e.senderPublicKey, oi)
                      : void 0,
                  n = "u" > typeof e.iv ? nL(e.iv, oi) : s_(12);
                return oh({
                  type: r,
                  sealed: aO(nL(e.symKey, oi), n).encrypt(nL(e.message, oa)),
                  iv: n,
                  senderPublicKey: i,
                  encoding: e.encoding,
                });
              })({
                type: a,
                symKey: s,
                message: n,
                senderPublicKey: o,
                encoding: r?.encoding,
              });
            }),
            cx(this, "decode", async (e, t, r) => {
              this.isInitialized();
              let i = (function (e, t) {
                let r = od({ encoded: e, encoding: t?.encoding });
                return op({
                  type: ou(r.type),
                  senderPublicKey:
                    "u" > typeof r.senderPublicKey
                      ? nM(r.senderPublicKey, oi)
                      : void 0,
                  receiverPublicKey: t?.receiverPublicKey,
                });
              })(t, r);
              if (2 === i.type) {
                let e = (function (e, t) {
                  let { sealed: r } = od({ encoded: e, encoding: t });
                  return nM(r, oa);
                })(t, r?.encoding);
                return (0, q.D)(e);
              }
              if (of(i)) {
                let t = i.receiverPublicKey,
                  r = i.senderPublicKey;
                e = await this.generateSharedKey(t, r);
              }
              try {
                let i = this.getSymKey(e),
                  n = (function (e) {
                    let t = nL(e.symKey, oi),
                      { sealed: r, iv: i } = od(e),
                      n = aO(t, i).decrypt(r);
                    if (null === n) throw Error("Failed to decrypt");
                    return nM(n, oa);
                  })({ symKey: i, encoded: t, encoding: r?.encoding });
                return (0, q.D)(n);
              } catch (t) {
                this.logger.error(
                  `Failed to decode message from topic: '${e}', clientId: '${await this.getClientId()}'`
                ),
                  this.logger.error(t);
              }
            }),
            cx(this, "getPayloadType", (e, t = on) =>
              ou(od({ encoded: e, encoding: t }).type)
            ),
            cx(this, "getPayloadSenderPublicKey", (e, t = on) => {
              let r = od({ encoded: e, encoding: t });
              return r.senderPublicKey ? nM(r.senderPublicKey, oi) : void 0;
            }),
            (this.core = e),
            (this.logger = (0, ee.Ep)(t, this.name)),
            (this.keychain = r || new cT(this.core, this.logger));
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        async setPrivateKey(e, t) {
          return await this.keychain.set(e, t), e;
        }
        getPrivateKey(e) {
          return this.keychain.get(e);
        }
        async getClientSeed() {
          let e = "";
          try {
            e = this.keychain.get(lg);
          } catch {
            (e = oo()), await this.keychain.set(lg, e);
          }
          return (function (e, t = "utf8") {
            let r = c_[t];
            if (!r) throw Error(`Unsupported encoding "${t}"`);
            return ("utf8" === t || "utf-8" === t) &&
              null != globalThis.Buffer &&
              null != globalThis.Buffer.from
              ? globalThis.Buffer.from(e, "utf8")
              : r.decoder.decode(`${r.prefix}${e}`);
          })(e, "base16");
        }
        getSymKey(e) {
          return this.keychain.get(e);
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = oN("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var cR = Object.defineProperty,
        cD = Object.defineProperties,
        cU = Object.getOwnPropertyDescriptors,
        cL = Object.getOwnPropertySymbols,
        cM = Object.prototype.hasOwnProperty,
        cB = Object.prototype.propertyIsEnumerable,
        cj = (e, t, r) =>
          t in e
            ? cR(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        cF = (e, t) => {
          for (var r in t || (t = {})) cM.call(t, r) && cj(e, r, t[r]);
          if (cL) for (var r of cL(t)) cB.call(t, r) && cj(e, r, t[r]);
          return e;
        },
        c$ = (e, t) => cD(e, cU(t)),
        cH = (e, t, r) => cj(e, "symbol" != typeof t ? t + "" : t, r);
      class cz extends ec {
        constructor(e, t) {
          super(e, t),
            (this.logger = e),
            (this.core = t),
            cH(this, "messages", new Map()),
            cH(this, "messagesWithoutClientAck", new Map()),
            cH(this, "name", "messages"),
            cH(this, "version", "0.3"),
            cH(this, "initialized", !1),
            cH(this, "storagePrefix", ld),
            cH(this, "init", async () => {
              if (!this.initialized) {
                this.logger.trace("Initialized");
                try {
                  let e = await this.getRelayerMessages();
                  "u" > typeof e && (this.messages = e);
                  let t = await this.getRelayerMessagesWithoutClientAck();
                  "u" > typeof t && (this.messagesWithoutClientAck = t),
                    this.logger.debug(
                      `Successfully Restored records for ${this.name}`
                    ),
                    this.logger.trace({
                      type: "method",
                      method: "restore",
                      size: this.messages.size,
                    });
                } catch (e) {
                  this.logger.debug(
                    `Failed to Restore records for ${this.name}`
                  ),
                    this.logger.error(e);
                } finally {
                  this.initialized = !0;
                }
              }
            }),
            cH(this, "set", async (e, t, r) => {
              this.isInitialized();
              let i = oc(t),
                n = this.messages.get(e);
              if ((typeof n > "u" && (n = {}), "u" > typeof n[i])) return i;
              if (((n[i] = t), this.messages.set(e, n), r === lC.inbound)) {
                let r = this.messagesWithoutClientAck.get(e) || {};
                this.messagesWithoutClientAck.set(e, c$(cF({}, r), { [i]: t }));
              }
              return await this.persist(), i;
            }),
            cH(this, "get", (e) => {
              this.isInitialized();
              let t = this.messages.get(e);
              return typeof t > "u" && (t = {}), t;
            }),
            cH(this, "getWithoutAck", (e) => {
              this.isInitialized();
              let t = {};
              for (let r of e) {
                let e = this.messagesWithoutClientAck.get(r) || {};
                t[r] = Object.values(e);
              }
              return t;
            }),
            cH(
              this,
              "has",
              (e, t) => (this.isInitialized(), "u" > typeof this.get(e)[oc(t)])
            ),
            cH(this, "ack", async (e, t) => {
              this.isInitialized();
              let r = this.messagesWithoutClientAck.get(e);
              if (typeof r > "u") return;
              let i = oc(t);
              delete r[i],
                0 === Object.keys(r).length
                  ? this.messagesWithoutClientAck.delete(e)
                  : this.messagesWithoutClientAck.set(e, r),
                await this.persist();
            }),
            cH(this, "del", async (e) => {
              this.isInitialized(),
                this.messages.delete(e),
                this.messagesWithoutClientAck.delete(e),
                await this.persist();
            }),
            (this.logger = (0, ee.Ep)(e, this.name)),
            (this.core = t);
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get storageKeyWithoutClientAck() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name +
            "_withoutClientAck"
          );
        }
        async setRelayerMessages(e) {
          await this.core.storage.setItem(this.storageKey, nX(e));
        }
        async setRelayerMessagesWithoutClientAck(e) {
          await this.core.storage.setItem(
            this.storageKeyWithoutClientAck,
            nX(e)
          );
        }
        async getRelayerMessages() {
          let e = await this.core.storage.getItem(this.storageKey);
          return "u" > typeof e ? n0(e) : void 0;
        }
        async getRelayerMessagesWithoutClientAck() {
          let e = await this.core.storage.getItem(
            this.storageKeyWithoutClientAck
          );
          return "u" > typeof e ? n0(e) : void 0;
        }
        async persist() {
          await this.setRelayerMessages(this.messages),
            await this.setRelayerMessagesWithoutClientAck(
              this.messagesWithoutClientAck
            );
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = oN("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var cq = Object.defineProperty,
        cV = Object.defineProperties,
        cG = Object.getOwnPropertyDescriptors,
        cW = Object.getOwnPropertySymbols,
        cK = Object.prototype.hasOwnProperty,
        cZ = Object.prototype.propertyIsEnumerable,
        cJ = (e, t, r) =>
          t in e
            ? cq(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        cQ = (e, t) => {
          for (var r in t || (t = {})) cK.call(t, r) && cJ(e, r, t[r]);
          if (cW) for (var r of cW(t)) cZ.call(t, r) && cJ(e, r, t[r]);
          return e;
        },
        cY = (e, t) => cV(e, cG(t)),
        cX = (e, t, r) => cJ(e, "symbol" != typeof t ? t + "" : t, r);
      class c0 extends eu {
        constructor(e, t) {
          super(e, t),
            (this.relayer = e),
            (this.logger = t),
            cX(this, "events", new w.EventEmitter()),
            cX(this, "name", "publisher"),
            cX(this, "queue", new Map()),
            cX(this, "publishTimeout", (0, v.toMiliseconds)(v.ONE_MINUTE)),
            cX(
              this,
              "initialPublishTimeout",
              (0, v.toMiliseconds)(15 * v.ONE_SECOND)
            ),
            cX(this, "needsTransportRestart", !1),
            cX(this, "publish", async (e, t, r) => {
              var i;
              this.logger.debug("Publishing Payload"),
                this.logger.trace({
                  type: "method",
                  method: "publish",
                  params: { topic: e, message: t, opts: r },
                });
              let n = r?.ttl || ly,
                s = og(r),
                a = r?.prompt || !1,
                o = r?.tag || 0,
                l = r?.id || o0().toString(),
                c = {
                  topic: e,
                  message: t,
                  opts: {
                    ttl: n,
                    relay: s,
                    prompt: a,
                    tag: o,
                    id: l,
                    attestation: r?.attestation,
                    tvf: r?.tvf,
                  },
                },
                u = `Failed to publish payload, please try again. id:${l} tag:${o}`;
              try {
                let i = new Promise(async (i) => {
                  let s = ({ id: e }) => {
                    c.opts.id === e &&
                      (this.removeRequestFromQueue(e),
                      this.relayer.events.removeListener(lb.publish, s),
                      i(c));
                  };
                  this.relayer.events.on(lb.publish, s);
                  let u = n2(
                    new Promise((i, s) => {
                      this.rpcPublish({
                        topic: e,
                        message: t,
                        ttl: n,
                        prompt: a,
                        tag: o,
                        id: l,
                        attestation: r?.attestation,
                        tvf: r?.tvf,
                      })
                        .then(i)
                        .catch((e) => {
                          this.logger.warn(e, e?.message), s(e);
                        });
                    }),
                    this.initialPublishTimeout,
                    `Failed initial publish, retrying.... id:${l} tag:${o}`
                  );
                  try {
                    await u, this.events.removeListener(lb.publish, s);
                  } catch (e) {
                    this.queue.set(l, cY(cQ({}, c), { attempt: 1 })),
                      this.logger.warn(e, e?.message);
                  }
                });
                this.logger.trace({
                  type: "method",
                  method: "publish",
                  params: { id: l, topic: e, message: t, opts: r },
                }),
                  await n2(i, this.publishTimeout, u);
              } catch (e) {
                if (
                  (this.logger.debug("Failed to Publish Payload"),
                  this.logger.error(e),
                  null != (i = r?.internal) && i.throwOnFailedPublish)
                )
                  throw e;
              } finally {
                this.queue.delete(l);
              }
            }),
            cX(this, "on", (e, t) => {
              this.events.on(e, t);
            }),
            cX(this, "once", (e, t) => {
              this.events.once(e, t);
            }),
            cX(this, "off", (e, t) => {
              this.events.off(e, t);
            }),
            cX(this, "removeListener", (e, t) => {
              this.events.removeListener(e, t);
            }),
            (this.relayer = e),
            (this.logger = (0, ee.Ep)(t, this.name)),
            this.registerEventListeners();
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        async rpcPublish(e) {
          var t, r, i, n;
          let {
              topic: s,
              message: a,
              ttl: o = ly,
              prompt: l,
              tag: c,
              id: u,
              attestation: h,
              tvf: d,
            } = e,
            p = {
              method: om(og().protocol).publish,
              params: cQ(
                {
                  topic: s,
                  message: a,
                  ttl: o,
                  prompt: l,
                  tag: c,
                  attestation: h,
                },
                d
              ),
              id: u,
            };
          oO(null == (t = p.params) ? void 0 : t.prompt) &&
            (null == (r = p.params) || delete r.prompt),
            oO(null == (i = p.params) ? void 0 : i.tag) &&
              (null == (n = p.params) || delete n.tag),
            this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "message",
              direction: "outgoing",
              request: p,
            });
          let f = await this.relayer.request(p);
          return (
            this.relayer.events.emit(lb.publish, e),
            this.logger.debug("Successfully Published Payload"),
            f
          );
        }
        removeRequestFromQueue(e) {
          this.queue.delete(e);
        }
        checkQueue() {
          this.queue.forEach(async (e, t) => {
            let r = e.attempt + 1;
            this.queue.set(t, cY(cQ({}, e), { attempt: r }));
            let { topic: i, message: n, opts: s, attestation: a } = e;
            this.logger.warn(
              {},
              `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${r}`
            ),
              await this.rpcPublish(
                cY(cQ({}, e), {
                  topic: i,
                  message: n,
                  ttl: s.ttl,
                  prompt: s.prompt,
                  tag: s.tag,
                  id: s.id,
                  attestation: a,
                  tvf: s.tvf,
                })
              ),
              this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
          });
        }
        registerEventListeners() {
          this.relayer.core.heartbeat.on(_, () => {
            if (this.needsTransportRestart) {
              (this.needsTransportRestart = !1),
                this.relayer.events.emit(lb.connection_stalled);
              return;
            }
            this.checkQueue();
          }),
            this.relayer.on(lb.message_ack, (e) => {
              this.removeRequestFromQueue(e.id.toString());
            });
        }
      }
      var c1 = Object.defineProperty,
        c2 = (e, t, r) =>
          t in e
            ? c1(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        c3 = (e, t, r) => c2(e, "symbol" != typeof t ? t + "" : t, r);
      class c5 {
        constructor() {
          c3(this, "map", new Map()),
            c3(this, "set", (e, t) => {
              let r = this.get(e);
              this.exists(e, t) || this.map.set(e, [...r, t]);
            }),
            c3(this, "get", (e) => this.map.get(e) || []),
            c3(this, "exists", (e, t) => this.get(e).includes(t)),
            c3(this, "delete", (e, t) => {
              if (typeof t > "u") {
                this.map.delete(e);
                return;
              }
              if (!this.map.has(e)) return;
              let r = this.get(e);
              if (!this.exists(e, t)) return;
              let i = r.filter((e) => e !== t);
              if (!i.length) {
                this.map.delete(e);
                return;
              }
              this.map.set(e, i);
            }),
            c3(this, "clear", () => {
              this.map.clear();
            });
        }
        get topics() {
          return Array.from(this.map.keys());
        }
      }
      var c8 = Object.defineProperty,
        c4 = Object.defineProperties,
        c6 = Object.getOwnPropertyDescriptors,
        c9 = Object.getOwnPropertySymbols,
        c7 = Object.prototype.hasOwnProperty,
        ue = Object.prototype.propertyIsEnumerable,
        ut = (e, t, r) =>
          t in e
            ? c8(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        ur = (e, t) => {
          for (var r in t || (t = {})) c7.call(t, r) && ut(e, r, t[r]);
          if (c9) for (var r of c9(t)) ue.call(t, r) && ut(e, r, t[r]);
          return e;
        },
        ui = (e, t) => c4(e, c6(t)),
        un = (e, t, r) => ut(e, "symbol" != typeof t ? t + "" : t, r);
      class us extends ep {
        constructor(e, t) {
          super(e, t),
            (this.relayer = e),
            (this.logger = t),
            un(this, "subscriptions", new Map()),
            un(this, "topicMap", new c5()),
            un(this, "events", new w.EventEmitter()),
            un(this, "name", "subscription"),
            un(this, "version", "0.3"),
            un(this, "pending", new Map()),
            un(this, "cached", []),
            un(this, "initialized", !1),
            un(this, "storagePrefix", ld),
            un(this, "subscribeTimeout", (0, v.toMiliseconds)(v.ONE_MINUTE)),
            un(
              this,
              "initialSubscribeTimeout",
              (0, v.toMiliseconds)(15 * v.ONE_SECOND)
            ),
            un(this, "clientId"),
            un(this, "batchSubscribeTopicsLimit", 500),
            un(this, "init", async () => {
              this.initialized ||
                (this.logger.trace("Initialized"),
                this.registerEventListeners(),
                await this.restore()),
                (this.initialized = !0);
            }),
            un(this, "subscribe", async (e, t) => {
              this.isInitialized(),
                this.logger.debug("Subscribing Topic"),
                this.logger.trace({
                  type: "method",
                  method: "subscribe",
                  params: { topic: e, opts: t },
                });
              try {
                let r = og(t),
                  i = { topic: e, relay: r, transportType: t?.transportType };
                this.pending.set(e, i);
                let n = await this.rpcSubscribe(e, r, t);
                return (
                  "string" == typeof n &&
                    (this.onSubscribe(n, i),
                    this.logger.debug("Successfully Subscribed Topic"),
                    this.logger.trace({
                      type: "method",
                      method: "subscribe",
                      params: { topic: e, opts: t },
                    })),
                  n
                );
              } catch (e) {
                throw (
                  (this.logger.debug("Failed to Subscribe Topic"),
                  this.logger.error(e),
                  e)
                );
              }
            }),
            un(this, "unsubscribe", async (e, t) => {
              this.isInitialized(),
                "u" > typeof t?.id
                  ? await this.unsubscribeById(e, t.id, t)
                  : await this.unsubscribeByTopic(e, t);
            }),
            un(
              this,
              "isSubscribed",
              (e) =>
                new Promise((t) => {
                  t(this.topicMap.topics.includes(e));
                })
            ),
            un(
              this,
              "isKnownTopic",
              (e) =>
                new Promise((t) => {
                  t(
                    this.topicMap.topics.includes(e) ||
                      this.pending.has(e) ||
                      this.cached.some((t) => t.topic === e)
                  );
                })
            ),
            un(this, "on", (e, t) => {
              this.events.on(e, t);
            }),
            un(this, "once", (e, t) => {
              this.events.once(e, t);
            }),
            un(this, "off", (e, t) => {
              this.events.off(e, t);
            }),
            un(this, "removeListener", (e, t) => {
              this.events.removeListener(e, t);
            }),
            un(this, "start", async () => {
              await this.onConnect();
            }),
            un(this, "stop", async () => {
              await this.onDisconnect();
            }),
            un(this, "restart", async () => {
              await this.restore(), await this.onRestart();
            }),
            un(this, "checkPending", async () => {
              if (
                0 === this.pending.size &&
                (!this.initialized || !this.relayer.connected)
              )
                return;
              let e = [];
              this.pending.forEach((t) => {
                e.push(t);
              }),
                await this.batchSubscribe(e);
            }),
            un(this, "registerEventListeners", () => {
              this.relayer.core.heartbeat.on(_, async () => {
                await this.checkPending();
              }),
                this.events.on(lI.created, async (e) => {
                  let t = lI.created;
                  this.logger.info(`Emitting ${t}`),
                    this.logger.debug({ type: "event", event: t, data: e }),
                    await this.persist();
                }),
                this.events.on(lI.deleted, async (e) => {
                  let t = lI.deleted;
                  this.logger.info(`Emitting ${t}`),
                    this.logger.debug({ type: "event", event: t, data: e }),
                    await this.persist();
                });
            }),
            (this.relayer = e),
            (this.logger = (0, ee.Ep)(t, this.name)),
            (this.clientId = "");
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.relayer.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get length() {
          return this.subscriptions.size;
        }
        get ids() {
          return Array.from(this.subscriptions.keys());
        }
        get values() {
          return Array.from(this.subscriptions.values());
        }
        get topics() {
          return this.topicMap.topics;
        }
        get hasAnyTopics() {
          return (
            this.topicMap.topics.length > 0 ||
            this.pending.size > 0 ||
            this.cached.length > 0 ||
            this.subscriptions.size > 0
          );
        }
        hasSubscription(e, t) {
          let r = !1;
          try {
            r = this.getSubscription(e).topic === t;
          } catch {}
          return r;
        }
        reset() {
          (this.cached = []), (this.initialized = !0);
        }
        onDisable() {
          (this.cached = this.values),
            this.subscriptions.clear(),
            this.topicMap.clear();
        }
        async unsubscribeByTopic(e, t) {
          let r = this.topicMap.get(e);
          await Promise.all(
            r.map(async (r) => await this.unsubscribeById(e, r, t))
          );
        }
        async unsubscribeById(e, t, r) {
          this.logger.debug("Unsubscribing Topic"),
            this.logger.trace({
              type: "method",
              method: "unsubscribe",
              params: { topic: e, id: t, opts: r },
            });
          try {
            let i = og(r);
            await this.restartToComplete({ topic: e, id: t, relay: i }),
              await this.rpcUnsubscribe(e, t, i);
            let n = oS("USER_DISCONNECTED", `${this.name}, ${e}`);
            await this.onUnsubscribe(e, t, n),
              this.logger.debug("Successfully Unsubscribed Topic"),
              this.logger.trace({
                type: "method",
                method: "unsubscribe",
                params: { topic: e, id: t, opts: r },
              });
          } catch (e) {
            throw (
              (this.logger.debug("Failed to Unsubscribe Topic"),
              this.logger.error(e),
              e)
            );
          }
        }
        async rpcSubscribe(e, t, r) {
          var i;
          (r && r?.transportType !== lA.relay) ||
            (await this.restartToComplete({ topic: e, id: e, relay: t }));
          let n = { method: om(t.protocol).subscribe, params: { topic: e } };
          this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "outgoing",
              request: n,
            });
          let s = null == (i = r?.internal) ? void 0 : i.throwOnFailedPublish;
          try {
            let t = await this.getSubscriptionId(e);
            if (r?.transportType === lA.link_mode)
              return (
                setTimeout(() => {
                  (this.relayer.connected || this.relayer.connecting) &&
                    this.relayer.request(n).catch((e) => this.logger.warn(e));
                }, (0, v.toMiliseconds)(v.ONE_SECOND)),
                t
              );
            let i = new Promise(async (t) => {
                let r = (i) => {
                  i.topic === e &&
                    (this.events.removeListener(lI.created, r), t(i.id));
                };
                this.events.on(lI.created, r);
                try {
                  let i = await n2(
                    new Promise((e, t) => {
                      this.relayer
                        .request(n)
                        .catch((e) => {
                          this.logger.warn(e, e?.message), t(e);
                        })
                        .then(e);
                    }),
                    this.initialSubscribeTimeout,
                    `Subscribing to ${e} failed, please try again`
                  );
                  this.events.removeListener(lI.created, r), t(i);
                } catch {}
              }),
              a = await n2(
                i,
                this.subscribeTimeout,
                `Subscribing to ${e} failed, please try again`
              );
            if (!a && s)
              throw Error(`Subscribing to ${e} failed, please try again`);
            return a ? t : null;
          } catch (e) {
            if (
              (this.logger.debug("Outgoing Relay Subscribe Payload stalled"),
              this.relayer.events.emit(lb.connection_stalled),
              s)
            )
              throw e;
          }
          return null;
        }
        async rpcBatchSubscribe(e) {
          if (!e.length) return;
          let t = {
            method: om(e[0].relay.protocol).batchSubscribe,
            params: { topics: e.map((e) => e.topic) },
          };
          this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "outgoing",
              request: t,
            });
          try {
            await await n2(
              new Promise((e) => {
                this.relayer
                  .request(t)
                  .catch((e) => this.logger.warn(e))
                  .then(e);
              }),
              this.subscribeTimeout,
              "rpcBatchSubscribe failed, please try again"
            );
          } catch {
            this.relayer.events.emit(lb.connection_stalled);
          }
        }
        async rpcBatchFetchMessages(e) {
          let t;
          if (!e.length) return;
          let r = {
            method: om(e[0].relay.protocol).batchFetchMessages,
            params: { topics: e.map((e) => e.topic) },
          };
          this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "outgoing",
              request: r,
            });
          try {
            t = await await n2(
              new Promise((e, t) => {
                this.relayer
                  .request(r)
                  .catch((e) => {
                    this.logger.warn(e), t(e);
                  })
                  .then(e);
              }),
              this.subscribeTimeout,
              "rpcBatchFetchMessages failed, please try again"
            );
          } catch {
            this.relayer.events.emit(lb.connection_stalled);
          }
          return t;
        }
        rpcUnsubscribe(e, t, r) {
          let i = {
            method: om(r.protocol).unsubscribe,
            params: { topic: e, id: t },
          };
          return (
            this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "outgoing",
              request: i,
            }),
            this.relayer.request(i)
          );
        }
        onSubscribe(e, t) {
          this.setSubscription(e, ui(ur({}, t), { id: e })),
            this.pending.delete(t.topic);
        }
        onBatchSubscribe(e) {
          e.length &&
            e.forEach((e) => {
              this.setSubscription(e.id, ur({}, e)),
                this.pending.delete(e.topic);
            });
        }
        async onUnsubscribe(e, t, r) {
          this.events.removeAllListeners(t),
            this.hasSubscription(t, e) && this.deleteSubscription(t, r),
            await this.relayer.messages.del(e);
        }
        async setRelayerSubscriptions(e) {
          await this.relayer.core.storage.setItem(this.storageKey, e);
        }
        async getRelayerSubscriptions() {
          return await this.relayer.core.storage.getItem(this.storageKey);
        }
        setSubscription(e, t) {
          this.logger.debug("Setting subscription"),
            this.logger.trace({
              type: "method",
              method: "setSubscription",
              id: e,
              subscription: t,
            }),
            this.addSubscription(e, t);
        }
        addSubscription(e, t) {
          this.subscriptions.set(e, ur({}, t)),
            this.topicMap.set(t.topic, e),
            this.events.emit(lI.created, t);
        }
        getSubscription(e) {
          this.logger.debug("Getting subscription"),
            this.logger.trace({
              type: "method",
              method: "getSubscription",
              id: e,
            });
          let t = this.subscriptions.get(e);
          if (!t) {
            let { message: t } = oN("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw Error(t);
          }
          return t;
        }
        deleteSubscription(e, t) {
          this.logger.debug("Deleting subscription"),
            this.logger.trace({
              type: "method",
              method: "deleteSubscription",
              id: e,
              reason: t,
            });
          let r = this.getSubscription(e);
          this.subscriptions.delete(e),
            this.topicMap.delete(r.topic, e),
            this.events.emit(lI.deleted, ui(ur({}, r), { reason: t }));
        }
        async persist() {
          await this.setRelayerSubscriptions(this.values),
            this.events.emit(lI.sync);
        }
        async onRestart() {
          if (this.cached.length) {
            let e = [...this.cached],
              t = Math.ceil(
                this.cached.length / this.batchSubscribeTopicsLimit
              );
            for (let r = 0; r < t; r++) {
              let t = e.splice(0, this.batchSubscribeTopicsLimit);
              await this.batchSubscribe(t);
            }
          }
          this.events.emit(lI.resubscribed);
        }
        async restore() {
          try {
            let e = await this.getRelayerSubscriptions();
            if (typeof e > "u" || !e.length) return;
            if (this.subscriptions.size) {
              let { message: e } = oN("RESTORE_WILL_OVERRIDE", this.name);
              throw (
                (this.logger.error(e),
                this.logger.error(
                  `${this.name}: ${JSON.stringify(this.values)}`
                ),
                Error(e))
              );
            }
            (this.cached = e),
              this.logger.debug(
                `Successfully Restored subscriptions for ${this.name}`
              ),
              this.logger.trace({
                type: "method",
                method: "restore",
                subscriptions: this.values,
              });
          } catch (e) {
            this.logger.debug(
              `Failed to Restore subscriptions for ${this.name}`
            ),
              this.logger.error(e);
          }
        }
        async batchSubscribe(e) {
          e.length &&
            (await this.rpcBatchSubscribe(e),
            this.onBatchSubscribe(
              await Promise.all(
                e.map(async (e) =>
                  ui(ur({}, e), { id: await this.getSubscriptionId(e.topic) })
                )
              )
            ));
        }
        async batchFetchMessages(e) {
          var t;
          if (!e.length) return;
          this.logger.trace(
            `Fetching batch messages for ${e.length} subscriptions`
          );
          let r = await this.rpcBatchFetchMessages(e);
          r &&
            r.messages &&
            (await ((t = (0, v.toMiliseconds)(v.ONE_SECOND)),
            new Promise((e) => setTimeout(e, t))),
            await this.relayer.handleBatchMessageEvents(r.messages));
        }
        async onConnect() {
          await this.restart(), this.reset();
        }
        onDisconnect() {
          this.onDisable();
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = oN("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
        async restartToComplete(e) {
          this.relayer.connected ||
            this.relayer.connecting ||
            (this.cached.push(e), await this.relayer.transportOpen());
        }
        async getClientId() {
          return (
            this.clientId ||
              (this.clientId = await this.relayer.core.crypto.getClientId()),
            this.clientId
          );
        }
        async getSubscriptionId(e) {
          return oc(e + (await this.getClientId()));
        }
      }
      var ua = Object.defineProperty,
        uo = Object.getOwnPropertySymbols,
        ul = Object.prototype.hasOwnProperty,
        uc = Object.prototype.propertyIsEnumerable,
        uu = (e, t, r) =>
          t in e
            ? ua(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        uh = (e, t) => {
          for (var r in t || (t = {})) ul.call(t, r) && uu(e, r, t[r]);
          if (uo) for (var r of uo(t)) uc.call(t, r) && uu(e, r, t[r]);
          return e;
        },
        ud = (e, t, r) => uu(e, "symbol" != typeof t ? t + "" : t, r);
      class up extends eh {
        constructor(e) {
          super(e),
            ud(this, "protocol", "wc"),
            ud(this, "version", 2),
            ud(this, "core"),
            ud(this, "logger"),
            ud(this, "events", new w.EventEmitter()),
            ud(this, "provider"),
            ud(this, "messages"),
            ud(this, "subscriber"),
            ud(this, "publisher"),
            ud(this, "name", "relayer"),
            ud(this, "transportExplicitlyClosed", !1),
            ud(this, "initialized", !1),
            ud(this, "connectionAttemptInProgress", !1),
            ud(this, "relayUrl"),
            ud(this, "projectId"),
            ud(this, "packageName"),
            ud(this, "bundleId"),
            ud(this, "hasExperiencedNetworkDisruption", !1),
            ud(this, "pingTimeout"),
            ud(
              this,
              "heartBeatTimeout",
              (0, v.toMiliseconds)(v.THIRTY_SECONDS + v.FIVE_SECONDS)
            ),
            ud(this, "reconnectTimeout"),
            ud(this, "connectPromise"),
            ud(this, "reconnectInProgress", !1),
            ud(this, "requestsInFlight", []),
            ud(this, "connectTimeout", (0, v.toMiliseconds)(15 * v.ONE_SECOND)),
            ud(this, "request", async (e) => {
              var t, r;
              this.logger.debug("Publishing Request Payload");
              let i = e.id || o0().toString();
              await this.toEstablishConnection();
              try {
                this.logger.trace(
                  {
                    id: i,
                    method: e.method,
                    topic: null == (t = e.params) ? void 0 : t.topic,
                  },
                  "relayer.request - publishing..."
                );
                let n = `${i}:${
                  (null == (r = e.params) ? void 0 : r.tag) || ""
                }`;
                this.requestsInFlight.push(n);
                let s = await this.provider.request(e);
                return (
                  (this.requestsInFlight = this.requestsInFlight.filter(
                    (e) => e !== n
                  )),
                  s
                );
              } catch (e) {
                throw (this.logger.debug(`Failed to Publish Request: ${i}`), e);
              }
            }),
            ud(this, "resetPingTimeout", () => {
              nV() &&
                (clearTimeout(this.pingTimeout),
                (this.pingTimeout = setTimeout(() => {
                  var e, t, r, i;
                  try {
                    this.logger.debug(
                      {},
                      "pingTimeout: Connection stalled, terminating..."
                    ),
                      null ==
                        (i =
                          null ==
                          (r =
                            null ==
                            (t =
                              null == (e = this.provider)
                                ? void 0
                                : e.connection)
                              ? void 0
                              : t.socket)
                            ? void 0
                            : r.terminate) || i.call(r);
                  } catch (e) {
                    this.logger.warn(e, e?.message);
                  }
                }, this.heartBeatTimeout)));
            }),
            ud(this, "onPayloadHandler", (e) => {
              this.onProviderPayload(e), this.resetPingTimeout();
            }),
            ud(this, "onConnectHandler", () => {
              this.logger.warn({}, "Relayer connected \uD83D\uDEDC"),
                this.startPingTimeout(),
                this.events.emit(lb.connect);
            }),
            ud(this, "onDisconnectHandler", () => {
              this.logger.warn({}, "Relayer disconnected \uD83D\uDED1"),
                (this.requestsInFlight = []),
                this.onProviderDisconnect();
            }),
            ud(this, "onProviderErrorHandler", (e) => {
              this.logger.fatal(`Fatal socket error: ${e.message}`),
                this.events.emit(lb.error, e),
                this.logger.fatal(
                  "Fatal socket error received, closing transport"
                ),
                this.transportClose();
            }),
            ud(this, "registerProviderListeners", () => {
              this.provider.on(lv.payload, this.onPayloadHandler),
                this.provider.on(lv.connect, this.onConnectHandler),
                this.provider.on(lv.disconnect, this.onDisconnectHandler),
                this.provider.on(lv.error, this.onProviderErrorHandler);
            }),
            (this.core = e.core),
            (this.logger =
              "u" > typeof e.logger && "string" != typeof e.logger
                ? (0, ee.Ep)(e.logger, this.name)
                : (0, ee.gw)((0, ee.jI)({ level: e.logger || "error" }))),
            (this.messages = new cz(this.logger, e.core)),
            (this.subscriber = new us(this, this.logger)),
            (this.publisher = new c0(this, this.logger)),
            (this.relayUrl = e?.relayUrl || lw),
            (this.projectId = e.projectId),
            nG() &&
            "u" > typeof r.g &&
            "u" > typeof (null == r.g ? void 0 : r.g.Platform) &&
            (null == r.g ? void 0 : r.g.Platform.OS) === "android"
              ? (this.packageName = nZ())
              : nG() &&
                "u" > typeof r.g &&
                "u" > typeof (null == r.g ? void 0 : r.g.Platform) &&
                (null == r.g ? void 0 : r.g.Platform.OS) === "ios" &&
                (this.bundleId = nZ()),
            (this.provider = {});
        }
        async init() {
          if (
            (this.logger.trace("Initialized"),
            this.registerEventListeners(),
            await Promise.all([this.messages.init(), this.subscriber.init()]),
            (this.initialized = !0),
            this.subscriber.hasAnyTopics)
          )
            try {
              await this.transportOpen();
            } catch (e) {
              this.logger.warn(e, e?.message);
            }
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        get connected() {
          var e, t, r;
          return (
            (null ==
            (r =
              null == (t = null == (e = this.provider) ? void 0 : e.connection)
                ? void 0
                : t.socket)
              ? void 0
              : r.readyState) === 1
          );
        }
        get connecting() {
          var e, t, r;
          return (
            (null ==
            (r =
              null == (t = null == (e = this.provider) ? void 0 : e.connection)
                ? void 0
                : t.socket)
              ? void 0
              : r.readyState) === 0 || void 0 !== this.connectPromise
          );
        }
        async publish(e, t, r) {
          this.isInitialized(),
            await this.publisher.publish(e, t, r),
            await this.recordMessageEvent(
              {
                topic: e,
                message: t,
                publishedAt: Date.now(),
                transportType: lA.relay,
              },
              lC.outbound
            );
        }
        async subscribe(e, t) {
          var r, i, n;
          this.isInitialized(),
            (null != t && t.transportType && t?.transportType !== "relay") ||
              (await this.toEstablishConnection());
          let s =
              typeof (null == (r = t?.internal)
                ? void 0
                : r.throwOnFailedPublish) > "u" ||
              (null == (i = t?.internal) ? void 0 : i.throwOnFailedPublish),
            a =
              (null == (n = this.subscriber.topicMap.get(e)) ? void 0 : n[0]) ||
              "",
            o,
            l = (t) => {
              t.topic === e && (this.subscriber.off(lI.created, l), o());
            };
          return (
            await Promise.all([
              new Promise((e) => {
                (o = e), this.subscriber.on(lI.created, l);
              }),
              new Promise(async (r, i) => {
                (a =
                  (await this.subscriber
                    .subscribe(
                      e,
                      uh({ internal: { throwOnFailedPublish: s } }, t)
                    )
                    .catch((e) => {
                      s && i(e);
                    })) || a),
                  r();
              }),
            ]),
            a
          );
        }
        async unsubscribe(e, t) {
          this.isInitialized(), await this.subscriber.unsubscribe(e, t);
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async transportDisconnect() {
          this.provider.disconnect &&
          (this.hasExperiencedNetworkDisruption || this.connected)
            ? await n2(
                this.provider.disconnect(),
                2e3,
                "provider.disconnect()"
              ).catch(() => this.onProviderDisconnect())
            : this.onProviderDisconnect();
        }
        async transportClose() {
          (this.transportExplicitlyClosed = !0),
            await this.transportDisconnect();
        }
        async transportOpen(e) {
          if (!this.subscriber.hasAnyTopics) {
            this.logger.warn(
              "Starting WS connection skipped because the client has no topics to work with."
            );
            return;
          }
          if (
            (this.connectPromise
              ? (this.logger.debug(
                  {},
                  "Waiting for existing connection attempt to resolve..."
                ),
                await this.connectPromise,
                this.logger.debug({}, "Existing connection attempt resolved"))
              : ((this.connectPromise = new Promise(async (t, r) => {
                  await this.connect(e)
                    .then(t)
                    .catch(r)
                    .finally(() => {
                      this.connectPromise = void 0;
                    });
                })),
                await this.connectPromise),
            !this.connected)
          )
            throw Error(
              `Couldn't establish socket connection to the relay server: ${this.relayUrl}`
            );
        }
        async restartTransport(e) {
          this.logger.debug({}, "Restarting transport..."),
            this.connectionAttemptInProgress ||
              ((this.relayUrl = e || this.relayUrl),
              await this.confirmOnlineStateOrThrow(),
              await this.transportClose(),
              await this.transportOpen());
        }
        async confirmOnlineStateOrThrow() {
          if (!(await oH()))
            throw Error(
              "No internet connection detected. Please restart your network and try again."
            );
        }
        async handleBatchMessageEvents(e) {
          if (e?.length === 0) {
            this.logger.trace("Batch message events is empty. Ignoring...");
            return;
          }
          let t = e.sort((e, t) => e.publishedAt - t.publishedAt);
          for (let e of (this.logger.debug(
            `Batch of ${t.length} message events sorted`
          ),
          t))
            try {
              await this.onMessageEvent(e);
            } catch (e) {
              this.logger.warn(
                e,
                "Error while processing batch message event: " + e?.message
              );
            }
          this.logger.trace(`Batch of ${t.length} message events processed`);
        }
        async onLinkMessageEvent(e, t) {
          let { topic: r } = e;
          if (!t.sessionExists) {
            let e = n8(v.FIVE_MINUTES);
            await this.core.pairing.pairings.set(r, {
              topic: r,
              expiry: e,
              relay: { protocol: "irn" },
              active: !1,
            });
          }
          this.events.emit(lb.message, e),
            await this.recordMessageEvent(e, lC.inbound);
        }
        async connect(e) {
          await this.confirmOnlineStateOrThrow(),
            e &&
              e !== this.relayUrl &&
              ((this.relayUrl = e), await this.transportDisconnect()),
            (this.connectionAttemptInProgress = !0),
            (this.transportExplicitlyClosed = !1);
          let t = 1;
          for (; t < 6; ) {
            try {
              if (this.transportExplicitlyClosed) break;
              this.logger.debug(
                {},
                `Connecting to ${this.relayUrl}, attempt: ${t}...`
              ),
                await this.createProvider(),
                await new Promise(async (e, t) => {
                  let r = () => {
                    t(
                      Error("Connection interrupted while trying to subscribe")
                    );
                  };
                  this.provider.once(lv.disconnect, r),
                    await n2(
                      new Promise((e, t) => {
                        this.provider.connect().then(e).catch(t);
                      }),
                      this.connectTimeout,
                      `Socket stalled when trying to connect to ${this.relayUrl}`
                    )
                      .catch((e) => {
                        t(e);
                      })
                      .finally(() => {
                        this.provider.off(lv.disconnect, r),
                          clearTimeout(this.reconnectTimeout);
                      }),
                    await new Promise(async (e, t) => {
                      let r = () => {
                        t(
                          Error(
                            "Connection interrupted while trying to subscribe"
                          )
                        );
                      };
                      this.provider.once(lv.disconnect, r),
                        await this.subscriber
                          .start()
                          .then(e)
                          .catch(t)
                          .finally(() => {
                            this.provider.off(lv.disconnect, r);
                          });
                    }),
                    (this.hasExperiencedNetworkDisruption = !1),
                    e();
                });
            } catch (e) {
              await this.subscriber.stop(),
                this.logger.warn({}, e.message),
                (this.hasExperiencedNetworkDisruption = !0);
            } finally {
              this.connectionAttemptInProgress = !1;
            }
            if (this.connected) {
              this.logger.debug(
                {},
                `Connected to ${this.relayUrl} successfully on attempt: ${t}`
              );
              break;
            }
            await new Promise((e) =>
              setTimeout(e, (0, v.toMiliseconds)(1 * t))
            ),
              t++;
          }
        }
        startPingTimeout() {
          var e, t, r, i, n;
          if (nV())
            try {
              null !=
                (t = null == (e = this.provider) ? void 0 : e.connection) &&
                t.socket &&
                (null ==
                  (n =
                    null ==
                    (i = null == (r = this.provider) ? void 0 : r.connection)
                      ? void 0
                      : i.socket) ||
                  n.on("ping", () => {
                    this.resetPingTimeout();
                  })),
                this.resetPingTimeout();
            } catch (e) {
              this.logger.warn(e, e?.message);
            }
        }
        async createProvider() {
          this.provider.connection && this.unregisterProviderListeners();
          let e = await this.core.crypto.signJWT(this.relayUrl);
          (this.provider = new ls(
            new lc(
              (function ({
                protocol: e,
                version: t,
                relayUrl: r,
                sdkVersion: i,
                auth: n,
                projectId: s,
                useOnCloseEvent: a,
                bundleId: o,
                packageName: l,
              }) {
                let c = r.split("?"),
                  u = nQ(e, t, i),
                  h = (function (e, t) {
                    let r = new URLSearchParams(e);
                    for (let e of Object.keys(t).sort())
                      if (t.hasOwnProperty(e)) {
                        let i = t[e];
                        void 0 !== i && r.set(e, i);
                      }
                    return r.toString();
                  })(c[1] || "", {
                    auth: n,
                    ua: u,
                    projectId: s,
                    useOnCloseEvent: a || void 0,
                    packageName: l || void 0,
                    bundleId: o || void 0,
                  });
                return c[0] + "?" + h;
              })({
                sdkVersion: lE,
                protocol: this.protocol,
                version: this.version,
                relayUrl: this.relayUrl,
                projectId: this.projectId,
                auth: e,
                useOnCloseEvent: !0,
                bundleId: this.bundleId,
                packageName: this.packageName,
              })
            )
          )),
            this.registerProviderListeners();
        }
        async recordMessageEvent(e, t) {
          let { topic: r, message: i } = e;
          await this.messages.set(r, i, t);
        }
        async shouldIgnoreMessageEvent(e) {
          let { topic: t, message: r } = e;
          if (!r || 0 === r.length)
            return this.logger.warn(`Ignoring invalid/empty message: ${r}`), !0;
          if (!(await this.subscriber.isKnownTopic(t)))
            return (
              this.logger.warn(`Ignoring message for unknown topic ${t}`), !0
            );
          let i = this.messages.has(t, r);
          return i && this.logger.warn(`Ignoring duplicate message: ${r}`), i;
        }
        async onProviderPayload(e) {
          if (
            (this.logger.debug("Incoming Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "incoming",
              payload: e,
            }),
            lt(e))
          ) {
            if (!e.method.endsWith("_subscription")) return;
            let t = e.params,
              { topic: r, message: i, publishedAt: n, attestation: s } = t.data,
              a = {
                topic: r,
                message: i,
                publishedAt: n,
                transportType: lA.relay,
                attestation: s,
              };
            this.logger.debug("Emitting Relayer Payload"),
              this.logger.trace(uh({ type: "event", event: t.id }, a)),
              this.events.emit(t.id, a),
              await this.acknowledgePayload(e),
              await this.onMessageEvent(a);
          } else lr(e) && this.events.emit(lb.message_ack, e);
        }
        async onMessageEvent(e) {
          (await this.shouldIgnoreMessageEvent(e)) ||
            (await this.recordMessageEvent(e, lC.inbound),
            this.events.emit(lb.message, e));
        }
        async acknowledgePayload(e) {
          let t = o2(e.id, !0);
          await this.provider.connection.send(t);
        }
        unregisterProviderListeners() {
          this.provider.off(lv.payload, this.onPayloadHandler),
            this.provider.off(lv.connect, this.onConnectHandler),
            this.provider.off(lv.disconnect, this.onDisconnectHandler),
            this.provider.off(lv.error, this.onProviderErrorHandler),
            clearTimeout(this.pingTimeout);
        }
        async registerEventListeners() {
          let e = await oH();
          !(function (e) {
            switch (nK()) {
              case nq.browser:
                !nG() &&
                  nW() &&
                  (window.addEventListener("online", () => e(!0)),
                  window.addEventListener("offline", () => e(!1)));
                break;
              case nq.reactNative:
                nG() &&
                  "u" > typeof r.g &&
                  null != r.g &&
                  r.g.NetInfo &&
                  r.g?.NetInfo.addEventListener((t) => e(t?.isConnected));
              case nq.node:
            }
          })(async (t) => {
            e !== t &&
              ((e = t),
              t
                ? await this.transportOpen().catch((e) =>
                    this.logger.error(e, e?.message)
                  )
                : ((this.hasExperiencedNetworkDisruption = !0),
                  await this.transportDisconnect(),
                  (this.transportExplicitlyClosed = !1)));
          });
        }
        async onProviderDisconnect() {
          clearTimeout(this.pingTimeout),
            this.events.emit(lb.disconnect),
            (this.connectionAttemptInProgress = !1),
            !this.reconnectInProgress &&
              ((this.reconnectInProgress = !0),
              await this.subscriber.stop(),
              this.subscriber.hasAnyTopics &&
                (this.transportExplicitlyClosed ||
                  (this.reconnectTimeout = setTimeout(async () => {
                    await this.transportOpen().catch((e) =>
                      this.logger.error(e, e?.message)
                    ),
                      (this.reconnectTimeout = void 0),
                      (this.reconnectInProgress = !1);
                  }, (0, v.toMiliseconds)(0.1)))));
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = oN("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
        async toEstablishConnection() {
          await this.confirmOnlineStateOrThrow(),
            this.connected || (await this.connect());
        }
      }
      function uf() {}
      function ug(e) {
        if (!e || "object" != typeof e) return !1;
        let t = Object.getPrototypeOf(e);
        return (
          (null === t ||
            t === Object.prototype ||
            null === Object.getPrototypeOf(t)) &&
          "[object Object]" === Object.prototype.toString.call(e)
        );
      }
      function um(e) {
        return Object.getOwnPropertySymbols(e).filter((t) =>
          Object.prototype.propertyIsEnumerable.call(e, t)
        );
      }
      function uy(e) {
        return null == e
          ? void 0 === e
            ? "[object Undefined]"
            : "[object Null]"
          : Object.prototype.toString.call(e);
      }
      let uw = "[object Arguments]",
        ub = "[object Object]";
      var uv = Object.defineProperty,
        uE = Object.getOwnPropertySymbols,
        uA = Object.prototype.hasOwnProperty,
        uC = Object.prototype.propertyIsEnumerable,
        u_ = (e, t, r) =>
          t in e
            ? uv(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        uI = (e, t) => {
          for (var r in t || (t = {})) uA.call(t, r) && u_(e, r, t[r]);
          if (uE) for (var r of uE(t)) uC.call(t, r) && u_(e, r, t[r]);
          return e;
        },
        uN = (e, t, r) => u_(e, "symbol" != typeof t ? t + "" : t, r);
      class uS extends ed {
        constructor(e, t, r, i = ld, n) {
          super(e, t, r, i),
            (this.core = e),
            (this.logger = t),
            (this.name = r),
            uN(this, "map", new Map()),
            uN(this, "version", "0.3"),
            uN(this, "cached", []),
            uN(this, "initialized", !1),
            uN(this, "getKey"),
            uN(this, "storagePrefix", ld),
            uN(this, "recentlyDeleted", []),
            uN(this, "recentlyDeletedLimit", 200),
            uN(this, "init", async () => {
              this.initialized ||
                (this.logger.trace("Initialized"),
                await this.restore(),
                this.cached.forEach((e) => {
                  var t;
                  this.getKey && null !== e && !oO(e)
                    ? this.map.set(this.getKey(e), e)
                    : (null == (t = e?.proposer) ? void 0 : t.publicKey)
                    ? this.map.set(e.id, e)
                    : e?.topic && this.map.set(e.topic, e);
                }),
                (this.cached = []),
                (this.initialized = !0));
            }),
            uN(this, "set", async (e, t) => {
              this.isInitialized(),
                this.map.has(e)
                  ? await this.update(e, t)
                  : (this.logger.debug("Setting value"),
                    this.logger.trace({
                      type: "method",
                      method: "set",
                      key: e,
                      value: t,
                    }),
                    this.map.set(e, t),
                    await this.persist());
            }),
            uN(
              this,
              "get",
              (e) => (
                this.isInitialized(),
                this.logger.debug("Getting value"),
                this.logger.trace({ type: "method", method: "get", key: e }),
                this.getData(e)
              )
            ),
            uN(
              this,
              "getAll",
              (e) => (
                this.isInitialized(),
                e
                  ? this.values.filter((t) =>
                      Object.keys(e).every((r) =>
                        (function e(t, r, i, n, s, a, o) {
                          let l = o(t, r, i, n, s, a);
                          if (void 0 !== l) return l;
                          if (typeof t == typeof r)
                            switch (typeof t) {
                              case "bigint":
                              case "string":
                              case "boolean":
                              case "symbol":
                              case "undefined":
                              case "function":
                                return t === r;
                              case "number":
                                return t === r || Object.is(t, r);
                            }
                          return (function t(r, i, n, s) {
                            if (Object.is(r, i)) return !0;
                            let a = uy(r),
                              o = uy(i);
                            if (
                              (a === uw && (a = ub),
                              o === uw && (o = ub),
                              a !== o)
                            )
                              return !1;
                            switch (a) {
                              case "[object String]":
                                return r.toString() === i.toString();
                              case "[object Number]": {
                                let e = r.valueOf(),
                                  t = i.valueOf();
                                return (
                                  e === t ||
                                  (Number.isNaN(e) && Number.isNaN(t))
                                );
                              }
                              case "[object Boolean]":
                              case "[object Date]":
                              case "[object Symbol]":
                                return Object.is(r.valueOf(), i.valueOf());
                              case "[object RegExp]":
                                return (
                                  r.source === i.source && r.flags === i.flags
                                );
                              case "[object Function]":
                                return r === i;
                            }
                            let l = (n = n ?? new Map()).get(r),
                              c = n.get(i);
                            if (null != l && null != c) return l === i;
                            n.set(r, i), n.set(i, r);
                            try {
                              switch (a) {
                                case "[object Map]":
                                  if (r.size !== i.size) return !1;
                                  for (let [t, a] of r.entries())
                                    if (
                                      !i.has(t) ||
                                      !e(a, i.get(t), t, r, i, n, s)
                                    )
                                      return !1;
                                  return !0;
                                case "[object Set]": {
                                  if (r.size !== i.size) return !1;
                                  let t = Array.from(r.values()),
                                    a = Array.from(i.values());
                                  for (let o = 0; o < t.length; o++) {
                                    let l = t[o],
                                      c = a.findIndex((t) =>
                                        e(l, t, void 0, r, i, n, s)
                                      );
                                    if (-1 === c) return !1;
                                    a.splice(c, 1);
                                  }
                                  return !0;
                                }
                                case "[object Array]":
                                case "[object Uint8Array]":
                                case "[object Uint8ClampedArray]":
                                case "[object Uint16Array]":
                                case "[object Uint32Array]":
                                case "[object BigUint64Array]":
                                case "[object Int8Array]":
                                case "[object Int16Array]":
                                case "[object Int32Array]":
                                case "[object BigInt64Array]":
                                case "[object Float32Array]":
                                case "[object Float64Array]":
                                  if (
                                    ("u" > typeof lu &&
                                      lu.isBuffer(r) !== lu.isBuffer(i)) ||
                                    r.length !== i.length
                                  )
                                    return !1;
                                  for (let t = 0; t < r.length; t++)
                                    if (!e(r[t], i[t], t, r, i, n, s))
                                      return !1;
                                  return !0;
                                case "[object ArrayBuffer]":
                                  return (
                                    r.byteLength === i.byteLength &&
                                    t(
                                      new Uint8Array(r),
                                      new Uint8Array(i),
                                      n,
                                      s
                                    )
                                  );
                                case "[object DataView]":
                                  return (
                                    r.byteLength === i.byteLength &&
                                    r.byteOffset === i.byteOffset &&
                                    t(
                                      new Uint8Array(r),
                                      new Uint8Array(i),
                                      n,
                                      s
                                    )
                                  );
                                case "[object Error]":
                                  return (
                                    r.name === i.name && r.message === i.message
                                  );
                                case ub: {
                                  if (
                                    !(
                                      t(r.constructor, i.constructor, n, s) ||
                                      (ug(r) && ug(i))
                                    )
                                  )
                                    return !1;
                                  let a = [...Object.keys(r), ...um(r)],
                                    o = [...Object.keys(i), ...um(i)];
                                  if (a.length !== o.length) return !1;
                                  for (let t = 0; t < a.length; t++) {
                                    let o = a[t],
                                      l = r[o];
                                    if (!Object.hasOwn(i, o)) return !1;
                                    let c = i[o];
                                    if (!e(l, c, o, r, i, n, s)) return !1;
                                  }
                                  return !0;
                                }
                                default:
                                  return !1;
                              }
                            } finally {
                              n.delete(r), n.delete(i);
                            }
                          })(t, r, a, o);
                        })(t[r], e[r], void 0, void 0, void 0, void 0, uf)
                      )
                    )
                  : this.values
              )
            ),
            uN(this, "update", async (e, t) => {
              this.isInitialized(),
                this.logger.debug("Updating value"),
                this.logger.trace({
                  type: "method",
                  method: "update",
                  key: e,
                  update: t,
                });
              let r = uI(uI({}, this.getData(e)), t);
              this.map.set(e, r), await this.persist();
            }),
            uN(this, "delete", async (e, t) => {
              this.isInitialized(),
                this.map.has(e) &&
                  (this.logger.debug("Deleting value"),
                  this.logger.trace({
                    type: "method",
                    method: "delete",
                    key: e,
                    reason: t,
                  }),
                  this.map.delete(e),
                  this.addToRecentlyDeleted(e),
                  await this.persist());
            }),
            (this.logger = (0, ee.Ep)(t, this.name)),
            (this.storagePrefix = i),
            (this.getKey = n);
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get length() {
          return this.map.size;
        }
        get keys() {
          return Array.from(this.map.keys());
        }
        get values() {
          return Array.from(this.map.values());
        }
        addToRecentlyDeleted(e) {
          this.recentlyDeleted.push(e),
            this.recentlyDeleted.length >= this.recentlyDeletedLimit &&
              this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
        }
        async setDataStore(e) {
          await this.core.storage.setItem(this.storageKey, e);
        }
        async getDataStore() {
          return await this.core.storage.getItem(this.storageKey);
        }
        getData(e) {
          let t = this.map.get(e);
          if (!t) {
            if (this.recentlyDeleted.includes(e)) {
              let { message: t } = oN(
                "MISSING_OR_INVALID",
                `Record was recently deleted - ${this.name}: ${e}`
              );
              throw (this.logger.error(t), Error(t));
            }
            let { message: t } = oN("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw (this.logger.error(t), Error(t));
          }
          return t;
        }
        async persist() {
          await this.setDataStore(this.values);
        }
        async restore() {
          try {
            let e = await this.getDataStore();
            if (typeof e > "u" || !e.length) return;
            if (this.map.size) {
              let { message: e } = oN("RESTORE_WILL_OVERRIDE", this.name);
              throw (this.logger.error(e), Error(e));
            }
            (this.cached = e),
              this.logger.debug(`Successfully Restored value for ${this.name}`),
              this.logger.trace({
                type: "method",
                method: "restore",
                value: this.values,
              });
          } catch (e) {
            this.logger.debug(`Failed to Restore value for ${this.name}`),
              this.logger.error(e);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = oN("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var uT = Object.defineProperty,
        uP = (e, t, r) =>
          t in e
            ? uT(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        uO = (e, t, r) => uP(e, "symbol" != typeof t ? t + "" : t, r);
      class ux {
        constructor(e, t) {
          (this.core = e),
            (this.logger = t),
            uO(this, "name", "pairing"),
            uO(this, "version", "0.3"),
            uO(this, "events", new (b())()),
            uO(this, "pairings"),
            uO(this, "initialized", !1),
            uO(this, "storagePrefix", ld),
            uO(this, "ignoredPayloadTypes", [1]),
            uO(this, "registeredMethods", []),
            uO(this, "init", async () => {
              this.initialized ||
                (await this.pairings.init(),
                await this.cleanup(),
                this.registerRelayerEvents(),
                this.registerExpirerEvents(),
                (this.initialized = !0),
                this.logger.trace("Initialized"));
            }),
            uO(this, "register", ({ methods: e }) => {
              this.isInitialized(),
                (this.registeredMethods = [
                  ...new Set([...this.registeredMethods, ...e]),
                ]);
            }),
            uO(this, "create", async (e) => {
              this.isInitialized();
              let t = oo(),
                r = await this.core.crypto.setSymKey(t),
                i = n8(v.FIVE_MINUTES),
                n = { protocol: "irn" },
                s = {
                  topic: r,
                  expiry: i,
                  relay: n,
                  active: !1,
                  methods: e?.methods,
                },
                a = ow({
                  protocol: this.core.protocol,
                  version: this.core.version,
                  topic: r,
                  symKey: t,
                  relay: n,
                  expiryTimestamp: i,
                  methods: e?.methods,
                });
              return (
                this.events.emit(lS.create, s),
                this.core.expirer.set(r, i),
                await this.pairings.set(r, s),
                await this.core.relayer.subscribe(r, {
                  transportType: e?.transportType,
                }),
                { topic: r, uri: a }
              );
            }),
            uO(this, "pair", async (e) => {
              let t;
              this.isInitialized();
              let r = this.core.eventClient.createEvent({
                properties: { topic: e?.uri, trace: [lR.pairing_started] },
              });
              this.isValidPair(e, r);
              let {
                topic: i,
                symKey: n,
                relay: s,
                expiryTimestamp: a,
                methods: o,
              } = oy(e.uri);
              if (
                ((r.props.properties.topic = i),
                r.addTrace(lR.pairing_uri_validation_success),
                r.addTrace(lR.pairing_uri_not_expired),
                this.pairings.keys.includes(i))
              ) {
                if (
                  ((t = this.pairings.get(i)),
                  r.addTrace(lR.existing_pairing),
                  t.active)
                )
                  throw (
                    (r.setError(lD.active_pairing_already_exists),
                    Error(
                      `Pairing already exists: ${i}. Please try again with a new connection URI.`
                    ))
                  );
                r.addTrace(lR.pairing_not_expired);
              }
              let l = a || n8(v.FIVE_MINUTES),
                c = { topic: i, relay: s, expiry: l, active: !1, methods: o };
              this.core.expirer.set(i, l),
                await this.pairings.set(i, c),
                r.addTrace(lR.store_new_pairing),
                e.activatePairing && (await this.activate({ topic: i })),
                this.events.emit(lS.create, c),
                r.addTrace(lR.emit_inactive_pairing),
                this.core.crypto.keychain.has(i) ||
                  (await this.core.crypto.setSymKey(n, i)),
                r.addTrace(lR.subscribing_pairing_topic);
              try {
                await this.core.relayer.confirmOnlineStateOrThrow();
              } catch {
                r.setError(lD.no_internet_connection);
              }
              try {
                await this.core.relayer.subscribe(i, { relay: s });
              } catch (e) {
                throw (r.setError(lD.subscribe_pairing_topic_failure), e);
              }
              return r.addTrace(lR.subscribe_pairing_topic_success), c;
            }),
            uO(this, "activate", async ({ topic: e }) => {
              this.isInitialized();
              let t = n8(v.FIVE_MINUTES);
              this.core.expirer.set(e, t),
                await this.pairings.update(e, { active: !0, expiry: t });
            }),
            uO(this, "ping", async (e) => {
              this.isInitialized(),
                await this.isValidPing(e),
                this.logger.warn(
                  "ping() is deprecated and will be removed in the next major release."
                );
              let { topic: t } = e;
              if (this.pairings.keys.includes(t)) {
                let e = await this.sendRequest(t, "wc_pairingPing", {}),
                  { done: r, resolve: i, reject: n } = n1();
                this.events.once(n6("pairing_ping", e), ({ error: e }) => {
                  e ? n(e) : i();
                }),
                  await r();
              }
            }),
            uO(this, "updateExpiry", async ({ topic: e, expiry: t }) => {
              this.isInitialized(),
                await this.pairings.update(e, { expiry: t });
            }),
            uO(this, "updateMetadata", async ({ topic: e, metadata: t }) => {
              this.isInitialized(),
                await this.pairings.update(e, { peerMetadata: t });
            }),
            uO(
              this,
              "getPairings",
              () => (this.isInitialized(), this.pairings.values)
            ),
            uO(this, "disconnect", async (e) => {
              this.isInitialized(), await this.isValidDisconnect(e);
              let { topic: t } = e;
              this.pairings.keys.includes(t) &&
                (await this.sendRequest(
                  t,
                  "wc_pairingDelete",
                  oS("USER_DISCONNECTED")
                ),
                await this.deletePairing(t));
            }),
            uO(this, "formatUriFromPairing", (e) => {
              this.isInitialized();
              let { topic: t, relay: r, expiry: i, methods: n } = e,
                s = this.core.crypto.keychain.get(t);
              return ow({
                protocol: this.core.protocol,
                version: this.core.version,
                topic: t,
                symKey: s,
                relay: r,
                expiryTimestamp: i,
                methods: n,
              });
            }),
            uO(this, "sendRequest", async (e, t, r) => {
              let i = o1(t, r),
                n = await this.core.crypto.encode(e, i),
                s = lN[t].req;
              return (
                this.core.history.set(e, i),
                this.core.relayer.publish(e, n, s),
                i.id
              );
            }),
            uO(this, "sendResult", async (e, t, r) => {
              let i = o2(e, r),
                n = await this.core.crypto.encode(t, i),
                s = lN[(await this.core.history.get(t, e)).request.method].res;
              await this.core.relayer.publish(t, n, s),
                await this.core.history.resolve(i);
            }),
            uO(this, "sendError", async (e, t, r) => {
              let i = o3(e, r),
                n = await this.core.crypto.encode(t, i),
                s = (await this.core.history.get(t, e)).request.method,
                a = lN[s] ? lN[s].res : lN.unregistered_method.res;
              await this.core.relayer.publish(t, n, a),
                await this.core.history.resolve(i);
            }),
            uO(this, "deletePairing", async (e, t) => {
              await this.core.relayer.unsubscribe(e),
                await Promise.all([
                  this.pairings.delete(e, oS("USER_DISCONNECTED")),
                  this.core.crypto.deleteSymKey(e),
                  t ? Promise.resolve() : this.core.expirer.del(e),
                ]);
            }),
            uO(this, "cleanup", async () => {
              let e = this.pairings.getAll().filter((e) => n4(e.expiry));
              await Promise.all(e.map((e) => this.deletePairing(e.topic)));
            }),
            uO(this, "onRelayEventRequest", async (e) => {
              let { topic: t, payload: r } = e;
              switch (r.method) {
                case "wc_pairingPing":
                  return await this.onPairingPingRequest(t, r);
                case "wc_pairingDelete":
                  return await this.onPairingDeleteRequest(t, r);
                default:
                  return await this.onUnknownRpcMethodRequest(t, r);
              }
            }),
            uO(this, "onRelayEventResponse", async (e) => {
              let { topic: t, payload: r } = e,
                i = (await this.core.history.get(t, r.id)).request.method;
              return "wc_pairingPing" === i
                ? this.onPairingPingResponse(t, r)
                : this.onUnknownRpcMethodResponse(i);
            }),
            uO(this, "onPairingPingRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidPing({ topic: e }),
                  await this.sendResult(r, e, !0),
                  this.events.emit(lS.ping, { id: r, topic: e });
              } catch (t) {
                await this.sendError(r, e, t), this.logger.error(t);
              }
            }),
            uO(this, "onPairingPingResponse", (e, t) => {
              let { id: r } = t;
              setTimeout(() => {
                li(t)
                  ? this.events.emit(n6("pairing_ping", r), {})
                  : ln(t) &&
                    this.events.emit(n6("pairing_ping", r), { error: t.error });
              }, 500);
            }),
            uO(this, "onPairingDeleteRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidDisconnect({ topic: e }),
                  await this.deletePairing(e),
                  this.events.emit(lS.delete, { id: r, topic: e });
              } catch (t) {
                await this.sendError(r, e, t), this.logger.error(t);
              }
            }),
            uO(this, "onUnknownRpcMethodRequest", async (e, t) => {
              let { id: r, method: i } = t;
              try {
                if (this.registeredMethods.includes(i)) return;
                let t = oS("WC_METHOD_UNSUPPORTED", i);
                await this.sendError(r, e, t), this.logger.error(t);
              } catch (t) {
                await this.sendError(r, e, t), this.logger.error(t);
              }
            }),
            uO(this, "onUnknownRpcMethodResponse", (e) => {
              this.registeredMethods.includes(e) ||
                this.logger.error(oS("WC_METHOD_UNSUPPORTED", e));
            }),
            uO(this, "isValidPair", (e, t) => {
              var r;
              if (!oB(e)) {
                let { message: r } = oN(
                  "MISSING_OR_INVALID",
                  `pair() params: ${e}`
                );
                throw (t.setError(lD.malformed_pairing_uri), Error(r));
              }
              if (
                !(function (e) {
                  function t(e) {
                    try {
                      return "u" > typeof new URL(e);
                    } catch {
                      return !1;
                    }
                  }
                  try {
                    if (ox(e, !1)) {
                      if (t(e)) return !0;
                      let r = sn(e);
                      return t(r);
                    }
                  } catch {}
                  return !1;
                })(e.uri)
              ) {
                let { message: r } = oN(
                  "MISSING_OR_INVALID",
                  `pair() uri: ${e.uri}`
                );
                throw (t.setError(lD.malformed_pairing_uri), Error(r));
              }
              let i = oy(e?.uri);
              if (!(null != (r = i?.relay) && r.protocol)) {
                let { message: e } = oN(
                  "MISSING_OR_INVALID",
                  "pair() uri#relay-protocol"
                );
                throw (t.setError(lD.malformed_pairing_uri), Error(e));
              }
              if (!(null != i && i.symKey)) {
                let { message: e } = oN(
                  "MISSING_OR_INVALID",
                  "pair() uri#symKey"
                );
                throw (t.setError(lD.malformed_pairing_uri), Error(e));
              }
              if (
                null != i &&
                i.expiryTimestamp &&
                (0, v.toMiliseconds)(i?.expiryTimestamp) < Date.now()
              ) {
                t.setError(lD.pairing_expired);
                let { message: e } = oN(
                  "EXPIRED",
                  "pair() URI has expired. Please try again with a new connection URI."
                );
                throw Error(e);
              }
            }),
            uO(this, "isValidPing", async (e) => {
              if (!oB(e)) {
                let { message: t } = oN(
                  "MISSING_OR_INVALID",
                  `ping() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidPairingTopic(t);
            }),
            uO(this, "isValidDisconnect", async (e) => {
              if (!oB(e)) {
                let { message: t } = oN(
                  "MISSING_OR_INVALID",
                  `disconnect() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidPairingTopic(t);
            }),
            uO(this, "isValidPairingTopic", async (e) => {
              if (!ox(e, !1)) {
                let { message: t } = oN(
                  "MISSING_OR_INVALID",
                  `pairing topic should be a string: ${e}`
                );
                throw Error(t);
              }
              if (!this.pairings.keys.includes(e)) {
                let { message: t } = oN(
                  "NO_MATCHING_KEY",
                  `pairing topic doesn't exist: ${e}`
                );
                throw Error(t);
              }
              if (n4(this.pairings.get(e).expiry)) {
                await this.deletePairing(e);
                let { message: t } = oN("EXPIRED", `pairing topic: ${e}`);
                throw Error(t);
              }
            }),
            (this.core = e),
            (this.logger = (0, ee.Ep)(t, this.name)),
            (this.pairings = new uS(
              this.core,
              this.logger,
              this.name,
              this.storagePrefix
            ));
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = oN("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
        registerRelayerEvents() {
          this.core.relayer.on(lb.message, async (e) => {
            let { topic: t, message: r, transportType: i } = e;
            if (
              this.pairings.keys.includes(t) &&
              i !== lA.link_mode &&
              !this.ignoredPayloadTypes.includes(
                this.core.crypto.getPayloadType(r)
              )
            )
              try {
                let e = await this.core.crypto.decode(t, r);
                lt(e)
                  ? (this.core.history.set(t, e),
                    await this.onRelayEventRequest({ topic: t, payload: e }))
                  : lr(e) &&
                    (await this.core.history.resolve(e),
                    await this.onRelayEventResponse({ topic: t, payload: e }),
                    this.core.history.delete(t, e.id)),
                  await this.core.relayer.messages.ack(t, r);
              } catch (e) {
                this.logger.error(e);
              }
          });
        }
        registerExpirerEvents() {
          this.core.expirer.on(lP.expired, async (e) => {
            let { topic: t } = n5(e.target);
            t &&
              this.pairings.keys.includes(t) &&
              (await this.deletePairing(t, !0),
              this.events.emit(lS.expire, { topic: t }));
          });
        }
      }
      var uk = Object.defineProperty,
        uR = (e, t, r) =>
          t in e
            ? uk(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        uD = (e, t, r) => uR(e, "symbol" != typeof t ? t + "" : t, r);
      class uU extends el {
        constructor(e, t) {
          super(e, t),
            (this.core = e),
            (this.logger = t),
            uD(this, "records", new Map()),
            uD(this, "events", new w.EventEmitter()),
            uD(this, "name", "history"),
            uD(this, "version", "0.3"),
            uD(this, "cached", []),
            uD(this, "initialized", !1),
            uD(this, "storagePrefix", ld),
            uD(this, "init", async () => {
              this.initialized ||
                (this.logger.trace("Initialized"),
                await this.restore(),
                this.cached.forEach((e) => this.records.set(e.id, e)),
                (this.cached = []),
                this.registerEventListeners(),
                (this.initialized = !0));
            }),
            uD(this, "set", (e, t, r) => {
              if (
                (this.isInitialized(),
                this.logger.debug("Setting JSON-RPC request history record"),
                this.logger.trace({
                  type: "method",
                  method: "set",
                  topic: e,
                  request: t,
                  chainId: r,
                }),
                this.records.has(t.id))
              )
                return;
              let i = {
                id: t.id,
                topic: e,
                request: { method: t.method, params: t.params || null },
                chainId: r,
                expiry: n8(v.THIRTY_DAYS),
              };
              this.records.set(i.id, i),
                this.persist(),
                this.events.emit(lT.created, i);
            }),
            uD(this, "resolve", async (e) => {
              if (
                (this.isInitialized(),
                this.logger.debug("Updating JSON-RPC response history record"),
                this.logger.trace({
                  type: "method",
                  method: "update",
                  response: e,
                }),
                !this.records.has(e.id))
              )
                return;
              let t = await this.getRecord(e.id);
              typeof t.response > "u" &&
                ((t.response = ln(e)
                  ? { error: e.error }
                  : { result: e.result }),
                this.records.set(t.id, t),
                this.persist(),
                this.events.emit(lT.updated, t));
            }),
            uD(
              this,
              "get",
              async (e, t) => (
                this.isInitialized(),
                this.logger.debug("Getting record"),
                this.logger.trace({
                  type: "method",
                  method: "get",
                  topic: e,
                  id: t,
                }),
                await this.getRecord(t)
              )
            ),
            uD(this, "delete", (e, t) => {
              this.isInitialized(),
                this.logger.debug("Deleting record"),
                this.logger.trace({ type: "method", method: "delete", id: t }),
                this.values.forEach((r) => {
                  r.topic !== e ||
                    ("u" > typeof t && r.id !== t) ||
                    (this.records.delete(r.id),
                    this.events.emit(lT.deleted, r));
                }),
                this.persist();
            }),
            uD(
              this,
              "exists",
              async (e, t) => (
                this.isInitialized(),
                !!this.records.has(t) && (await this.getRecord(t)).topic === e
              )
            ),
            uD(this, "on", (e, t) => {
              this.events.on(e, t);
            }),
            uD(this, "once", (e, t) => {
              this.events.once(e, t);
            }),
            uD(this, "off", (e, t) => {
              this.events.off(e, t);
            }),
            uD(this, "removeListener", (e, t) => {
              this.events.removeListener(e, t);
            }),
            (this.logger = (0, ee.Ep)(t, this.name));
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get size() {
          return this.records.size;
        }
        get keys() {
          return Array.from(this.records.keys());
        }
        get values() {
          return Array.from(this.records.values());
        }
        get pending() {
          let e = [];
          return (
            this.values.forEach((t) => {
              if ("u" > typeof t.response) return;
              let r = {
                topic: t.topic,
                request: o1(t.request.method, t.request.params, t.id),
                chainId: t.chainId,
              };
              return e.push(r);
            }),
            e
          );
        }
        async setJsonRpcRecords(e) {
          await this.core.storage.setItem(this.storageKey, e);
        }
        async getJsonRpcRecords() {
          return await this.core.storage.getItem(this.storageKey);
        }
        getRecord(e) {
          this.isInitialized();
          let t = this.records.get(e);
          if (!t) {
            let { message: t } = oN("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw Error(t);
          }
          return t;
        }
        async persist() {
          await this.setJsonRpcRecords(this.values), this.events.emit(lT.sync);
        }
        async restore() {
          try {
            let e = await this.getJsonRpcRecords();
            if (typeof e > "u" || !e.length) return;
            if (this.records.size) {
              let { message: e } = oN("RESTORE_WILL_OVERRIDE", this.name);
              throw (this.logger.error(e), Error(e));
            }
            (this.cached = e),
              this.logger.debug(
                `Successfully Restored records for ${this.name}`
              ),
              this.logger.trace({
                type: "method",
                method: "restore",
                records: this.values,
              });
          } catch (e) {
            this.logger.debug(`Failed to Restore records for ${this.name}`),
              this.logger.error(e);
          }
        }
        registerEventListeners() {
          this.events.on(lT.created, (e) => {
            let t = lT.created;
            this.logger.info(`Emitting ${t}`),
              this.logger.debug({ type: "event", event: t, record: e });
          }),
            this.events.on(lT.updated, (e) => {
              let t = lT.updated;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, record: e });
            }),
            this.events.on(lT.deleted, (e) => {
              let t = lT.deleted;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, record: e });
            }),
            this.core.heartbeat.on(_, () => {
              this.cleanup();
            });
        }
        cleanup() {
          try {
            this.isInitialized();
            let e = !1;
            this.records.forEach((t) => {
              (0, v.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 &&
                (this.logger.info(`Deleting expired history log: ${t.id}`),
                this.records.delete(t.id),
                this.events.emit(lT.deleted, t, !1),
                (e = !0));
            }),
              e && this.persist();
          } catch (e) {
            this.logger.warn(e);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = oN("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var uL = Object.defineProperty,
        uM = (e, t, r) =>
          t in e
            ? uL(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        uB = (e, t, r) => uM(e, "symbol" != typeof t ? t + "" : t, r);
      class uj extends ef {
        constructor(e, t) {
          super(e, t),
            (this.core = e),
            (this.logger = t),
            uB(this, "expirations", new Map()),
            uB(this, "events", new w.EventEmitter()),
            uB(this, "name", "expirer"),
            uB(this, "version", "0.3"),
            uB(this, "cached", []),
            uB(this, "initialized", !1),
            uB(this, "storagePrefix", ld),
            uB(this, "init", async () => {
              this.initialized ||
                (this.logger.trace("Initialized"),
                await this.restore(),
                this.cached.forEach((e) => this.expirations.set(e.target, e)),
                (this.cached = []),
                this.registerEventListeners(),
                (this.initialized = !0));
            }),
            uB(this, "has", (e) => {
              try {
                let t = this.formatTarget(e);
                return "u" > typeof this.getExpiration(t);
              } catch {
                return !1;
              }
            }),
            uB(this, "set", (e, t) => {
              this.isInitialized();
              let r = this.formatTarget(e),
                i = { target: r, expiry: t };
              this.expirations.set(r, i),
                this.checkExpiry(r, i),
                this.events.emit(lP.created, { target: r, expiration: i });
            }),
            uB(this, "get", (e) => {
              this.isInitialized();
              let t = this.formatTarget(e);
              return this.getExpiration(t);
            }),
            uB(this, "del", (e) => {
              if ((this.isInitialized(), this.has(e))) {
                let t = this.formatTarget(e),
                  r = this.getExpiration(t);
                this.expirations.delete(t),
                  this.events.emit(lP.deleted, { target: t, expiration: r });
              }
            }),
            uB(this, "on", (e, t) => {
              this.events.on(e, t);
            }),
            uB(this, "once", (e, t) => {
              this.events.once(e, t);
            }),
            uB(this, "off", (e, t) => {
              this.events.off(e, t);
            }),
            uB(this, "removeListener", (e, t) => {
              this.events.removeListener(e, t);
            }),
            (this.logger = (0, ee.Ep)(t, this.name));
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get length() {
          return this.expirations.size;
        }
        get keys() {
          return Array.from(this.expirations.keys());
        }
        get values() {
          return Array.from(this.expirations.values());
        }
        formatTarget(e) {
          if ("string" == typeof e) return n3("topic", e);
          if ("number" == typeof e) return n3("id", e);
          let { message: t } = oN("UNKNOWN_TYPE", `Target type: ${typeof e}`);
          throw Error(t);
        }
        async setExpirations(e) {
          await this.core.storage.setItem(this.storageKey, e);
        }
        async getExpirations() {
          return await this.core.storage.getItem(this.storageKey);
        }
        async persist() {
          await this.setExpirations(this.values), this.events.emit(lP.sync);
        }
        async restore() {
          try {
            let e = await this.getExpirations();
            if (typeof e > "u" || !e.length) return;
            if (this.expirations.size) {
              let { message: e } = oN("RESTORE_WILL_OVERRIDE", this.name);
              throw (this.logger.error(e), Error(e));
            }
            (this.cached = e),
              this.logger.debug(
                `Successfully Restored expirations for ${this.name}`
              ),
              this.logger.trace({
                type: "method",
                method: "restore",
                expirations: this.values,
              });
          } catch (e) {
            this.logger.debug(`Failed to Restore expirations for ${this.name}`),
              this.logger.error(e);
          }
        }
        getExpiration(e) {
          let t = this.expirations.get(e);
          if (!t) {
            let { message: t } = oN("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw (this.logger.warn(t), Error(t));
          }
          return t;
        }
        checkExpiry(e, t) {
          let { expiry: r } = t;
          (0, v.toMiliseconds)(r) - Date.now() <= 0 && this.expire(e, t);
        }
        expire(e, t) {
          this.expirations.delete(e),
            this.events.emit(lP.expired, { target: e, expiration: t });
        }
        checkExpirations() {
          this.core.relayer.connected &&
            this.expirations.forEach((e, t) => this.checkExpiry(t, e));
        }
        registerEventListeners() {
          this.core.heartbeat.on(_, () => this.checkExpirations()),
            this.events.on(lP.created, (e) => {
              let t = lP.created;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, data: e }),
                this.persist();
            }),
            this.events.on(lP.expired, (e) => {
              let t = lP.expired;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, data: e }),
                this.persist();
            }),
            this.events.on(lP.deleted, (e) => {
              let t = lP.deleted;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, data: e }),
                this.persist();
            });
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = oN("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var uF = Object.defineProperty,
        u$ = (e, t, r) =>
          t in e
            ? uF(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        uH = (e, t, r) => u$(e, "symbol" != typeof t ? t + "" : t, r);
      class uz extends eg {
        constructor(e, t, r) {
          super(e, t, r),
            (this.core = e),
            (this.logger = t),
            (this.store = r),
            uH(this, "name", "verify-api"),
            uH(this, "abortController"),
            uH(this, "isDevEnv"),
            uH(this, "verifyUrlV3", lx),
            uH(this, "storagePrefix", ld),
            uH(this, "version", 2),
            uH(this, "publicKey"),
            uH(this, "fetchPromise"),
            uH(this, "init", async () => {
              var e;
              this.isDevEnv ||
                ((this.publicKey = await this.store.getItem(this.storeKey)),
                this.publicKey &&
                  (0, v.toMiliseconds)(
                    null == (e = this.publicKey) ? void 0 : e.expiresAt
                  ) < Date.now() &&
                  (this.logger.debug("verify v2 public key expired"),
                  await this.removePublicKey()));
            }),
            uH(this, "register", async (e) => {
              if (!nW() || this.isDevEnv) return;
              let t = window.location.origin,
                { id: r, decryptedId: i } = e,
                n = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${t}&id=${r}&decryptedId=${i}`;
              try {
                let e = (0, rV.getDocument)(),
                  t = this.startAbortTimer(5 * v.ONE_SECOND),
                  i = await new Promise((i, s) => {
                    let a = () => {
                      window.removeEventListener("message", l),
                        e.body.removeChild(o),
                        s("attestation aborted");
                    };
                    this.abortController.signal.addEventListener("abort", a);
                    let o = e.createElement("iframe");
                    (o.src = n),
                      (o.style.display = "none"),
                      o.addEventListener("error", a, {
                        signal: this.abortController.signal,
                      });
                    let l = (n) => {
                      if (n.data && "string" == typeof n.data)
                        try {
                          let s = JSON.parse(n.data);
                          if ("verify_attestation" === s.type) {
                            if (rk(s.attestation).payload.id !== r) return;
                            clearInterval(t),
                              e.body.removeChild(o),
                              this.abortController.signal.removeEventListener(
                                "abort",
                                a
                              ),
                              window.removeEventListener("message", l),
                              i(null === s.attestation ? "" : s.attestation);
                          }
                        } catch (e) {
                          this.logger.warn(e);
                        }
                    };
                    e.body.appendChild(o),
                      window.addEventListener("message", l, {
                        signal: this.abortController.signal,
                      });
                  });
                return this.logger.debug("jwt attestation", i), i;
              } catch (e) {
                this.logger.warn(e);
              }
              return "";
            }),
            uH(this, "resolve", async (e) => {
              if (this.isDevEnv) return "";
              let { attestationId: t, hash: r, encryptedId: i } = e;
              if ("" === t) {
                this.logger.debug("resolve: attestationId is empty, skipping");
                return;
              }
              if (t) {
                if (rk(t).payload.id !== i) return;
                let e = await this.isValidJwtAttestation(t);
                if (e) {
                  if (!e.isVerified) {
                    this.logger.warn(
                      "resolve: jwt attestation: origin url not verified"
                    );
                    return;
                  }
                  return e;
                }
              }
              if (!r) return;
              let n = this.getVerifyUrl(e?.verifyUrl);
              return this.fetchAttestation(r, n);
            }),
            uH(this, "fetchAttestation", async (e, t) => {
              this.logger.debug(`resolving attestation: ${e} from url: ${t}`);
              let r = this.startAbortTimer(5 * v.ONE_SECOND),
                i = await fetch(`${t}/attestation/${e}?v2Supported=true`, {
                  signal: this.abortController.signal,
                });
              return (
                clearTimeout(r), 200 === i.status ? await i.json() : void 0
              );
            }),
            uH(this, "getVerifyUrl", (e) => {
              let t = e || lO;
              return (
                lk.includes(t) ||
                  (this.logger.info(
                    `verify url: ${t}, not included in trusted list, assigning default: ${lO}`
                  ),
                  (t = lO)),
                t
              );
            }),
            uH(this, "fetchPublicKey", async () => {
              try {
                this.logger.debug(
                  `fetching public key from: ${this.verifyUrlV3}`
                );
                let e = this.startAbortTimer(v.FIVE_SECONDS),
                  t = await fetch(`${this.verifyUrlV3}/public-key`, {
                    signal: this.abortController.signal,
                  });
                return clearTimeout(e), await t.json();
              } catch (e) {
                this.logger.warn(e);
              }
            }),
            uH(this, "persistPublicKey", async (e) => {
              this.logger.debug("persisting public key to local storage", e),
                await this.store.setItem(this.storeKey, e),
                (this.publicKey = e);
            }),
            uH(this, "removePublicKey", async () => {
              this.logger.debug("removing verify v2 public key from storage"),
                await this.store.removeItem(this.storeKey),
                (this.publicKey = void 0);
            }),
            uH(this, "isValidJwtAttestation", async (e) => {
              let t = await this.getPublicKey();
              try {
                if (t) return this.validateAttestation(e, t);
              } catch (e) {
                this.logger.error(e),
                  this.logger.warn("error validating attestation");
              }
              let r = await this.fetchAndPersistPublicKey();
              try {
                if (r) return this.validateAttestation(e, r);
              } catch (e) {
                this.logger.error(e),
                  this.logger.warn("error validating attestation");
              }
            }),
            uH(this, "getPublicKey", async () =>
              this.publicKey
                ? this.publicKey
                : await this.fetchAndPersistPublicKey()
            ),
            uH(this, "fetchAndPersistPublicKey", async () => {
              if (this.fetchPromise)
                return await this.fetchPromise, this.publicKey;
              this.fetchPromise = new Promise(async (e) => {
                let t = await this.fetchPublicKey();
                t && (await this.persistPublicKey(t), e(t));
              });
              let e = await this.fetchPromise;
              return (this.fetchPromise = void 0), e;
            }),
            uH(this, "validateAttestation", (e, t) => {
              let r = (function (e, t) {
                  let [r, i, n] = e.split("."),
                    s = n$.from(
                      (function (e) {
                        let t = e.replace(/-/g, "+").replace(/_/g, "/"),
                          r = t.length % 4;
                        return r > 0 && (t += "=".repeat(4 - r)), t;
                      })(n),
                      "base64"
                    );
                  if (64 !== s.length) throw Error("Invalid signature length");
                  let a = s.slice(0, 32).toString("hex"),
                    o = s.slice(32, 64).toString("hex"),
                    l = a$(`${r}.${i}`),
                    c = new nB.ec("p256").keyFromPublic(
                      {
                        x: n$.from(t.x, "base64").toString("hex"),
                        y: n$.from(t.y, "base64").toString("hex"),
                      },
                      "hex"
                    ),
                    u = nM(l, oi);
                  if (!c.verify(u, { r: a, s: o }))
                    throw Error("Invalid signature");
                  return rk(e).payload;
                })(e, t.publicKey),
                i = {
                  hasExpired: (0, v.toMiliseconds)(r.exp) < Date.now(),
                  payload: r,
                };
              if (i.hasExpired)
                throw (
                  (this.logger.warn("resolve: jwt attestation expired"),
                  Error("JWT attestation expired"))
                );
              return {
                origin: i.payload.origin,
                isScam: i.payload.isScam,
                isVerified: i.payload.isVerified,
              };
            }),
            (this.logger = (0, ee.Ep)(t, this.name)),
            (this.abortController = new AbortController()),
            (this.isDevEnv = si()),
            this.init();
        }
        get storeKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//verify:public:key"
          );
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        startAbortTimer(e) {
          return (
            (this.abortController = new AbortController()),
            setTimeout(
              () => this.abortController.abort(),
              (0, v.toMiliseconds)(e)
            )
          );
        }
      }
      var uq = Object.defineProperty,
        uV = (e, t, r) =>
          t in e
            ? uq(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        uG = (e, t, r) => uV(e, "symbol" != typeof t ? t + "" : t, r);
      class uW extends em {
        constructor(e, t) {
          super(e, t),
            (this.projectId = e),
            (this.logger = t),
            uG(this, "context", "echo"),
            uG(this, "registerDeviceToken", async (e) => {
              let {
                  clientId: t,
                  token: r,
                  notificationType: i,
                  enableEncrypted: n = !1,
                } = e,
                s = `https://echo.walletconnect.com/${this.projectId}/clients`;
              await fetch(s, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  client_id: t,
                  type: i,
                  token: r,
                  always_raw: n,
                }),
              });
            }),
            (this.logger = (0, ee.Ep)(t, this.context));
        }
      }
      var uK = Object.defineProperty,
        uZ = Object.getOwnPropertySymbols,
        uJ = Object.prototype.hasOwnProperty,
        uQ = Object.prototype.propertyIsEnumerable,
        uY = (e, t, r) =>
          t in e
            ? uK(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        uX = (e, t) => {
          for (var r in t || (t = {})) uJ.call(t, r) && uY(e, r, t[r]);
          if (uZ) for (var r of uZ(t)) uQ.call(t, r) && uY(e, r, t[r]);
          return e;
        },
        u0 = (e, t, r) => uY(e, "symbol" != typeof t ? t + "" : t, r);
      class u1 extends ey {
        constructor(e, t, r = !0) {
          super(e, t, r),
            (this.core = e),
            (this.logger = t),
            u0(this, "context", "event-client"),
            u0(this, "storagePrefix", ld),
            u0(this, "storageVersion", 0.1),
            u0(this, "events", new Map()),
            u0(this, "shouldPersist", !1),
            u0(this, "init", async () => {
              if (!si())
                try {
                  let e = {
                    eventId: sr(),
                    timestamp: Date.now(),
                    domain: this.getAppDomain(),
                    props: {
                      event: "INIT",
                      type: "",
                      properties: {
                        client_id: await this.core.crypto.getClientId(),
                        user_agent: nQ(
                          this.core.relayer.protocol,
                          this.core.relayer.version,
                          lE
                        ),
                      },
                    },
                  };
                  await this.sendEvent([e]);
                } catch (e) {
                  this.logger.warn(e);
                }
            }),
            u0(this, "createEvent", (e) => {
              let {
                  event: t = "ERROR",
                  type: r = "",
                  properties: { topic: i, trace: n },
                } = e,
                s = sr(),
                a = this.core.projectId || "",
                o = uX(
                  {
                    eventId: s,
                    timestamp: Date.now(),
                    props: {
                      event: t,
                      type: r,
                      properties: { topic: i, trace: n },
                    },
                    bundleId: a,
                    domain: this.getAppDomain(),
                  },
                  this.setMethods(s)
                );
              return (
                this.telemetryEnabled &&
                  (this.events.set(s, o), (this.shouldPersist = !0)),
                o
              );
            }),
            u0(this, "getEvent", (e) => {
              let { eventId: t, topic: r } = e;
              if (t) return this.events.get(t);
              let i = Array.from(this.events.values()).find(
                (e) => e.props.properties.topic === r
              );
              if (i) return uX(uX({}, i), this.setMethods(i.eventId));
            }),
            u0(this, "deleteEvent", (e) => {
              let { eventId: t } = e;
              this.events.delete(t), (this.shouldPersist = !0);
            }),
            u0(this, "setEventListeners", () => {
              this.core.heartbeat.on(_, async () => {
                this.shouldPersist && (await this.persist()),
                  this.events.forEach((e) => {
                    (0, v.fromMiliseconds)(Date.now()) -
                      (0, v.fromMiliseconds)(e.timestamp) >
                      86400 &&
                      (this.events.delete(e.eventId),
                      (this.shouldPersist = !0));
                  });
              });
            }),
            u0(this, "setMethods", (e) => ({
              addTrace: (t) => this.addTrace(e, t),
              setError: (t) => this.setError(e, t),
            })),
            u0(this, "addTrace", (e, t) => {
              let r = this.events.get(e);
              r &&
                (r.props.properties.trace.push(t),
                this.events.set(e, r),
                (this.shouldPersist = !0));
            }),
            u0(this, "setError", (e, t) => {
              let r = this.events.get(e);
              r &&
                ((r.props.type = t),
                (r.timestamp = Date.now()),
                this.events.set(e, r),
                (this.shouldPersist = !0));
            }),
            u0(this, "persist", async () => {
              await this.core.storage.setItem(
                this.storageKey,
                Array.from(this.events.values())
              ),
                (this.shouldPersist = !1);
            }),
            u0(this, "restore", async () => {
              try {
                let e =
                  (await this.core.storage.getItem(this.storageKey)) || [];
                if (!e.length) return;
                e.forEach((e) => {
                  this.events.set(
                    e.eventId,
                    uX(uX({}, e), this.setMethods(e.eventId))
                  );
                });
              } catch (e) {
                this.logger.warn(e);
              }
            }),
            u0(this, "submit", async () => {
              if (!this.telemetryEnabled || 0 === this.events.size) return;
              let e = [];
              for (let [t, r] of this.events) r.props.type && e.push(r);
              if (0 !== e.length)
                try {
                  if ((await this.sendEvent(e)).ok)
                    for (let t of e)
                      this.events.delete(t.eventId), (this.shouldPersist = !0);
                } catch (e) {
                  this.logger.warn(e);
                }
            }),
            u0(this, "sendEvent", async (e) => {
              let t = this.getAppDomain() ? "" : "&sp=desktop";
              return await fetch(
                `https://pulse.walletconnect.org/batch?projectId=${this.core.projectId}&st=events_sdk&sv=js-${lE}${t}`,
                { method: "POST", body: JSON.stringify(e) }
              );
            }),
            u0(this, "getAppDomain", () => nJ().url),
            (this.logger = (0, ee.Ep)(t, this.context)),
            (this.telemetryEnabled = r),
            r
              ? this.restore().then(async () => {
                  await this.submit(), this.setEventListeners();
                })
              : this.persist();
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.storageVersion +
            this.core.customStoragePrefix +
            "//" +
            this.context
          );
        }
      }
      var u2 = Object.defineProperty,
        u3 = Object.getOwnPropertySymbols,
        u5 = Object.prototype.hasOwnProperty,
        u8 = Object.prototype.propertyIsEnumerable,
        u4 = (e, t, r) =>
          t in e
            ? u2(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        u6 = (e, t) => {
          for (var r in t || (t = {})) u5.call(t, r) && u4(e, r, t[r]);
          if (u3) for (var r of u3(t)) u8.call(t, r) && u4(e, r, t[r]);
          return e;
        },
        u9 = (e, t, r) => u4(e, "symbol" != typeof t ? t + "" : t, r);
      class u7 extends en {
        constructor(e) {
          var t;
          super(e),
            u9(this, "protocol", "wc"),
            u9(this, "version", 2),
            u9(this, "name", lh),
            u9(this, "relayUrl"),
            u9(this, "projectId"),
            u9(this, "customStoragePrefix"),
            u9(this, "events", new w.EventEmitter()),
            u9(this, "logger"),
            u9(this, "heartbeat"),
            u9(this, "relayer"),
            u9(this, "crypto"),
            u9(this, "storage"),
            u9(this, "history"),
            u9(this, "expirer"),
            u9(this, "pairing"),
            u9(this, "verify"),
            u9(this, "echoClient"),
            u9(this, "linkModeSupportedApps"),
            u9(this, "eventClient"),
            u9(this, "initialized", !1),
            u9(this, "logChunkController"),
            u9(this, "on", (e, t) => this.events.on(e, t)),
            u9(this, "once", (e, t) => this.events.once(e, t)),
            u9(this, "off", (e, t) => this.events.off(e, t)),
            u9(this, "removeListener", (e, t) =>
              this.events.removeListener(e, t)
            ),
            u9(
              this,
              "dispatchEnvelope",
              ({ topic: e, message: t, sessionExists: r }) => {
                if (!e || !t) return;
                let i = {
                  topic: e,
                  message: t,
                  publishedAt: Date.now(),
                  transportType: lA.link_mode,
                };
                this.relayer.onLinkMessageEvent(i, { sessionExists: r });
              }
            ),
            (this.projectId = e?.projectId),
            (this.relayUrl = e?.relayUrl || lw),
            (this.customStoragePrefix =
              null != e && e.customStoragePrefix
                ? `:${e.customStoragePrefix}`
                : "");
          let r = (0, ee.jI)({
              level:
                "string" == typeof e?.logger && e.logger ? e.logger : lp.logger,
              name: lh,
            }),
            { logger: i, chunkLoggerController: n } = (0, ee.Rt)({
              opts: r,
              maxSizeInBytes: e?.maxLogBlobSizeInBytes,
              loggerOverride: e?.logger,
            });
          (this.logChunkController = n),
            null != (t = this.logChunkController) &&
              t.downloadLogsBlobInBrowser &&
              (window.downloadLogsBlobInBrowser = async () => {
                var e, t;
                null != (e = this.logChunkController) &&
                  e.downloadLogsBlobInBrowser &&
                  (null == (t = this.logChunkController) ||
                    t.downloadLogsBlobInBrowser({
                      clientId: await this.crypto.getClientId(),
                    }));
              }),
            (this.logger = (0, ee.Ep)(i, this.name)),
            (this.heartbeat = new I()),
            (this.crypto = new ck(this, this.logger, e?.keychain)),
            (this.history = new uU(this, this.logger)),
            (this.expirer = new uj(this, this.logger)),
            (this.storage =
              null != e && e.storage
                ? e.storage
                : new X(u6(u6({}, lf), e?.storageOptions))),
            (this.relayer = new up({
              core: this,
              logger: this.logger,
              relayUrl: this.relayUrl,
              projectId: this.projectId,
            })),
            (this.pairing = new ux(this, this.logger)),
            (this.verify = new uz(this, this.logger, this.storage)),
            (this.echoClient = new uW(this.projectId || "", this.logger)),
            (this.linkModeSupportedApps = []),
            (this.eventClient = new u1(this, this.logger, e?.telemetryEnabled));
        }
        static async init(e) {
          let t = new u7(e);
          await t.initialize();
          let r = await t.crypto.getClientId();
          return await t.storage.setItem("WALLETCONNECT_CLIENT_ID", r), t;
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        async start() {
          this.initialized || (await this.initialize());
        }
        async getLogsBlob() {
          var e;
          return null == (e = this.logChunkController)
            ? void 0
            : e.logsToBlob({ clientId: await this.crypto.getClientId() });
        }
        async addLinkModeSupportedApp(e) {
          this.linkModeSupportedApps.includes(e) ||
            (this.linkModeSupportedApps.push(e),
            await this.storage.setItem(l_, this.linkModeSupportedApps));
        }
        async initialize() {
          this.logger.trace("Initialized");
          try {
            await this.crypto.init(),
              await this.history.init(),
              await this.expirer.init(),
              await this.relayer.init(),
              await this.heartbeat.init(),
              await this.pairing.init(),
              (this.linkModeSupportedApps =
                (await this.storage.getItem(l_)) || []),
              (this.initialized = !0),
              this.logger.info("Core Initialization Success");
          } catch (e) {
            throw (
              (this.logger.warn(
                `Core Initialization Failure at epoch ${Date.now()}`,
                e
              ),
              this.logger.error(e.message),
              e)
            );
          }
        }
      }
      let he = "client",
        ht = `wc@2:${he}:`,
        hr = { name: he, logger: "error" },
        hi = "WALLETCONNECT_DEEPLINK_CHOICE",
        hn = "Proposal expired",
        hs = v.SEVEN_DAYS,
        ha = {
          wc_sessionPropose: {
            req: { ttl: v.FIVE_MINUTES, prompt: !0, tag: 1100 },
            res: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1101 },
            reject: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1120 },
            autoReject: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1121 },
          },
          wc_sessionSettle: {
            req: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1102 },
            res: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1103 },
          },
          wc_sessionUpdate: {
            req: { ttl: v.ONE_DAY, prompt: !1, tag: 1104 },
            res: { ttl: v.ONE_DAY, prompt: !1, tag: 1105 },
          },
          wc_sessionExtend: {
            req: { ttl: v.ONE_DAY, prompt: !1, tag: 1106 },
            res: { ttl: v.ONE_DAY, prompt: !1, tag: 1107 },
          },
          wc_sessionRequest: {
            req: { ttl: v.FIVE_MINUTES, prompt: !0, tag: 1108 },
            res: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1109 },
          },
          wc_sessionEvent: {
            req: { ttl: v.FIVE_MINUTES, prompt: !0, tag: 1110 },
            res: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1111 },
          },
          wc_sessionDelete: {
            req: { ttl: v.ONE_DAY, prompt: !1, tag: 1112 },
            res: { ttl: v.ONE_DAY, prompt: !1, tag: 1113 },
          },
          wc_sessionPing: {
            req: { ttl: v.ONE_DAY, prompt: !1, tag: 1114 },
            res: { ttl: v.ONE_DAY, prompt: !1, tag: 1115 },
          },
          wc_sessionAuthenticate: {
            req: { ttl: v.ONE_HOUR, prompt: !0, tag: 1116 },
            res: { ttl: v.ONE_HOUR, prompt: !1, tag: 1117 },
            reject: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1118 },
            autoReject: { ttl: v.FIVE_MINUTES, prompt: !1, tag: 1119 },
          },
        },
        ho = { min: v.FIVE_MINUTES, max: v.SEVEN_DAYS },
        hl = { idle: "IDLE", active: "ACTIVE" },
        hc = {
          eth_sendTransaction: { key: "" },
          eth_sendRawTransaction: { key: "" },
          wallet_sendCalls: { key: "" },
          solana_signTransaction: { key: "signature" },
          solana_signAllTransactions: { key: "transactions" },
          solana_signAndSendTransaction: { key: "signature" },
        },
        hu = [
          "wc_sessionPropose",
          "wc_sessionRequest",
          "wc_authRequest",
          "wc_sessionAuthenticate",
        ],
        hh = "wc@1.5:auth:",
        hd = `${hh}:PUB_KEY`;
      var hp = Object.defineProperty,
        hf = Object.defineProperties,
        hg = Object.getOwnPropertyDescriptors,
        hm = Object.getOwnPropertySymbols,
        hy = Object.prototype.hasOwnProperty,
        hw = Object.prototype.propertyIsEnumerable,
        hb = (e, t, r) =>
          t in e
            ? hp(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        hv = (e, t) => {
          for (var r in t || (t = {})) hy.call(t, r) && hb(e, r, t[r]);
          if (hm) for (var r of hm(t)) hw.call(t, r) && hb(e, r, t[r]);
          return e;
        },
        hE = (e, t) => hf(e, hg(t)),
        hA = (e, t, r) => hb(e, "symbol" != typeof t ? t + "" : t, r);
      class hC extends eA {
        constructor(e) {
          super(e),
            hA(this, "name", "engine"),
            hA(this, "events", new (b())()),
            hA(this, "initialized", !1),
            hA(this, "requestQueue", { state: hl.idle, queue: [] }),
            hA(this, "sessionRequestQueue", { state: hl.idle, queue: [] }),
            hA(this, "requestQueueDelay", v.ONE_SECOND),
            hA(this, "expectedPairingMethodMap", new Map()),
            hA(this, "recentlyDeletedMap", new Map()),
            hA(this, "recentlyDeletedLimit", 200),
            hA(this, "relayMessageCache", []),
            hA(this, "pendingSessions", new Map()),
            hA(this, "init", async () => {
              this.initialized ||
                (await this.cleanup(),
                this.registerRelayerEvents(),
                this.registerExpirerEvents(),
                this.registerPairingEvents(),
                await this.registerLinkModeListeners(),
                this.client.core.pairing.register({ methods: Object.keys(ha) }),
                (this.initialized = !0),
                setTimeout(async () => {
                  await this.processPendingMessageEvents(),
                    (this.sessionRequestQueue.queue =
                      this.getPendingSessionRequests()),
                    this.processSessionRequestQueue();
                }, (0, v.toMiliseconds)(this.requestQueueDelay)));
            }),
            hA(this, "connect", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              let t = hE(hv({}, e), {
                requiredNamespaces: e.requiredNamespaces || {},
                optionalNamespaces: e.optionalNamespaces || {},
              });
              await this.isValidConnect(t);
              let {
                  pairingTopic: r,
                  requiredNamespaces: i,
                  optionalNamespaces: n,
                  sessionProperties: s,
                  scopedProperties: a,
                  relays: o,
                } = t,
                l = r,
                c,
                u = !1;
              try {
                if (l) {
                  let e = this.client.core.pairing.pairings.get(l);
                  this.client.logger.warn(
                    "connect() with existing pairing topic is deprecated and will be removed in the next major release."
                  ),
                    (u = e.active);
                }
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    `connect() -> pairing.get(${l}) failed`
                  ),
                  e)
                );
              }
              if (!l || !u) {
                let { topic: e, uri: t } =
                  await this.client.core.pairing.create();
                (l = e), (c = t);
              }
              if (!l) {
                let { message: e } = oN(
                  "NO_MATCHING_KEY",
                  `connect() pairing topic: ${l}`
                );
                throw Error(e);
              }
              let h = await this.client.core.crypto.generateKeyPair(),
                d = ha.wc_sessionPropose.req.ttl || v.FIVE_MINUTES,
                p = n8(d),
                f = hE(
                  hv(
                    hv(
                      {
                        requiredNamespaces: i,
                        optionalNamespaces: n,
                        relays: o ?? [{ protocol: "irn" }],
                        proposer: {
                          publicKey: h,
                          metadata: this.client.metadata,
                        },
                        expiryTimestamp: p,
                        pairingTopic: l,
                      },
                      s && { sessionProperties: s }
                    ),
                    a && { scopedProperties: a }
                  ),
                  { id: oX() }
                ),
                g = n6("session_connect", f.id),
                { reject: m, resolve: y, done: w } = n1(d, hn),
                b = ({ id: e }) => {
                  e === f.id &&
                    (this.client.events.off("proposal_expire", b),
                    this.pendingSessions.delete(f.id),
                    this.events.emit(g, { error: { message: hn, code: 0 } }));
                };
              return (
                this.client.events.on("proposal_expire", b),
                this.events.once(g, ({ error: e, session: t }) => {
                  this.client.events.off("proposal_expire", b),
                    e ? m(e) : t && y(t);
                }),
                await this.sendRequest({
                  topic: l,
                  method: "wc_sessionPropose",
                  params: f,
                  throwOnFailedPublish: !0,
                  clientRpcId: f.id,
                }),
                await this.setProposal(f.id, f),
                { uri: c, approval: w }
              );
            }),
            hA(this, "pair", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                return await this.client.core.pairing.pair(e);
              } catch (e) {
                throw (this.client.logger.error("pair() failed"), e);
              }
            }),
            hA(this, "approve", async (e) => {
              var t, r, i;
              let n = this.client.core.eventClient.createEvent({
                properties: {
                  topic: null == (t = e?.id) ? void 0 : t.toString(),
                  trace: [lU.session_approve_started],
                },
              });
              try {
                this.isInitialized(), await this.confirmOnlineStateOrThrow();
              } catch (e) {
                throw (n.setError(lL.no_internet_connection), e);
              }
              try {
                await this.isValidProposalId(e?.id);
              } catch (t) {
                throw (
                  (this.client.logger.error(
                    `approve() -> proposal.get(${e?.id}) failed`
                  ),
                  n.setError(lL.proposal_not_found),
                  t)
                );
              }
              try {
                await this.isValidApprove(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "approve() -> isValidApprove() failed"
                  ),
                  n.setError(lL.session_approve_namespace_validation_failure),
                  e)
                );
              }
              let {
                  id: s,
                  relayProtocol: a,
                  namespaces: o,
                  sessionProperties: l,
                  scopedProperties: c,
                  sessionConfig: u,
                } = e,
                h = this.client.proposal.get(s);
              this.client.core.eventClient.deleteEvent({ eventId: n.eventId });
              let {
                  pairingTopic: d,
                  proposer: p,
                  requiredNamespaces: f,
                  optionalNamespaces: g,
                } = h,
                m =
                  null == (r = this.client.core.eventClient)
                    ? void 0
                    : r.getEvent({ topic: d });
              m ||
                (m =
                  null == (i = this.client.core.eventClient)
                    ? void 0
                    : i.createEvent({
                        type: lU.session_approve_started,
                        properties: {
                          topic: d,
                          trace: [
                            lU.session_approve_started,
                            lU.session_namespaces_validation_success,
                          ],
                        },
                      }));
              let y = await this.client.core.crypto.generateKeyPair(),
                w = p.publicKey,
                b = await this.client.core.crypto.generateSharedKey(y, w),
                v = hv(
                  hv(
                    hv(
                      {
                        relay: { protocol: a ?? "irn" },
                        namespaces: o,
                        controller: {
                          publicKey: y,
                          metadata: this.client.metadata,
                        },
                        expiry: n8(hs),
                      },
                      l && { sessionProperties: l }
                    ),
                    c && { scopedProperties: c }
                  ),
                  u && { sessionConfig: u }
                ),
                E = lA.relay;
              m.addTrace(lU.subscribing_session_topic);
              try {
                await this.client.core.relayer.subscribe(b, {
                  transportType: E,
                });
              } catch (e) {
                throw (m.setError(lL.subscribe_session_topic_failure), e);
              }
              m.addTrace(lU.subscribe_session_topic_success);
              let A = hE(hv({}, v), {
                topic: b,
                requiredNamespaces: f,
                optionalNamespaces: g,
                pairingTopic: d,
                acknowledged: !1,
                self: v.controller,
                peer: { publicKey: p.publicKey, metadata: p.metadata },
                controller: y,
                transportType: lA.relay,
              });
              await this.client.session.set(b, A), m.addTrace(lU.store_session);
              try {
                m.addTrace(lU.publishing_session_settle),
                  await this.sendRequest({
                    topic: b,
                    method: "wc_sessionSettle",
                    params: v,
                    throwOnFailedPublish: !0,
                  }).catch((e) => {
                    throw (m?.setError(lL.session_settle_publish_failure), e);
                  }),
                  m.addTrace(lU.session_settle_publish_success),
                  m.addTrace(lU.publishing_session_approve),
                  await this.sendResult({
                    id: s,
                    topic: d,
                    result: {
                      relay: { protocol: a ?? "irn" },
                      responderPublicKey: y,
                    },
                    throwOnFailedPublish: !0,
                  }).catch((e) => {
                    throw (m?.setError(lL.session_approve_publish_failure), e);
                  }),
                  m.addTrace(lU.session_approve_publish_success);
              } catch (e) {
                throw (
                  (this.client.logger.error(e),
                  this.client.session.delete(b, oS("USER_DISCONNECTED")),
                  await this.client.core.relayer.unsubscribe(b),
                  e)
                );
              }
              return (
                this.client.core.eventClient.deleteEvent({
                  eventId: m.eventId,
                }),
                await this.client.core.pairing.updateMetadata({
                  topic: d,
                  metadata: p.metadata,
                }),
                await this.client.proposal.delete(s, oS("USER_DISCONNECTED")),
                await this.client.core.pairing.activate({ topic: d }),
                await this.setExpiry(b, n8(hs)),
                {
                  topic: b,
                  acknowledged: () =>
                    Promise.resolve(this.client.session.get(b)),
                }
              );
            }),
            hA(this, "reject", async (e) => {
              let t;
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidReject(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "reject() -> isValidReject() failed"
                  ),
                  e)
                );
              }
              let { id: r, reason: i } = e;
              try {
                t = this.client.proposal.get(r).pairingTopic;
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    `reject() -> proposal.get(${r}) failed`
                  ),
                  e)
                );
              }
              t &&
                (await this.sendError({
                  id: r,
                  topic: t,
                  error: i,
                  rpcOpts: ha.wc_sessionPropose.reject,
                }),
                await this.client.proposal.delete(r, oS("USER_DISCONNECTED")));
            }),
            hA(this, "update", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidUpdate(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "update() -> isValidUpdate() failed"
                  ),
                  e)
                );
              }
              let { topic: t, namespaces: r } = e,
                { done: i, resolve: n, reject: s } = n1(),
                a = oX(),
                o = o0().toString(),
                l = this.client.session.get(t).namespaces;
              return (
                this.events.once(n6("session_update", a), ({ error: e }) => {
                  e ? s(e) : n();
                }),
                await this.client.session.update(t, { namespaces: r }),
                await this.sendRequest({
                  topic: t,
                  method: "wc_sessionUpdate",
                  params: { namespaces: r },
                  throwOnFailedPublish: !0,
                  clientRpcId: a,
                  relayRpcId: o,
                }).catch((e) => {
                  this.client.logger.error(e),
                    this.client.session.update(t, { namespaces: l }),
                    s(e);
                }),
                { acknowledged: i }
              );
            }),
            hA(this, "extend", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidExtend(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "extend() -> isValidExtend() failed"
                  ),
                  e)
                );
              }
              let { topic: t } = e,
                r = oX(),
                { done: i, resolve: n, reject: s } = n1();
              return (
                this.events.once(n6("session_extend", r), ({ error: e }) => {
                  e ? s(e) : n();
                }),
                await this.setExpiry(t, n8(hs)),
                this.sendRequest({
                  topic: t,
                  method: "wc_sessionExtend",
                  params: {},
                  clientRpcId: r,
                  throwOnFailedPublish: !0,
                }).catch((e) => {
                  s(e);
                }),
                { acknowledged: i }
              );
            }),
            hA(this, "request", async (e) => {
              this.isInitialized();
              try {
                await this.isValidRequest(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "request() -> isValidRequest() failed"
                  ),
                  e)
                );
              }
              let {
                  chainId: t,
                  request: r,
                  topic: i,
                  expiry: n = ha.wc_sessionRequest.req.ttl,
                } = e,
                s = this.client.session.get(i);
              s?.transportType === lA.relay &&
                (await this.confirmOnlineStateOrThrow());
              let a = oX(),
                o = o0().toString(),
                {
                  done: l,
                  resolve: c,
                  reject: u,
                } = n1(n, "Request expired. Please try again.");
              this.events.once(
                n6("session_request", a),
                ({ error: e, result: t }) => {
                  e ? u(e) : c(t);
                }
              );
              let h = "wc_sessionRequest",
                d = this.getAppLinkIfEnabled(s.peer.metadata, s.transportType);
              if (d)
                return (
                  await this.sendRequest({
                    clientRpcId: a,
                    relayRpcId: o,
                    topic: i,
                    method: h,
                    params: {
                      request: hE(hv({}, r), { expiryTimestamp: n8(n) }),
                      chainId: t,
                    },
                    expiry: n,
                    throwOnFailedPublish: !0,
                    appLink: d,
                  }).catch((e) => u(e)),
                  this.client.events.emit("session_request_sent", {
                    topic: i,
                    request: r,
                    chainId: t,
                    id: a,
                  }),
                  await l()
                );
              let p = {
                  request: hE(hv({}, r), { expiryTimestamp: n8(n) }),
                  chainId: t,
                },
                f = this.shouldSetTVF(h, p);
              return await Promise.all([
                new Promise(async (e) => {
                  await this.sendRequest(
                    hv(
                      {
                        clientRpcId: a,
                        relayRpcId: o,
                        topic: i,
                        method: h,
                        params: p,
                        expiry: n,
                        throwOnFailedPublish: !0,
                      },
                      f && { tvf: this.getTVFParams(a, p) }
                    )
                  ).catch((e) => u(e)),
                    this.client.events.emit("session_request_sent", {
                      topic: i,
                      request: r,
                      chainId: t,
                      id: a,
                    }),
                    e();
                }),
                new Promise(async (e) => {
                  var t;
                  if (!(null != (t = s.sessionConfig) && t.disableDeepLink)) {
                    let e = await se(this.client.core.storage, hi);
                    await n7({ id: a, topic: i, wcDeepLink: e });
                  }
                  e();
                }),
                l(),
              ]).then((e) => e[2]);
            }),
            hA(this, "respond", async (e) => {
              this.isInitialized(), await this.isValidRespond(e);
              let { topic: t, response: r } = e,
                { id: i } = r,
                n = this.client.session.get(t);
              n.transportType === lA.relay &&
                (await this.confirmOnlineStateOrThrow());
              let s = this.getAppLinkIfEnabled(
                n.peer.metadata,
                n.transportType
              );
              li(r)
                ? await this.sendResult({
                    id: i,
                    topic: t,
                    result: r.result,
                    throwOnFailedPublish: !0,
                    appLink: s,
                  })
                : ln(r) &&
                  (await this.sendError({
                    id: i,
                    topic: t,
                    error: r.error,
                    appLink: s,
                  })),
                this.cleanupAfterResponse(e);
            }),
            hA(this, "ping", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidPing(e);
              } catch (e) {
                throw (
                  (this.client.logger.error("ping() -> isValidPing() failed"),
                  e)
                );
              }
              let { topic: t } = e;
              if (this.client.session.keys.includes(t)) {
                let e = oX(),
                  r = o0().toString(),
                  { done: i, resolve: n, reject: s } = n1();
                this.events.once(n6("session_ping", e), ({ error: e }) => {
                  e ? s(e) : n();
                }),
                  await Promise.all([
                    this.sendRequest({
                      topic: t,
                      method: "wc_sessionPing",
                      params: {},
                      throwOnFailedPublish: !0,
                      clientRpcId: e,
                      relayRpcId: r,
                    }),
                    i(),
                  ]);
              } else
                this.client.core.pairing.pairings.keys.includes(t) &&
                  (this.client.logger.warn(
                    "ping() on pairing topic is deprecated and will be removed in the next major release."
                  ),
                  await this.client.core.pairing.ping({ topic: t }));
            }),
            hA(this, "emit", async (e) => {
              this.isInitialized(),
                await this.confirmOnlineStateOrThrow(),
                await this.isValidEmit(e);
              let { topic: t, event: r, chainId: i } = e,
                n = o0().toString(),
                s = oX();
              await this.sendRequest({
                topic: t,
                method: "wc_sessionEvent",
                params: { event: r, chainId: i },
                throwOnFailedPublish: !0,
                relayRpcId: n,
                clientRpcId: s,
              });
            }),
            hA(this, "disconnect", async (e) => {
              this.isInitialized(),
                await this.confirmOnlineStateOrThrow(),
                await this.isValidDisconnect(e);
              let { topic: t } = e;
              if (this.client.session.keys.includes(t))
                await this.sendRequest({
                  topic: t,
                  method: "wc_sessionDelete",
                  params: oS("USER_DISCONNECTED"),
                  throwOnFailedPublish: !0,
                }),
                  await this.deleteSession({ topic: t, emitEvent: !1 });
              else if (this.client.core.pairing.pairings.keys.includes(t))
                await this.client.core.pairing.disconnect({ topic: t });
              else {
                let { message: e } = oN(
                  "MISMATCHED_TOPIC",
                  `Session or pairing topic not found: ${t}`
                );
                throw Error(e);
              }
            }),
            hA(
              this,
              "find",
              (e) => (
                this.isInitialized(),
                this.client.session.getAll().filter((t) =>
                  (function (e, t) {
                    let { requiredNamespaces: r } = t,
                      i = Object.keys(e.namespaces),
                      n = Object.keys(r),
                      s = !0;
                    return (
                      !!nY(n, i) &&
                      (i.forEach((t) => {
                        let {
                            accounts: i,
                            methods: n,
                            events: a,
                          } = e.namespaces[t],
                          o = ov(i),
                          l = r[t];
                        (nY(nz(t, l), o) &&
                          nY(l.methods, n) &&
                          nY(l.events, a)) ||
                          (s = !1);
                      }),
                      s)
                    );
                  })(t, e)
                )
              )
            ),
            hA(this, "getPendingSessionRequests", () =>
              this.client.pendingRequest.getAll()
            ),
            hA(this, "authenticate", async (e, t) => {
              var r, i, n;
              let s;
              this.isInitialized(), this.isValidAuthenticate(e);
              let a =
                  t &&
                  this.client.core.linkModeSupportedApps.includes(t) &&
                  (null == (r = this.client.metadata.redirect)
                    ? void 0
                    : r.linkMode),
                o = a ? lA.link_mode : lA.relay;
              o === lA.relay && (await this.confirmOnlineStateOrThrow());
              let {
                  chains: l,
                  statement: c = "",
                  uri: u,
                  domain: h,
                  nonce: d,
                  type: p,
                  exp: f,
                  nbf: g,
                  methods: m = [],
                  expiry: y,
                } = e,
                w = [...(e.resources || [])],
                { topic: b, uri: v } = await this.client.core.pairing.create({
                  methods: ["wc_sessionAuthenticate"],
                  transportType: o,
                });
              this.client.logger.info({
                message: "Generated new pairing",
                pairing: { topic: b, uri: v },
              });
              let E = await this.client.core.crypto.generateKeyPair(),
                A = ol(E);
              if (
                (await Promise.all([
                  this.client.auth.authKeys.set(hd, {
                    responseTopic: A,
                    publicKey: E,
                  }),
                  this.client.auth.pairingTopics.set(A, {
                    topic: A,
                    pairingTopic: b,
                  }),
                ]),
                await this.client.core.relayer.subscribe(A, {
                  transportType: o,
                }),
                this.client.logger.info(
                  `sending request to new pairing topic: ${b}`
                ),
                m.length > 0)
              ) {
                let { namespace: e } = nH(l[0]),
                  t = s4(
                    (function (e, t, r, i = {}) {
                      return (
                        r?.sort((e, t) => e.localeCompare(t)),
                        {
                          att: {
                            [e]: (function (e, t, r = {}) {
                              return Object.assign(
                                {},
                                ...(t = t?.sort((e, t) =>
                                  e.localeCompare(t)
                                )).map((t) => ({ [`${e}/${t}`]: [r] }))
                              );
                            })(t, r, i),
                          },
                        }
                      );
                    })(e, "request", m)
                  );
                ae(w) &&
                  ((i = t),
                  (n = w.pop()),
                  (t = s4(
                    (function (e, t) {
                      s8(e), s8(t);
                      let r = Object.keys(e.att)
                          .concat(Object.keys(t.att))
                          .sort((e, t) => e.localeCompare(t)),
                        i = { att: {} };
                      return (
                        r.forEach((r) => {
                          var n, s;
                          Object.keys(
                            (null == (n = e.att) ? void 0 : n[r]) || {}
                          )
                            .concat(
                              Object.keys(
                                (null == (s = t.att) ? void 0 : s[r]) || {}
                              )
                            )
                            .sort((e, t) => e.localeCompare(t))
                            .forEach((n) => {
                              var s, a;
                              i.att[r] = sY(sQ({}, i.att[r]), {
                                [n]:
                                  (null == (s = e.att[r]) ? void 0 : s[n]) ||
                                  (null == (a = t.att[r]) ? void 0 : a[n]),
                              });
                            });
                        }),
                        i
                      );
                    })(s6(i), s6(n))
                  ))),
                  w.push(t);
              }
              let C =
                  y && y > ha.wc_sessionAuthenticate.req.ttl
                    ? y
                    : ha.wc_sessionAuthenticate.req.ttl,
                _ = {
                  authPayload: {
                    type: p ?? "caip122",
                    chains: l,
                    statement: c,
                    aud: u,
                    domain: h,
                    version: "1",
                    nonce: d,
                    iat: new Date().toISOString(),
                    exp: f,
                    nbf: g,
                    resources: w,
                  },
                  requester: { publicKey: E, metadata: this.client.metadata },
                  expiryTimestamp: n8(C),
                },
                I = {
                  requiredNamespaces: {},
                  optionalNamespaces: {
                    eip155: {
                      chains: l,
                      methods: [...new Set(["personal_sign", ...m])],
                      events: ["chainChanged", "accountsChanged"],
                    },
                  },
                  relays: [{ protocol: "irn" }],
                  pairingTopic: b,
                  proposer: { publicKey: E, metadata: this.client.metadata },
                  expiryTimestamp: n8(ha.wc_sessionPropose.req.ttl),
                  id: oX(),
                },
                { done: N, resolve: S, reject: T } = n1(C, "Request expired"),
                P = oX(),
                O = n6("session_connect", I.id),
                x = n6("session_request", P),
                k = async ({ error: e, session: t }) => {
                  this.events.off(x, R), e ? T(e) : t && S({ session: t });
                },
                R = async (e) => {
                  var r, i, n;
                  let s;
                  if (
                    (await this.deletePendingAuthRequest(P, {
                      message: "fulfilled",
                      code: 0,
                    }),
                    e.error)
                  ) {
                    let t = oS(
                      "WC_METHOD_UNSUPPORTED",
                      "wc_sessionAuthenticate"
                    );
                    return e.error.code === t.code
                      ? void 0
                      : (this.events.off(O, k), T(e.error.message));
                  }
                  await this.deleteProposal(I.id), this.events.off(O, k);
                  let { cacaos: a, responder: l } = e.result,
                    c = [],
                    u = [];
                  for (let e of a) {
                    (await s3({
                      cacao: e,
                      projectId: this.client.core.projectId,
                    })) ||
                      (this.client.logger.error(
                        e,
                        "Signature verification failed"
                      ),
                      T(
                        oS(
                          "SESSION_SETTLEMENT_FAILED",
                          "Signature verification failed"
                        )
                      ));
                    let { p: t } = e,
                      r = ae(t.resources),
                      i = [s1(t.iss)],
                      n = s2(t.iss);
                    if (r) {
                      let e = s9(r),
                        t = s7(r);
                      c.push(...e), i.push(...t);
                    }
                    for (let e of i) u.push(`${e}:${n}`);
                  }
                  let h = await this.client.core.crypto.generateSharedKey(
                    E,
                    l.publicKey
                  );
                  c.length > 0 &&
                    ((s = {
                      topic: h,
                      acknowledged: !0,
                      self: { publicKey: E, metadata: this.client.metadata },
                      peer: l,
                      controller: l.publicKey,
                      expiry: n8(hs),
                      requiredNamespaces: {},
                      optionalNamespaces: {},
                      relay: { protocol: "irn" },
                      pairingTopic: b,
                      namespaces: oC([...new Set(c)], [...new Set(u)]),
                      transportType: o,
                    }),
                    await this.client.core.relayer.subscribe(h, {
                      transportType: o,
                    }),
                    await this.client.session.set(h, s),
                    b &&
                      (await this.client.core.pairing.updateMetadata({
                        topic: b,
                        metadata: l.metadata,
                      })),
                    (s = this.client.session.get(h))),
                    null != (r = this.client.metadata.redirect) &&
                      r.linkMode &&
                      null != (i = l.metadata.redirect) &&
                      i.linkMode &&
                      null != (n = l.metadata.redirect) &&
                      n.universal &&
                      t &&
                      (this.client.core.addLinkModeSupportedApp(
                        l.metadata.redirect.universal
                      ),
                      this.client.session.update(h, {
                        transportType: lA.link_mode,
                      })),
                    S({ auths: a, session: s });
                };
              this.events.once(O, k), this.events.once(x, R);
              try {
                if (a) {
                  let e = o1("wc_sessionAuthenticate", _, P);
                  this.client.core.history.set(b, e);
                  let r = await this.client.core.crypto.encode("", e, {
                    type: 2,
                    encoding: os,
                  });
                  s = ob(t, b, r);
                } else
                  await Promise.all([
                    this.sendRequest({
                      topic: b,
                      method: "wc_sessionAuthenticate",
                      params: _,
                      expiry: e.expiry,
                      throwOnFailedPublish: !0,
                      clientRpcId: P,
                    }),
                    this.sendRequest({
                      topic: b,
                      method: "wc_sessionPropose",
                      params: I,
                      expiry: ha.wc_sessionPropose.req.ttl,
                      throwOnFailedPublish: !0,
                      clientRpcId: I.id,
                    }),
                  ]);
              } catch (e) {
                throw (this.events.off(O, k), this.events.off(x, R), e);
              }
              return (
                await this.setProposal(I.id, I),
                await this.setAuthRequest(P, {
                  request: hE(hv({}, _), { verifyContext: {} }),
                  pairingTopic: b,
                  transportType: o,
                }),
                { uri: s ?? v, response: N }
              );
            }),
            hA(this, "approveSessionAuthenticate", async (e) => {
              let t;
              let { id: r, auths: i } = e,
                n = this.client.core.eventClient.createEvent({
                  properties: {
                    topic: r.toString(),
                    trace: [lM.authenticated_session_approve_started],
                  },
                });
              try {
                this.isInitialized();
              } catch (e) {
                throw (n.setError(lB.no_internet_connection), e);
              }
              let s = this.getPendingAuthRequest(r);
              if (!s)
                throw (
                  (n.setError(
                    lB.authenticated_session_pending_request_not_found
                  ),
                  Error(`Could not find pending auth request with id ${r}`))
                );
              let a = s.transportType || lA.relay;
              a === lA.relay && (await this.confirmOnlineStateOrThrow());
              let o = s.requester.publicKey,
                l = await this.client.core.crypto.generateKeyPair(),
                c = ol(o),
                u = { type: 1, receiverPublicKey: o, senderPublicKey: l },
                h = [],
                d = [];
              for (let e of i) {
                if (
                  !(await s3({
                    cacao: e,
                    projectId: this.client.core.projectId,
                  }))
                ) {
                  n.setError(lB.invalid_cacao);
                  let e = oS(
                    "SESSION_SETTLEMENT_FAILED",
                    "Signature verification failed"
                  );
                  throw (
                    (await this.sendError({
                      id: r,
                      topic: c,
                      error: e,
                      encodeOpts: u,
                    }),
                    Error(e.message))
                  );
                }
                n.addTrace(lM.cacaos_verified);
                let { p: t } = e,
                  i = ae(t.resources),
                  s = [s1(t.iss)],
                  a = s2(t.iss);
                if (i) {
                  let e = s9(i),
                    t = s7(i);
                  h.push(...e), s.push(...t);
                }
                for (let e of s) d.push(`${e}:${a}`);
              }
              let p = await this.client.core.crypto.generateSharedKey(l, o);
              if (
                (n.addTrace(lM.create_authenticated_session_topic),
                h?.length > 0)
              ) {
                (t = {
                  topic: p,
                  acknowledged: !0,
                  self: { publicKey: l, metadata: this.client.metadata },
                  peer: { publicKey: o, metadata: s.requester.metadata },
                  controller: o,
                  expiry: n8(hs),
                  authentication: i,
                  requiredNamespaces: {},
                  optionalNamespaces: {},
                  relay: { protocol: "irn" },
                  pairingTopic: s.pairingTopic,
                  namespaces: oC([...new Set(h)], [...new Set(d)]),
                  transportType: a,
                }),
                  n.addTrace(lM.subscribing_authenticated_session_topic);
                try {
                  await this.client.core.relayer.subscribe(p, {
                    transportType: a,
                  });
                } catch (e) {
                  throw (
                    (n.setError(
                      lB.subscribe_authenticated_session_topic_failure
                    ),
                    e)
                  );
                }
                n.addTrace(lM.subscribe_authenticated_session_topic_success),
                  await this.client.session.set(p, t),
                  n.addTrace(lM.store_authenticated_session),
                  await this.client.core.pairing.updateMetadata({
                    topic: s.pairingTopic,
                    metadata: s.requester.metadata,
                  });
              }
              n.addTrace(lM.publishing_authenticated_session_approve);
              try {
                await this.sendResult({
                  topic: c,
                  id: r,
                  result: {
                    cacaos: i,
                    responder: { publicKey: l, metadata: this.client.metadata },
                  },
                  encodeOpts: u,
                  throwOnFailedPublish: !0,
                  appLink: this.getAppLinkIfEnabled(s.requester.metadata, a),
                });
              } catch (e) {
                throw (
                  (n.setError(lB.authenticated_session_approve_publish_failure),
                  e)
                );
              }
              return (
                await this.client.auth.requests.delete(r, {
                  message: "fulfilled",
                  code: 0,
                }),
                await this.client.core.pairing.activate({
                  topic: s.pairingTopic,
                }),
                this.client.core.eventClient.deleteEvent({
                  eventId: n.eventId,
                }),
                { session: t }
              );
            }),
            hA(this, "rejectSessionAuthenticate", async (e) => {
              this.isInitialized();
              let { id: t, reason: r } = e,
                i = this.getPendingAuthRequest(t);
              if (!i)
                throw Error(`Could not find pending auth request with id ${t}`);
              i.transportType === lA.relay &&
                (await this.confirmOnlineStateOrThrow());
              let n = i.requester.publicKey,
                s = await this.client.core.crypto.generateKeyPair(),
                a = ol(n);
              await this.sendError({
                id: t,
                topic: a,
                error: r,
                encodeOpts: {
                  type: 1,
                  receiverPublicKey: n,
                  senderPublicKey: s,
                },
                rpcOpts: ha.wc_sessionAuthenticate.reject,
                appLink: this.getAppLinkIfEnabled(
                  i.requester.metadata,
                  i.transportType
                ),
              }),
                await this.client.auth.requests.delete(t, {
                  message: "rejected",
                  code: 0,
                }),
                await this.client.proposal.delete(t, oS("USER_DISCONNECTED"));
            }),
            hA(this, "formatAuthMessage", (e) => {
              this.isInitialized();
              let { request: t, iss: r } = e;
              return s5(t, r);
            }),
            hA(this, "processRelayMessageCache", () => {
              setTimeout(async () => {
                if (0 !== this.relayMessageCache.length)
                  for (; this.relayMessageCache.length > 0; )
                    try {
                      let e = this.relayMessageCache.shift();
                      e && (await this.onRelayMessage(e));
                    } catch (e) {
                      this.client.logger.error(e);
                    }
              }, 50);
            }),
            hA(this, "cleanupDuplicatePairings", async (e) => {
              if (e.pairingTopic)
                try {
                  let t = this.client.core.pairing.pairings.get(e.pairingTopic),
                    r = this.client.core.pairing.pairings
                      .getAll()
                      .filter((r) => {
                        var i, n;
                        return (
                          (null == (i = r.peerMetadata) ? void 0 : i.url) &&
                          (null == (n = r.peerMetadata) ? void 0 : n.url) ===
                            e.peer.metadata.url &&
                          r.topic &&
                          r.topic !== t.topic
                        );
                      });
                  if (0 === r.length) return;
                  this.client.logger.info(
                    `Cleaning up ${r.length} duplicate pairing(s)`
                  ),
                    await Promise.all(
                      r.map((e) =>
                        this.client.core.pairing.disconnect({ topic: e.topic })
                      )
                    ),
                    this.client.logger.info(
                      "Duplicate pairings clean up finished"
                    );
                } catch (e) {
                  this.client.logger.error(e);
                }
            }),
            hA(this, "deleteSession", async (e) => {
              var t;
              let {
                  topic: r,
                  expirerHasDeleted: i = !1,
                  emitEvent: n = !0,
                  id: s = 0,
                } = e,
                { self: a } = this.client.session.get(r);
              await this.client.core.relayer.unsubscribe(r),
                await this.client.session.delete(r, oS("USER_DISCONNECTED")),
                this.addToRecentlyDeleted(r, "session"),
                this.client.core.crypto.keychain.has(a.publicKey) &&
                  (await this.client.core.crypto.deleteKeyPair(a.publicKey)),
                this.client.core.crypto.keychain.has(r) &&
                  (await this.client.core.crypto.deleteSymKey(r)),
                i || this.client.core.expirer.del(r),
                this.client.core.storage
                  .removeItem(hi)
                  .catch((e) => this.client.logger.warn(e)),
                this.getPendingSessionRequests().forEach((e) => {
                  e.topic === r &&
                    this.deletePendingSessionRequest(
                      e.id,
                      oS("USER_DISCONNECTED")
                    );
                }),
                r ===
                  (null == (t = this.sessionRequestQueue.queue[0])
                    ? void 0
                    : t.topic) && (this.sessionRequestQueue.state = hl.idle),
                n &&
                  this.client.events.emit("session_delete", {
                    id: s,
                    topic: r,
                  });
            }),
            hA(this, "deleteProposal", async (e, t) => {
              if (t)
                try {
                  let t = this.client.proposal.get(e),
                    r = this.client.core.eventClient.getEvent({
                      topic: t.pairingTopic,
                    });
                  r?.setError(lL.proposal_expired);
                } catch {}
              await Promise.all([
                this.client.proposal.delete(e, oS("USER_DISCONNECTED")),
                t ? Promise.resolve() : this.client.core.expirer.del(e),
              ]),
                this.addToRecentlyDeleted(e, "proposal");
            }),
            hA(this, "deletePendingSessionRequest", async (e, t, r = !1) => {
              await Promise.all([
                this.client.pendingRequest.delete(e, t),
                r ? Promise.resolve() : this.client.core.expirer.del(e),
              ]),
                this.addToRecentlyDeleted(e, "request"),
                (this.sessionRequestQueue.queue =
                  this.sessionRequestQueue.queue.filter((t) => t.id !== e)),
                r &&
                  ((this.sessionRequestQueue.state = hl.idle),
                  this.client.events.emit("session_request_expire", { id: e }));
            }),
            hA(this, "deletePendingAuthRequest", async (e, t, r = !1) => {
              await Promise.all([
                this.client.auth.requests.delete(e, t),
                r ? Promise.resolve() : this.client.core.expirer.del(e),
              ]);
            }),
            hA(this, "setExpiry", async (e, t) => {
              this.client.session.keys.includes(e) &&
                (this.client.core.expirer.set(e, t),
                await this.client.session.update(e, { expiry: t }));
            }),
            hA(this, "setProposal", async (e, t) => {
              this.client.core.expirer.set(e, n8(ha.wc_sessionPropose.req.ttl)),
                await this.client.proposal.set(e, t);
            }),
            hA(this, "setAuthRequest", async (e, t) => {
              let {
                request: r,
                pairingTopic: i,
                transportType: n = lA.relay,
              } = t;
              this.client.core.expirer.set(e, r.expiryTimestamp),
                await this.client.auth.requests.set(e, {
                  authPayload: r.authPayload,
                  requester: r.requester,
                  expiryTimestamp: r.expiryTimestamp,
                  id: e,
                  pairingTopic: i,
                  verifyContext: r.verifyContext,
                  transportType: n,
                });
            }),
            hA(this, "setPendingSessionRequest", async (e) => {
              let { id: t, topic: r, params: i, verifyContext: n } = e,
                s =
                  i.request.expiryTimestamp || n8(ha.wc_sessionRequest.req.ttl);
              this.client.core.expirer.set(t, s),
                await this.client.pendingRequest.set(t, {
                  id: t,
                  topic: r,
                  params: i,
                  verifyContext: n,
                });
            }),
            hA(this, "sendRequest", async (e) => {
              let t, i;
              let {
                  topic: n,
                  method: s,
                  params: a,
                  expiry: o,
                  relayRpcId: l,
                  clientRpcId: c,
                  throwOnFailedPublish: u,
                  appLink: h,
                  tvf: d,
                } = e,
                p = o1(s, a, c),
                f = !!h;
              try {
                let e = f ? os : on;
                t = await this.client.core.crypto.encode(n, p, { encoding: e });
              } catch (e) {
                throw (
                  (await this.cleanup(),
                  this.client.logger.error(
                    `sendRequest() -> core.crypto.encode() for topic ${n} failed`
                  ),
                  e)
                );
              }
              if (hu.includes(s)) {
                let e = oc(JSON.stringify(p)),
                  r = oc(t);
                i = await this.client.core.verify.register({
                  id: r,
                  decryptedId: e,
                });
              }
              let g = ha[s].req;
              if (
                ((g.attestation = i),
                o && (g.ttl = o),
                l && (g.id = l),
                this.client.core.history.set(n, p),
                f)
              ) {
                let e = ob(h, n, t);
                await r.g.Linking.openURL(e, this.client.name);
              } else {
                let e = ha[s].req;
                o && (e.ttl = o),
                  l && (e.id = l),
                  (e.tvf = hE(hv({}, d), { correlationId: p.id })),
                  u
                    ? ((e.internal = hE(hv({}, e.internal), {
                        throwOnFailedPublish: !0,
                      })),
                      await this.client.core.relayer.publish(n, t, e))
                    : this.client.core.relayer
                        .publish(n, t, e)
                        .catch((e) => this.client.logger.error(e));
              }
              return p.id;
            }),
            hA(this, "sendResult", async (e) => {
              let t, i, n;
              let {
                  id: s,
                  topic: a,
                  result: o,
                  throwOnFailedPublish: l,
                  encodeOpts: c,
                  appLink: u,
                } = e,
                h = o2(s, o),
                d = u && "u" > typeof (null == r.g ? void 0 : r.g.Linking);
              try {
                let e = d ? os : on;
                t = await this.client.core.crypto.encode(
                  a,
                  h,
                  hE(hv({}, c || {}), { encoding: e })
                );
              } catch (e) {
                throw (
                  (await this.cleanup(),
                  this.client.logger.error(
                    `sendResult() -> core.crypto.encode() for topic ${a} failed`
                  ),
                  e)
                );
              }
              try {
                let e = (i = await this.client.core.history.get(a, s)).request;
                try {
                  this.shouldSetTVF(e.method, e.params) &&
                    (n = this.getTVFParams(s, e.params, o));
                } catch (e) {
                  this.client.logger.warn(
                    "sendResult() -> getTVFParams() failed",
                    e
                  );
                }
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    `sendResult() -> history.get(${a}, ${s}) failed`
                  ),
                  e)
                );
              }
              if (d) {
                let e = ob(u, a, t);
                await r.g.Linking.openURL(e, this.client.name);
              } else {
                let e = ha[i.request.method].res;
                (e.tvf = hE(hv({}, n), { correlationId: s })),
                  l
                    ? ((e.internal = hE(hv({}, e.internal), {
                        throwOnFailedPublish: !0,
                      })),
                      await this.client.core.relayer.publish(a, t, e))
                    : this.client.core.relayer
                        .publish(a, t, e)
                        .catch((e) => this.client.logger.error(e));
              }
              await this.client.core.history.resolve(h);
            }),
            hA(this, "sendError", async (e) => {
              let t, i;
              let {
                  id: n,
                  topic: s,
                  error: a,
                  encodeOpts: o,
                  rpcOpts: l,
                  appLink: c,
                } = e,
                u = o3(n, a),
                h = c && "u" > typeof (null == r.g ? void 0 : r.g.Linking);
              try {
                let e = h ? os : on;
                t = await this.client.core.crypto.encode(
                  s,
                  u,
                  hE(hv({}, o || {}), { encoding: e })
                );
              } catch (e) {
                throw (
                  (await this.cleanup(),
                  this.client.logger.error(
                    `sendError() -> core.crypto.encode() for topic ${s} failed`
                  ),
                  e)
                );
              }
              try {
                i = await this.client.core.history.get(s, n);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    `sendError() -> history.get(${s}, ${n}) failed`
                  ),
                  e)
                );
              }
              if (h) {
                let e = ob(c, s, t);
                await r.g.Linking.openURL(e, this.client.name);
              } else {
                let e = i.request.method,
                  r = l || ha[e].res;
                this.client.core.relayer.publish(s, t, r);
              }
              await this.client.core.history.resolve(u);
            }),
            hA(this, "cleanup", async () => {
              let e = [],
                t = [];
              this.client.session.getAll().forEach((t) => {
                let r = !1;
                n4(t.expiry) && (r = !0),
                  this.client.core.crypto.keychain.has(t.topic) || (r = !0),
                  r && e.push(t.topic);
              }),
                this.client.proposal.getAll().forEach((e) => {
                  n4(e.expiryTimestamp) && t.push(e.id);
                }),
                await Promise.all([
                  ...e.map((e) => this.deleteSession({ topic: e })),
                  ...t.map((e) => this.deleteProposal(e)),
                ]);
            }),
            hA(this, "onProviderMessageEvent", async (e) => {
              !this.initialized || this.relayMessageCache.length > 0
                ? this.relayMessageCache.push(e)
                : await this.onRelayMessage(e);
            }),
            hA(this, "onRelayEventRequest", async (e) => {
              this.requestQueue.queue.push(e),
                await this.processRequestsQueue();
            }),
            hA(this, "processRequestsQueue", async () => {
              if (this.requestQueue.state === hl.active) {
                this.client.logger.info(
                  "Request queue already active, skipping..."
                );
                return;
              }
              for (
                this.client.logger.info(
                  `Request queue starting with ${this.requestQueue.queue.length} requests`
                );
                this.requestQueue.queue.length > 0;

              ) {
                this.requestQueue.state = hl.active;
                let e = this.requestQueue.queue.shift();
                if (e)
                  try {
                    await this.processRequest(e);
                  } catch (e) {
                    this.client.logger.warn(e);
                  }
              }
              this.requestQueue.state = hl.idle;
            }),
            hA(this, "processRequest", async (e) => {
              let {
                  topic: t,
                  payload: r,
                  attestation: i,
                  transportType: n,
                  encryptedId: s,
                } = e,
                a = r.method;
              if (
                !this.shouldIgnorePairingRequest({ topic: t, requestMethod: a })
              )
                switch (a) {
                  case "wc_sessionPropose":
                    return await this.onSessionProposeRequest({
                      topic: t,
                      payload: r,
                      attestation: i,
                      encryptedId: s,
                    });
                  case "wc_sessionSettle":
                    return await this.onSessionSettleRequest(t, r);
                  case "wc_sessionUpdate":
                    return await this.onSessionUpdateRequest(t, r);
                  case "wc_sessionExtend":
                    return await this.onSessionExtendRequest(t, r);
                  case "wc_sessionPing":
                    return await this.onSessionPingRequest(t, r);
                  case "wc_sessionDelete":
                    return await this.onSessionDeleteRequest(t, r);
                  case "wc_sessionRequest":
                    return await this.onSessionRequest({
                      topic: t,
                      payload: r,
                      attestation: i,
                      encryptedId: s,
                      transportType: n,
                    });
                  case "wc_sessionEvent":
                    return await this.onSessionEventRequest(t, r);
                  case "wc_sessionAuthenticate":
                    return await this.onSessionAuthenticateRequest({
                      topic: t,
                      payload: r,
                      attestation: i,
                      encryptedId: s,
                      transportType: n,
                    });
                  default:
                    return this.client.logger.info(
                      `Unsupported request method ${a}`
                    );
                }
            }),
            hA(this, "onRelayEventResponse", async (e) => {
              let { topic: t, payload: r, transportType: i } = e,
                n = (await this.client.core.history.get(t, r.id)).request
                  .method;
              switch (n) {
                case "wc_sessionPropose":
                  return this.onSessionProposeResponse(t, r, i);
                case "wc_sessionSettle":
                  return this.onSessionSettleResponse(t, r);
                case "wc_sessionUpdate":
                  return this.onSessionUpdateResponse(t, r);
                case "wc_sessionExtend":
                  return this.onSessionExtendResponse(t, r);
                case "wc_sessionPing":
                  return this.onSessionPingResponse(t, r);
                case "wc_sessionRequest":
                  return this.onSessionRequestResponse(t, r);
                case "wc_sessionAuthenticate":
                  return this.onSessionAuthenticateResponse(t, r);
                default:
                  return this.client.logger.info(
                    `Unsupported response method ${n}`
                  );
              }
            }),
            hA(this, "onRelayEventUnknownPayload", (e) => {
              let { topic: t } = e,
                { message: r } = oN(
                  "MISSING_OR_INVALID",
                  `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`
                );
              throw Error(r);
            }),
            hA(this, "shouldIgnorePairingRequest", (e) => {
              let { topic: t, requestMethod: r } = e,
                i = this.expectedPairingMethodMap.get(t);
              return (
                !(!i || i.includes(r)) &&
                !!(
                  i.includes("wc_sessionAuthenticate") &&
                  this.client.events.listenerCount("session_authenticate") > 0
                )
              );
            }),
            hA(this, "onSessionProposeRequest", async (e) => {
              let { topic: t, payload: r, attestation: i, encryptedId: n } = e,
                { params: s, id: a } = r;
              try {
                let e = this.client.core.eventClient.getEvent({ topic: t });
                0 === this.client.events.listenerCount("session_proposal") &&
                  (console.warn("No listener for session_proposal event"),
                  e?.setError(lD.proposal_listener_not_found)),
                  this.isValidConnect(hv({}, r.params));
                let o = s.expiryTimestamp || n8(ha.wc_sessionPropose.req.ttl),
                  l = hv({ id: a, pairingTopic: t, expiryTimestamp: o }, s);
                await this.setProposal(a, l);
                let c = await this.getVerifyContext({
                  attestationId: i,
                  hash: oc(JSON.stringify(r)),
                  encryptedId: n,
                  metadata: l.proposer.metadata,
                });
                e?.addTrace(lR.emit_session_proposal),
                  this.client.events.emit("session_proposal", {
                    id: a,
                    params: l,
                    verifyContext: c,
                  });
              } catch (e) {
                await this.sendError({
                  id: a,
                  topic: t,
                  error: e,
                  rpcOpts: ha.wc_sessionPropose.autoReject,
                }),
                  this.client.logger.error(e);
              }
            }),
            hA(this, "onSessionProposeResponse", async (e, t, r) => {
              let { id: i } = t;
              if (li(t)) {
                let { result: n } = t;
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  result: n,
                });
                let s = this.client.proposal.get(i);
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  proposal: s,
                });
                let a = s.proposer.publicKey;
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  selfPublicKey: a,
                });
                let o = n.responderPublicKey;
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  peerPublicKey: o,
                });
                let l = await this.client.core.crypto.generateSharedKey(a, o);
                this.pendingSessions.set(i, {
                  sessionTopic: l,
                  pairingTopic: e,
                  proposalId: i,
                  publicKey: a,
                });
                let c = await this.client.core.relayer.subscribe(l, {
                  transportType: r,
                });
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  subscriptionId: c,
                }),
                  await this.client.core.pairing.activate({ topic: e });
              } else if (ln(t)) {
                await this.client.proposal.delete(i, oS("USER_DISCONNECTED"));
                let e = n6("session_connect", i);
                if (0 === this.events.listenerCount(e))
                  throw Error(`emitting ${e} without any listeners, 954`);
                this.events.emit(e, { error: t.error });
              }
            }),
            hA(this, "onSessionSettleRequest", async (e, t) => {
              let { id: r, params: i } = t;
              try {
                this.isValidSessionSettleRequest(i);
                let {
                    relay: r,
                    controller: n,
                    expiry: s,
                    namespaces: a,
                    sessionProperties: o,
                    scopedProperties: l,
                    sessionConfig: c,
                  } = t.params,
                  u = [...this.pendingSessions.values()].find(
                    (t) => t.sessionTopic === e
                  );
                if (!u)
                  return this.client.logger.error(
                    `Pending session not found for topic ${e}`
                  );
                let h = this.client.proposal.get(u.proposalId),
                  d = hE(
                    hv(
                      hv(
                        hv(
                          {
                            topic: e,
                            relay: r,
                            expiry: s,
                            namespaces: a,
                            acknowledged: !0,
                            pairingTopic: u.pairingTopic,
                            requiredNamespaces: h.requiredNamespaces,
                            optionalNamespaces: h.optionalNamespaces,
                            controller: n.publicKey,
                            self: {
                              publicKey: u.publicKey,
                              metadata: this.client.metadata,
                            },
                            peer: {
                              publicKey: n.publicKey,
                              metadata: n.metadata,
                            },
                          },
                          o && { sessionProperties: o }
                        ),
                        l && { scopedProperties: l }
                      ),
                      c && { sessionConfig: c }
                    ),
                    { transportType: lA.relay }
                  );
                await this.client.session.set(d.topic, d),
                  await this.setExpiry(d.topic, d.expiry),
                  await this.client.core.pairing.updateMetadata({
                    topic: u.pairingTopic,
                    metadata: d.peer.metadata,
                  }),
                  this.client.events.emit("session_connect", { session: d }),
                  this.events.emit(n6("session_connect", u.proposalId), {
                    session: d,
                  }),
                  this.pendingSessions.delete(u.proposalId),
                  this.deleteProposal(u.proposalId, !1),
                  this.cleanupDuplicatePairings(d),
                  await this.sendResult({
                    id: t.id,
                    topic: e,
                    result: !0,
                    throwOnFailedPublish: !0,
                  });
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            hA(this, "onSessionSettleResponse", async (e, t) => {
              let { id: r } = t;
              li(t)
                ? (await this.client.session.update(e, { acknowledged: !0 }),
                  this.events.emit(n6("session_approve", r), {}))
                : ln(t) &&
                  (await this.client.session.delete(e, oS("USER_DISCONNECTED")),
                  this.events.emit(n6("session_approve", r), {
                    error: t.error,
                  }));
            }),
            hA(this, "onSessionUpdateRequest", async (e, t) => {
              let { params: r, id: i } = t;
              try {
                let t = `${e}_session_update`,
                  n = oV.get(t);
                if (n && this.isRequestOutOfSync(n, i)) {
                  this.client.logger.warn(
                    `Discarding out of sync request - ${i}`
                  ),
                    this.sendError({
                      id: i,
                      topic: e,
                      error: oS("INVALID_UPDATE_REQUEST"),
                    });
                  return;
                }
                this.isValidUpdate(hv({ topic: e }, r));
                try {
                  oV.set(t, i),
                    await this.client.session.update(e, {
                      namespaces: r.namespaces,
                    }),
                    await this.sendResult({
                      id: i,
                      topic: e,
                      result: !0,
                      throwOnFailedPublish: !0,
                    });
                } catch (e) {
                  throw (oV.delete(t), e);
                }
                this.client.events.emit("session_update", {
                  id: i,
                  topic: e,
                  params: r,
                });
              } catch (t) {
                await this.sendError({ id: i, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            hA(
              this,
              "isRequestOutOfSync",
              (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3)
            ),
            hA(this, "onSessionUpdateResponse", (e, t) => {
              let { id: r } = t,
                i = n6("session_update", r);
              if (0 === this.events.listenerCount(i))
                throw Error(`emitting ${i} without any listeners`);
              li(t)
                ? this.events.emit(n6("session_update", r), {})
                : ln(t) &&
                  this.events.emit(n6("session_update", r), { error: t.error });
            }),
            hA(this, "onSessionExtendRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidExtend({ topic: e }),
                  await this.setExpiry(e, n8(hs)),
                  await this.sendResult({
                    id: r,
                    topic: e,
                    result: !0,
                    throwOnFailedPublish: !0,
                  }),
                  this.client.events.emit("session_extend", {
                    id: r,
                    topic: e,
                  });
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            hA(this, "onSessionExtendResponse", (e, t) => {
              let { id: r } = t,
                i = n6("session_extend", r);
              if (0 === this.events.listenerCount(i))
                throw Error(`emitting ${i} without any listeners`);
              li(t)
                ? this.events.emit(n6("session_extend", r), {})
                : ln(t) &&
                  this.events.emit(n6("session_extend", r), { error: t.error });
            }),
            hA(this, "onSessionPingRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidPing({ topic: e }),
                  await this.sendResult({
                    id: r,
                    topic: e,
                    result: !0,
                    throwOnFailedPublish: !0,
                  }),
                  this.client.events.emit("session_ping", { id: r, topic: e });
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            hA(this, "onSessionPingResponse", (e, t) => {
              let { id: r } = t,
                i = n6("session_ping", r);
              setTimeout(() => {
                if (0 === this.events.listenerCount(i))
                  throw Error(`emitting ${i} without any listeners 2176`);
                li(t)
                  ? this.events.emit(n6("session_ping", r), {})
                  : ln(t) &&
                    this.events.emit(n6("session_ping", r), { error: t.error });
              }, 500);
            }),
            hA(this, "onSessionDeleteRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidDisconnect({ topic: e, reason: t.params }),
                  Promise.all([
                    new Promise((t) => {
                      this.client.core.relayer.once(lb.publish, async () => {
                        t(await this.deleteSession({ topic: e, id: r }));
                      });
                    }),
                    this.sendResult({
                      id: r,
                      topic: e,
                      result: !0,
                      throwOnFailedPublish: !0,
                    }),
                    this.cleanupPendingSentRequestsForTopic({
                      topic: e,
                      error: oS("USER_DISCONNECTED"),
                    }),
                  ]).catch((e) => this.client.logger.error(e));
              } catch (e) {
                this.client.logger.error(e);
              }
            }),
            hA(this, "onSessionRequest", async (e) => {
              var t, r, i;
              let {
                  topic: n,
                  payload: s,
                  attestation: a,
                  encryptedId: o,
                  transportType: l,
                } = e,
                { id: c, params: u } = s;
              try {
                await this.isValidRequest(hv({ topic: n }, u));
                let e = this.client.session.get(n),
                  s = await this.getVerifyContext({
                    attestationId: a,
                    hash: oc(JSON.stringify(o1("wc_sessionRequest", u, c))),
                    encryptedId: o,
                    metadata: e.peer.metadata,
                    transportType: l,
                  }),
                  h = { id: c, topic: n, params: u, verifyContext: s };
                await this.setPendingSessionRequest(h),
                  l === lA.link_mode &&
                    null != (t = e.peer.metadata.redirect) &&
                    t.universal &&
                    this.client.core.addLinkModeSupportedApp(
                      null == (r = e.peer.metadata.redirect)
                        ? void 0
                        : r.universal
                    ),
                  null != (i = this.client.signConfig) && i.disableRequestQueue
                    ? this.emitSessionRequest(h)
                    : (this.addSessionRequestToSessionRequestQueue(h),
                      this.processSessionRequestQueue());
              } catch (e) {
                await this.sendError({ id: c, topic: n, error: e }),
                  this.client.logger.error(e);
              }
            }),
            hA(this, "onSessionRequestResponse", (e, t) => {
              let { id: r } = t,
                i = n6("session_request", r);
              if (0 === this.events.listenerCount(i))
                throw Error(`emitting ${i} without any listeners`);
              li(t)
                ? this.events.emit(n6("session_request", r), {
                    result: t.result,
                  })
                : ln(t) &&
                  this.events.emit(n6("session_request", r), {
                    error: t.error,
                  });
            }),
            hA(this, "onSessionEventRequest", async (e, t) => {
              let { id: r, params: i } = t;
              try {
                let t = `${e}_session_event_${i.event.name}`,
                  n = oV.get(t);
                if (n && this.isRequestOutOfSync(n, r)) {
                  this.client.logger.info(
                    `Discarding out of sync request - ${r}`
                  );
                  return;
                }
                this.isValidEmit(hv({ topic: e }, i)),
                  this.client.events.emit("session_event", {
                    id: r,
                    topic: e,
                    params: i,
                  }),
                  oV.set(t, r);
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            hA(this, "onSessionAuthenticateResponse", (e, t) => {
              let { id: r } = t;
              this.client.logger.trace({
                type: "method",
                method: "onSessionAuthenticateResponse",
                topic: e,
                payload: t,
              }),
                li(t)
                  ? this.events.emit(n6("session_request", r), {
                      result: t.result,
                    })
                  : ln(t) &&
                    this.events.emit(n6("session_request", r), {
                      error: t.error,
                    });
            }),
            hA(this, "onSessionAuthenticateRequest", async (e) => {
              var t;
              let {
                topic: r,
                payload: i,
                attestation: n,
                encryptedId: s,
                transportType: a,
              } = e;
              try {
                let {
                    requester: e,
                    authPayload: o,
                    expiryTimestamp: l,
                  } = i.params,
                  c = await this.getVerifyContext({
                    attestationId: n,
                    hash: oc(JSON.stringify(i)),
                    encryptedId: s,
                    metadata: e.metadata,
                    transportType: a,
                  }),
                  u = {
                    requester: e,
                    pairingTopic: r,
                    id: i.id,
                    authPayload: o,
                    verifyContext: c,
                    expiryTimestamp: l,
                  };
                await this.setAuthRequest(i.id, {
                  request: u,
                  pairingTopic: r,
                  transportType: a,
                }),
                  a === lA.link_mode &&
                    null != (t = e.metadata.redirect) &&
                    t.universal &&
                    this.client.core.addLinkModeSupportedApp(
                      e.metadata.redirect.universal
                    ),
                  this.client.events.emit("session_authenticate", {
                    topic: r,
                    params: i.params,
                    id: i.id,
                    verifyContext: c,
                  });
              } catch (s) {
                this.client.logger.error(s);
                let e = i.params.requester.publicKey,
                  t = await this.client.core.crypto.generateKeyPair(),
                  n = this.getAppLinkIfEnabled(i.params.requester.metadata, a);
                await this.sendError({
                  id: i.id,
                  topic: r,
                  error: s,
                  encodeOpts: {
                    type: 1,
                    receiverPublicKey: e,
                    senderPublicKey: t,
                  },
                  rpcOpts: ha.wc_sessionAuthenticate.autoReject,
                  appLink: n,
                });
              }
            }),
            hA(this, "addSessionRequestToSessionRequestQueue", (e) => {
              this.sessionRequestQueue.queue.push(e);
            }),
            hA(this, "cleanupAfterResponse", (e) => {
              this.deletePendingSessionRequest(e.response.id, {
                message: "fulfilled",
                code: 0,
              }),
                setTimeout(() => {
                  (this.sessionRequestQueue.state = hl.idle),
                    this.processSessionRequestQueue();
                }, (0, v.toMiliseconds)(this.requestQueueDelay));
            }),
            hA(
              this,
              "cleanupPendingSentRequestsForTopic",
              ({ topic: e, error: t }) => {
                let r = this.client.core.history.pending;
                r.length > 0 &&
                  r
                    .filter(
                      (t) =>
                        t.topic === e &&
                        "wc_sessionRequest" === t.request.method
                    )
                    .forEach((e) => {
                      let r = n6("session_request", e.request.id);
                      if (0 === this.events.listenerCount(r))
                        throw Error(`emitting ${r} without any listeners`);
                      this.events.emit(n6("session_request", e.request.id), {
                        error: t,
                      });
                    });
              }
            ),
            hA(this, "processSessionRequestQueue", () => {
              if (this.sessionRequestQueue.state === hl.active) {
                this.client.logger.info(
                  "session request queue is already active."
                );
                return;
              }
              let e = this.sessionRequestQueue.queue[0];
              if (!e) {
                this.client.logger.info("session request queue is empty.");
                return;
              }
              try {
                (this.sessionRequestQueue.state = hl.active),
                  this.emitSessionRequest(e);
              } catch (e) {
                this.client.logger.error(e);
              }
            }),
            hA(this, "emitSessionRequest", (e) => {
              this.client.events.emit("session_request", e);
            }),
            hA(this, "onPairingCreated", (e) => {
              if (
                (e.methods &&
                  this.expectedPairingMethodMap.set(e.topic, e.methods),
                e.active)
              )
                return;
              let t = this.client.proposal
                .getAll()
                .find((t) => t.pairingTopic === e.topic);
              t &&
                this.onSessionProposeRequest({
                  topic: e.topic,
                  payload: o1(
                    "wc_sessionPropose",
                    hE(hv({}, t), {
                      requiredNamespaces: t.requiredNamespaces,
                      optionalNamespaces: t.optionalNamespaces,
                      relays: t.relays,
                      proposer: t.proposer,
                      sessionProperties: t.sessionProperties,
                      scopedProperties: t.scopedProperties,
                    }),
                    t.id
                  ),
                });
            }),
            hA(this, "isValidConnect", async (e) => {
              let t;
              if (!oB(e)) {
                let { message: t } = oN(
                  "MISSING_OR_INVALID",
                  `connect() params: ${JSON.stringify(e)}`
                );
                throw Error(t);
              }
              let {
                pairingTopic: r,
                requiredNamespaces: i,
                optionalNamespaces: n,
                sessionProperties: s,
                scopedProperties: a,
                relays: o,
              } = e;
              if (
                (oO(r) || (await this.isValidPairingTopic(r)),
                (t = !1),
                o
                  ? o &&
                    oT(o) &&
                    o.length &&
                    o.forEach((e) => {
                      t = oM(e);
                    })
                  : (t = !0),
                !t)
              ) {
                let { message: e } = oN(
                  "MISSING_OR_INVALID",
                  `connect() relays: ${o}`
                );
                throw Error(e);
              }
              if (
                (oO(i) ||
                  0 === oP(i) ||
                  this.validateNamespaces(i, "requiredNamespaces"),
                oO(n) ||
                  0 === oP(n) ||
                  this.validateNamespaces(n, "optionalNamespaces"),
                oO(s) || this.validateSessionProps(s, "sessionProperties"),
                !oO(a))
              ) {
                this.validateSessionProps(a, "scopedProperties");
                let e = Object.keys(i || {}).concat(Object.keys(n || {}));
                if (!Object.keys(a).every((t) => e.includes(t)))
                  throw Error(
                    `Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(
                      a
                    )}, required/optional namespaces: ${JSON.stringify(e)}`
                  );
              }
            }),
            hA(this, "validateNamespaces", (e, t) => {
              let r = (function (e, t, r) {
                let i = null;
                if (e && oP(e)) {
                  let n;
                  let s = oU(e, t);
                  s && (i = s);
                  let a =
                    ((n = null),
                    Object.entries(e).forEach(([e, i]) => {
                      var s, a;
                      let o;
                      if (n) return;
                      let l =
                        ((s = nz(e, i)),
                        (a = `${t} ${r}`),
                        (o = null),
                        oT(s) && s.length
                          ? s.forEach((e) => {
                              o ||
                                oR(e) ||
                                (o = oS(
                                  "UNSUPPORTED_CHAINS",
                                  `${a}, chain ${e} should be a string and conform to "namespace:chainId" format`
                                ));
                            })
                          : oR(e) ||
                            (o = oS(
                              "UNSUPPORTED_CHAINS",
                              `${a}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`
                            )),
                        o);
                      l && (n = l);
                    }),
                    n);
                  a && (i = a);
                } else
                  i = oN(
                    "MISSING_OR_INVALID",
                    `${t}, ${r} should be an object with data`
                  );
                return i;
              })(e, "connect()", t);
              if (r) throw Error(r.message);
            }),
            hA(this, "isValidApprove", async (e) => {
              if (!oB(e))
                throw Error(
                  oN("MISSING_OR_INVALID", `approve() params: ${e}`).message
                );
              let {
                id: t,
                namespaces: r,
                relayProtocol: i,
                sessionProperties: n,
                scopedProperties: s,
              } = e;
              this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
              let a = this.client.proposal.get(t),
                o = oL(r, "approve()");
              if (o) throw Error(o.message);
              let l = oF(a.requiredNamespaces, r, "approve()");
              if (l) throw Error(l.message);
              if (!ox(i, !0)) {
                let { message: e } = oN(
                  "MISSING_OR_INVALID",
                  `approve() relayProtocol: ${i}`
                );
                throw Error(e);
              }
              if (
                (oO(n) || this.validateSessionProps(n, "sessionProperties"),
                !oO(s))
              ) {
                this.validateSessionProps(s, "scopedProperties");
                let e = new Set(Object.keys(r));
                if (!Object.keys(s).every((t) => e.has(t)))
                  throw Error(
                    `Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(
                      s
                    )}, approved namespaces: ${Array.from(e).join(", ")}`
                  );
              }
            }),
            hA(this, "isValidReject", async (e) => {
              if (!oB(e)) {
                let { message: t } = oN(
                  "MISSING_OR_INVALID",
                  `reject() params: ${e}`
                );
                throw Error(t);
              }
              let { id: t, reason: r } = e;
              if (
                (this.checkRecentlyDeleted(t),
                await this.isValidProposalId(t),
                !r ||
                  "object" != typeof r ||
                  !r.code ||
                  !ok(r.code, !1) ||
                  !r.message ||
                  !ox(r.message, !1))
              ) {
                let { message: e } = oN(
                  "MISSING_OR_INVALID",
                  `reject() reason: ${JSON.stringify(r)}`
                );
                throw Error(e);
              }
            }),
            hA(this, "isValidSessionSettleRequest", (e) => {
              let t;
              if (!oB(e)) {
                let { message: t } = oN(
                  "MISSING_OR_INVALID",
                  `onSessionSettleRequest() params: ${e}`
                );
                throw Error(t);
              }
              let { relay: r, controller: i, namespaces: n, expiry: s } = e;
              if (!oM(r)) {
                let { message: e } = oN(
                  "MISSING_OR_INVALID",
                  "onSessionSettleRequest() relay protocol should be a string"
                );
                throw Error(e);
              }
              let a =
                ((t = null),
                ox(i?.publicKey, !1) ||
                  (t = oN(
                    "MISSING_OR_INVALID",
                    "onSessionSettleRequest() controller public key should be a string"
                  )),
                t);
              if (a) throw Error(a.message);
              let o = oL(n, "onSessionSettleRequest()");
              if (o) throw Error(o.message);
              if (n4(s)) {
                let { message: e } = oN("EXPIRED", "onSessionSettleRequest()");
                throw Error(e);
              }
            }),
            hA(this, "isValidUpdate", async (e) => {
              if (!oB(e)) {
                let { message: t } = oN(
                  "MISSING_OR_INVALID",
                  `update() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t, namespaces: r } = e;
              this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
              let i = this.client.session.get(t),
                n = oL(r, "update()");
              if (n) throw Error(n.message);
              let s = oF(i.requiredNamespaces, r, "update()");
              if (s) throw Error(s.message);
            }),
            hA(this, "isValidExtend", async (e) => {
              if (!oB(e)) {
                let { message: t } = oN(
                  "MISSING_OR_INVALID",
                  `extend() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
            }),
            hA(this, "isValidRequest", async (e) => {
              var t;
              if (!oB(e)) {
                let { message: t } = oN(
                  "MISSING_OR_INVALID",
                  `request() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: r, request: i, chainId: n, expiry: s } = e;
              this.checkRecentlyDeleted(r), await this.isValidSessionTopic(r);
              let { namespaces: a } = this.client.session.get(r);
              if (!oj(a, n)) {
                let { message: e } = oN(
                  "MISSING_OR_INVALID",
                  `request() chainId: ${n}`
                );
                throw Error(e);
              }
              if (oO(i) || !ox(i.method, !1)) {
                let { message: e } = oN(
                  "MISSING_OR_INVALID",
                  `request() ${JSON.stringify(i)}`
                );
                throw Error(e);
              }
              if (
                !(
                  ox((t = i.method), !1) &&
                  (function (e, t) {
                    let r = [];
                    return (
                      Object.values(e).forEach((e) => {
                        ov(e.accounts).includes(t) && r.push(...e.methods);
                      }),
                      r
                    );
                  })(a, n).includes(t)
                )
              ) {
                let { message: e } = oN(
                  "MISSING_OR_INVALID",
                  `request() method: ${i.method}`
                );
                throw Error(e);
              }
              if (s && (!ok(s, !1) || !(s <= ho.max) || !(s >= ho.min))) {
                let { message: e } = oN(
                  "MISSING_OR_INVALID",
                  `request() expiry: ${s}. Expiry must be a number (in seconds) between ${ho.min} and ${ho.max}`
                );
                throw Error(e);
              }
            }),
            hA(this, "isValidRespond", async (e) => {
              var t;
              if (!oB(e)) {
                let { message: t } = oN(
                  "MISSING_OR_INVALID",
                  `respond() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: r, response: i } = e;
              try {
                await this.isValidSessionTopic(r);
              } catch (r) {
                throw (
                  (null != (t = e?.response) &&
                    t.id &&
                    this.cleanupAfterResponse(e),
                  r)
                );
              }
              if (
                oO(i) ||
                (oO(i.result) && oO(i.error)) ||
                !ok(i.id, !1) ||
                !ox(i.jsonrpc, !1)
              ) {
                let { message: e } = oN(
                  "MISSING_OR_INVALID",
                  `respond() response: ${JSON.stringify(i)}`
                );
                throw Error(e);
              }
            }),
            hA(this, "isValidPing", async (e) => {
              if (!oB(e)) {
                let { message: t } = oN(
                  "MISSING_OR_INVALID",
                  `ping() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidSessionOrPairingTopic(t);
            }),
            hA(this, "isValidEmit", async (e) => {
              var t;
              if (!oB(e)) {
                let { message: t } = oN(
                  "MISSING_OR_INVALID",
                  `emit() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: r, event: i, chainId: n } = e;
              await this.isValidSessionTopic(r);
              let { namespaces: s } = this.client.session.get(r);
              if (!oj(s, n)) {
                let { message: e } = oN(
                  "MISSING_OR_INVALID",
                  `emit() chainId: ${n}`
                );
                throw Error(e);
              }
              if (oO(i) || !ox(i.name, !1)) {
                let { message: e } = oN(
                  "MISSING_OR_INVALID",
                  `emit() event: ${JSON.stringify(i)}`
                );
                throw Error(e);
              }
              if (
                !(
                  ox((t = i.name), !1) &&
                  (function (e, t) {
                    let r = [];
                    return (
                      Object.values(e).forEach((e) => {
                        ov(e.accounts).includes(t) && r.push(...e.events);
                      }),
                      r
                    );
                  })(s, n).includes(t)
                )
              ) {
                let { message: e } = oN(
                  "MISSING_OR_INVALID",
                  `emit() event: ${JSON.stringify(i)}`
                );
                throw Error(e);
              }
            }),
            hA(this, "isValidDisconnect", async (e) => {
              if (!oB(e)) {
                let { message: t } = oN(
                  "MISSING_OR_INVALID",
                  `disconnect() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidSessionOrPairingTopic(t);
            }),
            hA(this, "isValidAuthenticate", (e) => {
              let { chains: t, uri: r, domain: i, nonce: n } = e;
              if (!Array.isArray(t) || 0 === t.length)
                throw Error("chains is required and must be a non-empty array");
              if (!ox(r, !1)) throw Error("uri is required parameter");
              if (!ox(i, !1)) throw Error("domain is required parameter");
              if (!ox(n, !1)) throw Error("nonce is required parameter");
              if ([...new Set(t.map((e) => nH(e).namespace))].length > 1)
                throw Error(
                  "Multi-namespace requests are not supported. Please request single namespace only."
                );
              let { namespace: s } = nH(t[0]);
              if ("eip155" !== s)
                throw Error(
                  "Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains."
                );
            }),
            hA(this, "getVerifyContext", async (e) => {
              let {
                  attestationId: t,
                  hash: r,
                  encryptedId: i,
                  metadata: n,
                  transportType: s,
                } = e,
                a = {
                  verified: {
                    verifyUrl: n.verifyUrl || lO,
                    validation: "UNKNOWN",
                    origin: n.url || "",
                  },
                };
              try {
                if (s === lA.link_mode) {
                  let e = this.getAppLinkIfEnabled(n, s);
                  return (
                    (a.verified.validation =
                      e && new URL(e).origin === new URL(n.url).origin
                        ? "VALID"
                        : "INVALID"),
                    a
                  );
                }
                let e = await this.client.core.verify.resolve({
                  attestationId: t,
                  hash: r,
                  encryptedId: i,
                  verifyUrl: n.verifyUrl,
                });
                e &&
                  ((a.verified.origin = e.origin),
                  (a.verified.isScam = e.isScam),
                  (a.verified.validation =
                    e.origin === new URL(n.url).origin ? "VALID" : "INVALID"));
              } catch (e) {
                this.client.logger.warn(e);
              }
              return (
                this.client.logger.debug(
                  `Verify context: ${JSON.stringify(a)}`
                ),
                a
              );
            }),
            hA(this, "validateSessionProps", (e, t) => {
              Object.values(e).forEach((r, i) => {
                if (null == r) {
                  let { message: n } = oN(
                    "MISSING_OR_INVALID",
                    `${t} must contain an existing value for each key. Received: ${r} for key ${
                      Object.keys(e)[i]
                    }`
                  );
                  throw Error(n);
                }
              });
            }),
            hA(this, "getPendingAuthRequest", (e) => {
              let t = this.client.auth.requests.get(e);
              return "object" == typeof t ? t : void 0;
            }),
            hA(this, "addToRecentlyDeleted", (e, t) => {
              if (
                (this.recentlyDeletedMap.set(e, t),
                this.recentlyDeletedMap.size >= this.recentlyDeletedLimit)
              ) {
                let e = 0,
                  t = this.recentlyDeletedLimit / 2;
                for (let r of this.recentlyDeletedMap.keys()) {
                  if (e++ >= t) break;
                  this.recentlyDeletedMap.delete(r);
                }
              }
            }),
            hA(this, "checkRecentlyDeleted", (e) => {
              let t = this.recentlyDeletedMap.get(e);
              if (t) {
                let { message: r } = oN(
                  "MISSING_OR_INVALID",
                  `Record was recently deleted - ${t}: ${e}`
                );
                throw Error(r);
              }
            }),
            hA(this, "isLinkModeEnabled", (e, t) => {
              var i, n, s, a, o, l, c, u, h;
              return (
                !!e &&
                t === lA.link_mode &&
                (null ==
                (n = null == (i = this.client.metadata) ? void 0 : i.redirect)
                  ? void 0
                  : n.linkMode) === !0 &&
                (null ==
                (a = null == (s = this.client.metadata) ? void 0 : s.redirect)
                  ? void 0
                  : a.universal) !== void 0 &&
                (null ==
                (l = null == (o = this.client.metadata) ? void 0 : o.redirect)
                  ? void 0
                  : l.universal) !== "" &&
                (null == (c = e?.redirect) ? void 0 : c.universal) !== void 0 &&
                (null == (u = e?.redirect) ? void 0 : u.universal) !== "" &&
                (null == (h = e?.redirect) ? void 0 : h.linkMode) === !0 &&
                this.client.core.linkModeSupportedApps.includes(
                  e.redirect.universal
                ) &&
                "u" > typeof (null == r.g ? void 0 : r.g.Linking)
              );
            }),
            hA(this, "getAppLinkIfEnabled", (e, t) => {
              var r;
              return this.isLinkModeEnabled(e, t)
                ? null == (r = e?.redirect)
                  ? void 0
                  : r.universal
                : void 0;
            }),
            hA(this, "handleLinkModeMessage", ({ url: e }) => {
              if (!e || !e.includes("wc_ev") || !e.includes("topic")) return;
              let t = st(e, "topic") || "",
                r = decodeURIComponent(st(e, "wc_ev") || ""),
                i = this.client.session.keys.includes(t);
              i &&
                this.client.session.update(t, { transportType: lA.link_mode }),
                this.client.core.dispatchEnvelope({
                  topic: t,
                  message: r,
                  sessionExists: i,
                });
            }),
            hA(this, "registerLinkModeListeners", async () => {
              var e;
              if (
                si() ||
                (nG() &&
                  null != (e = this.client.metadata.redirect) &&
                  e.linkMode)
              ) {
                let e = null == r.g ? void 0 : r.g.Linking;
                if ("u" > typeof e) {
                  e.addEventListener(
                    "url",
                    this.handleLinkModeMessage,
                    this.client.name
                  );
                  let t = await e.getInitialURL();
                  t &&
                    setTimeout(() => {
                      this.handleLinkModeMessage({ url: t });
                    }, 50);
                }
              }
            }),
            hA(this, "shouldSetTVF", (e, t) => {
              if (!t || "wc_sessionRequest" !== e) return !1;
              let { request: r } = t;
              return Object.keys(hc).includes(r.method);
            }),
            hA(this, "getTVFParams", (e, t, r) => {
              var i, n;
              try {
                let s = t.request.method,
                  a = this.extractTxHashesFromResult(s, r);
                return hE(
                  hv(
                    { correlationId: e, rpcMethods: [s], chainId: t.chainId },
                    this.isValidContractData(t.request.params) && {
                      contractAddresses: [
                        null ==
                        (n = null == (i = t.request.params) ? void 0 : i[0])
                          ? void 0
                          : n.to,
                      ],
                    }
                  ),
                  { txHashes: a }
                );
              } catch (e) {
                this.client.logger.warn("Error getting TVF params", e);
              }
              return {};
            }),
            hA(this, "isValidContractData", (e) => {
              var t;
              if (!e) return !1;
              try {
                let r = e?.data || (null == (t = e?.[0]) ? void 0 : t.data);
                if (!r.startsWith("0x")) return !1;
                let i = r.slice(2);
                return !!/^[0-9a-fA-F]*$/.test(i) && i.length % 2 == 0;
              } catch {}
              return !1;
            }),
            hA(this, "extractTxHashesFromResult", (e, t) => {
              try {
                let r = hc[e];
                if ("string" == typeof t) return [t];
                let i = t[r.key];
                if (oT(i))
                  return "solana_signAllTransactions" === e
                    ? i.map((e) =>
                        (function (e) {
                          let t = atob(e),
                            r = new Uint8Array(t.length);
                          for (let e = 0; e < t.length; e++)
                            r[e] = t.charCodeAt(e);
                          let i = r[0];
                          if (0 === i) throw Error("No signatures found");
                          if (r.length < 1 + 64 * i)
                            throw Error(
                              "Transaction data too short for claimed signature count"
                            );
                          if (r.length < 100)
                            throw Error("Transaction too short");
                          let n = n$.from(e, "base64").slice(1, 65);
                          return id.Z.encode(n);
                        })(e)
                      )
                    : i;
                if ("string" == typeof i) return [i];
              } catch (e) {
                this.client.logger.warn(
                  "Error extracting tx hashes from result",
                  e
                );
              }
              return [];
            });
        }
        async processPendingMessageEvents() {
          try {
            let e = this.client.session.keys,
              t = this.client.core.relayer.messages.getWithoutAck(e);
            for (let [e, r] of Object.entries(t))
              for (let t of r)
                try {
                  await this.onProviderMessageEvent({
                    topic: e,
                    message: t,
                    publishedAt: Date.now(),
                  });
                } catch {
                  this.client.logger.warn(
                    `Error processing pending message event for topic: ${e}, message: ${t}`
                  );
                }
          } catch (e) {
            this.client.logger.warn("processPendingMessageEvents failed", e);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = oN("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
        async confirmOnlineStateOrThrow() {
          await this.client.core.relayer.confirmOnlineStateOrThrow();
        }
        registerRelayerEvents() {
          this.client.core.relayer.on(lb.message, (e) => {
            this.onProviderMessageEvent(e);
          });
        }
        async onRelayMessage(e) {
          let { topic: t, message: r, attestation: i, transportType: n } = e,
            { publicKey: s } = this.client.auth.authKeys.keys.includes(hd)
              ? this.client.auth.authKeys.get(hd)
              : { responseTopic: void 0, publicKey: void 0 };
          try {
            let e = await this.client.core.crypto.decode(t, r, {
              receiverPublicKey: s,
              encoding: n === lA.link_mode ? os : on,
            });
            lt(e)
              ? (this.client.core.history.set(t, e),
                await this.onRelayEventRequest({
                  topic: t,
                  payload: e,
                  attestation: i,
                  transportType: n,
                  encryptedId: oc(r),
                }))
              : lr(e)
              ? (await this.client.core.history.resolve(e),
                await this.onRelayEventResponse({
                  topic: t,
                  payload: e,
                  transportType: n,
                }),
                this.client.core.history.delete(t, e.id))
              : await this.onRelayEventUnknownPayload({
                  topic: t,
                  payload: e,
                  transportType: n,
                }),
              await this.client.core.relayer.messages.ack(t, r);
          } catch (e) {
            this.client.logger.error(e);
          }
        }
        registerExpirerEvents() {
          this.client.core.expirer.on(lP.expired, async (e) => {
            let { topic: t, id: r } = n5(e.target);
            return r && this.client.pendingRequest.keys.includes(r)
              ? await this.deletePendingSessionRequest(r, oN("EXPIRED"), !0)
              : r && this.client.auth.requests.keys.includes(r)
              ? await this.deletePendingAuthRequest(r, oN("EXPIRED"), !0)
              : void (t
                  ? this.client.session.keys.includes(t) &&
                    (await this.deleteSession({
                      topic: t,
                      expirerHasDeleted: !0,
                    }),
                    this.client.events.emit("session_expire", { topic: t }))
                  : r &&
                    (await this.deleteProposal(r, !0),
                    this.client.events.emit("proposal_expire", { id: r })));
          });
        }
        registerPairingEvents() {
          this.client.core.pairing.events.on(lS.create, (e) =>
            this.onPairingCreated(e)
          ),
            this.client.core.pairing.events.on(lS.delete, (e) => {
              this.addToRecentlyDeleted(e.topic, "pairing");
            });
        }
        isValidPairingTopic(e) {
          if (!ox(e, !1)) {
            let { message: t } = oN(
              "MISSING_OR_INVALID",
              `pairing topic should be a string: ${e}`
            );
            throw Error(t);
          }
          if (!this.client.core.pairing.pairings.keys.includes(e)) {
            let { message: t } = oN(
              "NO_MATCHING_KEY",
              `pairing topic doesn't exist: ${e}`
            );
            throw Error(t);
          }
          if (n4(this.client.core.pairing.pairings.get(e).expiry)) {
            let { message: t } = oN("EXPIRED", `pairing topic: ${e}`);
            throw Error(t);
          }
        }
        async isValidSessionTopic(e) {
          if (!ox(e, !1)) {
            let { message: t } = oN(
              "MISSING_OR_INVALID",
              `session topic should be a string: ${e}`
            );
            throw Error(t);
          }
          if (
            (this.checkRecentlyDeleted(e),
            !this.client.session.keys.includes(e))
          ) {
            let { message: t } = oN(
              "NO_MATCHING_KEY",
              `session topic doesn't exist: ${e}`
            );
            throw Error(t);
          }
          if (n4(this.client.session.get(e).expiry)) {
            await this.deleteSession({ topic: e });
            let { message: t } = oN("EXPIRED", `session topic: ${e}`);
            throw Error(t);
          }
          if (!this.client.core.crypto.keychain.has(e)) {
            let { message: t } = oN(
              "MISSING_OR_INVALID",
              `session topic does not exist in keychain: ${e}`
            );
            throw (await this.deleteSession({ topic: e }), Error(t));
          }
        }
        async isValidSessionOrPairingTopic(e) {
          if (
            (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e))
          )
            await this.isValidSessionTopic(e);
          else if (this.client.core.pairing.pairings.keys.includes(e))
            this.isValidPairingTopic(e);
          else if (ox(e, !1)) {
            let { message: t } = oN(
              "NO_MATCHING_KEY",
              `session or pairing topic doesn't exist: ${e}`
            );
            throw Error(t);
          } else {
            let { message: t } = oN(
              "MISSING_OR_INVALID",
              `session or pairing topic should be a string: ${e}`
            );
            throw Error(t);
          }
        }
        async isValidProposalId(e) {
          if ("number" != typeof e) {
            let { message: t } = oN(
              "MISSING_OR_INVALID",
              `proposal id should be a number: ${e}`
            );
            throw Error(t);
          }
          if (!this.client.proposal.keys.includes(e)) {
            let { message: t } = oN(
              "NO_MATCHING_KEY",
              `proposal id doesn't exist: ${e}`
            );
            throw Error(t);
          }
          if (n4(this.client.proposal.get(e).expiryTimestamp)) {
            await this.deleteProposal(e);
            let { message: t } = oN("EXPIRED", `proposal id: ${e}`);
            throw Error(t);
          }
        }
      }
      class h_ extends uS {
        constructor(e, t) {
          super(e, t, "proposal", ht), (this.core = e), (this.logger = t);
        }
      }
      class hI extends uS {
        constructor(e, t) {
          super(e, t, "session", ht), (this.core = e), (this.logger = t);
        }
      }
      class hN extends uS {
        constructor(e, t) {
          super(e, t, "request", ht, (e) => e.id),
            (this.core = e),
            (this.logger = t);
        }
      }
      class hS extends uS {
        constructor(e, t) {
          super(e, t, "authKeys", hh, () => hd),
            (this.core = e),
            (this.logger = t);
        }
      }
      class hT extends uS {
        constructor(e, t) {
          super(e, t, "pairingTopics", hh), (this.core = e), (this.logger = t);
        }
      }
      class hP extends uS {
        constructor(e, t) {
          super(e, t, "requests", hh, (e) => e.id),
            (this.core = e),
            (this.logger = t);
        }
      }
      var hO = Object.defineProperty,
        hx = (e, t, r) =>
          t in e
            ? hO(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        hk = (e, t, r) => hx(e, "symbol" != typeof t ? t + "" : t, r);
      class hR {
        constructor(e, t) {
          (this.core = e),
            (this.logger = t),
            hk(this, "authKeys"),
            hk(this, "pairingTopics"),
            hk(this, "requests"),
            (this.authKeys = new hS(this.core, this.logger)),
            (this.pairingTopics = new hT(this.core, this.logger)),
            (this.requests = new hP(this.core, this.logger));
        }
        async init() {
          await this.authKeys.init(),
            await this.pairingTopics.init(),
            await this.requests.init();
        }
      }
      var hD = Object.defineProperty,
        hU = (e, t, r) =>
          t in e
            ? hD(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        hL = (e, t, r) => hU(e, "symbol" != typeof t ? t + "" : t, r);
      class hM extends eE {
        constructor(e) {
          super(e),
            hL(this, "protocol", "wc"),
            hL(this, "version", 2),
            hL(this, "name", hr.name),
            hL(this, "metadata"),
            hL(this, "core"),
            hL(this, "logger"),
            hL(this, "events", new w.EventEmitter()),
            hL(this, "engine"),
            hL(this, "session"),
            hL(this, "proposal"),
            hL(this, "pendingRequest"),
            hL(this, "auth"),
            hL(this, "signConfig"),
            hL(this, "on", (e, t) => this.events.on(e, t)),
            hL(this, "once", (e, t) => this.events.once(e, t)),
            hL(this, "off", (e, t) => this.events.off(e, t)),
            hL(this, "removeListener", (e, t) =>
              this.events.removeListener(e, t)
            ),
            hL(this, "removeAllListeners", (e) =>
              this.events.removeAllListeners(e)
            ),
            hL(this, "connect", async (e) => {
              try {
                return await this.engine.connect(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            hL(this, "pair", async (e) => {
              try {
                return await this.engine.pair(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            hL(this, "approve", async (e) => {
              try {
                return await this.engine.approve(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            hL(this, "reject", async (e) => {
              try {
                return await this.engine.reject(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            hL(this, "update", async (e) => {
              try {
                return await this.engine.update(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            hL(this, "extend", async (e) => {
              try {
                return await this.engine.extend(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            hL(this, "request", async (e) => {
              try {
                return await this.engine.request(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            hL(this, "respond", async (e) => {
              try {
                return await this.engine.respond(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            hL(this, "ping", async (e) => {
              try {
                return await this.engine.ping(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            hL(this, "emit", async (e) => {
              try {
                return await this.engine.emit(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            hL(this, "disconnect", async (e) => {
              try {
                return await this.engine.disconnect(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            hL(this, "find", (e) => {
              try {
                return this.engine.find(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            hL(this, "getPendingSessionRequests", () => {
              try {
                return this.engine.getPendingSessionRequests();
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            hL(this, "authenticate", async (e, t) => {
              try {
                return await this.engine.authenticate(e, t);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            hL(this, "formatAuthMessage", (e) => {
              try {
                return this.engine.formatAuthMessage(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            hL(this, "approveSessionAuthenticate", async (e) => {
              try {
                return await this.engine.approveSessionAuthenticate(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            hL(this, "rejectSessionAuthenticate", async (e) => {
              try {
                return await this.engine.rejectSessionAuthenticate(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            (this.name = e?.name || hr.name),
            (this.metadata = e?.metadata || nJ()),
            (this.signConfig = e?.signConfig);
          let t =
            "u" > typeof e?.logger && "string" != typeof e?.logger
              ? e.logger
              : (0, ee.gw)((0, ee.jI)({ level: e?.logger || hr.logger }));
          (this.core = e?.core || new u7(e)),
            (this.logger = (0, ee.Ep)(t, this.name)),
            (this.session = new hI(this.core, this.logger)),
            (this.proposal = new h_(this.core, this.logger)),
            (this.pendingRequest = new hN(this.core, this.logger)),
            (this.engine = new hC(this)),
            (this.auth = new hR(this.core, this.logger));
        }
        static async init(e) {
          let t = new hM(e);
          return await t.initialize(), t;
        }
        get context() {
          return (0, ee.Fd)(this.logger);
        }
        get pairing() {
          return this.core.pairing.pairings;
        }
        async initialize() {
          this.logger.trace("Initialized");
          try {
            await this.core.start(),
              await this.session.init(),
              await this.proposal.init(),
              await this.pendingRequest.init(),
              await this.auth.init(),
              await this.engine.init(),
              this.logger.info("SignClient Initialization Success"),
              setTimeout(() => {
                this.engine.processRelayMessageCache();
              }, (0, v.toMiliseconds)(v.ONE_SECOND));
          } catch (e) {
            throw (
              (this.logger.info("SignClient Initialization Failure"),
              this.logger.error(e.message),
              e)
            );
          }
        }
      }
      var hB = r(80751),
        hj = r.n(hB),
        hF = Object.defineProperty,
        h$ = Object.defineProperties,
        hH = Object.getOwnPropertyDescriptors,
        hz = Object.getOwnPropertySymbols,
        hq = Object.prototype.hasOwnProperty,
        hV = Object.prototype.propertyIsEnumerable,
        hG = (e, t, r) =>
          t in e
            ? hF(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        hW = (e, t) => {
          for (var r in t || (t = {})) hq.call(t, r) && hG(e, r, t[r]);
          if (hz) for (var r of hz(t)) hV.call(t, r) && hG(e, r, t[r]);
          return e;
        },
        hK = (e, t) => h$(e, hH(t));
      let hZ = {
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
        },
        method: "POST",
      };
      class hJ {
        constructor(e, t = !1) {
          if (
            ((this.url = e),
            (this.disableProviderPing = t),
            (this.events = new w.EventEmitter()),
            (this.isAvailable = !1),
            (this.registering = !1),
            !o9(e))
          )
            throw Error(
              `Provided URL is not compatible with HTTP connection: ${e}`
            );
          (this.url = e), (this.disableProviderPing = t);
        }
        get connected() {
          return this.isAvailable;
        }
        get connecting() {
          return this.registering;
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async open(e = this.url) {
          await this.register(e);
        }
        async close() {
          if (!this.isAvailable) throw Error("Connection already closed");
          this.onClose();
        }
        async send(e) {
          this.isAvailable || (await this.register());
          try {
            let t = (0, q.u)(e),
              r = await (
                await hj()(this.url, hK(hW({}, hZ), { body: t }))
              ).json();
            this.onPayload({ data: r });
          } catch (t) {
            this.onError(e.id, t);
          }
        }
        async register(e = this.url) {
          if (!o9(e))
            throw Error(
              `Provided URL is not compatible with HTTP connection: ${e}`
            );
          if (this.registering) {
            let e = this.events.getMaxListeners();
            return (
              (this.events.listenerCount("register_error") >= e ||
                this.events.listenerCount("open") >= e) &&
                this.events.setMaxListeners(e + 1),
              new Promise((e, t) => {
                this.events.once("register_error", (e) => {
                  this.resetMaxListeners(), t(e);
                }),
                  this.events.once("open", () => {
                    if (
                      (this.resetMaxListeners(), typeof this.isAvailable > "u")
                    )
                      return t(Error("HTTP connection is missing or invalid"));
                    e();
                  });
              })
            );
          }
          (this.url = e), (this.registering = !0);
          try {
            if (!this.disableProviderPing) {
              let t = (0, q.u)({
                id: 1,
                jsonrpc: "2.0",
                method: "test",
                params: [],
              });
              await hj()(e, hK(hW({}, hZ), { body: t }));
            }
            this.onOpen();
          } catch (t) {
            let e = this.parseError(t);
            throw (this.events.emit("register_error", e), this.onClose(), e);
          }
        }
        onOpen() {
          (this.isAvailable = !0),
            (this.registering = !1),
            this.events.emit("open");
        }
        onClose() {
          (this.isAvailable = !1),
            (this.registering = !1),
            this.events.emit("close");
        }
        onPayload(e) {
          if (typeof e.data > "u") return;
          let t = "string" == typeof e.data ? (0, q.D)(e.data) : e.data;
          this.events.emit("payload", t);
        }
        onError(e, t) {
          let r = this.parseError(t),
            i = o3(e, r.message || r.toString());
          this.events.emit("payload", i);
        }
        parseError(e, t = this.url) {
          return oQ(e, t, "HTTP");
        }
        resetMaxListeners() {
          this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10);
        }
      }
      var hQ = r(82957).Buffer;
      let hY = "error",
        hX = "wc@2:universal_provider:",
        h0 = "https://rpc.walletconnect.org/v1/",
        h1 = "generic",
        h2 = `${h0}bundler`,
        h3 = "default_chain_changed";
      function h5() {}
      function h8(e) {
        return null == e || ("object" != typeof e && "function" != typeof e);
      }
      function h4(e) {
        return ArrayBuffer.isView(e) && !(e instanceof DataView);
      }
      function h6(e) {
        return "object" == typeof e && null !== e;
      }
      function h9(e) {
        return Object.getOwnPropertySymbols(e).filter((t) =>
          Object.prototype.propertyIsEnumerable.call(e, t)
        );
      }
      function h7(e) {
        return null == e
          ? void 0 === e
            ? "[object Undefined]"
            : "[object Null]"
          : Object.prototype.toString.call(e);
      }
      let de = "[object String]",
        dt = "[object Number]",
        dr = "[object Boolean]",
        di = "[object Arguments]";
      function dn(e, t, r, i = new Map(), n) {
        let s = n?.(e, t, r, i);
        if (null != s) return s;
        if (h8(e)) return e;
        if (i.has(e)) return i.get(e);
        if (Array.isArray(e)) {
          let t = Array(e.length);
          i.set(e, t);
          for (let s = 0; s < e.length; s++) t[s] = dn(e[s], s, r, i, n);
          return (
            Object.hasOwn(e, "index") && (t.index = e.index),
            Object.hasOwn(e, "input") && (t.input = e.input),
            t
          );
        }
        if (e instanceof Date) return new Date(e.getTime());
        if (e instanceof RegExp) {
          let t = new RegExp(e.source, e.flags);
          return (t.lastIndex = e.lastIndex), t;
        }
        if (e instanceof Map) {
          let t = new Map();
          for (let [s, a] of (i.set(e, t), e)) t.set(s, dn(a, s, r, i, n));
          return t;
        }
        if (e instanceof Set) {
          let t = new Set();
          for (let s of (i.set(e, t), e)) t.add(dn(s, void 0, r, i, n));
          return t;
        }
        if ("u" > typeof hQ && hQ.isBuffer(e)) return e.subarray();
        if (h4(e)) {
          let t = new (Object.getPrototypeOf(e).constructor)(e.length);
          i.set(e, t);
          for (let s = 0; s < e.length; s++) t[s] = dn(e[s], s, r, i, n);
          return t;
        }
        if (
          e instanceof ArrayBuffer ||
          ("u" > typeof SharedArrayBuffer && e instanceof SharedArrayBuffer)
        )
          return e.slice(0);
        if (e instanceof DataView) {
          let t = new DataView(e.buffer.slice(0), e.byteOffset, e.byteLength);
          return i.set(e, t), ds(t, e, r, i, n), t;
        }
        if ("u" > typeof File && e instanceof File) {
          let t = new File([e], e.name, { type: e.type });
          return i.set(e, t), ds(t, e, r, i, n), t;
        }
        if (e instanceof Blob) {
          let t = new Blob([e], { type: e.type });
          return i.set(e, t), ds(t, e, r, i, n), t;
        }
        if (e instanceof Error) {
          let t = new e.constructor();
          return (
            i.set(e, t),
            (t.message = e.message),
            (t.name = e.name),
            (t.stack = e.stack),
            (t.cause = e.cause),
            ds(t, e, r, i, n),
            t
          );
        }
        if (
          "object" == typeof e &&
          (function (e) {
            switch (h7(e)) {
              case di:
              case "[object Array]":
              case "[object ArrayBuffer]":
              case "[object DataView]":
              case dr:
              case "[object Date]":
              case "[object Float32Array]":
              case "[object Float64Array]":
              case "[object Int8Array]":
              case "[object Int16Array]":
              case "[object Int32Array]":
              case "[object Map]":
              case dt:
              case "[object Object]":
              case "[object RegExp]":
              case "[object Set]":
              case de:
              case "[object Symbol]":
              case "[object Uint8Array]":
              case "[object Uint8ClampedArray]":
              case "[object Uint16Array]":
              case "[object Uint32Array]":
                return !0;
              default:
                return !1;
            }
          })(e)
        ) {
          let t = Object.create(Object.getPrototypeOf(e));
          return i.set(e, t), ds(t, e, r, i, n), t;
        }
        return e;
      }
      function ds(e, t, r = e, i, n) {
        let s = [...Object.keys(t), ...h9(t)];
        for (let a = 0; a < s.length; a++) {
          let o = s[a],
            l = Object.getOwnPropertyDescriptor(e, o);
          (null == l || l.writable) && (e[o] = dn(t[o], o, r, i, n));
        }
      }
      function da(e) {
        var t;
        return (
          (t = (t, r, i, n) => {
            let s = void 0;
            if (null != s) return s;
            if ("object" == typeof e)
              switch (Object.prototype.toString.call(e)) {
                case dt:
                case de:
                case dr: {
                  let t = new e.constructor(e?.valueOf());
                  return ds(t, e), t;
                }
                case di: {
                  let t = {};
                  return (
                    ds(t, e),
                    (t.length = e.length),
                    (t[Symbol.iterator] = e[Symbol.iterator]),
                    t
                  );
                }
                default:
                  return;
              }
          }),
          dn(e, void 0, e, new Map(), t)
        );
      }
      function dl(e) {
        return (
          null !== e && "object" == typeof e && "[object Arguments]" === h7(e)
        );
      }
      var dc = Object.defineProperty,
        du = Object.defineProperties,
        dh = Object.getOwnPropertyDescriptors,
        dd = Object.getOwnPropertySymbols,
        dp = Object.prototype.hasOwnProperty,
        df = Object.prototype.propertyIsEnumerable,
        dg = (e, t, r) =>
          t in e
            ? dc(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        dm = (e, t) => {
          for (var r in t || (t = {})) dp.call(t, r) && dg(e, r, t[r]);
          if (dd) for (var r of dd(t)) df.call(t, r) && dg(e, r, t[r]);
          return e;
        },
        dy = (e, t) => du(e, dh(t));
      function dw(e, t, r) {
        var i;
        let n = nH(e);
        return (
          (null == (i = t.rpcMap) ? void 0 : i[n.reference]) ||
          `${h0}?chainId=${n.namespace}:${n.reference}&projectId=${r}`
        );
      }
      function db(e) {
        return e.includes(":") ? e.split(":")[1] : e;
      }
      function dv(e) {
        return e.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
      }
      function dE(e = {}, t = {}) {
        return (function (e, ...t) {
          return (function (e, ...t) {
            let r = t.slice(0, -1),
              i = t[t.length - 1],
              n = e;
            for (let e = 0; e < r.length; e++)
              n = (function e(t, r, i, n) {
                if (
                  (h8(t) && (t = Object(t)), null == r || "object" != typeof r)
                )
                  return t;
                if (n.has(r))
                  return (function (e) {
                    if (h8(e)) return e;
                    if (
                      Array.isArray(e) ||
                      h4(e) ||
                      e instanceof ArrayBuffer ||
                      ("u" > typeof SharedArrayBuffer &&
                        e instanceof SharedArrayBuffer)
                    )
                      return e.slice(0);
                    let t = Object.getPrototypeOf(e),
                      r = t.constructor;
                    if (
                      e instanceof Date ||
                      e instanceof Map ||
                      e instanceof Set
                    )
                      return new r(e);
                    if (e instanceof RegExp) {
                      let t = new r(e);
                      return (t.lastIndex = e.lastIndex), t;
                    }
                    if (e instanceof DataView) return new r(e.buffer.slice(0));
                    if (e instanceof Error) {
                      let t = new r(e.message);
                      return (
                        (t.stack = e.stack),
                        (t.name = e.name),
                        (t.cause = e.cause),
                        t
                      );
                    }
                    return "u" > typeof File && e instanceof File
                      ? new r([e], e.name, {
                          type: e.type,
                          lastModified: e.lastModified,
                        })
                      : "object" == typeof e
                      ? Object.assign(Object.create(t), e)
                      : e;
                  })(n.get(r));
                if ((n.set(r, t), Array.isArray(r))) {
                  r = r.slice();
                  for (let e = 0; e < r.length; e++) r[e] = r[e] ?? void 0;
                }
                let s = [...Object.keys(r), ...h9(r)];
                for (let a = 0; a < s.length; a++) {
                  let o = s[a],
                    l = r[o],
                    c = t[o];
                  if (
                    (dl(l) && (l = { ...l }),
                    dl(c) && (c = { ...c }),
                    "u" > typeof hQ && hQ.isBuffer(l) && (l = da(l)),
                    Array.isArray(l))
                  ) {
                    if ("object" == typeof c && null != c) {
                      let e = [],
                        t = Reflect.ownKeys(c);
                      for (let r = 0; r < t.length; r++) {
                        let i = t[r];
                        e[i] = c[i];
                      }
                      c = e;
                    } else c = [];
                  }
                  let u = i(c, l, o, t, r, n);
                  null != u
                    ? (t[o] = u)
                    : Array.isArray(l) || (h6(c) && h6(l))
                    ? (t[o] = e(c, l, i, n))
                    : null == c &&
                      (function (e) {
                        if ("object" != typeof e || null == e) return !1;
                        if (null === Object.getPrototypeOf(e)) return !0;
                        if (
                          "[object Object]" !==
                          Object.prototype.toString.call(e)
                        ) {
                          let t = e[Symbol.toStringTag];
                          return (
                            !!(
                              null != t &&
                              Object.getOwnPropertyDescriptor(
                                e,
                                Symbol.toStringTag
                              )?.writable
                            ) && e.toString() === `[object ${t}]`
                          );
                        }
                        let t = e;
                        for (; null !== Object.getPrototypeOf(t); )
                          t = Object.getPrototypeOf(t);
                        return Object.getPrototypeOf(e) === t;
                      })(l)
                    ? (t[o] = e({}, l, i, n))
                    : null == c && h4(l)
                    ? (t[o] = da(l))
                    : (void 0 === c || void 0 !== l) && (t[o] = l);
                }
                return t;
              })(n, r[e], i, new Map());
            return n;
          })(e, ...t, h5);
        })(dA(e), dA(t));
      }
      function dA(e) {
        var t, r, i, n;
        let s = {};
        if (!oP(e)) return s;
        for (let [a, o] of Object.entries(e)) {
          let e = oE(a) ? [a] : o.chains,
            l = o.methods || [],
            c = o.events || [],
            u = o.rpcMap || {},
            h = oA(a);
          s[h] = dy(dm(dm({}, s[h]), o), {
            chains: n9(e, null == (t = s[h]) ? void 0 : t.chains),
            methods: n9(l, null == (r = s[h]) ? void 0 : r.methods),
            events: n9(c, null == (i = s[h]) ? void 0 : i.events),
            rpcMap: dm(dm({}, u), null == (n = s[h]) ? void 0 : n.rpcMap),
          });
        }
        return s;
      }
      function dC(e) {
        return e.includes(":") ? e.split(":")[2] : e;
      }
      function d_(e) {
        let t = {};
        for (let [r, i] of Object.entries(e)) {
          let e = i.methods || [],
            n = i.events || [],
            s = i.accounts || [],
            a = oE(r) ? [r] : i.chains ? i.chains : dv(i.accounts);
          t[r] = { chains: a, methods: e, events: n, accounts: s };
        }
        return t;
      }
      function dI(e) {
        return "number" == typeof e
          ? e
          : e.includes("0x")
          ? parseInt(e, 16)
          : isNaN(Number((e = e.includes(":") ? e.split(":")[1] : e)))
          ? e
          : Number(e);
      }
      let dN = {},
        dS = (e) => dN[e],
        dT = (e, t) => {
          dN[e] = t;
        };
      var dP = Object.defineProperty,
        dO = (e, t, r) =>
          t in e
            ? dP(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        dx = (e, t, r) => dO(e, "symbol" != typeof t ? t + "" : t, r);
      class dk {
        constructor(e) {
          dx(this, "name", "polkadot"),
            dx(this, "client"),
            dx(this, "httpProviders"),
            dx(this, "events"),
            dx(this, "namespace"),
            dx(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = dS("events")),
            (this.client = dS("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(h3, `${this.name}:${e}`);
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return (
            (e &&
              e
                .filter((e) => e.split(":")[1] === this.chainId.toString())
                .map((e) => e.split(":")[2])) ||
            []
          );
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = db(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || dw(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new ls(new hJ(r, dS("disableProviderPing")));
        }
      }
      var dR = Object.defineProperty,
        dD = Object.defineProperties,
        dU = Object.getOwnPropertyDescriptors,
        dL = Object.getOwnPropertySymbols,
        dM = Object.prototype.hasOwnProperty,
        dB = Object.prototype.propertyIsEnumerable,
        dj = (e, t, r) =>
          t in e
            ? dR(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        dF = (e, t) => {
          for (var r in t || (t = {})) dM.call(t, r) && dj(e, r, t[r]);
          if (dL) for (var r of dL(t)) dB.call(t, r) && dj(e, r, t[r]);
          return e;
        },
        d$ = (e, t) => dD(e, dU(t)),
        dH = (e, t, r) => dj(e, "symbol" != typeof t ? t + "" : t, r);
      class dz {
        constructor(e) {
          dH(this, "name", "eip155"),
            dH(this, "client"),
            dH(this, "chainId"),
            dH(this, "namespace"),
            dH(this, "httpProviders"),
            dH(this, "events"),
            (this.namespace = e.namespace),
            (this.events = dS("events")),
            (this.client = dS("client")),
            (this.httpProviders = this.createHttpProviders()),
            (this.chainId = parseInt(this.getDefaultChain()));
        }
        async request(e) {
          switch (e.request.method) {
            case "eth_requestAccounts":
            case "eth_accounts":
              return this.getAccounts();
            case "wallet_switchEthereumChain":
              return await this.handleSwitchChain(e);
            case "eth_chainId":
              return parseInt(this.getDefaultChain());
            case "wallet_getCapabilities":
              return await this.getCapabilities(e);
            case "wallet_getCallsStatus":
              return await this.getCallStatus(e);
          }
          return this.namespace.methods.includes(e.request.method)
            ? await this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(parseInt(e), t),
            (this.chainId = parseInt(e)),
            this.events.emit(h3, `${this.name}:${e}`);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId.toString();
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        createHttpProvider(e, t) {
          let r =
            t ||
            dw(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new ls(new hJ(r, dS("disableProviderPing")));
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = parseInt(db(t));
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        getHttpProvider() {
          let e = this.chainId,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        async handleSwitchChain(e) {
          var t, r;
          let i = e.request.params
              ? null == (t = e.request.params[0])
                ? void 0
                : t.chainId
              : "0x0",
            n = parseInt((i = i.startsWith("0x") ? i : `0x${i}`), 16);
          if (this.isChainApproved(n)) this.setDefaultChain(`${n}`);
          else if (
            this.namespace.methods.includes("wallet_switchEthereumChain")
          )
            await this.client.request({
              topic: e.topic,
              request: { method: e.request.method, params: [{ chainId: i }] },
              chainId: null == (r = this.namespace.chains) ? void 0 : r[0],
            }),
              this.setDefaultChain(`${n}`);
          else
            throw Error(
              `Failed to switch to chain 'eip155:${n}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`
            );
          return null;
        }
        isChainApproved(e) {
          return this.namespace.chains.includes(`${this.name}:${e}`);
        }
        async getCapabilities(e) {
          var t, r, i;
          let n =
            null == (r = null == (t = e.request) ? void 0 : t.params)
              ? void 0
              : r[0];
          if (!n)
            throw Error(
              "Missing address parameter in `wallet_getCapabilities` request"
            );
          let s = this.client.session.get(e.topic),
            a =
              (null == (i = s?.sessionProperties) ? void 0 : i.capabilities) ||
              {};
          if (null != a && a[n]) return a?.[n];
          let o = await this.client.request(e);
          try {
            await this.client.session.update(e.topic, {
              sessionProperties: d$(dF({}, s.sessionProperties || {}), {
                capabilities: d$(dF({}, a || {}), { [n]: o }),
              }),
            });
          } catch (e) {
            console.warn("Failed to update session with capabilities", e);
          }
          return o;
        }
        async getCallStatus(e) {
          var t, r;
          let i = this.client.session.get(e.topic),
            n = null == (t = i.sessionProperties) ? void 0 : t.bundler_name;
          if (n) {
            let t = this.getBundlerUrl(e.chainId, n);
            try {
              return await this.getUserOperationReceipt(t, e);
            } catch (e) {
              console.warn("Failed to fetch call status from bundler", e, t);
            }
          }
          let s = null == (r = i.sessionProperties) ? void 0 : r.bundler_url;
          if (s)
            try {
              return await this.getUserOperationReceipt(s, e);
            } catch (e) {
              console.warn(
                "Failed to fetch call status from custom bundler",
                e,
                s
              );
            }
          if (this.namespace.methods.includes(e.request.method))
            return await this.client.request(e);
          throw Error("Fetching call status not approved by the wallet.");
        }
        async getUserOperationReceipt(e, t) {
          var r;
          let i = new URL(e),
            n = await fetch(i, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(
                o1("eth_getUserOperationReceipt", [
                  null == (r = t.request.params) ? void 0 : r[0],
                ])
              ),
            });
          if (!n.ok)
            throw Error(`Failed to fetch user operation receipt - ${n.status}`);
          return await n.json();
        }
        getBundlerUrl(e, t) {
          return `${h2}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`;
        }
      }
      var dq = Object.defineProperty,
        dV = (e, t, r) =>
          t in e
            ? dq(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        dG = (e, t, r) => dV(e, "symbol" != typeof t ? t + "" : t, r);
      class dW {
        constructor(e) {
          dG(this, "name", "solana"),
            dG(this, "client"),
            dG(this, "httpProviders"),
            dG(this, "events"),
            dG(this, "namespace"),
            dG(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = dS("events")),
            (this.client = dS("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(h3, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = db(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || dw(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new ls(new hJ(r, dS("disableProviderPing")));
        }
      }
      var dK = Object.defineProperty,
        dZ = (e, t, r) =>
          t in e
            ? dK(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        dJ = (e, t, r) => dZ(e, "symbol" != typeof t ? t + "" : t, r);
      class dQ {
        constructor(e) {
          dJ(this, "name", "cosmos"),
            dJ(this, "client"),
            dJ(this, "httpProviders"),
            dJ(this, "events"),
            dJ(this, "namespace"),
            dJ(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = dS("events")),
            (this.client = dS("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(h3, `${this.name}:${this.chainId}`);
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = db(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || dw(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new ls(new hJ(r, dS("disableProviderPing")));
        }
      }
      var dY = Object.defineProperty,
        dX = (e, t, r) =>
          t in e
            ? dY(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        d0 = (e, t, r) => dX(e, "symbol" != typeof t ? t + "" : t, r);
      class d1 {
        constructor(e) {
          d0(this, "name", "algorand"),
            d0(this, "client"),
            d0(this, "httpProviders"),
            d0(this, "events"),
            d0(this, "namespace"),
            d0(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = dS("events")),
            (this.client = dS("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          if (!this.httpProviders[e]) {
            let r =
              t ||
              dw(
                `${this.name}:${e}`,
                this.namespace,
                this.client.core.projectId
              );
            if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, r);
          }
          (this.chainId = e),
            this.events.emit(h3, `${this.name}:${this.chainId}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              e[t] = this.createHttpProvider(
                t,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || dw(e, this.namespace, this.client.core.projectId);
          return typeof r > "u"
            ? void 0
            : new ls(new hJ(r, dS("disableProviderPing")));
        }
      }
      var d2 = Object.defineProperty,
        d3 = (e, t, r) =>
          t in e
            ? d2(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        d5 = (e, t, r) => d3(e, "symbol" != typeof t ? t + "" : t, r);
      class d8 {
        constructor(e) {
          d5(this, "name", "cip34"),
            d5(this, "client"),
            d5(this, "httpProviders"),
            d5(this, "events"),
            d5(this, "namespace"),
            d5(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = dS("events")),
            (this.client = dS("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(h3, `${this.name}:${this.chainId}`);
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              let r = this.getCardanoRPCUrl(t),
                i = db(t);
              e[i] = this.createHttpProvider(i, r);
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        getCardanoRPCUrl(e) {
          let t = this.namespace.rpcMap;
          if (t) return t[e];
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || this.getCardanoRPCUrl(e);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new ls(new hJ(r, dS("disableProviderPing")));
        }
      }
      var d4 = Object.defineProperty,
        d6 = (e, t, r) =>
          t in e
            ? d4(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        d9 = (e, t, r) => d6(e, "symbol" != typeof t ? t + "" : t, r);
      class d7 {
        constructor(e) {
          d9(this, "name", "elrond"),
            d9(this, "client"),
            d9(this, "httpProviders"),
            d9(this, "events"),
            d9(this, "namespace"),
            d9(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = dS("events")),
            (this.client = dS("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(h3, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = db(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || dw(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new ls(new hJ(r, dS("disableProviderPing")));
        }
      }
      var pe = Object.defineProperty,
        pt = (e, t, r) =>
          t in e
            ? pe(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        pr = (e, t, r) => pt(e, "symbol" != typeof t ? t + "" : t, r);
      class pi {
        constructor(e) {
          pr(this, "name", "multiversx"),
            pr(this, "client"),
            pr(this, "httpProviders"),
            pr(this, "events"),
            pr(this, "namespace"),
            pr(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = dS("events")),
            (this.client = dS("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(h3, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = db(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || dw(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new ls(new hJ(r, dS("disableProviderPing")));
        }
      }
      var pn = Object.defineProperty,
        ps = (e, t, r) =>
          t in e
            ? pn(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        pa = (e, t, r) => ps(e, "symbol" != typeof t ? t + "" : t, r);
      class po {
        constructor(e) {
          pa(this, "name", "near"),
            pa(this, "client"),
            pa(this, "httpProviders"),
            pa(this, "events"),
            pa(this, "namespace"),
            pa(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = dS("events")),
            (this.client = dS("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          if (((this.chainId = e), !this.httpProviders[e])) {
            let r = t || dw(`${this.name}:${e}`, this.namespace);
            if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, r);
          }
          this.events.emit(h3, `${this.name}:${this.chainId}`);
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return (
            (e &&
              e
                .filter((e) => e.split(":")[1] === this.chainId.toString())
                .map((e) => e.split(":")[2])) ||
            []
          );
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              e[t] = this.createHttpProvider(
                t,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || dw(e, this.namespace);
          return typeof r > "u"
            ? void 0
            : new ls(new hJ(r, dS("disableProviderPing")));
        }
      }
      var pl = Object.defineProperty,
        pc = (e, t, r) =>
          t in e
            ? pl(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        pu = (e, t, r) => pc(e, "symbol" != typeof t ? t + "" : t, r);
      class ph {
        constructor(e) {
          pu(this, "name", "tezos"),
            pu(this, "client"),
            pu(this, "httpProviders"),
            pu(this, "events"),
            pu(this, "namespace"),
            pu(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = dS("events")),
            (this.client = dS("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          if (((this.chainId = e), !this.httpProviders[e])) {
            let r = t || dw(`${this.name}:${e}`, this.namespace);
            if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, r);
          }
          this.events.emit(h3, `${this.name}:${this.chainId}`);
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return (
            (e &&
              e
                .filter((e) => e.split(":")[1] === this.chainId.toString())
                .map((e) => e.split(":")[2])) ||
            []
          );
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              e[t] = this.createHttpProvider(t);
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || dw(e, this.namespace);
          return typeof r > "u" ? void 0 : new ls(new hJ(r));
        }
      }
      var pd = Object.defineProperty,
        pp = (e, t, r) =>
          t in e
            ? pd(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        pf = (e, t, r) => pp(e, "symbol" != typeof t ? t + "" : t, r);
      class pg {
        constructor(e) {
          pf(this, "name", h1),
            pf(this, "client"),
            pf(this, "httpProviders"),
            pf(this, "events"),
            pf(this, "namespace"),
            pf(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = dS("events")),
            (this.client = dS("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          (this.namespace.chains = [
            ...new Set((this.namespace.chains || []).concat(e.chains || [])),
          ]),
            (this.namespace.accounts = [
              ...new Set(
                (this.namespace.accounts || []).concat(e.accounts || [])
              ),
            ]),
            (this.namespace.methods = [
              ...new Set(
                (this.namespace.methods || []).concat(e.methods || [])
              ),
            ]),
            (this.namespace.events = [
              ...new Set((this.namespace.events || []).concat(e.events || [])),
            ]),
            (this.httpProviders = this.createHttpProviders());
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider(e.chainId).request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(h3, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          var e, t;
          let r = {};
          return (
            null == (t = null == (e = this.namespace) ? void 0 : e.accounts) ||
              t.forEach((e) => {
                let t = nH(e);
                r[`${t.namespace}:${t.reference}`] = this.createHttpProvider(e);
              }),
            r
          );
        }
        getHttpProvider(e) {
          let t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || dw(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new ls(new hJ(r, dS("disableProviderPing")));
        }
      }
      var pm = Object.defineProperty,
        py = Object.defineProperties,
        pw = Object.getOwnPropertyDescriptors,
        pb = Object.getOwnPropertySymbols,
        pv = Object.prototype.hasOwnProperty,
        pE = Object.prototype.propertyIsEnumerable,
        pA = (e, t, r) =>
          t in e
            ? pm(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        pC = (e, t) => {
          for (var r in t || (t = {})) pv.call(t, r) && pA(e, r, t[r]);
          if (pb) for (var r of pb(t)) pE.call(t, r) && pA(e, r, t[r]);
          return e;
        },
        p_ = (e, t) => py(e, pw(t)),
        pI = (e, t, r) => pA(e, "symbol" != typeof t ? t + "" : t, r);
      class pN {
        constructor(e) {
          pI(this, "client"),
            pI(this, "namespaces"),
            pI(this, "optionalNamespaces"),
            pI(this, "sessionProperties"),
            pI(this, "scopedProperties"),
            pI(this, "events", new (b())()),
            pI(this, "rpcProviders", {}),
            pI(this, "session"),
            pI(this, "providerOpts"),
            pI(this, "logger"),
            pI(this, "uri"),
            pI(this, "disableProviderPing", !1),
            (this.providerOpts = e),
            (this.logger =
              "u" > typeof e?.logger && "string" != typeof e?.logger
                ? e.logger
                : (0, ee.gw)((0, ee.jI)({ level: e?.logger || hY }))),
            (this.disableProviderPing = e?.disableProviderPing || !1);
        }
        static async init(e) {
          let t = new pN(e);
          return await t.initialize(), t;
        }
        async request(e, t, r) {
          let [i, n] = this.validateChain(t);
          if (!this.session)
            throw Error("Please call connect() before request()");
          return await this.getProvider(i).request({
            request: pC({}, e),
            chainId: `${i}:${n}`,
            topic: this.session.topic,
            expiry: r,
          });
        }
        sendAsync(e, t, r, i) {
          let n = new Date().getTime();
          this.request(e, r, i)
            .then((e) => t(null, o2(n, e)))
            .catch((e) => t(e, void 0));
        }
        async enable() {
          if (!this.client) throw Error("Sign Client not initialized");
          return (
            this.session ||
              (await this.connect({
                namespaces: this.namespaces,
                optionalNamespaces: this.optionalNamespaces,
                sessionProperties: this.sessionProperties,
                scopedProperties: this.scopedProperties,
              })),
            await this.requestAccounts()
          );
        }
        async disconnect() {
          var e;
          if (!this.session)
            throw Error("Please call connect() before enable()");
          await this.client.disconnect({
            topic: null == (e = this.session) ? void 0 : e.topic,
            reason: oS("USER_DISCONNECTED"),
          }),
            await this.cleanup();
        }
        async connect(e) {
          if (!this.client) throw Error("Sign Client not initialized");
          if (
            (this.setNamespaces(e),
            await this.cleanupPendingPairings(),
            !e.skipPairing)
          )
            return await this.pair(e.pairingTopic);
        }
        async authenticate(e, t) {
          if (!this.client) throw Error("Sign Client not initialized");
          this.setNamespaces(e), await this.cleanupPendingPairings();
          let { uri: r, response: i } = await this.client.authenticate(e, t);
          r && ((this.uri = r), this.events.emit("display_uri", r));
          let n = await i();
          if (((this.session = n.session), this.session)) {
            let e = d_(this.session.namespaces);
            (this.namespaces = dE(this.namespaces, e)),
              await this.persist("namespaces", this.namespaces),
              this.onConnect();
          }
          return n;
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        get isWalletConnect() {
          return !0;
        }
        async pair(e) {
          let { uri: t, approval: r } = await this.client.connect({
            pairingTopic: e,
            requiredNamespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties,
            scopedProperties: this.scopedProperties,
          });
          t && ((this.uri = t), this.events.emit("display_uri", t));
          let i = await r();
          this.session = i;
          let n = d_(i.namespaces);
          return (
            (this.namespaces = dE(this.namespaces, n)),
            await this.persist("namespaces", this.namespaces),
            await this.persist("optionalNamespaces", this.optionalNamespaces),
            this.onConnect(),
            this.session
          );
        }
        setDefaultChain(e, t) {
          try {
            if (!this.session) return;
            let [r, i] = this.validateChain(e),
              n = this.getProvider(r);
            n.name === h1
              ? n.setDefaultChain(`${r}:${i}`, t)
              : n.setDefaultChain(i, t);
          } catch (e) {
            if (!/Please call connect/.test(e.message)) throw e;
          }
        }
        async cleanupPendingPairings(e = {}) {
          this.logger.info("Cleaning up inactive pairings...");
          let t = this.client.pairing.getAll();
          if (oT(t)) {
            for (let r of t)
              e.deletePairings
                ? this.client.core.expirer.set(r.topic, 0)
                : await this.client.core.relayer.subscriber.unsubscribe(
                    r.topic
                  );
            this.logger.info(`Inactive pairings cleared: ${t.length}`);
          }
        }
        abortPairingAttempt() {
          this.logger.warn(
            "abortPairingAttempt is deprecated. This is now a no-op."
          );
        }
        async checkStorage() {
          (this.namespaces = (await this.getFromStore("namespaces")) || {}),
            (this.optionalNamespaces =
              (await this.getFromStore("optionalNamespaces")) || {}),
            this.session && this.createProviders();
        }
        async initialize() {
          this.logger.trace("Initialized"),
            await this.createClient(),
            await this.checkStorage(),
            this.registerEventListeners();
        }
        async createClient() {
          var e, t;
          if (
            ((this.client =
              this.providerOpts.client ||
              (await hM.init({
                core: this.providerOpts.core,
                logger: this.providerOpts.logger || hY,
                relayUrl:
                  this.providerOpts.relayUrl || "wss://relay.walletconnect.org",
                projectId: this.providerOpts.projectId,
                metadata: this.providerOpts.metadata,
                storageOptions: this.providerOpts.storageOptions,
                storage: this.providerOpts.storage,
                name: this.providerOpts.name,
                customStoragePrefix: this.providerOpts.customStoragePrefix,
                telemetryEnabled: this.providerOpts.telemetryEnabled,
              }))),
            this.providerOpts.session)
          )
            try {
              this.session = this.client.session.get(
                this.providerOpts.session.topic
              );
            } catch (r) {
              throw (
                (this.logger.error("Failed to get session", r),
                Error(
                  `The provided session: ${
                    null ==
                    (t = null == (e = this.providerOpts) ? void 0 : e.session)
                      ? void 0
                      : t.topic
                  } doesn't exist in the Sign client`
                ))
              );
            }
          else {
            let e = this.client.session.getAll();
            this.session = e[0];
          }
          this.logger.trace("SignClient Initialized");
        }
        createProviders() {
          if (!this.client) throw Error("Sign Client not initialized");
          if (!this.session)
            throw Error(
              "Session not initialized. Please call connect() before enable()"
            );
          let e = [
            ...new Set(Object.keys(this.session.namespaces).map((e) => oA(e))),
          ];
          dT("client", this.client),
            dT("events", this.events),
            dT("disableProviderPing", this.disableProviderPing),
            e.forEach((e) => {
              if (!this.session) return;
              let t = (function (e, t) {
                  let r = Object.keys(t.namespaces).filter((t) =>
                    t.includes(e)
                  );
                  if (!r.length) return [];
                  let i = [];
                  return (
                    r.forEach((e) => {
                      let r = t.namespaces[e].accounts;
                      i.push(...r);
                    }),
                    i
                  );
                })(e, this.session),
                r = dv(t),
                i = p_(
                  pC({}, dE(this.namespaces, this.optionalNamespaces)[e]),
                  { accounts: t, chains: r }
                );
              switch (e) {
                case "eip155":
                  this.rpcProviders[e] = new dz({ namespace: i });
                  break;
                case "algorand":
                  this.rpcProviders[e] = new d1({ namespace: i });
                  break;
                case "solana":
                  this.rpcProviders[e] = new dW({ namespace: i });
                  break;
                case "cosmos":
                  this.rpcProviders[e] = new dQ({ namespace: i });
                  break;
                case "polkadot":
                  this.rpcProviders[e] = new dk({ namespace: i });
                  break;
                case "cip34":
                  this.rpcProviders[e] = new d8({ namespace: i });
                  break;
                case "elrond":
                  this.rpcProviders[e] = new d7({ namespace: i });
                  break;
                case "multiversx":
                  this.rpcProviders[e] = new pi({ namespace: i });
                  break;
                case "near":
                  this.rpcProviders[e] = new po({ namespace: i });
                  break;
                case "tezos":
                  this.rpcProviders[e] = new ph({ namespace: i });
                  break;
                default:
                  this.rpcProviders[h1]
                    ? this.rpcProviders[h1].updateNamespace(i)
                    : (this.rpcProviders[h1] = new pg({ namespace: i }));
              }
            });
        }
        registerEventListeners() {
          if (typeof this.client > "u")
            throw Error("Sign Client is not initialized");
          this.client.on("session_ping", (e) => {
            var t;
            let { topic: r } = e;
            r === (null == (t = this.session) ? void 0 : t.topic) &&
              this.events.emit("session_ping", e);
          }),
            this.client.on("session_event", (e) => {
              var t;
              let { params: r, topic: i } = e;
              if (i !== (null == (t = this.session) ? void 0 : t.topic)) return;
              let { event: n } = r;
              if ("accountsChanged" === n.name) {
                let e = n.data;
                e && oT(e) && this.events.emit("accountsChanged", e.map(dC));
              } else if ("chainChanged" === n.name) {
                let e = r.chainId,
                  t = r.event.data,
                  i = oA(e),
                  n = dI(e) !== dI(t) ? `${i}:${dI(t)}` : e;
                this.onChainChanged(n);
              } else this.events.emit(n.name, n.data);
              this.events.emit("session_event", e);
            }),
            this.client.on("session_update", ({ topic: e, params: t }) => {
              var r, i;
              if (e !== (null == (r = this.session) ? void 0 : r.topic)) return;
              let { namespaces: n } = t,
                s = null == (i = this.client) ? void 0 : i.session.get(e);
              (this.session = p_(pC({}, s), { namespaces: n })),
                this.onSessionUpdate(),
                this.events.emit("session_update", { topic: e, params: t });
            }),
            this.client.on("session_delete", async (e) => {
              var t;
              e.topic === (null == (t = this.session) ? void 0 : t.topic) &&
                (await this.cleanup(),
                this.events.emit("session_delete", e),
                this.events.emit(
                  "disconnect",
                  p_(pC({}, oS("USER_DISCONNECTED")), { data: e.topic })
                ));
            }),
            this.on(h3, (e) => {
              this.onChainChanged(e, !0);
            });
        }
        getProvider(e) {
          return this.rpcProviders[e] || this.rpcProviders[h1];
        }
        onSessionUpdate() {
          Object.keys(this.rpcProviders).forEach((e) => {
            var t;
            this.getProvider(e).updateNamespace(
              null == (t = this.session) ? void 0 : t.namespaces[e]
            );
          });
        }
        setNamespaces(e) {
          let {
            namespaces: t,
            optionalNamespaces: r,
            sessionProperties: i,
            scopedProperties: n,
          } = e;
          t && Object.keys(t).length && (this.namespaces = t),
            r && Object.keys(r).length && (this.optionalNamespaces = r),
            (this.sessionProperties = i),
            (this.scopedProperties = n);
        }
        validateChain(e) {
          let [t, r] = e?.split(":") || ["", ""];
          if (!this.namespaces || !Object.keys(this.namespaces).length)
            return [t, r];
          if (
            t &&
            !Object.keys(this.namespaces || {})
              .map((e) => oA(e))
              .includes(t)
          )
            throw Error(
              `Namespace '${t}' is not configured. Please call connect() first with namespace config.`
            );
          if (t && r) return [t, r];
          let i = oA(Object.keys(this.namespaces)[0]),
            n = this.rpcProviders[i].getDefaultChain();
          return [i, n];
        }
        async requestAccounts() {
          let [e] = this.validateChain();
          return await this.getProvider(e).requestAccounts();
        }
        async onChainChanged(e, t = !1) {
          if (!this.namespaces) return;
          let [r, i] = this.validateChain(e);
          i &&
            (t || this.getProvider(r).setDefaultChain(i),
            this.namespaces[r]
              ? (this.namespaces[r].defaultChain = i)
              : this.namespaces[`${r}:${i}`]
              ? (this.namespaces[`${r}:${i}`].defaultChain = i)
              : (this.namespaces[`${r}:${i}`] = { defaultChain: i }),
            this.events.emit("chainChanged", i),
            await this.persist("namespaces", this.namespaces));
        }
        onConnect() {
          this.createProviders(),
            this.events.emit("connect", { session: this.session });
        }
        async cleanup() {
          (this.namespaces = void 0),
            (this.optionalNamespaces = void 0),
            (this.sessionProperties = void 0),
            await this.deleteFromStore("namespaces"),
            await this.deleteFromStore("optionalNamespaces"),
            await this.deleteFromStore("sessionProperties"),
            (this.session = void 0),
            await this.cleanupPendingPairings({ deletePairings: !0 }),
            await this.cleanupStorage();
        }
        async persist(e, t) {
          var r;
          let i = (null == (r = this.session) ? void 0 : r.topic) || "";
          await this.client.core.storage.setItem(`${hX}/${e}${i}`, t);
        }
        async getFromStore(e) {
          var t;
          let r = (null == (t = this.session) ? void 0 : t.topic) || "";
          return await this.client.core.storage.getItem(`${hX}/${e}${r}`);
        }
        async deleteFromStore(e) {
          var t;
          let r = (null == (t = this.session) ? void 0 : t.topic) || "";
          await this.client.core.storage.removeItem(`${hX}/${e}${r}`);
        }
        async cleanupStorage() {
          var e;
          try {
            if ((null == (e = this.client) ? void 0 : e.session.length) > 0)
              return;
            for (let e of await this.client.core.storage.getKeys())
              e.startsWith(hX) &&
                (await this.client.core.storage.removeItem(e));
          } catch (e) {
            this.logger.warn("Failed to cleanup storage", e);
          }
        }
      }
    },
    93611: function (e, t) {
      "use strict";
      function r(e) {
        let t;
        return (
          "undefined" != typeof window &&
            void 0 !== window[e] &&
            (t = window[e]),
          t
        );
      }
      function i(e) {
        let t = r(e);
        if (!t) throw Error(`${e} is not defined in Window`);
        return t;
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.getLocalStorage =
          t.getLocalStorageOrThrow =
          t.getCrypto =
          t.getCryptoOrThrow =
          t.getLocation =
          t.getLocationOrThrow =
          t.getNavigator =
          t.getNavigatorOrThrow =
          t.getDocument =
          t.getDocumentOrThrow =
          t.getFromWindowOrThrow =
          t.getFromWindow =
            void 0),
        (t.getFromWindow = r),
        (t.getFromWindowOrThrow = i),
        (t.getDocumentOrThrow = function () {
          return i("document");
        }),
        (t.getDocument = function () {
          return r("document");
        }),
        (t.getNavigatorOrThrow = function () {
          return i("navigator");
        }),
        (t.getNavigator = function () {
          return r("navigator");
        }),
        (t.getLocationOrThrow = function () {
          return i("location");
        }),
        (t.getLocation = function () {
          return r("location");
        }),
        (t.getCryptoOrThrow = function () {
          return i("crypto");
        }),
        (t.getCrypto = function () {
          return r("crypto");
        }),
        (t.getLocalStorageOrThrow = function () {
          return i("localStorage");
        }),
        (t.getLocalStorage = function () {
          return r("localStorage");
        });
    },
    3897: function (e, t, r) {
      "use strict";
      t.D = void 0;
      let i = r(93611);
      t.D = function () {
        let e, t, r;
        try {
          (e = i.getDocumentOrThrow()), (t = i.getLocationOrThrow());
        } catch (e) {
          return null;
        }
        function n(...t) {
          let r = e.getElementsByTagName("meta");
          for (let e = 0; e < r.length; e++) {
            let i = r[e],
              n = ["itemprop", "property", "name"]
                .map((e) => i.getAttribute(e))
                .filter((e) => !!e && t.includes(e));
            if (n.length && n) {
              let e = i.getAttribute("content");
              if (e) return e;
            }
          }
          return "";
        }
        let s =
            ((r = n("name", "og:site_name", "og:title", "twitter:title")) ||
              (r = e.title),
            r),
          a = n(
            "description",
            "og:description",
            "twitter:description",
            "keywords"
          );
        return {
          description: a,
          url: t.origin,
          icons: (function () {
            let r = e.getElementsByTagName("link"),
              i = [];
            for (let e = 0; e < r.length; e++) {
              let n = r[e],
                s = n.getAttribute("rel");
              if (s && s.toLowerCase().indexOf("icon") > -1) {
                let e = n.getAttribute("href");
                if (e) {
                  if (
                    -1 === e.toLowerCase().indexOf("https:") &&
                    -1 === e.toLowerCase().indexOf("http:") &&
                    0 !== e.indexOf("//")
                  ) {
                    let r = t.protocol + "//" + t.host;
                    if (0 === e.indexOf("/")) r += e;
                    else {
                      let i = t.pathname.split("/");
                      i.pop(), (r += i.join("/") + "/" + e);
                    }
                    i.push(r);
                  } else if (0 === e.indexOf("//")) {
                    let r = t.protocol + e;
                    i.push(r);
                  } else i.push(e);
                }
              }
            }
            return i;
          })(),
          name: s,
        };
      };
    },
    23284: function (e, t, r) {
      var i;
      !(function (n) {
        "use strict";
        function s(e, t) {
          var r = (65535 & e) + (65535 & t);
          return (((e >> 16) + (t >> 16) + (r >> 16)) << 16) | (65535 & r);
        }
        function a(e, t, r, i, n, a) {
          var o;
          return s(((o = s(s(t, e), s(i, a))) << n) | (o >>> (32 - n)), r);
        }
        function o(e, t, r, i, n, s, o) {
          return a((t & r) | (~t & i), e, t, n, s, o);
        }
        function l(e, t, r, i, n, s, o) {
          return a((t & i) | (r & ~i), e, t, n, s, o);
        }
        function c(e, t, r, i, n, s, o) {
          return a(t ^ r ^ i, e, t, n, s, o);
        }
        function u(e, t, r, i, n, s, o) {
          return a(r ^ (t | ~i), e, t, n, s, o);
        }
        function h(e, t) {
          (e[t >> 5] |= 128 << t % 32), (e[(((t + 64) >>> 9) << 4) + 14] = t);
          var r,
            i,
            n,
            a,
            h,
            d = 1732584193,
            p = -271733879,
            f = -1732584194,
            g = 271733878;
          for (r = 0; r < e.length; r += 16)
            (i = d),
              (n = p),
              (a = f),
              (h = g),
              (d = o(d, p, f, g, e[r], 7, -680876936)),
              (g = o(g, d, p, f, e[r + 1], 12, -389564586)),
              (f = o(f, g, d, p, e[r + 2], 17, 606105819)),
              (p = o(p, f, g, d, e[r + 3], 22, -1044525330)),
              (d = o(d, p, f, g, e[r + 4], 7, -176418897)),
              (g = o(g, d, p, f, e[r + 5], 12, 1200080426)),
              (f = o(f, g, d, p, e[r + 6], 17, -1473231341)),
              (p = o(p, f, g, d, e[r + 7], 22, -45705983)),
              (d = o(d, p, f, g, e[r + 8], 7, 1770035416)),
              (g = o(g, d, p, f, e[r + 9], 12, -1958414417)),
              (f = o(f, g, d, p, e[r + 10], 17, -42063)),
              (p = o(p, f, g, d, e[r + 11], 22, -1990404162)),
              (d = o(d, p, f, g, e[r + 12], 7, 1804603682)),
              (g = o(g, d, p, f, e[r + 13], 12, -40341101)),
              (f = o(f, g, d, p, e[r + 14], 17, -1502002290)),
              (p = o(p, f, g, d, e[r + 15], 22, 1236535329)),
              (d = l(d, p, f, g, e[r + 1], 5, -165796510)),
              (g = l(g, d, p, f, e[r + 6], 9, -1069501632)),
              (f = l(f, g, d, p, e[r + 11], 14, 643717713)),
              (p = l(p, f, g, d, e[r], 20, -373897302)),
              (d = l(d, p, f, g, e[r + 5], 5, -701558691)),
              (g = l(g, d, p, f, e[r + 10], 9, 38016083)),
              (f = l(f, g, d, p, e[r + 15], 14, -660478335)),
              (p = l(p, f, g, d, e[r + 4], 20, -405537848)),
              (d = l(d, p, f, g, e[r + 9], 5, 568446438)),
              (g = l(g, d, p, f, e[r + 14], 9, -1019803690)),
              (f = l(f, g, d, p, e[r + 3], 14, -187363961)),
              (p = l(p, f, g, d, e[r + 8], 20, 1163531501)),
              (d = l(d, p, f, g, e[r + 13], 5, -1444681467)),
              (g = l(g, d, p, f, e[r + 2], 9, -51403784)),
              (f = l(f, g, d, p, e[r + 7], 14, 1735328473)),
              (p = l(p, f, g, d, e[r + 12], 20, -1926607734)),
              (d = c(d, p, f, g, e[r + 5], 4, -378558)),
              (g = c(g, d, p, f, e[r + 8], 11, -2022574463)),
              (f = c(f, g, d, p, e[r + 11], 16, 1839030562)),
              (p = c(p, f, g, d, e[r + 14], 23, -35309556)),
              (d = c(d, p, f, g, e[r + 1], 4, -1530992060)),
              (g = c(g, d, p, f, e[r + 4], 11, 1272893353)),
              (f = c(f, g, d, p, e[r + 7], 16, -155497632)),
              (p = c(p, f, g, d, e[r + 10], 23, -1094730640)),
              (d = c(d, p, f, g, e[r + 13], 4, 681279174)),
              (g = c(g, d, p, f, e[r], 11, -358537222)),
              (f = c(f, g, d, p, e[r + 3], 16, -722521979)),
              (p = c(p, f, g, d, e[r + 6], 23, 76029189)),
              (d = c(d, p, f, g, e[r + 9], 4, -640364487)),
              (g = c(g, d, p, f, e[r + 12], 11, -421815835)),
              (f = c(f, g, d, p, e[r + 15], 16, 530742520)),
              (p = c(p, f, g, d, e[r + 2], 23, -995338651)),
              (d = u(d, p, f, g, e[r], 6, -198630844)),
              (g = u(g, d, p, f, e[r + 7], 10, 1126891415)),
              (f = u(f, g, d, p, e[r + 14], 15, -1416354905)),
              (p = u(p, f, g, d, e[r + 5], 21, -57434055)),
              (d = u(d, p, f, g, e[r + 12], 6, 1700485571)),
              (g = u(g, d, p, f, e[r + 3], 10, -1894986606)),
              (f = u(f, g, d, p, e[r + 10], 15, -1051523)),
              (p = u(p, f, g, d, e[r + 1], 21, -2054922799)),
              (d = u(d, p, f, g, e[r + 8], 6, 1873313359)),
              (g = u(g, d, p, f, e[r + 15], 10, -30611744)),
              (f = u(f, g, d, p, e[r + 6], 15, -1560198380)),
              (p = u(p, f, g, d, e[r + 13], 21, 1309151649)),
              (d = u(d, p, f, g, e[r + 4], 6, -145523070)),
              (g = u(g, d, p, f, e[r + 11], 10, -1120210379)),
              (f = u(f, g, d, p, e[r + 2], 15, 718787259)),
              (p = u(p, f, g, d, e[r + 9], 21, -343485551)),
              (d = s(d, i)),
              (p = s(p, n)),
              (f = s(f, a)),
              (g = s(g, h));
          return [d, p, f, g];
        }
        function d(e) {
          var t,
            r = "",
            i = 32 * e.length;
          for (t = 0; t < i; t += 8)
            r += String.fromCharCode((e[t >> 5] >>> t % 32) & 255);
          return r;
        }
        function p(e) {
          var t,
            r = [];
          for (t = 0, r[(e.length >> 2) - 1] = void 0; t < r.length; t += 1)
            r[t] = 0;
          var i = 8 * e.length;
          for (t = 0; t < i; t += 8)
            r[t >> 5] |= (255 & e.charCodeAt(t / 8)) << t % 32;
          return r;
        }
        function f(e) {
          var t,
            r,
            i = "0123456789abcdef",
            n = "";
          for (r = 0; r < e.length; r += 1)
            n +=
              i.charAt(((t = e.charCodeAt(r)) >>> 4) & 15) + i.charAt(15 & t);
          return n;
        }
        function g(e) {
          return unescape(encodeURIComponent(e));
        }
        function m(e) {
          var t;
          return d(h(p((t = g(e))), 8 * t.length));
        }
        function y(e, t) {
          return (function (e, t) {
            var r,
              i,
              n = p(e),
              s = [],
              a = [];
            for (
              s[15] = a[15] = void 0,
                n.length > 16 && (n = h(n, 8 * e.length)),
                r = 0;
              r < 16;
              r += 1
            )
              (s[r] = 909522486 ^ n[r]), (a[r] = 1549556828 ^ n[r]);
            return (
              (i = h(s.concat(p(t)), 512 + 8 * t.length)),
              d(h(a.concat(i), 640))
            );
          })(g(e), g(t));
        }
        function w(e, t, r) {
          return t ? (r ? y(t, e) : f(y(t, e))) : r ? m(e) : f(m(e));
        }
        void 0 !==
          (i = function () {
            return w;
          }.call(t, r, t, e)) && (e.exports = i);
      })(0);
    },
    80751: function (e, t, r) {
      var i =
          ("undefined" != typeof globalThis && globalThis) ||
          ("undefined" != typeof self && self) ||
          (void 0 !== r.g && r.g),
        n = (function () {
          function e() {
            (this.fetch = !1), (this.DOMException = i.DOMException);
          }
          return (e.prototype = i), new e();
        })();
      (function (e) {
        var t =
            (void 0 !== n && n) ||
            ("undefined" != typeof self && self) ||
            (void 0 !== r.g && r.g) ||
            {},
          i = {
            searchParams: "URLSearchParams" in t,
            iterable: "Symbol" in t && "iterator" in Symbol,
            blob:
              "FileReader" in t &&
              "Blob" in t &&
              (function () {
                try {
                  return new Blob(), !0;
                } catch (e) {
                  return !1;
                }
              })(),
            formData: "FormData" in t,
            arrayBuffer: "ArrayBuffer" in t,
          };
        if (i.arrayBuffer)
          var s = [
              "[object Int8Array]",
              "[object Uint8Array]",
              "[object Uint8ClampedArray]",
              "[object Int16Array]",
              "[object Uint16Array]",
              "[object Int32Array]",
              "[object Uint32Array]",
              "[object Float32Array]",
              "[object Float64Array]",
            ],
            a =
              ArrayBuffer.isView ||
              function (e) {
                return e && s.indexOf(Object.prototype.toString.call(e)) > -1;
              };
        function o(e) {
          if (
            ("string" != typeof e && (e = String(e)),
            /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(e) || "" === e)
          )
            throw TypeError(
              'Invalid character in header field name: "' + e + '"'
            );
          return e.toLowerCase();
        }
        function l(e) {
          return "string" != typeof e && (e = String(e)), e;
        }
        function c(e) {
          var t = {
            next: function () {
              var t = e.shift();
              return { done: void 0 === t, value: t };
            },
          };
          return (
            i.iterable &&
              (t[Symbol.iterator] = function () {
                return t;
              }),
            t
          );
        }
        function u(e) {
          (this.map = {}),
            e instanceof u
              ? e.forEach(function (e, t) {
                  this.append(t, e);
                }, this)
              : Array.isArray(e)
              ? e.forEach(function (e) {
                  if (2 != e.length)
                    throw TypeError(
                      "Headers constructor: expected name/value pair to be length 2, found" +
                        e.length
                    );
                  this.append(e[0], e[1]);
                }, this)
              : e &&
                Object.getOwnPropertyNames(e).forEach(function (t) {
                  this.append(t, e[t]);
                }, this);
        }
        function h(e) {
          if (!e._noBody) {
            if (e.bodyUsed) return Promise.reject(TypeError("Already read"));
            e.bodyUsed = !0;
          }
        }
        function d(e) {
          return new Promise(function (t, r) {
            (e.onload = function () {
              t(e.result);
            }),
              (e.onerror = function () {
                r(e.error);
              });
          });
        }
        function p(e) {
          var t = new FileReader(),
            r = d(t);
          return t.readAsArrayBuffer(e), r;
        }
        function f(e) {
          if (e.slice) return e.slice(0);
          var t = new Uint8Array(e.byteLength);
          return t.set(new Uint8Array(e)), t.buffer;
        }
        function g() {
          return (
            (this.bodyUsed = !1),
            (this._initBody = function (e) {
              if (((this.bodyUsed = this.bodyUsed), (this._bodyInit = e), e)) {
                if ("string" == typeof e) this._bodyText = e;
                else if (i.blob && Blob.prototype.isPrototypeOf(e))
                  this._bodyBlob = e;
                else if (i.formData && FormData.prototype.isPrototypeOf(e))
                  this._bodyFormData = e;
                else if (
                  i.searchParams &&
                  URLSearchParams.prototype.isPrototypeOf(e)
                )
                  this._bodyText = e.toString();
                else {
                  var t;
                  i.arrayBuffer &&
                  i.blob &&
                  (t = e) &&
                  DataView.prototype.isPrototypeOf(t)
                    ? ((this._bodyArrayBuffer = f(e.buffer)),
                      (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                    : i.arrayBuffer &&
                      (ArrayBuffer.prototype.isPrototypeOf(e) || a(e))
                    ? (this._bodyArrayBuffer = f(e))
                    : (this._bodyText = e = Object.prototype.toString.call(e));
                }
              } else (this._noBody = !0), (this._bodyText = "");
              !this.headers.get("content-type") &&
                ("string" == typeof e
                  ? this.headers.set("content-type", "text/plain;charset=UTF-8")
                  : this._bodyBlob && this._bodyBlob.type
                  ? this.headers.set("content-type", this._bodyBlob.type)
                  : i.searchParams &&
                    URLSearchParams.prototype.isPrototypeOf(e) &&
                    this.headers.set(
                      "content-type",
                      "application/x-www-form-urlencoded;charset=UTF-8"
                    ));
            }),
            i.blob &&
              (this.blob = function () {
                var e = h(this);
                if (e) return e;
                if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                if (this._bodyArrayBuffer)
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                if (!this._bodyFormData)
                  return Promise.resolve(new Blob([this._bodyText]));
                throw Error("could not read FormData body as blob");
              }),
            (this.arrayBuffer = function () {
              if (this._bodyArrayBuffer)
                return (
                  h(this) ||
                  (ArrayBuffer.isView(this._bodyArrayBuffer)
                    ? Promise.resolve(
                        this._bodyArrayBuffer.buffer.slice(
                          this._bodyArrayBuffer.byteOffset,
                          this._bodyArrayBuffer.byteOffset +
                            this._bodyArrayBuffer.byteLength
                        )
                      )
                    : Promise.resolve(this._bodyArrayBuffer))
                );
              if (i.blob) return this.blob().then(p);
              throw Error("could not read as ArrayBuffer");
            }),
            (this.text = function () {
              var e,
                t,
                r,
                i,
                n,
                s = h(this);
              if (s) return s;
              if (this._bodyBlob)
                return (
                  (e = this._bodyBlob),
                  (r = d((t = new FileReader()))),
                  (n = (i = /charset=([A-Za-z0-9_-]+)/.exec(e.type))
                    ? i[1]
                    : "utf-8"),
                  t.readAsText(e, n),
                  r
                );
              if (this._bodyArrayBuffer)
                return Promise.resolve(
                  (function (e) {
                    for (
                      var t = new Uint8Array(e), r = Array(t.length), i = 0;
                      i < t.length;
                      i++
                    )
                      r[i] = String.fromCharCode(t[i]);
                    return r.join("");
                  })(this._bodyArrayBuffer)
                );
              if (!this._bodyFormData) return Promise.resolve(this._bodyText);
              throw Error("could not read FormData body as text");
            }),
            i.formData &&
              (this.formData = function () {
                return this.text().then(w);
              }),
            (this.json = function () {
              return this.text().then(JSON.parse);
            }),
            this
          );
        }
        (u.prototype.append = function (e, t) {
          (e = o(e)), (t = l(t));
          var r = this.map[e];
          this.map[e] = r ? r + ", " + t : t;
        }),
          (u.prototype.delete = function (e) {
            delete this.map[o(e)];
          }),
          (u.prototype.get = function (e) {
            return (e = o(e)), this.has(e) ? this.map[e] : null;
          }),
          (u.prototype.has = function (e) {
            return this.map.hasOwnProperty(o(e));
          }),
          (u.prototype.set = function (e, t) {
            this.map[o(e)] = l(t);
          }),
          (u.prototype.forEach = function (e, t) {
            for (var r in this.map)
              this.map.hasOwnProperty(r) && e.call(t, this.map[r], r, this);
          }),
          (u.prototype.keys = function () {
            var e = [];
            return (
              this.forEach(function (t, r) {
                e.push(r);
              }),
              c(e)
            );
          }),
          (u.prototype.values = function () {
            var e = [];
            return (
              this.forEach(function (t) {
                e.push(t);
              }),
              c(e)
            );
          }),
          (u.prototype.entries = function () {
            var e = [];
            return (
              this.forEach(function (t, r) {
                e.push([r, t]);
              }),
              c(e)
            );
          }),
          i.iterable && (u.prototype[Symbol.iterator] = u.prototype.entries);
        var m = [
          "CONNECT",
          "DELETE",
          "GET",
          "HEAD",
          "OPTIONS",
          "PATCH",
          "POST",
          "PUT",
          "TRACE",
        ];
        function y(e, r) {
          if (!(this instanceof y))
            throw TypeError(
              'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
            );
          var i,
            n,
            s = (r = r || {}).body;
          if (e instanceof y) {
            if (e.bodyUsed) throw TypeError("Already read");
            (this.url = e.url),
              (this.credentials = e.credentials),
              r.headers || (this.headers = new u(e.headers)),
              (this.method = e.method),
              (this.mode = e.mode),
              (this.signal = e.signal),
              s ||
                null == e._bodyInit ||
                ((s = e._bodyInit), (e.bodyUsed = !0));
          } else this.url = String(e);
          if (
            ((this.credentials =
              r.credentials || this.credentials || "same-origin"),
            (r.headers || !this.headers) && (this.headers = new u(r.headers)),
            (this.method =
              ((n = (i = r.method || this.method || "GET").toUpperCase()),
              m.indexOf(n) > -1 ? n : i)),
            (this.mode = r.mode || this.mode || null),
            (this.signal =
              r.signal ||
              this.signal ||
              (function () {
                if ("AbortController" in t) return new AbortController().signal;
              })()),
            (this.referrer = null),
            ("GET" === this.method || "HEAD" === this.method) && s)
          )
            throw TypeError("Body not allowed for GET or HEAD requests");
          if (
            (this._initBody(s),
            ("GET" === this.method || "HEAD" === this.method) &&
              ("no-store" === r.cache || "no-cache" === r.cache))
          ) {
            var a = /([?&])_=[^&]*/;
            a.test(this.url)
              ? (this.url = this.url.replace(a, "$1_=" + new Date().getTime()))
              : (this.url +=
                  (/\?/.test(this.url) ? "&" : "?") +
                  "_=" +
                  new Date().getTime());
          }
        }
        function w(e) {
          var t = new FormData();
          return (
            e
              .trim()
              .split("&")
              .forEach(function (e) {
                if (e) {
                  var r = e.split("="),
                    i = r.shift().replace(/\+/g, " "),
                    n = r.join("=").replace(/\+/g, " ");
                  t.append(decodeURIComponent(i), decodeURIComponent(n));
                }
              }),
            t
          );
        }
        function b(e, t) {
          if (!(this instanceof b))
            throw TypeError(
              'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
            );
          if (
            (t || (t = {}),
            (this.type = "default"),
            (this.status = void 0 === t.status ? 200 : t.status),
            this.status < 200 || this.status > 599)
          )
            throw RangeError(
              "Failed to construct 'Response': The status provided (0) is outside the range [200, 599]."
            );
          (this.ok = this.status >= 200 && this.status < 300),
            (this.statusText =
              void 0 === t.statusText ? "" : "" + t.statusText),
            (this.headers = new u(t.headers)),
            (this.url = t.url || ""),
            this._initBody(e);
        }
        (y.prototype.clone = function () {
          return new y(this, { body: this._bodyInit });
        }),
          g.call(y.prototype),
          g.call(b.prototype),
          (b.prototype.clone = function () {
            return new b(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new u(this.headers),
              url: this.url,
            });
          }),
          (b.error = function () {
            var e = new b(null, { status: 200, statusText: "" });
            return (e.ok = !1), (e.status = 0), (e.type = "error"), e;
          });
        var v = [301, 302, 303, 307, 308];
        (b.redirect = function (e, t) {
          if (-1 === v.indexOf(t)) throw RangeError("Invalid status code");
          return new b(null, { status: t, headers: { location: e } });
        }),
          (e.DOMException = t.DOMException);
        try {
          new e.DOMException();
        } catch (t) {
          (e.DOMException = function (e, t) {
            (this.message = e), (this.name = t);
            var r = Error(e);
            this.stack = r.stack;
          }),
            (e.DOMException.prototype = Object.create(Error.prototype)),
            (e.DOMException.prototype.constructor = e.DOMException);
        }
        function E(r, n) {
          return new Promise(function (s, a) {
            var c = new y(r, n);
            if (c.signal && c.signal.aborted)
              return a(new e.DOMException("Aborted", "AbortError"));
            var h = new XMLHttpRequest();
            function d() {
              h.abort();
            }
            if (
              ((h.onload = function () {
                var e,
                  t,
                  r = {
                    statusText: h.statusText,
                    headers:
                      ((e = h.getAllResponseHeaders() || ""),
                      (t = new u()),
                      e
                        .replace(/\r?\n[\t ]+/g, " ")
                        .split("\r")
                        .map(function (e) {
                          return 0 === e.indexOf("\n")
                            ? e.substr(1, e.length)
                            : e;
                        })
                        .forEach(function (e) {
                          var r = e.split(":"),
                            i = r.shift().trim();
                          if (i) {
                            var n = r.join(":").trim();
                            try {
                              t.append(i, n);
                            } catch (e) {
                              console.warn("Response " + e.message);
                            }
                          }
                        }),
                      t),
                  };
                0 === c.url.indexOf("file://") &&
                (h.status < 200 || h.status > 599)
                  ? (r.status = 200)
                  : (r.status = h.status),
                  (r.url =
                    "responseURL" in h
                      ? h.responseURL
                      : r.headers.get("X-Request-URL"));
                var i = "response" in h ? h.response : h.responseText;
                setTimeout(function () {
                  s(new b(i, r));
                }, 0);
              }),
              (h.onerror = function () {
                setTimeout(function () {
                  a(TypeError("Network request failed"));
                }, 0);
              }),
              (h.ontimeout = function () {
                setTimeout(function () {
                  a(TypeError("Network request timed out"));
                }, 0);
              }),
              (h.onabort = function () {
                setTimeout(function () {
                  a(new e.DOMException("Aborted", "AbortError"));
                }, 0);
              }),
              h.open(
                c.method,
                (function (e) {
                  try {
                    return "" === e && t.location.href ? t.location.href : e;
                  } catch (t) {
                    return e;
                  }
                })(c.url),
                !0
              ),
              "include" === c.credentials
                ? (h.withCredentials = !0)
                : "omit" === c.credentials && (h.withCredentials = !1),
              "responseType" in h &&
                (i.blob
                  ? (h.responseType = "blob")
                  : i.arrayBuffer && (h.responseType = "arraybuffer")),
              n &&
                "object" == typeof n.headers &&
                !(
                  n.headers instanceof u ||
                  (t.Headers && n.headers instanceof t.Headers)
                ))
            ) {
              var p = [];
              Object.getOwnPropertyNames(n.headers).forEach(function (e) {
                p.push(o(e)), h.setRequestHeader(e, l(n.headers[e]));
              }),
                c.headers.forEach(function (e, t) {
                  -1 === p.indexOf(t) && h.setRequestHeader(t, e);
                });
            } else
              c.headers.forEach(function (e, t) {
                h.setRequestHeader(t, e);
              });
            c.signal &&
              (c.signal.addEventListener("abort", d),
              (h.onreadystatechange = function () {
                4 === h.readyState && c.signal.removeEventListener("abort", d);
              })),
              h.send(void 0 === c._bodyInit ? null : c._bodyInit);
          });
        }
        (E.polyfill = !0),
          t.fetch ||
            ((t.fetch = E), (t.Headers = u), (t.Request = y), (t.Response = b)),
          (e.Headers = u),
          (e.Request = y),
          (e.Response = b),
          (e.fetch = E),
          Object.defineProperty(e, "__esModule", { value: !0 });
      })({}),
        (n.fetch.ponyfill = !0),
        delete n.fetch.polyfill;
      var s = i.fetch ? i : n;
      ((t = s.fetch).default = s.fetch),
        (t.fetch = s.fetch),
        (t.Headers = s.Headers),
        (t.Request = s.Request),
        (t.Response = s.Response),
        (e.exports = t);
    },
    71096: function (e) {
      var t;
      (t = function () {
        "use strict";
        var e = "millisecond",
          t = "second",
          r = "minute",
          i = "hour",
          n = "week",
          s = "month",
          a = "quarter",
          o = "year",
          l = "date",
          c = "Invalid Date",
          u =
            /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
          h =
            /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
          d = function (e, t, r) {
            var i = String(e);
            return !i || i.length >= t
              ? e
              : "" + Array(t + 1 - i.length).join(r) + e;
          },
          p = "en",
          f = {};
        f[p] = {
          name: "en",
          weekdays:
            "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
              "_"
            ),
          months:
            "January_February_March_April_May_June_July_August_September_October_November_December".split(
              "_"
            ),
          ordinal: function (e) {
            var t = ["th", "st", "nd", "rd"],
              r = e % 100;
            return "[" + e + (t[(r - 20) % 10] || t[r] || "th") + "]";
          },
        };
        var g = "$isDayjsObject",
          m = function (e) {
            return e instanceof v || !(!e || !e[g]);
          },
          y = function e(t, r, i) {
            var n;
            if (!t) return p;
            if ("string" == typeof t) {
              var s = t.toLowerCase();
              f[s] && (n = s), r && ((f[s] = r), (n = s));
              var a = t.split("-");
              if (!n && a.length > 1) return e(a[0]);
            } else {
              var o = t.name;
              (f[o] = t), (n = o);
            }
            return !i && n && (p = n), n || (!i && p);
          },
          w = function (e, t) {
            if (m(e)) return e.clone();
            var r = "object" == typeof t ? t : {};
            return (r.date = e), (r.args = arguments), new v(r);
          },
          b = {
            s: d,
            z: function (e) {
              var t = -e.utcOffset(),
                r = Math.abs(t);
              return (
                (t <= 0 ? "+" : "-") +
                d(Math.floor(r / 60), 2, "0") +
                ":" +
                d(r % 60, 2, "0")
              );
            },
            m: function e(t, r) {
              if (t.date() < r.date()) return -e(r, t);
              var i = 12 * (r.year() - t.year()) + (r.month() - t.month()),
                n = t.clone().add(i, s),
                a = r - n < 0,
                o = t.clone().add(i + (a ? -1 : 1), s);
              return +(-(i + (r - n) / (a ? n - o : o - n)) || 0);
            },
            a: function (e) {
              return e < 0 ? Math.ceil(e) || 0 : Math.floor(e);
            },
            p: function (c) {
              return (
                {
                  M: s,
                  y: o,
                  w: n,
                  d: "day",
                  D: l,
                  h: i,
                  m: r,
                  s: t,
                  ms: e,
                  Q: a,
                }[c] ||
                String(c || "")
                  .toLowerCase()
                  .replace(/s$/, "")
              );
            },
            u: function (e) {
              return void 0 === e;
            },
          };
        (b.l = y),
          (b.i = m),
          (b.w = function (e, t) {
            return w(e, {
              locale: t.$L,
              utc: t.$u,
              x: t.$x,
              $offset: t.$offset,
            });
          });
        var v = (function () {
            function d(e) {
              (this.$L = y(e.locale, null, !0)),
                this.parse(e),
                (this.$x = this.$x || e.x || {}),
                (this[g] = !0);
            }
            var p = d.prototype;
            return (
              (p.parse = function (e) {
                (this.$d = (function (e) {
                  var t = e.date,
                    r = e.utc;
                  if (null === t) return new Date(NaN);
                  if (b.u(t)) return new Date();
                  if (t instanceof Date) return new Date(t);
                  if ("string" == typeof t && !/Z$/i.test(t)) {
                    var i = t.match(u);
                    if (i) {
                      var n = i[2] - 1 || 0,
                        s = (i[7] || "0").substring(0, 3);
                      return r
                        ? new Date(
                            Date.UTC(
                              i[1],
                              n,
                              i[3] || 1,
                              i[4] || 0,
                              i[5] || 0,
                              i[6] || 0,
                              s
                            )
                          )
                        : new Date(
                            i[1],
                            n,
                            i[3] || 1,
                            i[4] || 0,
                            i[5] || 0,
                            i[6] || 0,
                            s
                          );
                    }
                  }
                  return new Date(t);
                })(e)),
                  this.init();
              }),
              (p.init = function () {
                var e = this.$d;
                (this.$y = e.getFullYear()),
                  (this.$M = e.getMonth()),
                  (this.$D = e.getDate()),
                  (this.$W = e.getDay()),
                  (this.$H = e.getHours()),
                  (this.$m = e.getMinutes()),
                  (this.$s = e.getSeconds()),
                  (this.$ms = e.getMilliseconds());
              }),
              (p.$utils = function () {
                return b;
              }),
              (p.isValid = function () {
                return this.$d.toString() !== c;
              }),
              (p.isSame = function (e, t) {
                var r = w(e);
                return this.startOf(t) <= r && r <= this.endOf(t);
              }),
              (p.isAfter = function (e, t) {
                return w(e) < this.startOf(t);
              }),
              (p.isBefore = function (e, t) {
                return this.endOf(t) < w(e);
              }),
              (p.$g = function (e, t, r) {
                return b.u(e) ? this[t] : this.set(r, e);
              }),
              (p.unix = function () {
                return Math.floor(this.valueOf() / 1e3);
              }),
              (p.valueOf = function () {
                return this.$d.getTime();
              }),
              (p.startOf = function (e, a) {
                var c = this,
                  u = !!b.u(a) || a,
                  h = b.p(e),
                  d = function (e, t) {
                    var r = b.w(
                      c.$u ? Date.UTC(c.$y, t, e) : new Date(c.$y, t, e),
                      c
                    );
                    return u ? r : r.endOf("day");
                  },
                  p = function (e, t) {
                    return b.w(
                      c
                        .toDate()
                        [e].apply(
                          c.toDate("s"),
                          (u ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(t)
                        ),
                      c
                    );
                  },
                  f = this.$W,
                  g = this.$M,
                  m = this.$D,
                  y = "set" + (this.$u ? "UTC" : "");
                switch (h) {
                  case o:
                    return u ? d(1, 0) : d(31, 11);
                  case s:
                    return u ? d(1, g) : d(0, g + 1);
                  case n:
                    var w = this.$locale().weekStart || 0,
                      v = (f < w ? f + 7 : f) - w;
                    return d(u ? m - v : m + (6 - v), g);
                  case "day":
                  case l:
                    return p(y + "Hours", 0);
                  case i:
                    return p(y + "Minutes", 1);
                  case r:
                    return p(y + "Seconds", 2);
                  case t:
                    return p(y + "Milliseconds", 3);
                  default:
                    return this.clone();
                }
              }),
              (p.endOf = function (e) {
                return this.startOf(e, !1);
              }),
              (p.$set = function (n, a) {
                var c,
                  u = b.p(n),
                  h = "set" + (this.$u ? "UTC" : ""),
                  d = (((c = {}).day = h + "Date"),
                  (c[l] = h + "Date"),
                  (c[s] = h + "Month"),
                  (c[o] = h + "FullYear"),
                  (c[i] = h + "Hours"),
                  (c[r] = h + "Minutes"),
                  (c[t] = h + "Seconds"),
                  (c[e] = h + "Milliseconds"),
                  c)[u],
                  p = "day" === u ? this.$D + (a - this.$W) : a;
                if (u === s || u === o) {
                  var f = this.clone().set(l, 1);
                  f.$d[d](p),
                    f.init(),
                    (this.$d = f.set(l, Math.min(this.$D, f.daysInMonth())).$d);
                } else d && this.$d[d](p);
                return this.init(), this;
              }),
              (p.set = function (e, t) {
                return this.clone().$set(e, t);
              }),
              (p.get = function (e) {
                return this[b.p(e)]();
              }),
              (p.add = function (e, a) {
                var l,
                  c = this;
                e = Number(e);
                var u = b.p(a),
                  h = function (t) {
                    var r = w(c);
                    return b.w(r.date(r.date() + Math.round(t * e)), c);
                  };
                if (u === s) return this.set(s, this.$M + e);
                if (u === o) return this.set(o, this.$y + e);
                if ("day" === u) return h(1);
                if (u === n) return h(7);
                var d =
                    (((l = {})[r] = 6e4), (l[i] = 36e5), (l[t] = 1e3), l)[u] ||
                    1,
                  p = this.$d.getTime() + e * d;
                return b.w(p, this);
              }),
              (p.subtract = function (e, t) {
                return this.add(-1 * e, t);
              }),
              (p.format = function (e) {
                var t = this,
                  r = this.$locale();
                if (!this.isValid()) return r.invalidDate || c;
                var i = e || "YYYY-MM-DDTHH:mm:ssZ",
                  n = b.z(this),
                  s = this.$H,
                  a = this.$m,
                  o = this.$M,
                  l = r.weekdays,
                  u = r.months,
                  d = r.meridiem,
                  p = function (e, r, n, s) {
                    return (e && (e[r] || e(t, i))) || n[r].slice(0, s);
                  },
                  f = function (e) {
                    return b.s(s % 12 || 12, e, "0");
                  },
                  g =
                    d ||
                    function (e, t, r) {
                      var i = e < 12 ? "AM" : "PM";
                      return r ? i.toLowerCase() : i;
                    };
                return i.replace(h, function (e, i) {
                  return (
                    i ||
                    (function (e) {
                      switch (e) {
                        case "YY":
                          return String(t.$y).slice(-2);
                        case "YYYY":
                          return b.s(t.$y, 4, "0");
                        case "M":
                          return o + 1;
                        case "MM":
                          return b.s(o + 1, 2, "0");
                        case "MMM":
                          return p(r.monthsShort, o, u, 3);
                        case "MMMM":
                          return p(u, o);
                        case "D":
                          return t.$D;
                        case "DD":
                          return b.s(t.$D, 2, "0");
                        case "d":
                          return String(t.$W);
                        case "dd":
                          return p(r.weekdaysMin, t.$W, l, 2);
                        case "ddd":
                          return p(r.weekdaysShort, t.$W, l, 3);
                        case "dddd":
                          return l[t.$W];
                        case "H":
                          return String(s);
                        case "HH":
                          return b.s(s, 2, "0");
                        case "h":
                          return f(1);
                        case "hh":
                          return f(2);
                        case "a":
                          return g(s, a, !0);
                        case "A":
                          return g(s, a, !1);
                        case "m":
                          return String(a);
                        case "mm":
                          return b.s(a, 2, "0");
                        case "s":
                          return String(t.$s);
                        case "ss":
                          return b.s(t.$s, 2, "0");
                        case "SSS":
                          return b.s(t.$ms, 3, "0");
                        case "Z":
                          return n;
                      }
                      return null;
                    })(e) ||
                    n.replace(":", "")
                  );
                });
              }),
              (p.utcOffset = function () {
                return -(15 * Math.round(this.$d.getTimezoneOffset() / 15));
              }),
              (p.diff = function (e, l, c) {
                var u,
                  h = this,
                  d = b.p(l),
                  p = w(e),
                  f = (p.utcOffset() - this.utcOffset()) * 6e4,
                  g = this - p,
                  m = function () {
                    return b.m(h, p);
                  };
                switch (d) {
                  case o:
                    u = m() / 12;
                    break;
                  case s:
                    u = m();
                    break;
                  case a:
                    u = m() / 3;
                    break;
                  case n:
                    u = (g - f) / 6048e5;
                    break;
                  case "day":
                    u = (g - f) / 864e5;
                    break;
                  case i:
                    u = g / 36e5;
                    break;
                  case r:
                    u = g / 6e4;
                    break;
                  case t:
                    u = g / 1e3;
                    break;
                  default:
                    u = g;
                }
                return c ? u : b.a(u);
              }),
              (p.daysInMonth = function () {
                return this.endOf(s).$D;
              }),
              (p.$locale = function () {
                return f[this.$L];
              }),
              (p.locale = function (e, t) {
                if (!e) return this.$L;
                var r = this.clone(),
                  i = y(e, t, !0);
                return i && (r.$L = i), r;
              }),
              (p.clone = function () {
                return b.w(this.$d, this);
              }),
              (p.toDate = function () {
                return new Date(this.valueOf());
              }),
              (p.toJSON = function () {
                return this.isValid() ? this.toISOString() : null;
              }),
              (p.toISOString = function () {
                return this.$d.toISOString();
              }),
              (p.toString = function () {
                return this.$d.toUTCString();
              }),
              d
            );
          })(),
          E = v.prototype;
        return (
          (w.prototype = E),
          [
            ["$ms", e],
            ["$s", t],
            ["$m", r],
            ["$H", i],
            ["$W", "day"],
            ["$M", s],
            ["$y", o],
            ["$D", l],
          ].forEach(function (e) {
            E[e[1]] = function (t) {
              return this.$g(t, e[0], e[1]);
            };
          }),
          (w.extend = function (e, t) {
            return e.$i || (e(t, v, w), (e.$i = !0)), w;
          }),
          (w.locale = y),
          (w.isDayjs = m),
          (w.unix = function (e) {
            return w(1e3 * e);
          }),
          (w.en = f[p]),
          (w.Ls = f),
          (w.p = {}),
          w
        );
      }),
        (e.exports = t());
    },
    70939: function (e) {
      var t;
      (t = function () {
        return {
          name: "en",
          weekdays:
            "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
              "_"
            ),
          months:
            "January_February_March_April_May_June_July_August_September_October_November_December".split(
              "_"
            ),
          ordinal: function (e) {
            var t = ["th", "st", "nd", "rd"],
              r = e % 100;
            return "[" + e + (t[(r - 20) % 10] || t[r] || "th") + "]";
          },
        };
      }),
        (e.exports = t());
    },
    45721: function (e) {
      var t;
      (t = function () {
        return function (e, t, r) {
          e = e || {};
          var i = t.prototype,
            n = {
              future: "in %s",
              past: "%s ago",
              s: "a few seconds",
              m: "a minute",
              mm: "%d minutes",
              h: "an hour",
              hh: "%d hours",
              d: "a day",
              dd: "%d days",
              M: "a month",
              MM: "%d months",
              y: "a year",
              yy: "%d years",
            };
          function s(e, t, r, n) {
            return i.fromToBase(e, t, r, n);
          }
          (r.en.relativeTime = n),
            (i.fromToBase = function (t, i, s, a, o) {
              for (
                var l,
                  c,
                  u,
                  h = s.$locale().relativeTime || n,
                  d = e.thresholds || [
                    { l: "s", r: 44, d: "second" },
                    { l: "m", r: 89 },
                    { l: "mm", r: 44, d: "minute" },
                    { l: "h", r: 89 },
                    { l: "hh", r: 21, d: "hour" },
                    { l: "d", r: 35 },
                    { l: "dd", r: 25, d: "day" },
                    { l: "M", r: 45 },
                    { l: "MM", r: 10, d: "month" },
                    { l: "y", r: 17 },
                    { l: "yy", d: "year" },
                  ],
                  p = d.length,
                  f = 0;
                f < p;
                f += 1
              ) {
                var g = d[f];
                g.d && (l = a ? r(t).diff(s, g.d, !0) : s.diff(t, g.d, !0));
                var m = (e.rounding || Math.round)(Math.abs(l));
                if (((u = l > 0), m <= g.r || !g.r)) {
                  m <= 1 && f > 0 && (g = d[f - 1]);
                  var y = h[g.l];
                  o && (m = o("" + m)),
                    (c =
                      "string" == typeof y
                        ? y.replace("%d", m)
                        : y(m, i, g.l, u));
                  break;
                }
              }
              if (i) return c;
              var w = u ? h.future : h.past;
              return "function" == typeof w ? w(c) : w.replace("%s", c);
            }),
            (i.to = function (e, t) {
              return s(e, t, this, !0);
            }),
            (i.from = function (e, t) {
              return s(e, t, this);
            });
          var a = function (e) {
            return e.$u ? r.utc() : r();
          };
          (i.toNow = function (e) {
            return this.to(a(this), e);
          }),
            (i.fromNow = function (e) {
              return this.from(a(this), e);
            });
        };
      }),
        (e.exports = t());
    },
    96961: function (e) {
      var t;
      (t = function () {
        return function (e, t, r) {
          r.updateLocale = function (e, t) {
            var i = r.Ls[e];
            if (i)
              return (
                (t ? Object.keys(t) : []).forEach(function (e) {
                  i[e] = t[e];
                }),
                i
              );
          };
        };
      }),
        (e.exports = t());
    },
    55445: function (e) {
      "use strict";
      var t,
        r = "object" == typeof Reflect ? Reflect : null,
        i =
          r && "function" == typeof r.apply
            ? r.apply
            : function (e, t, r) {
                return Function.prototype.apply.call(e, t, r);
              };
      t =
        r && "function" == typeof r.ownKeys
          ? r.ownKeys
          : Object.getOwnPropertySymbols
          ? function (e) {
              return Object.getOwnPropertyNames(e).concat(
                Object.getOwnPropertySymbols(e)
              );
            }
          : function (e) {
              return Object.getOwnPropertyNames(e);
            };
      var n =
        Number.isNaN ||
        function (e) {
          return e != e;
        };
      function s() {
        s.init.call(this);
      }
      (e.exports = s),
        (e.exports.once = function (e, t) {
          return new Promise(function (r, i) {
            var n;
            function s(r) {
              e.removeListener(t, a), i(r);
            }
            function a() {
              "function" == typeof e.removeListener &&
                e.removeListener("error", s),
                r([].slice.call(arguments));
            }
            g(e, t, a, { once: !0 }),
              "error" !== t &&
                ((n = { once: !0 }),
                "function" == typeof e.on && g(e, "error", s, n));
          });
        }),
        (s.EventEmitter = s),
        (s.prototype._events = void 0),
        (s.prototype._eventsCount = 0),
        (s.prototype._maxListeners = void 0);
      var a = 10;
      function o(e) {
        if ("function" != typeof e)
          throw TypeError(
            'The "listener" argument must be of type Function. Received type ' +
              typeof e
          );
      }
      function l(e) {
        return void 0 === e._maxListeners
          ? s.defaultMaxListeners
          : e._maxListeners;
      }
      function c(e, t, r, i) {
        if (
          (o(r),
          void 0 === (s = e._events)
            ? ((s = e._events = Object.create(null)), (e._eventsCount = 0))
            : (void 0 !== s.newListener &&
                (e.emit("newListener", t, r.listener ? r.listener : r),
                (s = e._events)),
              (a = s[t])),
          void 0 === a)
        )
          (a = s[t] = r), ++e._eventsCount;
        else if (
          ("function" == typeof a
            ? (a = s[t] = i ? [r, a] : [a, r])
            : i
            ? a.unshift(r)
            : a.push(r),
          (n = l(e)) > 0 && a.length > n && !a.warned)
        ) {
          a.warned = !0;
          var n,
            s,
            a,
            c = Error(
              "Possible EventEmitter memory leak detected. " +
                a.length +
                " " +
                String(t) +
                " listeners added. Use emitter.setMaxListeners() to increase limit"
            );
          (c.name = "MaxListenersExceededWarning"),
            (c.emitter = e),
            (c.type = t),
            (c.count = a.length),
            console && console.warn && console.warn(c);
        }
        return e;
      }
      function u() {
        if (!this.fired)
          return (this.target.removeListener(this.type, this.wrapFn),
          (this.fired = !0),
          0 == arguments.length)
            ? this.listener.call(this.target)
            : this.listener.apply(this.target, arguments);
      }
      function h(e, t, r) {
        var i = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r },
          n = u.bind(i);
        return (n.listener = r), (i.wrapFn = n), n;
      }
      function d(e, t, r) {
        var i = e._events;
        if (void 0 === i) return [];
        var n = i[t];
        return void 0 === n
          ? []
          : "function" == typeof n
          ? r
            ? [n.listener || n]
            : [n]
          : r
          ? (function (e) {
              for (var t = Array(e.length), r = 0; r < t.length; ++r)
                t[r] = e[r].listener || e[r];
              return t;
            })(n)
          : f(n, n.length);
      }
      function p(e) {
        var t = this._events;
        if (void 0 !== t) {
          var r = t[e];
          if ("function" == typeof r) return 1;
          if (void 0 !== r) return r.length;
        }
        return 0;
      }
      function f(e, t) {
        for (var r = Array(t), i = 0; i < t; ++i) r[i] = e[i];
        return r;
      }
      function g(e, t, r, i) {
        if ("function" == typeof e.on) i.once ? e.once(t, r) : e.on(t, r);
        else if ("function" == typeof e.addEventListener)
          e.addEventListener(t, function n(s) {
            i.once && e.removeEventListener(t, n), r(s);
          });
        else
          throw TypeError(
            'The "emitter" argument must be of type EventEmitter. Received type ' +
              typeof e
          );
      }
      Object.defineProperty(s, "defaultMaxListeners", {
        enumerable: !0,
        get: function () {
          return a;
        },
        set: function (e) {
          if ("number" != typeof e || e < 0 || n(e))
            throw RangeError(
              'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                e +
                "."
            );
          a = e;
        },
      }),
        (s.init = function () {
          (void 0 === this._events ||
            this._events === Object.getPrototypeOf(this)._events) &&
            ((this._events = Object.create(null)), (this._eventsCount = 0)),
            (this._maxListeners = this._maxListeners || void 0);
        }),
        (s.prototype.setMaxListeners = function (e) {
          if ("number" != typeof e || e < 0 || n(e))
            throw RangeError(
              'The value of "n" is out of range. It must be a non-negative number. Received ' +
                e +
                "."
            );
          return (this._maxListeners = e), this;
        }),
        (s.prototype.getMaxListeners = function () {
          return l(this);
        }),
        (s.prototype.emit = function (e) {
          for (var t = [], r = 1; r < arguments.length; r++)
            t.push(arguments[r]);
          var n = "error" === e,
            s = this._events;
          if (void 0 !== s) n = n && void 0 === s.error;
          else if (!n) return !1;
          if (n) {
            if ((t.length > 0 && (a = t[0]), a instanceof Error)) throw a;
            var a,
              o = Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
            throw ((o.context = a), o);
          }
          var l = s[e];
          if (void 0 === l) return !1;
          if ("function" == typeof l) i(l, this, t);
          else
            for (var c = l.length, u = f(l, c), r = 0; r < c; ++r)
              i(u[r], this, t);
          return !0;
        }),
        (s.prototype.addListener = function (e, t) {
          return c(this, e, t, !1);
        }),
        (s.prototype.on = s.prototype.addListener),
        (s.prototype.prependListener = function (e, t) {
          return c(this, e, t, !0);
        }),
        (s.prototype.once = function (e, t) {
          return o(t), this.on(e, h(this, e, t)), this;
        }),
        (s.prototype.prependOnceListener = function (e, t) {
          return o(t), this.prependListener(e, h(this, e, t)), this;
        }),
        (s.prototype.removeListener = function (e, t) {
          var r, i, n, s, a;
          if ((o(t), void 0 === (i = this._events) || void 0 === (r = i[e])))
            return this;
          if (r === t || r.listener === t)
            0 == --this._eventsCount
              ? (this._events = Object.create(null))
              : (delete i[e],
                i.removeListener &&
                  this.emit("removeListener", e, r.listener || t));
          else if ("function" != typeof r) {
            for (n = -1, s = r.length - 1; s >= 0; s--)
              if (r[s] === t || r[s].listener === t) {
                (a = r[s].listener), (n = s);
                break;
              }
            if (n < 0) return this;
            0 === n
              ? r.shift()
              : (function (e, t) {
                  for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                  e.pop();
                })(r, n),
              1 === r.length && (i[e] = r[0]),
              void 0 !== i.removeListener &&
                this.emit("removeListener", e, a || t);
          }
          return this;
        }),
        (s.prototype.off = s.prototype.removeListener),
        (s.prototype.removeAllListeners = function (e) {
          var t, r, i;
          if (void 0 === (r = this._events)) return this;
          if (void 0 === r.removeListener)
            return (
              0 == arguments.length
                ? ((this._events = Object.create(null)),
                  (this._eventsCount = 0))
                : void 0 !== r[e] &&
                  (0 == --this._eventsCount
                    ? (this._events = Object.create(null))
                    : delete r[e]),
              this
            );
          if (0 == arguments.length) {
            var n,
              s = Object.keys(r);
            for (i = 0; i < s.length; ++i)
              "removeListener" !== (n = s[i]) && this.removeAllListeners(n);
            return (
              this.removeAllListeners("removeListener"),
              (this._events = Object.create(null)),
              (this._eventsCount = 0),
              this
            );
          }
          if ("function" == typeof (t = r[e])) this.removeListener(e, t);
          else if (void 0 !== t)
            for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]);
          return this;
        }),
        (s.prototype.listeners = function (e) {
          return d(this, e, !0);
        }),
        (s.prototype.rawListeners = function (e) {
          return d(this, e, !1);
        }),
        (s.listenerCount = function (e, t) {
          return "function" == typeof e.listenerCount
            ? e.listenerCount(t)
            : p.call(e, t);
        }),
        (s.prototype.listenerCount = p),
        (s.prototype.eventNames = function () {
          return this._eventsCount > 0 ? t(this._events) : [];
        });
    },
    84716: function (e, t, r) {
      "use strict";
      r.d(t, {
        DM: function () {
          return d;
        },
        h8: function () {
          return m;
        },
        jc: function () {
          return g;
        },
        ln: function () {
          return p;
        },
        o5: function () {
          return f;
        },
      });
      let i = Symbol(),
        n = Symbol(),
        s = (e, t) => new Proxy(e, t),
        a = Object.getPrototypeOf,
        o = new WeakMap(),
        l = (e) =>
          e &&
          (o.has(e)
            ? o.get(e)
            : a(e) === Object.prototype || a(e) === Array.prototype),
        c = (e) => "object" == typeof e && null !== e,
        u = (e) => {
          if (Array.isArray(e)) return Array.from(e);
          let t = Object.getOwnPropertyDescriptors(e);
          return (
            Object.values(t).forEach((e) => {
              e.configurable = !0;
            }),
            Object.create(a(e), t)
          );
        },
        h = (e) => e[n] || e,
        d = (e, t, r, a) => {
          if (!l(e)) return e;
          let o = a && a.get(e);
          if (!o) {
            let t = h(e);
            (o = Object.values(Object.getOwnPropertyDescriptors(t)).some(
              (e) => !e.configurable && !e.writable
            )
              ? [t, u(t)]
              : [t]),
              null == a || a.set(e, o);
          }
          let [c, p] = o,
            f = r && r.get(c);
          return (
            (f && !!p === f[1].f) ||
              (((f = ((e, t) => {
                let r = { f: t },
                  s = !1,
                  a = (t, i) => {
                    if (!s) {
                      let n = r.a.get(e);
                      if ((n || ((n = {}), r.a.set(e, n)), "w" === t)) n.w = !0;
                      else {
                        let e = n[t];
                        e || ((e = new Set()), (n[t] = e)), e.add(i);
                      }
                    }
                  },
                  o = {
                    get: (t, i) =>
                      i === n
                        ? e
                        : (a("k", i), d(Reflect.get(t, i), r.a, r.c, r.t)),
                    has: (t, n) =>
                      n === i
                        ? ((s = !0), r.a.delete(e), !0)
                        : (a("h", n), Reflect.has(t, n)),
                    getOwnPropertyDescriptor: (e, t) => (
                      a("o", t), Reflect.getOwnPropertyDescriptor(e, t)
                    ),
                    ownKeys: (e) => (a("w"), Reflect.ownKeys(e)),
                  };
                return t && (o.set = o.deleteProperty = () => !1), [o, r];
              })(c, !!p))[1].p = s(p || c, f[0])),
              r && r.set(c, f)),
            (f[1].a = t),
            (f[1].c = r),
            (f[1].t = a),
            f[1].p
          );
        },
        p = (e, t, r, i, n = Object.is) => {
          if (n(e, t)) return !1;
          if (!c(e) || !c(t)) return !0;
          let s = r.get(h(e));
          if (!s) return !0;
          if (i) {
            let r = i.get(e);
            if (r && r.n === t) return r.g;
            i.set(e, { n: t, g: !1 });
          }
          let a = null;
          try {
            for (let r of s.h || [])
              if ((a = Reflect.has(e, r) !== Reflect.has(t, r))) return a;
            if (!0 === s.w) {
              if (
                (a = ((e, t) => {
                  let r = Reflect.ownKeys(e),
                    i = Reflect.ownKeys(t);
                  return r.length !== i.length || r.some((e, t) => e !== i[t]);
                })(e, t))
              )
                return a;
            } else
              for (let r of s.o || [])
                if (
                  (a =
                    !!Reflect.getOwnPropertyDescriptor(e, r) !=
                    !!Reflect.getOwnPropertyDescriptor(t, r))
                )
                  return a;
            for (let o of s.k || []) if ((a = p(e[o], t[o], r, i, n))) return a;
            return null === a && (a = !0), a;
          } finally {
            i && i.set(e, { n: t, g: a });
          }
        },
        f = (e) => (l(e) && e[n]) || null,
        g = (e, t = !0) => {
          o.set(e, t);
        },
        m = (e, t, r) => {
          let i = [],
            n = new WeakSet(),
            s = (e, a) => {
              if (n.has(e)) return;
              c(e) && n.add(e);
              let o = c(e) && t.get(h(e));
              if (o) {
                var l, u, d;
                if (
                  (null == (l = o.h) ||
                    l.forEach((e) => {
                      let t = `:has(${String(e)})`;
                      i.push(a ? [...a, t] : [t]);
                    }),
                  !0 === o.w)
                ) {
                  let e = ":ownKeys";
                  i.push(a ? [...a, e] : [e]);
                } else
                  null == (d = o.o) ||
                    d.forEach((e) => {
                      let t = `:hasOwn(${String(e)})`;
                      i.push(a ? [...a, t] : [t]);
                    });
                null == (u = o.k) ||
                  u.forEach((t) => {
                    (!r ||
                      "value" in
                        (Object.getOwnPropertyDescriptor(e, t) || {})) &&
                      s(e[t], a ? [...a, t] : [t]);
                  });
              } else a && i.push(a);
            };
          return s(e), i;
        };
    },
    95172: function (e) {
      "use strict";
      function t(e) {
        try {
          return JSON.stringify(e);
        } catch (e) {
          return '"[Circular]"';
        }
      }
      e.exports = function (e, r, i) {
        var n = (i && i.stringify) || t;
        if ("object" == typeof e && null !== e) {
          var s = r.length + 1;
          if (1 === s) return e;
          var a = Array(s);
          a[0] = n(e);
          for (var o = 1; o < s; o++) a[o] = n(r[o]);
          return a.join(" ");
        }
        if ("string" != typeof e) return e;
        var l = r.length;
        if (0 === l) return e;
        for (
          var c = "", u = 0, h = -1, d = (e && e.length) || 0, p = 0;
          p < d;

        ) {
          if (37 === e.charCodeAt(p) && p + 1 < d) {
            switch (((h = h > -1 ? h : 0), e.charCodeAt(p + 1))) {
              case 100:
              case 102:
                if (u >= l || null == r[u]) break;
                h < p && (c += e.slice(h, p)),
                  (c += Number(r[u])),
                  (h = p + 2),
                  p++;
                break;
              case 105:
                if (u >= l || null == r[u]) break;
                h < p && (c += e.slice(h, p)),
                  (c += Math.floor(Number(r[u]))),
                  (h = p + 2),
                  p++;
                break;
              case 79:
              case 111:
              case 106:
                if (u >= l || void 0 === r[u]) break;
                h < p && (c += e.slice(h, p));
                var f = typeof r[u];
                if ("string" === f) {
                  (c += "'" + r[u] + "'"), (h = p + 2), p++;
                  break;
                }
                if ("function" === f) {
                  (c += r[u].name || "<anonymous>"), (h = p + 2), p++;
                  break;
                }
                (c += n(r[u])), (h = p + 2), p++;
                break;
              case 115:
                if (u >= l) break;
                h < p && (c += e.slice(h, p)),
                  (c += String(r[u])),
                  (h = p + 2),
                  p++;
                break;
              case 37:
                h < p && (c += e.slice(h, p)),
                  (c += "%"),
                  (h = p + 2),
                  p++,
                  u--;
            }
            ++u;
          }
          ++p;
        }
        return -1 === h ? e : (h < d && (c += e.slice(h)), c);
      };
    },
    55223: function (e) {
      "use strict";
      e.exports = function () {
        throw Error(
          "ws does not work in the browser. Browser clients must use the native WebSocket object"
        );
      };
    },
    97435: function (e, t, r) {
      "use strict";
      let i = r(95172);
      e.exports = s;
      let n =
        (function () {
          function e(e) {
            return void 0 !== e && e;
          }
          try {
            if ("undefined" != typeof globalThis) return globalThis;
            return (
              Object.defineProperty(Object.prototype, "globalThis", {
                get: function () {
                  return (
                    delete Object.prototype.globalThis, (this.globalThis = this)
                  );
                },
                configurable: !0,
              }),
              globalThis
            );
          } catch (t) {
            return e(self) || e(window) || e(this) || {};
          }
        })().console || {};
      function s(e) {
        var t, r;
        (e = e || {}).browser = e.browser || {};
        let i = e.browser.transmit;
        if (i && "function" != typeof i.send)
          throw Error("pino: transmit option must have a send function");
        let u = e.browser.write || n;
        e.browser.write && (e.browser.asObject = !0);
        let h = e.serializers || {},
          g = Array.isArray((t = e.browser.serialize))
            ? t.filter(function (e) {
                return "!stdSerializers.err" !== e;
              })
            : !0 === t && Object.keys(h),
          m = e.browser.serialize;
        Array.isArray(e.browser.serialize) &&
          e.browser.serialize.indexOf("!stdSerializers.err") > -1 &&
          (m = !1),
          "function" == typeof u &&
            (u.error = u.fatal = u.warn = u.info = u.debug = u.trace = u),
          !1 === e.enabled && (e.level = "silent");
        let y = e.level || "info",
          w = Object.create(u);
        w.log || (w.log = d),
          Object.defineProperty(w, "levelVal", {
            get: function () {
              return "silent" === this.level
                ? 1 / 0
                : this.levels.values[this.level];
            },
          }),
          Object.defineProperty(w, "level", {
            get: function () {
              return this._level;
            },
            set: function (e) {
              if ("silent" !== e && !this.levels.values[e])
                throw Error("unknown level " + e);
              (this._level = e),
                a(b, w, "error", "log"),
                a(b, w, "fatal", "error"),
                a(b, w, "warn", "error"),
                a(b, w, "info", "log"),
                a(b, w, "debug", "log"),
                a(b, w, "trace", "log");
            },
          });
        let b = {
          transmit: i,
          serialize: g,
          asObject: e.browser.asObject,
          levels: ["error", "fatal", "warn", "info", "debug", "trace"],
          timestamp:
            "function" == typeof (r = e).timestamp
              ? r.timestamp
              : !1 === r.timestamp
              ? p
              : f,
        };
        return (
          (w.levels = s.levels),
          (w.level = y),
          (w.setMaxListeners =
            w.getMaxListeners =
            w.emit =
            w.addListener =
            w.on =
            w.prependListener =
            w.once =
            w.prependOnceListener =
            w.removeListener =
            w.removeAllListeners =
            w.listeners =
            w.listenerCount =
            w.eventNames =
            w.write =
            w.flush =
              d),
          (w.serializers = h),
          (w._serialize = g),
          (w._stdErrSerialize = m),
          (w.child = function (t, r) {
            if (!t) throw Error("missing bindings for child Pino");
            (r = r || {}),
              g && t.serializers && (r.serializers = t.serializers);
            let n = r.serializers;
            if (g && n) {
              var s = Object.assign({}, h, n),
                a = !0 === e.browser.serialize ? Object.keys(s) : g;
              delete t.serializers, o([t], a, s, this._stdErrSerialize);
            }
            function u(e) {
              (this._childLevel = (0 | e._childLevel) + 1),
                (this.error = l(e, t, "error")),
                (this.fatal = l(e, t, "fatal")),
                (this.warn = l(e, t, "warn")),
                (this.info = l(e, t, "info")),
                (this.debug = l(e, t, "debug")),
                (this.trace = l(e, t, "trace")),
                s && ((this.serializers = s), (this._serialize = a)),
                i && (this._logEvent = c([].concat(e._logEvent.bindings, t)));
            }
            return (u.prototype = this), new u(this);
          }),
          i && (w._logEvent = c()),
          w
        );
      }
      function a(e, t, r, a) {
        let l = Object.getPrototypeOf(t);
        (t[r] =
          t.levelVal > t.levels.values[r]
            ? d
            : l[r]
            ? l[r]
            : n[r] || n[a] || d),
          (function (e, t, r) {
            if (e.transmit || t[r] !== d) {
              var a;
              t[r] =
                ((a = t[r]),
                function () {
                  let l = e.timestamp(),
                    u = Array(arguments.length),
                    h =
                      Object.getPrototypeOf && Object.getPrototypeOf(this) === n
                        ? n
                        : this;
                  for (var d = 0; d < u.length; d++) u[d] = arguments[d];
                  if (
                    (e.serialize &&
                      !e.asObject &&
                      o(
                        u,
                        this._serialize,
                        this.serializers,
                        this._stdErrSerialize
                      ),
                    e.asObject
                      ? a.call(
                          h,
                          (function (e, t, r, n) {
                            e._serialize &&
                              o(
                                r,
                                e._serialize,
                                e.serializers,
                                e._stdErrSerialize
                              );
                            let a = r.slice(),
                              l = a[0],
                              c = {};
                            n && (c.time = n), (c.level = s.levels.values[t]);
                            let u = (0 | e._childLevel) + 1;
                            if (
                              (u < 1 && (u = 1),
                              null !== l && "object" == typeof l)
                            ) {
                              for (; u-- && "object" == typeof a[0]; )
                                Object.assign(c, a.shift());
                              l = a.length ? i(a.shift(), a) : void 0;
                            } else
                              "string" == typeof l && (l = i(a.shift(), a));
                            return void 0 !== l && (c.msg = l), c;
                          })(this, r, u, l)
                        )
                      : a.apply(h, u),
                    e.transmit)
                  ) {
                    let i = e.transmit.level || t.level,
                      n = s.levels.values[i],
                      a = s.levels.values[r];
                    if (a < n) return;
                    (function (e, t, r) {
                      let i = t.send,
                        n = t.ts,
                        s = t.methodLevel,
                        a = t.methodValue,
                        l = t.val,
                        u = e._logEvent.bindings;
                      o(
                        r,
                        e._serialize || Object.keys(e.serializers),
                        e.serializers,
                        void 0 === e._stdErrSerialize || e._stdErrSerialize
                      ),
                        (e._logEvent.ts = n),
                        (e._logEvent.messages = r.filter(function (e) {
                          return -1 === u.indexOf(e);
                        })),
                        (e._logEvent.level.label = s),
                        (e._logEvent.level.value = a),
                        i(s, e._logEvent, l),
                        (e._logEvent = c(u));
                    })(
                      this,
                      {
                        ts: l,
                        methodLevel: r,
                        methodValue: a,
                        transmitLevel: i,
                        transmitValue:
                          s.levels.values[e.transmit.level || t.level],
                        send: e.transmit.send,
                        val: t.levelVal,
                      },
                      u
                    );
                  }
                });
            }
          })(e, t, r);
      }
      function o(e, t, r, i) {
        for (let n in e)
          if (i && e[n] instanceof Error) e[n] = s.stdSerializers.err(e[n]);
          else if ("object" == typeof e[n] && !Array.isArray(e[n]))
            for (let i in e[n])
              t && t.indexOf(i) > -1 && i in r && (e[n][i] = r[i](e[n][i]));
      }
      function l(e, t, r) {
        return function () {
          let i = Array(1 + arguments.length);
          i[0] = t;
          for (var n = 1; n < i.length; n++) i[n] = arguments[n - 1];
          return e[r].apply(this, i);
        };
      }
      function c(e) {
        return {
          ts: 0,
          messages: [],
          bindings: e || [],
          level: { label: "", value: 0 },
        };
      }
      function u() {
        return {};
      }
      function h(e) {
        return e;
      }
      function d() {}
      function p() {
        return !1;
      }
      function f() {
        return Date.now();
      }
      (s.levels = {
        values: {
          fatal: 60,
          error: 50,
          warn: 40,
          info: 30,
          debug: 20,
          trace: 10,
        },
        labels: {
          10: "trace",
          20: "debug",
          30: "info",
          40: "warn",
          50: "error",
          60: "fatal",
        },
      }),
        (s.stdSerializers = {
          mapHttpRequest: u,
          mapHttpResponse: u,
          wrapRequestSerializer: h,
          wrapResponseSerializer: h,
          wrapErrorSerializer: h,
          req: u,
          res: u,
          err: function (e) {
            let t = {
              type: e.constructor.name,
              msg: e.message,
              stack: e.stack,
            };
            for (let r in e) void 0 === t[r] && (t[r] = e[r]);
            return t;
          },
        }),
        (s.stdTimeFunctions = Object.assign(
          {},
          {
            nullTime: p,
            epochTime: f,
            unixTime: function () {
              return Math.round(Date.now() / 1e3);
            },
            isoTime: function () {
              return new Date(Date.now()).toISOString();
            },
          }
        ));
    },
    93511: function (e, t, r) {
      "use strict";
      r.d(t, {
        fl: function () {
          return N;
        },
        iv: function () {
          return c;
        },
        Ts: function () {
          return C;
        },
        Qu: function () {
          return _;
        },
        $m: function () {
          return l;
        },
      });
      let i = globalThis,
        n =
          i.ShadowRoot &&
          (void 0 === i.ShadyCSS || i.ShadyCSS.nativeShadow) &&
          "adoptedStyleSheets" in Document.prototype &&
          "replace" in CSSStyleSheet.prototype,
        s = Symbol(),
        a = new WeakMap();
      class o {
        constructor(e, t, r) {
          if (((this._$cssResult$ = !0), r !== s))
            throw Error(
              "CSSResult is not constructable. Use `unsafeCSS` or `css` instead."
            );
          (this.cssText = e), (this.t = t);
        }
        get styleSheet() {
          let e = this.o,
            t = this.t;
          if (n && void 0 === e) {
            let r = void 0 !== t && 1 === t.length;
            r && (e = a.get(t)),
              void 0 === e &&
                ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText),
                r && a.set(t, e));
          }
          return e;
        }
        toString() {
          return this.cssText;
        }
      }
      let l = (e) => new o("string" == typeof e ? e : e + "", void 0, s),
        c = (e, ...t) =>
          new o(
            1 === e.length
              ? e[0]
              : t.reduce(
                  (t, r, i) =>
                    t +
                    ((e) => {
                      if (!0 === e._$cssResult$) return e.cssText;
                      if ("number" == typeof e) return e;
                      throw Error(
                        "Value passed to 'css' function must be a 'css' function result: " +
                          e +
                          ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security."
                      );
                    })(r) +
                    e[i + 1],
                  e[0]
                ),
            e,
            s
          ),
        u = (e, t) => {
          if (n)
            e.adoptedStyleSheets = t.map((e) =>
              e instanceof CSSStyleSheet ? e : e.styleSheet
            );
          else
            for (let r of t) {
              let t = document.createElement("style"),
                n = i.litNonce;
              void 0 !== n && t.setAttribute("nonce", n),
                (t.textContent = r.cssText),
                e.appendChild(t);
            }
        },
        h = n
          ? (e) => e
          : (e) =>
              e instanceof CSSStyleSheet
                ? ((e) => {
                    let t = "";
                    for (let r of e.cssRules) t += r.cssText;
                    return l(t);
                  })(e)
                : e,
        {
          is: d,
          defineProperty: p,
          getOwnPropertyDescriptor: f,
          getOwnPropertyNames: g,
          getOwnPropertySymbols: m,
          getPrototypeOf: y,
        } = Object,
        w = globalThis,
        b = w.trustedTypes,
        v = b ? b.emptyScript : "",
        E = w.reactiveElementPolyfillSupport,
        A = (e, t) => e,
        C = {
          toAttribute(e, t) {
            switch (t) {
              case Boolean:
                e = e ? v : null;
                break;
              case Object:
              case Array:
                e = null == e ? e : JSON.stringify(e);
            }
            return e;
          },
          fromAttribute(e, t) {
            let r = e;
            switch (t) {
              case Boolean:
                r = null !== e;
                break;
              case Number:
                r = null === e ? null : Number(e);
                break;
              case Object:
              case Array:
                try {
                  r = JSON.parse(e);
                } catch (e) {
                  r = null;
                }
            }
            return r;
          },
        },
        _ = (e, t) => !d(e, t),
        I = {
          attribute: !0,
          type: String,
          converter: C,
          reflect: !1,
          hasChanged: _,
        };
      (Symbol.metadata ??= Symbol("metadata")),
        (w.litPropertyMetadata ??= new WeakMap());
      class N extends HTMLElement {
        static addInitializer(e) {
          this._$Ei(), (this.l ??= []).push(e);
        }
        static get observedAttributes() {
          return this.finalize(), this._$Eh && [...this._$Eh.keys()];
        }
        static createProperty(e, t = I) {
          if (
            (t.state && (t.attribute = !1),
            this._$Ei(),
            this.elementProperties.set(e, t),
            !t.noAccessor)
          ) {
            let r = Symbol(),
              i = this.getPropertyDescriptor(e, r, t);
            void 0 !== i && p(this.prototype, e, i);
          }
        }
        static getPropertyDescriptor(e, t, r) {
          let { get: i, set: n } = f(this.prototype, e) ?? {
            get() {
              return this[t];
            },
            set(e) {
              this[t] = e;
            },
          };
          return {
            get() {
              return i?.call(this);
            },
            set(t) {
              let s = i?.call(this);
              n.call(this, t), this.requestUpdate(e, s, r);
            },
            configurable: !0,
            enumerable: !0,
          };
        }
        static getPropertyOptions(e) {
          return this.elementProperties.get(e) ?? I;
        }
        static _$Ei() {
          if (this.hasOwnProperty(A("elementProperties"))) return;
          let e = y(this);
          e.finalize(),
            void 0 !== e.l && (this.l = [...e.l]),
            (this.elementProperties = new Map(e.elementProperties));
        }
        static finalize() {
          if (this.hasOwnProperty(A("finalized"))) return;
          if (
            ((this.finalized = !0),
            this._$Ei(),
            this.hasOwnProperty(A("properties")))
          ) {
            let e = this.properties;
            for (let t of [...g(e), ...m(e)]) this.createProperty(t, e[t]);
          }
          let e = this[Symbol.metadata];
          if (null !== e) {
            let t = litPropertyMetadata.get(e);
            if (void 0 !== t)
              for (let [e, r] of t) this.elementProperties.set(e, r);
          }
          for (let [e, t] of ((this._$Eh = new Map()),
          this.elementProperties)) {
            let r = this._$Eu(e, t);
            void 0 !== r && this._$Eh.set(r, e);
          }
          this.elementStyles = this.finalizeStyles(this.styles);
        }
        static finalizeStyles(e) {
          let t = [];
          if (Array.isArray(e))
            for (let r of new Set(e.flat(1 / 0).reverse())) t.unshift(h(r));
          else void 0 !== e && t.push(h(e));
          return t;
        }
        static _$Eu(e, t) {
          let r = t.attribute;
          return !1 === r
            ? void 0
            : "string" == typeof r
            ? r
            : "string" == typeof e
            ? e.toLowerCase()
            : void 0;
        }
        constructor() {
          super(),
            (this._$Ep = void 0),
            (this.isUpdatePending = !1),
            (this.hasUpdated = !1),
            (this._$Em = null),
            this._$Ev();
        }
        _$Ev() {
          (this._$ES = new Promise((e) => (this.enableUpdating = e))),
            (this._$AL = new Map()),
            this._$E_(),
            this.requestUpdate(),
            this.constructor.l?.forEach((e) => e(this));
        }
        addController(e) {
          (this._$EO ??= new Set()).add(e),
            void 0 !== this.renderRoot &&
              this.isConnected &&
              e.hostConnected?.();
        }
        removeController(e) {
          this._$EO?.delete(e);
        }
        _$E_() {
          let e = new Map();
          for (let t of this.constructor.elementProperties.keys())
            this.hasOwnProperty(t) && (e.set(t, this[t]), delete this[t]);
          e.size > 0 && (this._$Ep = e);
        }
        createRenderRoot() {
          let e =
            this.shadowRoot ??
            this.attachShadow(this.constructor.shadowRootOptions);
          return u(e, this.constructor.elementStyles), e;
        }
        connectedCallback() {
          (this.renderRoot ??= this.createRenderRoot()),
            this.enableUpdating(!0),
            this._$EO?.forEach((e) => e.hostConnected?.());
        }
        enableUpdating(e) {}
        disconnectedCallback() {
          this._$EO?.forEach((e) => e.hostDisconnected?.());
        }
        attributeChangedCallback(e, t, r) {
          this._$AK(e, r);
        }
        _$EC(e, t) {
          let r = this.constructor.elementProperties.get(e),
            i = this.constructor._$Eu(e, r);
          if (void 0 !== i && !0 === r.reflect) {
            let n = (
              void 0 !== r.converter?.toAttribute ? r.converter : C
            ).toAttribute(t, r.type);
            (this._$Em = e),
              null == n ? this.removeAttribute(i) : this.setAttribute(i, n),
              (this._$Em = null);
          }
        }
        _$AK(e, t) {
          let r = this.constructor,
            i = r._$Eh.get(e);
          if (void 0 !== i && this._$Em !== i) {
            let e = r.getPropertyOptions(i),
              n =
                "function" == typeof e.converter
                  ? { fromAttribute: e.converter }
                  : void 0 !== e.converter?.fromAttribute
                  ? e.converter
                  : C;
            (this._$Em = i),
              (this[i] = n.fromAttribute(t, e.type)),
              (this._$Em = null);
          }
        }
        requestUpdate(e, t, r) {
          if (void 0 !== e) {
            if (
              !((r ??= this.constructor.getPropertyOptions(e)).hasChanged ?? _)(
                this[e],
                t
              )
            )
              return;
            this.P(e, t, r);
          }
          !1 === this.isUpdatePending && (this._$ES = this._$ET());
        }
        P(e, t, r) {
          this._$AL.has(e) || this._$AL.set(e, t),
            !0 === r.reflect &&
              this._$Em !== e &&
              (this._$Ej ??= new Set()).add(e);
        }
        async _$ET() {
          this.isUpdatePending = !0;
          try {
            await this._$ES;
          } catch (e) {
            Promise.reject(e);
          }
          let e = this.scheduleUpdate();
          return null != e && (await e), !this.isUpdatePending;
        }
        scheduleUpdate() {
          return this.performUpdate();
        }
        performUpdate() {
          if (!this.isUpdatePending) return;
          if (!this.hasUpdated) {
            if (((this.renderRoot ??= this.createRenderRoot()), this._$Ep)) {
              for (let [e, t] of this._$Ep) this[e] = t;
              this._$Ep = void 0;
            }
            let e = this.constructor.elementProperties;
            if (e.size > 0)
              for (let [t, r] of e)
                !0 !== r.wrapped ||
                  this._$AL.has(t) ||
                  void 0 === this[t] ||
                  this.P(t, this[t], r);
          }
          let e = !1,
            t = this._$AL;
          try {
            (e = this.shouldUpdate(t))
              ? (this.willUpdate(t),
                this._$EO?.forEach((e) => e.hostUpdate?.()),
                this.update(t))
              : this._$EU();
          } catch (t) {
            throw ((e = !1), this._$EU(), t);
          }
          e && this._$AE(t);
        }
        willUpdate(e) {}
        _$AE(e) {
          this._$EO?.forEach((e) => e.hostUpdated?.()),
            this.hasUpdated || ((this.hasUpdated = !0), this.firstUpdated(e)),
            this.updated(e);
        }
        _$EU() {
          (this._$AL = new Map()), (this.isUpdatePending = !1);
        }
        get updateComplete() {
          return this.getUpdateComplete();
        }
        getUpdateComplete() {
          return this._$ES;
        }
        shouldUpdate(e) {
          return !0;
        }
        update(e) {
          (this._$Ej &&= this._$Ej.forEach((e) => this._$EC(e, this[e]))),
            this._$EU();
        }
        updated(e) {}
        firstUpdated(e) {}
      }
      (N.elementStyles = []),
        (N.shadowRootOptions = { mode: "open" }),
        (N[A("elementProperties")] = new Map()),
        (N[A("finalized")] = new Map()),
        E?.({ ReactiveElement: N }),
        (w.reactiveElementVersions ??= []).push("2.0.4");
    },
    44649: function (e, t, r) {
      "use strict";
      r.d(t, {
        b: function () {
          return i;
        },
      });
      let i = {
        WC_NAME_SUFFIX: ".reown.id",
        WC_NAME_SUFFIX_LEGACY: ".wcn.id",
        BLOCKCHAIN_API_RPC_URL: "https://rpc.walletconnect.org",
        PULSE_API_URL: "https://pulse.walletconnect.org",
        W3M_API_URL: "https://api.web3modal.org",
        CONNECTOR_ID: {
          WALLET_CONNECT: "walletConnect",
          INJECTED: "injected",
          WALLET_STANDARD: "announced",
          COINBASE: "coinbaseWallet",
          COINBASE_SDK: "coinbaseWalletSDK",
          SAFE: "safe",
          LEDGER: "ledger",
          OKX: "okx",
          EIP6963: "eip6963",
          AUTH: "ID_AUTH",
        },
        CONNECTOR_NAMES: { AUTH: "Auth" },
        AUTH_CONNECTOR_SUPPORTED_CHAINS: ["eip155", "solana"],
        LIMITS: { PENDING_TRANSACTIONS: 99 },
        CHAIN: {
          EVM: "eip155",
          SOLANA: "solana",
          POLKADOT: "polkadot",
          BITCOIN: "bip122",
        },
        CHAIN_NAME_MAP: {
          eip155: "EVM Networks",
          solana: "Solana",
          polkadot: "Polkadot",
          bip122: "Bitcoin",
        },
        USDT_CONTRACT_ADDRESSES: [
          "0xdac17f958d2ee523a2206206994597c13d831ec7",
          "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
          "0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7",
          "0x919C1c267BC06a7039e03fcc2eF738525769109c",
          "0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e",
          "0x55d398326f99059fF775485246999027B3197955",
          "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
        ],
        HTTP_STATUS_CODES: { SERVICE_UNAVAILABLE: 503, FORBIDDEN: 403 },
        UNSUPPORTED_NETWORK_NAME: "Unknown Network",
      };
    },
    41262: function (e, t, r) {
      "use strict";
      r.d(t, {
        E: function () {
          return c;
        },
      });
      var i = r(71096),
        n = r(70939),
        s = r(45721),
        a = r(96961);
      i.extend(s), i.extend(a);
      let o = {
          ...n,
          name: "en-web3-modal",
          relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "%d sec",
            m: "1 min",
            mm: "%d min",
            h: "1 hr",
            hh: "%d hrs",
            d: "1 d",
            dd: "%d d",
            M: "1 mo",
            MM: "%d mo",
            y: "1 yr",
            yy: "%d yr",
          },
        },
        l = [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December",
        ];
      i.locale("en-web3-modal", o);
      let c = {
        getMonthNameByIndex: (e) => l[e],
        getYear: (e = new Date().toISOString()) => i(e).year(),
        getRelativeDateFromNow: (e) => i(e).locale("en-web3-modal").fromNow(!0),
        formatDate: (e, t = "DD MMM") => i(e).format(t),
      };
    },
    68903: function (e, t, r) {
      "use strict";
      r.d(t, {
        p: function () {
          return i;
        },
      });
      let i = {
        caipNetworkIdToNumber: (e) => (e ? Number(e.split(":")[1]) : void 0),
        parseEvmChainId(e) {
          return "string" == typeof e ? this.caipNetworkIdToNumber(e) : e;
        },
        getNetworksByNamespace: (e, t) =>
          e?.filter((e) => e.chainNamespace === t) || [],
        getFirstNetworkByNamespace(e, t) {
          return this.getNetworksByNamespace(e, t)[0];
        },
      };
    },
    23614: function (e, t, r) {
      "use strict";
      r.d(t, {
        C: function () {
          return f;
        },
      });
      var i = "[big.js] ",
        n = i + "Invalid ",
        s = n + "decimal places",
        a = n + "rounding mode",
        o = i + "Division by zero",
        l = {},
        c = void 0,
        u = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
      function h(e, t, r, i) {
        var n = e.c;
        if (
          (r === c && (r = e.constructor.RM),
          0 !== r && 1 !== r && 2 !== r && 3 !== r)
        )
          throw Error(a);
        if (t < 1)
          (i =
            (3 === r && (i || !!n[0])) ||
            (0 === t &&
              ((1 === r && n[0] >= 5) ||
                (2 === r && (n[0] > 5 || (5 === n[0] && (i || n[1] !== c))))))),
            (n.length = 1),
            i ? ((e.e = e.e - t + 1), (n[0] = 1)) : (n[0] = e.e = 0);
        else if (t < n.length) {
          if (
            ((i =
              (1 === r && n[t] >= 5) ||
              (2 === r &&
                (n[t] > 5 ||
                  (5 === n[t] && (i || n[t + 1] !== c || 1 & n[t - 1])))) ||
              (3 === r && (i || !!n[0]))),
            (n.length = t),
            i)
          ) {
            for (; ++n[--t] > 9; )
              if (((n[t] = 0), 0 === t)) {
                ++e.e, n.unshift(1);
                break;
              }
          }
          for (t = n.length; !n[--t]; ) n.pop();
        }
        return e;
      }
      function d(e, t, r) {
        var i = e.e,
          n = e.c.join(""),
          s = n.length;
        if (t)
          n =
            n.charAt(0) +
            (s > 1 ? "." + n.slice(1) : "") +
            (i < 0 ? "e" : "e+") +
            i;
        else if (i < 0) {
          for (; ++i; ) n = "0" + n;
          n = "0." + n;
        } else if (i > 0) {
          if (++i > s) for (i -= s; i--; ) n += "0";
          else i < s && (n = n.slice(0, i) + "." + n.slice(i));
        } else s > 1 && (n = n.charAt(0) + "." + n.slice(1));
        return e.s < 0 && r ? "-" + n : n;
      }
      (l.abs = function () {
        var e = new this.constructor(this);
        return (e.s = 1), e;
      }),
        (l.cmp = function (e) {
          var t,
            r = this.c,
            i = (e = new this.constructor(e)).c,
            n = this.s,
            s = e.s,
            a = this.e,
            o = e.e;
          if (!r[0] || !i[0]) return r[0] ? n : i[0] ? -s : 0;
          if (n != s) return n;
          if (((t = n < 0), a != o)) return (a > o) ^ t ? 1 : -1;
          for (n = -1, s = (a = r.length) < (o = i.length) ? a : o; ++n < s; )
            if (r[n] != i[n]) return (r[n] > i[n]) ^ t ? 1 : -1;
          return a == o ? 0 : (a > o) ^ t ? 1 : -1;
        }),
        (l.div = function (e) {
          var t = this.constructor,
            r = this.c,
            i = (e = new t(e)).c,
            n = this.s == e.s ? 1 : -1,
            a = t.DP;
          if (a !== ~~a || a < 0 || a > 1e6) throw Error(s);
          if (!i[0]) throw Error(o);
          if (!r[0]) return (e.s = n), (e.c = [(e.e = 0)]), e;
          var l,
            u,
            d,
            p,
            f,
            g = i.slice(),
            m = (l = i.length),
            y = r.length,
            w = r.slice(0, l),
            b = w.length,
            v = e,
            E = (v.c = []),
            A = 0,
            C = a + (v.e = this.e - e.e) + 1;
          for (v.s = n, n = C < 0 ? 0 : C, g.unshift(0); b++ < l; ) w.push(0);
          do {
            for (d = 0; d < 10; d++) {
              if (l != (b = w.length)) p = l > b ? 1 : -1;
              else
                for (f = -1, p = 0; ++f < l; )
                  if (i[f] != w[f]) {
                    p = i[f] > w[f] ? 1 : -1;
                    break;
                  }
              if (p < 0) {
                for (u = b == l ? i : g; b; ) {
                  if (w[--b] < u[b]) {
                    for (f = b; f && !w[--f]; ) w[f] = 9;
                    --w[f], (w[b] += 10);
                  }
                  w[b] -= u[b];
                }
                for (; !w[0]; ) w.shift();
              } else break;
            }
            (E[A++] = p ? d : ++d),
              w[0] && p ? (w[b] = r[m] || 0) : (w = [r[m]]);
          } while ((m++ < y || w[0] !== c) && n--);
          return (
            !E[0] && 1 != A && (E.shift(), v.e--, C--),
            A > C && h(v, C, t.RM, w[0] !== c),
            v
          );
        }),
        (l.eq = function (e) {
          return 0 === this.cmp(e);
        }),
        (l.gt = function (e) {
          return this.cmp(e) > 0;
        }),
        (l.gte = function (e) {
          return this.cmp(e) > -1;
        }),
        (l.lt = function (e) {
          return 0 > this.cmp(e);
        }),
        (l.lte = function (e) {
          return 1 > this.cmp(e);
        }),
        (l.minus = l.sub =
          function (e) {
            var t,
              r,
              i,
              n,
              s = this.constructor,
              a = this.s,
              o = (e = new s(e)).s;
            if (a != o) return (e.s = -o), this.plus(e);
            var l = this.c.slice(),
              c = this.e,
              u = e.c,
              h = e.e;
            if (!l[0] || !u[0])
              return (
                u[0] ? (e.s = -o) : l[0] ? (e = new s(this)) : (e.s = 1), e
              );
            if ((a = c - h)) {
              for (
                (n = a < 0) ? ((a = -a), (i = l)) : ((h = c), (i = u)),
                  i.reverse(),
                  o = a;
                o--;

              )
                i.push(0);
              i.reverse();
            } else
              for (
                r = ((n = l.length < u.length) ? l : u).length, a = o = 0;
                o < r;
                o++
              )
                if (l[o] != u[o]) {
                  n = l[o] < u[o];
                  break;
                }
            if (
              (n && ((i = l), (l = u), (u = i), (e.s = -e.s)),
              (o = (r = u.length) - (t = l.length)) > 0)
            )
              for (; o--; ) l[t++] = 0;
            for (o = t; r > a; ) {
              if (l[--r] < u[r]) {
                for (t = r; t && !l[--t]; ) l[t] = 9;
                --l[t], (l[r] += 10);
              }
              l[r] -= u[r];
            }
            for (; 0 === l[--o]; ) l.pop();
            for (; 0 === l[0]; ) l.shift(), --h;
            return (
              l[0] || ((e.s = 1), (l = [(h = 0)])), (e.c = l), (e.e = h), e
            );
          }),
        (l.mod = function (e) {
          var t,
            r = this,
            i = r.constructor,
            n = r.s,
            s = (e = new i(e)).s;
          if (!e.c[0]) throw Error(o);
          return ((r.s = e.s = 1), (t = 1 == e.cmp(r)), (r.s = n), (e.s = s), t)
            ? new i(r)
            : ((n = i.DP),
              (s = i.RM),
              (i.DP = i.RM = 0),
              (r = r.div(e)),
              (i.DP = n),
              (i.RM = s),
              this.minus(r.times(e)));
        }),
        (l.neg = function () {
          var e = new this.constructor(this);
          return (e.s = -e.s), e;
        }),
        (l.plus = l.add =
          function (e) {
            var t,
              r,
              i,
              n = this.constructor;
            if (((e = new n(e)), this.s != e.s))
              return (e.s = -e.s), this.minus(e);
            var s = this.e,
              a = this.c,
              o = e.e,
              l = e.c;
            if (!a[0] || !l[0])
              return l[0] || (a[0] ? (e = new n(this)) : (e.s = this.s)), e;
            if (((a = a.slice()), (t = s - o))) {
              for (
                t > 0 ? ((o = s), (i = l)) : ((t = -t), (i = a)), i.reverse();
                t--;

              )
                i.push(0);
              i.reverse();
            }
            for (
              a.length - l.length < 0 && ((i = l), (l = a), (a = i)),
                t = l.length,
                r = 0;
              t;
              a[t] %= 10
            )
              r = ((a[--t] = a[t] + l[t] + r) / 10) | 0;
            for (r && (a.unshift(r), ++o), t = a.length; 0 === a[--t]; )
              a.pop();
            return (e.c = a), (e.e = o), e;
          }),
        (l.pow = function (e) {
          var t = this,
            r = new t.constructor("1"),
            i = r,
            s = e < 0;
          if (e !== ~~e || e < -1e6 || e > 1e6) throw Error(n + "exponent");
          for (s && (e = -e); 1 & e && (i = i.times(t)), (e >>= 1); )
            t = t.times(t);
          return s ? r.div(i) : i;
        }),
        (l.prec = function (e, t) {
          if (e !== ~~e || e < 1 || e > 1e6) throw Error(n + "precision");
          return h(new this.constructor(this), e, t);
        }),
        (l.round = function (e, t) {
          if (e === c) e = 0;
          else if (e !== ~~e || e < -1e6 || e > 1e6) throw Error(s);
          return h(new this.constructor(this), e + this.e + 1, t);
        }),
        (l.sqrt = function () {
          var e,
            t,
            r,
            n = this.constructor,
            s = this.s,
            a = this.e,
            o = new n("0.5");
          if (!this.c[0]) return new n(this);
          if (s < 0) throw Error(i + "No square root");
          0 === (s = Math.sqrt(+d(this, !0, !0))) || s === 1 / 0
            ? (((t = this.c.join("")).length + a) & 1 || (t += "0"),
              (a = (((a + 1) / 2) | 0) - (a < 0 || 1 & a)),
              (e = new n(
                ((s = Math.sqrt(t)) == 1 / 0
                  ? "5e"
                  : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + a
              )))
            : (e = new n(s + "")),
            (a = e.e + (n.DP += 4));
          do (r = e), (e = o.times(r.plus(this.div(r))));
          while (r.c.slice(0, a).join("") !== e.c.slice(0, a).join(""));
          return h(e, (n.DP -= 4) + e.e + 1, n.RM);
        }),
        (l.times = l.mul =
          function (e) {
            var t,
              r = this.constructor,
              i = this.c,
              n = (e = new r(e)).c,
              s = i.length,
              a = n.length,
              o = this.e,
              l = e.e;
            if (((e.s = this.s == e.s ? 1 : -1), !i[0] || !n[0]))
              return (e.c = [(e.e = 0)]), e;
            for (
              e.e = o + l,
                s < a && ((t = i), (i = n), (n = t), (l = s), (s = a), (a = l)),
                t = Array((l = s + a));
              l--;

            )
              t[l] = 0;
            for (o = a; o--; ) {
              for (a = 0, l = s + o; l > o; )
                (a = t[l] + n[o] * i[l - o - 1] + a),
                  (t[l--] = a % 10),
                  (a = (a / 10) | 0);
              t[l] = a;
            }
            for (a ? ++e.e : t.shift(), o = t.length; !t[--o]; ) t.pop();
            return (e.c = t), e;
          }),
        (l.toExponential = function (e, t) {
          var r = this,
            i = r.c[0];
          if (e !== c) {
            if (e !== ~~e || e < 0 || e > 1e6) throw Error(s);
            for (r = h(new r.constructor(r), ++e, t); r.c.length < e; )
              r.c.push(0);
          }
          return d(r, !0, !!i);
        }),
        (l.toFixed = function (e, t) {
          var r = this,
            i = r.c[0];
          if (e !== c) {
            if (e !== ~~e || e < 0 || e > 1e6) throw Error(s);
            for (
              r = h(new r.constructor(r), e + r.e + 1, t), e = e + r.e + 1;
              r.c.length < e;

            )
              r.c.push(0);
          }
          return d(r, !1, !!i);
        }),
        (l[Symbol.for("nodejs.util.inspect.custom")] =
          l.toJSON =
          l.toString =
            function () {
              var e = this.constructor;
              return d(this, this.e <= e.NE || this.e >= e.PE, !!this.c[0]);
            }),
        (l.toNumber = function () {
          var e = +d(this, !0, !0);
          if (!0 === this.constructor.strict && !this.eq(e.toString()))
            throw Error(i + "Imprecise conversion");
          return e;
        }),
        (l.toPrecision = function (e, t) {
          var r = this,
            i = r.constructor,
            s = r.c[0];
          if (e !== c) {
            if (e !== ~~e || e < 1 || e > 1e6) throw Error(n + "precision");
            for (r = h(new i(r), e, t); r.c.length < e; ) r.c.push(0);
          }
          return d(r, e <= r.e || r.e <= i.NE || r.e >= i.PE, !!s);
        }),
        (l.valueOf = function () {
          var e = this.constructor;
          if (!0 === e.strict) throw Error(i + "valueOf disallowed");
          return d(this, this.e <= e.NE || this.e >= e.PE, !0);
        });
      var p = (function e() {
        function t(r) {
          if (!(this instanceof t)) return r === c ? e() : new t(r);
          if (r instanceof t)
            (this.s = r.s), (this.e = r.e), (this.c = r.c.slice());
          else {
            if ("string" != typeof r) {
              if (!0 === t.strict && "bigint" != typeof r)
                throw TypeError(n + "value");
              r = 0 === r && 1 / r < 0 ? "-0" : String(r);
            }
            !(function (e, t) {
              var r, i, s;
              if (!u.test(t)) throw Error(n + "number");
              for (
                e.s = "-" == t.charAt(0) ? ((t = t.slice(1)), -1) : 1,
                  (r = t.indexOf(".")) > -1 && (t = t.replace(".", "")),
                  (i = t.search(/e/i)) > 0
                    ? (r < 0 && (r = i),
                      (r += +t.slice(i + 1)),
                      (t = t.substring(0, i)))
                    : r < 0 && (r = t.length),
                  s = t.length,
                  i = 0;
                i < s && "0" == t.charAt(i);

              )
                ++i;
              if (i == s) e.c = [(e.e = 0)];
              else {
                for (; s > 0 && "0" == t.charAt(--s); );
                for (e.e = r - i - 1, e.c = [], r = 0; i <= s; )
                  e.c[r++] = +t.charAt(i++);
              }
            })(this, r);
          }
          this.constructor = t;
        }
        return (
          (t.prototype = l),
          (t.DP = 20),
          (t.RM = 1),
          (t.NE = -7),
          (t.PE = 21),
          (t.strict = !1),
          (t.roundDown = 0),
          (t.roundHalfUp = 1),
          (t.roundHalfEven = 2),
          (t.roundUp = 3),
          t
        );
      })();
      let f = {
        bigNumber: (e) => new p(e || 0),
        multiply(e, t) {
          if (void 0 === e || void 0 === t) return new p(0);
          let r = new p(e),
            i = new p(t);
          return r.times(i);
        },
        formatNumberToLocalString: (e, t = 2) =>
          void 0 === e
            ? "0.00"
            : "number" == typeof e
            ? e.toLocaleString("en-US", {
                maximumFractionDigits: t,
                minimumFractionDigits: t,
              })
            : parseFloat(e).toLocaleString("en-US", {
                maximumFractionDigits: t,
                minimumFractionDigits: t,
              }),
        parseLocalStringToNumber: (e) =>
          void 0 === e ? 0 : parseFloat(e.replace(/,/gu, "")),
      };
    },
    86988: function (e, t, r) {
      "use strict";
      r.d(t, {
        u: function () {
          return i;
        },
      });
      let i = {
        validateCaipAddress(e) {
          if (e.split(":")?.length !== 3) throw Error("Invalid CAIP Address");
          return e;
        },
        parseCaipAddress(e) {
          let t = e.split(":");
          if (3 !== t.length) throw Error(`Invalid CAIP-10 address: ${e}`);
          let [r, i, n] = t;
          if (!r || !i || !n) throw Error(`Invalid CAIP-10 address: ${e}`);
          return { chainNamespace: r, chainId: i, address: n };
        },
        parseCaipNetworkId(e) {
          let t = e.split(":");
          if (2 !== t.length) throw Error(`Invalid CAIP-2 network id: ${e}`);
          let [r, i] = t;
          if (!r || !i) throw Error(`Invalid CAIP-2 network id: ${e}`);
          return { chainNamespace: r, chainId: i };
        },
      };
    },
    61616: function (e, t, r) {
      "use strict";
      r.d(t, {
        $U: function () {
          return a;
        },
        Vk: function () {
          return n;
        },
        mr: function () {
          return s;
        },
        uJ: function () {
          return i;
        },
      });
      let i = {
        WALLET_ID: "@appkit/wallet_id",
        WALLET_NAME: "@appkit/wallet_name",
        SOLANA_WALLET: "@appkit/solana_wallet",
        SOLANA_CAIP_CHAIN: "@appkit/solana_caip_chain",
        ACTIVE_CAIP_NETWORK_ID: "@appkit/active_caip_network_id",
        CONNECTED_SOCIAL: "@appkit/connected_social",
        CONNECTED_SOCIAL_USERNAME: "@appkit-wallet/SOCIAL_USERNAME",
        RECENT_WALLETS: "@appkit/recent_wallets",
        DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
        ACTIVE_NAMESPACE: "@appkit/active_namespace",
        CONNECTED_NAMESPACES: "@appkit/connected_namespaces",
        CONNECTION_STATUS: "@appkit/connection_status",
        SIWX_AUTH_TOKEN: "@appkit/siwx-auth-token",
        SIWX_NONCE_TOKEN: "@appkit/siwx-nonce-token",
        TELEGRAM_SOCIAL_PROVIDER: "@appkit/social_provider",
        NATIVE_BALANCE_CACHE: "@appkit/native_balance_cache",
        PORTFOLIO_CACHE: "@appkit/portfolio_cache",
        ENS_CACHE: "@appkit/ens_cache",
        IDENTITY_CACHE: "@appkit/identity_cache",
      };
      function n(e) {
        if (!e) throw Error("Namespace is required for CONNECTED_CONNECTOR_ID");
        return `@appkit/${e}:connected_connector_id`;
      }
      let s = {
        setItem(e, t) {
          a() && void 0 !== t && localStorage.setItem(e, t);
        },
        getItem(e) {
          if (a()) return localStorage.getItem(e) || void 0;
        },
        removeItem(e) {
          a() && localStorage.removeItem(e);
        },
        clear() {
          a() && localStorage.clear();
        },
      };
      function a() {
        return (
          "undefined" != typeof window && "undefined" != typeof localStorage
        );
      }
    },
    62714: function (e, t, r) {
      "use strict";
      function i(e, t) {
        return "light" === t
          ? {
              "--w3m-accent": e?.["--w3m-accent"] || "hsla(231, 100%, 70%, 1)",
              "--w3m-background": "#fff",
            }
          : {
              "--w3m-accent": e?.["--w3m-accent"] || "hsla(230, 100%, 67%, 1)",
              "--w3m-background": "#121313",
            };
      }
      r.d(t, {
        t: function () {
          return i;
        },
      });
    },
    68584: function (e, t, r) {
      "use strict";
      r.d(t, {
        AccountController: function () {
          return d;
        },
      });
      var i = r(15708),
        n = r(59712),
        s = r(53357),
        a = r(87280),
        o = r(61704),
        l = r(55372),
        c = r(66909),
        u = r(41272);
      let h = (0, i.sj)({
          currentTab: 0,
          tokenBalance: [],
          smartAccountDeployed: !1,
          addressLabels: new Map(),
          allAccounts: [],
        }),
        d = {
          state: h,
          replaceState(e) {
            e && Object.assign(h, (0, i.iH)(e));
          },
          subscribe: (e) =>
            l.R.subscribeChainProp("accountState", (t) => {
              if (t) return e(t);
            }),
          subscribeKey(e, t, r) {
            let i;
            return l.R.subscribeChainProp(
              "accountState",
              (r) => {
                if (r) {
                  let n = r[e];
                  i !== n && ((i = n), t(n));
                }
              },
              r
            );
          },
          setStatus(e, t) {
            l.R.setAccountProp("status", e, t);
          },
          getCaipAddress: (e) => l.R.getAccountProp("caipAddress", e),
          setCaipAddress(e, t) {
            let r = e ? s.j.getPlainAddress(e) : void 0;
            t === l.R.state.activeChain && (l.R.state.activeCaipAddress = e),
              l.R.setAccountProp("caipAddress", e, t),
              l.R.setAccountProp("address", r, t);
          },
          setBalance(e, t, r) {
            l.R.setAccountProp("balance", e, r),
              l.R.setAccountProp("balanceSymbol", t, r);
          },
          setProfileName(e, t) {
            l.R.setAccountProp("profileName", e, t);
          },
          setProfileImage(e, t) {
            l.R.setAccountProp("profileImage", e, t);
          },
          setUser(e, t) {
            l.R.setAccountProp("user", e, t);
          },
          setAddressExplorerUrl(e, t) {
            l.R.setAccountProp("addressExplorerUrl", e, t);
          },
          setSmartAccountDeployed(e, t) {
            l.R.setAccountProp("smartAccountDeployed", e, t);
          },
          setCurrentTab(e) {
            l.R.setAccountProp("currentTab", e, l.R.state.activeChain);
          },
          setTokenBalance(e, t) {
            e && l.R.setAccountProp("tokenBalance", e, t);
          },
          setShouldUpdateToAddress(e, t) {
            l.R.setAccountProp("shouldUpdateToAddress", e, t);
          },
          setAllAccounts(e, t) {
            l.R.setAccountProp("allAccounts", e, t);
          },
          addAddressLabel(e, t, r) {
            let i = l.R.getAccountProp("addressLabels", r) || new Map();
            i.set(e, t), l.R.setAccountProp("addressLabels", i, r);
          },
          removeAddressLabel(e, t) {
            let r = l.R.getAccountProp("addressLabels", t) || new Map();
            r.delete(e), l.R.setAccountProp("addressLabels", r, t);
          },
          setConnectedWalletInfo(e, t) {
            l.R.setAccountProp("connectedWalletInfo", e, t, !1);
          },
          setPreferredAccountType(e, t) {
            l.R.setAccountProp("preferredAccountType", e, t);
          },
          setSocialProvider(e, t) {
            e && l.R.setAccountProp("socialProvider", e, t);
          },
          setSocialWindow(e, t) {
            l.R.setAccountProp("socialWindow", e ? (0, i.iH)(e) : void 0, t);
          },
          setFarcasterUrl(e, t) {
            l.R.setAccountProp("farcasterUrl", e, t);
          },
          async fetchTokenBalance(e) {
            h.balanceLoading = !0;
            let t = l.R.state.activeCaipNetwork?.caipNetworkId,
              r = l.R.state.activeCaipNetwork?.chainNamespace,
              i = l.R.state.activeCaipAddress,
              d = i ? s.j.getPlainAddress(i) : void 0;
            if (
              h.lastRetry &&
              !s.j.isAllowedRetry(h.lastRetry, 30 * n.bq.ONE_SEC_MS)
            )
              return (h.balanceLoading = !1), [];
            try {
              if (d && t && r) {
                let e = await o.L.getBalance(d, t),
                  i = e.balances.filter((e) => "0" !== e.quantity.decimals);
                return (
                  this.setTokenBalance(i, r),
                  u.nY.setBalances(a.n.mapBalancesToSwapTokens(e.balances)),
                  (h.lastRetry = void 0),
                  (h.balanceLoading = !1),
                  i
                );
              }
            } catch (t) {
              (h.lastRetry = Date.now()),
                e?.(t),
                c.SnackController.showError("Token Balance Unavailable");
            } finally {
              h.balanceLoading = !1;
            }
            return [];
          },
          resetAccount(e) {
            l.R.resetAccount(e);
          },
        };
    },
    72723: function (e, t, r) {
      "use strict";
      r.d(t, {
        AlertController: function () {
          return o;
        },
      });
      var i = r(15708),
        n = r(55543),
        s = r(48415);
      let a = (0, i.sj)({ message: "", variant: "info", open: !1 }),
        o = {
          state: a,
          subscribeKey: (e, t) => (0, n.VW)(a, e, t),
          open(e, t) {
            let { debug: r } = s.OptionsController.state,
              { shortMessage: i, longMessage: n } = e;
            r && ((a.message = i), (a.variant = t), (a.open = !0)),
              n && console.error("function" == typeof n ? n() : n);
          },
          close() {
            (a.open = !1), (a.message = ""), (a.variant = "info");
          },
        };
    },
    17766: function (e, t, r) {
      "use strict";
      r.d(t, {
        ApiController: function () {
          return y;
        },
      });
      var i = r(15708),
        n = r(55543),
        s = r(63043),
        a = r(53357),
        o = r(39905),
        l = r(36801),
        c = r(22472),
        u = r(55372),
        h = r(54173),
        d = r(31929),
        p = r(48415);
      let f = a.j.getApiUrl(),
        g = new o.V({ baseUrl: f, clientId: null }),
        m = (0, i.sj)({
          promises: {},
          page: 1,
          count: 0,
          featured: [],
          allFeatured: [],
          recommended: [],
          allRecommended: [],
          wallets: [],
          search: [],
          isAnalyticsEnabled: !1,
          excludedRDNS: [],
          isFetchingRecommendedWallets: !1,
        }),
        y = {
          state: m,
          subscribeKey: (e, t) => (0, n.VW)(m, e, t),
          _getSdkProperties() {
            let {
              projectId: e,
              sdkType: t,
              sdkVersion: r,
            } = p.OptionsController.state;
            return {
              projectId: e,
              st: t || "appkit",
              sv: r || "html-wagmi-4.2.2",
            };
          },
          _filterOutExtensions: (e) =>
            p.OptionsController.state.isUniversalProvider
              ? e.filter(
                  (e) => !!(e.mobile_link || e.desktop_link || e.webapp_link)
                )
              : e,
          async _fetchWalletImage(e) {
            let t = `${g.baseUrl}/getWalletImage/${e}`,
              r = await g.getBlob({ path: t, params: y._getSdkProperties() });
            c.W.setWalletImage(e, URL.createObjectURL(r));
          },
          async _fetchNetworkImage(e) {
            let t = `${g.baseUrl}/public/getAssetImage/${e}`,
              r = await g.getBlob({ path: t, params: y._getSdkProperties() });
            c.W.setNetworkImage(e, URL.createObjectURL(r));
          },
          async _fetchConnectorImage(e) {
            let t = `${g.baseUrl}/public/getAssetImage/${e}`,
              r = await g.getBlob({ path: t, params: y._getSdkProperties() });
            c.W.setConnectorImage(e, URL.createObjectURL(r));
          },
          async _fetchCurrencyImage(e) {
            let t = `${g.baseUrl}/public/getCurrencyImage/${e}`,
              r = await g.getBlob({ path: t, params: y._getSdkProperties() });
            c.W.setCurrencyImage(e, URL.createObjectURL(r));
          },
          async _fetchTokenImage(e) {
            let t = `${g.baseUrl}/public/getTokenImage/${e}`,
              r = await g.getBlob({ path: t, params: y._getSdkProperties() });
            c.W.setTokenImage(e, URL.createObjectURL(r));
          },
          async fetchNetworkImages() {
            let e = u.R.getAllRequestedCaipNetworks(),
              t = e
                ?.map(({ assets: e }) => e?.imageId)
                .filter(Boolean)
                .filter((e) => !s.f.getNetworkImageById(e));
            t &&
              (await Promise.allSettled(t.map((e) => y._fetchNetworkImage(e))));
          },
          async fetchConnectorImages() {
            let { connectors: e } = h.ConnectorController.state,
              t = e.map(({ imageId: e }) => e).filter(Boolean);
            await Promise.allSettled(t.map((e) => y._fetchConnectorImage(e)));
          },
          async fetchCurrencyImages(e = []) {
            await Promise.allSettled(e.map((e) => y._fetchCurrencyImage(e)));
          },
          async fetchTokenImages(e = []) {
            await Promise.allSettled(e.map((e) => y._fetchTokenImage(e)));
          },
          async fetchFeaturedWallets() {
            let { featuredWalletIds: e } = p.OptionsController.state;
            if (e?.length) {
              let { data: t } = await g.get({
                path: "/getWallets",
                params: {
                  ...y._getSdkProperties(),
                  page: "1",
                  entries: e?.length ? String(e.length) : "4",
                  include: e?.join(","),
                },
              });
              t.sort((t, r) => e.indexOf(t.id) - e.indexOf(r.id));
              let r = t.map((e) => e.image_id).filter(Boolean);
              await Promise.allSettled(r.map((e) => y._fetchWalletImage(e))),
                (m.featured = t),
                (m.allFeatured = t);
            }
          },
          async fetchRecommendedWallets() {
            try {
              m.isFetchingRecommendedWallets = !0;
              let {
                  includeWalletIds: e,
                  excludeWalletIds: t,
                  featuredWalletIds: r,
                } = p.OptionsController.state,
                i = [...(t ?? []), ...(r ?? [])].filter(Boolean),
                n = u.R.getRequestedCaipNetworkIds().join(","),
                { data: s, count: a } = await g.get({
                  path: "/getWallets",
                  params: {
                    ...y._getSdkProperties(),
                    page: "1",
                    chains: n,
                    entries: "4",
                    include: e?.join(","),
                    exclude: i?.join(","),
                  },
                }),
                o = l.M.getRecentWallets(),
                c = s.map((e) => e.image_id).filter(Boolean),
                h = o.map((e) => e.image_id).filter(Boolean);
              await Promise.allSettled(
                [...c, ...h].map((e) => y._fetchWalletImage(e))
              ),
                (m.recommended = s),
                (m.allRecommended = s),
                (m.count = a ?? 0);
            } catch {
            } finally {
              m.isFetchingRecommendedWallets = !1;
            }
          },
          async fetchWallets({ page: e }) {
            let {
                includeWalletIds: t,
                excludeWalletIds: r,
                featuredWalletIds: i,
              } = p.OptionsController.state,
              n = u.R.getRequestedCaipNetworkIds().join(","),
              s = [
                ...m.recommended.map(({ id: e }) => e),
                ...(r ?? []),
                ...(i ?? []),
              ].filter(Boolean),
              { data: o, count: l } = await g.get({
                path: "/getWallets",
                params: {
                  ...y._getSdkProperties(),
                  page: String(e),
                  entries: "40",
                  chains: n,
                  include: t?.join(","),
                  exclude: s.join(","),
                },
              }),
              c = o
                .slice(0, 20)
                .map((e) => e.image_id)
                .filter(Boolean);
            await Promise.allSettled(c.map((e) => y._fetchWalletImage(e))),
              (m.wallets = a.j.uniqueBy(
                [...m.wallets, ...y._filterOutExtensions(o)],
                "id"
              )),
              (m.count = l > m.count ? l : m.count),
              (m.page = e);
          },
          async initializeExcludedWalletRdns({ ids: e }) {
            let t = u.R.getRequestedCaipNetworkIds().join(","),
              { data: r } = await g.get({
                path: "/getWallets",
                params: {
                  ...y._getSdkProperties(),
                  page: "1",
                  entries: String(e.length),
                  chains: t,
                  include: e?.join(","),
                },
              });
            r &&
              r.forEach((e) => {
                e?.rdns && m.excludedRDNS.push(e.rdns);
              });
          },
          async searchWallet({ search: e, badge: t }) {
            let { includeWalletIds: r, excludeWalletIds: i } =
              p.OptionsController.state;
            m.search = [];
            let n = u.R.getRequestedCaipNetworkIds().join(","),
              { data: s } = await g.get({
                path: "/getWallets",
                params: {
                  ...y._getSdkProperties(),
                  page: "1",
                  entries: "100",
                  search: e?.trim(),
                  badge_type: t,
                  chains: n,
                  include: r?.join(","),
                  exclude: i?.join(","),
                },
              });
            d.X.sendEvent({
              type: "track",
              event: "SEARCH_WALLET",
              properties: { badge: t ?? "", search: e ?? "" },
            });
            let o = s.map((e) => e.image_id).filter(Boolean);
            await Promise.allSettled([
              ...o.map((e) => y._fetchWalletImage(e)),
              a.j.wait(300),
            ]),
              (m.search = y._filterOutExtensions(s));
          },
          initPromise: (e, t) => m.promises[e] || (m.promises[e] = t()),
          prefetch: ({
            fetchConnectorImages: e = !0,
            fetchFeaturedWallets: t = !0,
            fetchRecommendedWallets: r = !0,
            fetchNetworkImages: i = !0,
          } = {}) =>
            Promise.allSettled(
              [
                e && y.initPromise("connectorImages", y.fetchConnectorImages),
                t && y.initPromise("featuredWallets", y.fetchFeaturedWallets),
                r &&
                  y.initPromise(
                    "recommendedWallets",
                    y.fetchRecommendedWallets
                  ),
                i && y.initPromise("networkImages", y.fetchNetworkImages),
              ].filter(Boolean)
            ),
          prefetchAnalyticsConfig() {
            p.OptionsController.state.features?.analytics &&
              y.fetchAnalyticsConfig();
          },
          async fetchAnalyticsConfig() {
            try {
              let { isAnalyticsEnabled: e } = await g.get({
                path: "/getAnalyticsConfig",
                params: y._getSdkProperties(),
              });
              p.OptionsController.setFeatures({ analytics: e });
            } catch (e) {
              p.OptionsController.setFeatures({ analytics: !1 });
            }
          },
          setFilterByNamespace(e) {
            if (!e) {
              (m.featured = m.allFeatured), (m.recommended = m.allRecommended);
              return;
            }
            let t = u.R.getRequestedCaipNetworkIds().join(",");
            (m.featured = m.allFeatured.filter((e) =>
              e.chains?.some((e) => t.includes(e))
            )),
              (m.recommended = m.allRecommended.filter((e) =>
                e.chains?.some((e) => t.includes(e))
              ));
          },
        };
    },
    22472: function (e, t, r) {
      "use strict";
      r.d(t, {
        W: function () {
          return a;
        },
      });
      var i = r(15708),
        n = r(55543);
      let s = (0, i.sj)({
          walletImages: {},
          networkImages: {},
          chainImages: {},
          connectorImages: {},
          tokenImages: {},
          currencyImages: {},
        }),
        a = {
          state: s,
          subscribeNetworkImages: (e) =>
            (0, i.Ld)(s.networkImages, () => e(s.networkImages)),
          subscribeKey: (e, t) => (0, n.VW)(s, e, t),
          subscribe: (e) => (0, i.Ld)(s, () => e(s)),
          setWalletImage(e, t) {
            s.walletImages[e] = t;
          },
          setNetworkImage(e, t) {
            s.networkImages[e] = t;
          },
          setChainImage(e, t) {
            s.chainImages[e] = t;
          },
          setConnectorImage(e, t) {
            s.connectorImages = { ...s.connectorImages, [e]: t };
          },
          setTokenImage(e, t) {
            s.tokenImages[e] = t;
          },
          setCurrencyImage(e, t) {
            s.currencyImages[e] = t;
          },
        };
    },
    61704: function (e, t, r) {
      "use strict";
      r.d(t, {
        L: function () {
          return g;
        },
      });
      var i = r(15708),
        n = r(59712),
        s = r(53357),
        a = r(39905),
        o = r(36801),
        l = r(68584),
        c = r(55372),
        u = r(48415),
        h = r(66909);
      let d = {
          purchaseCurrencies: [
            {
              id: "2b92315d-eab7-5bef-84fa-089a131333f5",
              name: "USD Coin",
              symbol: "USDC",
              networks: [
                {
                  name: "ethereum-mainnet",
                  display_name: "Ethereum",
                  chain_id: "1",
                  contract_address:
                    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
                },
                {
                  name: "polygon-mainnet",
                  display_name: "Polygon",
                  chain_id: "137",
                  contract_address:
                    "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
                },
              ],
            },
            {
              id: "2b92315d-eab7-5bef-84fa-089a131333f5",
              name: "Ether",
              symbol: "ETH",
              networks: [
                {
                  name: "ethereum-mainnet",
                  display_name: "Ethereum",
                  chain_id: "1",
                  contract_address:
                    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
                },
                {
                  name: "polygon-mainnet",
                  display_name: "Polygon",
                  chain_id: "137",
                  contract_address:
                    "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
                },
              ],
            },
          ],
          paymentCurrencies: [
            {
              id: "USD",
              payment_method_limits: [
                { id: "card", min: "10.00", max: "7500.00" },
                { id: "ach_bank_account", min: "10.00", max: "25000.00" },
              ],
            },
            {
              id: "EUR",
              payment_method_limits: [
                { id: "card", min: "10.00", max: "7500.00" },
                { id: "ach_bank_account", min: "10.00", max: "25000.00" },
              ],
            },
          ],
        },
        p = s.j.getBlockchainApiUrl(),
        f = (0, i.sj)({
          clientId: null,
          api: new a.V({ baseUrl: p, clientId: null }),
          supportedChains: { http: [], ws: [] },
        }),
        g = {
          state: f,
          async get(e) {
            let { st: t, sv: r } = g.getSdkProperties(),
              i = u.OptionsController.state.projectId,
              n = { ...(e.params || {}), st: t, sv: r, projectId: i };
            return f.api.get({ ...e, params: n });
          },
          getSdkProperties() {
            let { sdkType: e, sdkVersion: t } = u.OptionsController.state;
            return { st: e || "unknown", sv: t || "unknown" };
          },
          async isNetworkSupported(e) {
            if (!e) return !1;
            try {
              f.supportedChains.http.length || (await g.getSupportedNetworks());
            } catch (e) {
              return !1;
            }
            return f.supportedChains.http.includes(e);
          },
          async getSupportedNetworks() {
            let e = await g.get({ path: "v1/supported-chains" });
            return (f.supportedChains = e), e;
          },
          async fetchIdentity({ address: e, caipNetworkId: t }) {
            if (!(await g.isNetworkSupported(t)))
              return { avatar: "", name: "" };
            let r = o.M.getIdentityFromCacheForAddress(e);
            if (r) return r;
            let i = await g.get({
              path: `/v1/identity/${e}`,
              params: {
                sender: c.R.state.activeCaipAddress
                  ? s.j.getPlainAddress(c.R.state.activeCaipAddress)
                  : void 0,
              },
            });
            return (
              o.M.updateIdentityCache({
                address: e,
                identity: i,
                timestamp: Date.now(),
              }),
              i
            );
          },
          fetchTransactions: async ({
            account: e,
            cursor: t,
            onramp: r,
            signal: i,
            cache: n,
            chainId: s,
          }) =>
            (await g.isNetworkSupported(
              c.R.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: `/v1/account/${e}/history`,
                  params: { cursor: t, onramp: r, chainId: s },
                  signal: i,
                  cache: n,
                })
              : { data: [], next: void 0 },
          fetchSwapQuote: async ({
            amount: e,
            userAddress: t,
            from: r,
            to: i,
            gasPrice: n,
          }) =>
            (await g.isNetworkSupported(
              c.R.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: "/v1/convert/quotes",
                  headers: { "Content-Type": "application/json" },
                  params: {
                    amount: e,
                    userAddress: t,
                    from: r,
                    to: i,
                    gasPrice: n,
                  },
                })
              : { quotes: [] },
          fetchSwapTokens: async ({ chainId: e }) =>
            (await g.isNetworkSupported(
              c.R.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({ path: "/v1/convert/tokens", params: { chainId: e } })
              : { tokens: [] },
          fetchTokenPrice: async ({ addresses: e }) =>
            (await g.isNetworkSupported(
              c.R.state.activeCaipNetwork?.caipNetworkId
            ))
              ? f.api.post({
                  path: "/v1/fungible/price",
                  body: {
                    currency: "usd",
                    addresses: e,
                    projectId: u.OptionsController.state.projectId,
                  },
                  headers: { "Content-Type": "application/json" },
                })
              : { fungibles: [] },
          fetchSwapAllowance: async ({ tokenAddress: e, userAddress: t }) =>
            (await g.isNetworkSupported(
              c.R.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: "/v1/convert/allowance",
                  params: { tokenAddress: e, userAddress: t },
                  headers: { "Content-Type": "application/json" },
                })
              : { allowance: "0" },
          async fetchGasPrice({ chainId: e }) {
            let { st: t, sv: r } = g.getSdkProperties();
            if (
              !(await g.isNetworkSupported(
                c.R.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              throw Error("Network not supported for Gas Price");
            return g.get({
              path: "/v1/convert/gas-price",
              headers: { "Content-Type": "application/json" },
              params: { chainId: e, st: t, sv: r },
            });
          },
          async generateSwapCalldata({
            amount: e,
            from: t,
            to: r,
            userAddress: i,
          }) {
            if (
              !(await g.isNetworkSupported(
                c.R.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              throw Error("Network not supported for Swaps");
            return f.api.post({
              path: "/v1/convert/build-transaction",
              headers: { "Content-Type": "application/json" },
              body: {
                amount: e,
                eip155: { slippage: n.bq.CONVERT_SLIPPAGE_TOLERANCE },
                projectId: u.OptionsController.state.projectId,
                from: t,
                to: r,
                userAddress: i,
              },
            });
          },
          async generateApproveCalldata({ from: e, to: t, userAddress: r }) {
            let { st: i, sv: n } = g.getSdkProperties();
            if (
              !(await g.isNetworkSupported(
                c.R.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              throw Error("Network not supported for Swaps");
            return g.get({
              path: "/v1/convert/build-approve",
              headers: { "Content-Type": "application/json" },
              params: { userAddress: r, from: e, to: t, st: i, sv: n },
            });
          },
          async getBalance(e, t, r) {
            let { st: i, sv: n } = g.getSdkProperties();
            if (
              !(await g.isNetworkSupported(
                c.R.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              return (
                h.SnackController.showError("Token Balance Unavailable"),
                { balances: [] }
              );
            let s = `${t}:${e}`,
              a = o.M.getBalanceCacheForCaipAddress(s);
            if (a) return a;
            let l = await g.get({
              path: `/v1/account/${e}/balance`,
              params: {
                currency: "usd",
                chainId: t,
                forceUpdate: r,
                st: i,
                sv: n,
              },
            });
            return (
              o.M.updateBalanceCache({
                caipAddress: s,
                balance: l,
                timestamp: Date.now(),
              }),
              l
            );
          },
          lookupEnsName: async (e) =>
            (await g.isNetworkSupported(
              c.R.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: `/v1/profile/account/${e}`,
                  params: { apiVersion: "2" },
                })
              : { addresses: {}, attributes: [] },
          reverseLookupEnsName: async ({ address: e }) =>
            (await g.isNetworkSupported(
              c.R.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: `/v1/profile/reverse/${e}`,
                  params: {
                    sender: l.AccountController.state.address,
                    apiVersion: "2",
                  },
                })
              : [],
          getEnsNameSuggestions: async (e) =>
            (await g.isNetworkSupported(
              c.R.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: `/v1/profile/suggestions/${e}`,
                  params: { zone: "reown.id" },
                })
              : { suggestions: [] },
          registerEnsName: async ({
            coinType: e,
            address: t,
            message: r,
            signature: i,
          }) =>
            (await g.isNetworkSupported(
              c.R.state.activeCaipNetwork?.caipNetworkId
            ))
              ? f.api.post({
                  path: "/v1/profile/account",
                  body: { coin_type: e, address: t, message: r, signature: i },
                  headers: { "Content-Type": "application/json" },
                })
              : { success: !1 },
          generateOnRampURL: async ({
            destinationWallets: e,
            partnerUserId: t,
            defaultNetwork: r,
            purchaseAmount: i,
            paymentAmount: n,
          }) =>
            (await g.isNetworkSupported(
              c.R.state.activeCaipNetwork?.caipNetworkId
            ))
              ? (
                  await f.api.post({
                    path: "/v1/generators/onrampurl",
                    params: { projectId: u.OptionsController.state.projectId },
                    body: {
                      destinationWallets: e,
                      defaultNetwork: r,
                      partnerUserId: t,
                      defaultExperience: "buy",
                      presetCryptoAmount: i,
                      presetFiatAmount: n,
                    },
                  })
                ).url
              : "",
          async getOnrampOptions() {
            if (
              !(await g.isNetworkSupported(
                c.R.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              return { paymentCurrencies: [], purchaseCurrencies: [] };
            try {
              return await g.get({ path: "/v1/onramp/options" });
            } catch (e) {
              return d;
            }
          },
          async getOnrampQuote({
            purchaseCurrency: e,
            paymentCurrency: t,
            amount: r,
            network: i,
          }) {
            try {
              if (
                !(await g.isNetworkSupported(
                  c.R.state.activeCaipNetwork?.caipNetworkId
                ))
              )
                return null;
              return await f.api.post({
                path: "/v1/onramp/quote",
                params: { projectId: u.OptionsController.state.projectId },
                body: {
                  purchaseCurrency: e,
                  paymentCurrency: t,
                  amount: r,
                  network: i,
                },
              });
            } catch (e) {
              return {
                coinbaseFee: { amount: r, currency: t.id },
                networkFee: { amount: r, currency: t.id },
                paymentSubtotal: { amount: r, currency: t.id },
                paymentTotal: { amount: r, currency: t.id },
                purchaseAmount: { amount: r, currency: t.id },
                quoteId: "mocked-quote-id",
              };
            }
          },
          getSmartSessions: async (e) =>
            (await g.isNetworkSupported(
              c.R.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({ path: `/v1/sessions/${e}` })
              : [],
          revokeSmartSession: async (e, t, r) =>
            (await g.isNetworkSupported(
              c.R.state.activeCaipNetwork?.caipNetworkId
            ))
              ? f.api.post({
                  path: `/v1/sessions/${e}/revoke`,
                  params: { projectId: u.OptionsController.state.projectId },
                  body: { pci: t, signature: r },
                })
              : { success: !1 },
          setClientId(e) {
            (f.clientId = e), (f.api = new a.V({ baseUrl: p, clientId: e }));
          },
        };
    },
    55372: function (e, t, r) {
      "use strict";
      r.d(t, {
        R: function () {
          return C;
        },
      });
      var i = r(15708),
        n = r(55543),
        s = r(68903),
        a = r(44649),
        o = r(54173);
      function l(e, t) {
        return o.ConnectorController.getConnectorId(e) === t;
      }
      var c = r(59712),
        u = r(53357),
        h = r(36801),
        d = r(68584),
        p = r(21278),
        f = r(31929),
        g = r(89512),
        m = r(48415),
        y = r(96986),
        w = r(86777),
        b = r(35212);
      let v = {
          currentTab: 0,
          tokenBalance: [],
          smartAccountDeployed: !1,
          addressLabels: new Map(),
          allAccounts: [],
          user: void 0,
        },
        E = {
          caipNetwork: void 0,
          supportsAllNetworks: !0,
          smartAccountEnabledNetworks: [],
        },
        A = (0, i.sj)({
          chains: (0, n.Yr)(),
          activeCaipAddress: void 0,
          activeChain: void 0,
          activeCaipNetwork: void 0,
          noAdapters: !1,
          universalAdapter: {
            networkControllerClient: void 0,
            connectionControllerClient: void 0,
          },
          isSwitchingNamespace: !1,
        }),
        C = {
          state: A,
          subscribe: (e) =>
            (0, i.Ld)(A, () => {
              e(A);
            }),
          subscribeKey: (e, t) => (0, n.VW)(A, e, t),
          subscribeChainProp(e, t, r) {
            let n;
            return (0, i.Ld)(A.chains, () => {
              let i = r || A.activeChain;
              if (i) {
                let r = A.chains.get(i)?.[e];
                n !== r && ((n = r), t(r));
              }
            });
          },
          initialize(e, t, r) {
            let { chainId: n, namespace: s } = h.M.getActiveNetworkProps(),
              a = t?.find((e) => e.id.toString() === n?.toString()),
              o = e.find((e) => e?.namespace === s) || e?.[0],
              l = new Set([...(t?.map((e) => e.chainNamespace) ?? [])]);
            (e?.length !== 0 && o) || (A.noAdapters = !0),
              !A.noAdapters &&
                ((A.activeChain = o?.namespace),
                (A.activeCaipNetwork = a),
                this.setChainNetworkData(o?.namespace, { caipNetwork: a }),
                A.activeChain && y.I.set({ activeChain: o?.namespace })),
              l.forEach((e) => {
                let n = t?.filter((t) => t.chainNamespace === e);
                C.state.chains.set(e, {
                  namespace: e,
                  networkState: (0, i.sj)({ ...E, caipNetwork: n?.[0] }),
                  accountState: (0, i.sj)(v),
                  caipNetworks: n ?? [],
                  ...r,
                }),
                  this.setRequestedCaipNetworks(n ?? [], e);
              });
          },
          removeAdapter(e) {
            if (A.activeChain === e) {
              let t = Array.from(A.chains.entries()).find(([t]) => t !== e);
              if (t) {
                let e = t[1]?.caipNetworks?.[0];
                e && this.setActiveCaipNetwork(e);
              }
            }
            A.chains.delete(e);
          },
          addAdapter(
            e,
            { networkControllerClient: t, connectionControllerClient: r },
            i
          ) {
            A.chains.set(e.namespace, {
              namespace: e.namespace,
              networkState: { ...E, caipNetwork: i[0] },
              accountState: v,
              caipNetworks: i,
              connectionControllerClient: r,
              networkControllerClient: t,
            }),
              this.setRequestedCaipNetworks(
                i?.filter((t) => t.chainNamespace === e.namespace) ?? [],
                e.namespace
              );
          },
          addNetwork(e) {
            let t = A.chains.get(e.chainNamespace);
            if (t) {
              let r = [...(t.caipNetworks || [])];
              t.caipNetworks?.find((t) => t.id === e.id) || r.push(e),
                A.chains.set(e.chainNamespace, { ...t, caipNetworks: r }),
                this.setRequestedCaipNetworks(r, e.chainNamespace);
            }
          },
          removeNetwork(e, t) {
            let r = A.chains.get(e);
            if (r) {
              let i = A.activeCaipNetwork?.id === t,
                n = [...(r.caipNetworks?.filter((e) => e.id !== t) || [])];
              i &&
                r?.caipNetworks?.[0] &&
                this.setActiveCaipNetwork(r.caipNetworks[0]),
                A.chains.set(e, { ...r, caipNetworks: n }),
                this.setRequestedCaipNetworks(n || [], e);
            }
          },
          setAdapterNetworkState(e, t) {
            let r = A.chains.get(e);
            r &&
              ((r.networkState = { ...(r.networkState || E), ...t }),
              A.chains.set(e, r));
          },
          setChainAccountData(e, t, r = !0) {
            if (!e)
              throw Error("Chain is required to update chain account data");
            let i = A.chains.get(e);
            if (i) {
              let r = { ...(i.accountState || v), ...t };
              A.chains.set(e, { ...i, accountState: r }),
                (1 === A.chains.size || A.activeChain === e) &&
                  (t.caipAddress && (A.activeCaipAddress = t.caipAddress),
                  d.AccountController.replaceState(r));
            }
          },
          setChainNetworkData(e, t) {
            if (!e) return;
            let r = A.chains.get(e);
            if (r) {
              let i = { ...(r.networkState || E), ...t };
              A.chains.set(e, { ...r, networkState: i });
            }
          },
          setAccountProp(e, t, r, i = !0) {
            this.setChainAccountData(r, { [e]: t }, i),
              "status" === e &&
                "disconnected" === t &&
                r &&
                o.ConnectorController.removeConnectorId(r);
          },
          setActiveNamespace(e) {
            A.activeChain = e;
            let t = e ? A.chains.get(e) : void 0,
              r = t?.networkState?.caipNetwork;
            r?.id &&
              e &&
              ((A.activeCaipAddress = t?.accountState?.caipAddress),
              (A.activeCaipNetwork = r),
              this.setChainNetworkData(e, { caipNetwork: r }),
              h.M.setActiveCaipNetworkId(r?.caipNetworkId),
              y.I.set({ activeChain: e, selectedNetworkId: r?.caipNetworkId }));
          },
          setActiveCaipNetwork(e) {
            if (!e) return;
            A.activeChain !== e.chainNamespace &&
              this.setIsSwitchingNamespace(!0);
            let t = A.chains.get(e.chainNamespace);
            (A.activeChain = e.chainNamespace),
              (A.activeCaipNetwork = e),
              this.setChainNetworkData(e.chainNamespace, { caipNetwork: e }),
              t?.accountState?.address
                ? (A.activeCaipAddress = `${e.chainNamespace}:${e.id}:${t?.accountState?.address}`)
                : (A.activeCaipAddress = void 0),
              this.setAccountProp(
                "caipAddress",
                A.activeCaipAddress,
                e.chainNamespace
              ),
              t && d.AccountController.replaceState(t.accountState),
              b.S.resetSend(),
              y.I.set({
                activeChain: A.activeChain,
                selectedNetworkId: A.activeCaipNetwork?.caipNetworkId,
              }),
              h.M.setActiveCaipNetworkId(e.caipNetworkId),
              this.checkIfSupportedNetwork(e.chainNamespace) ||
                m.OptionsController.state.allowUnsupportedChain ||
                p.ConnectionController.state.wcBasic ||
                this.showUnsupportedChainUI();
          },
          addCaipNetwork(e) {
            if (!e) return;
            let t = A.chains.get(e.chainNamespace);
            t && t?.caipNetworks?.push(e);
          },
          async switchActiveNamespace(e) {
            if (!e) return;
            let t = e !== C.state.activeChain,
              r = C.getNetworkData(e)?.caipNetwork,
              i = C.getCaipNetworkByNamespace(e, r?.id);
            t && i && (await C.switchActiveNetwork(i));
          },
          async switchActiveNetwork(e) {
            let t = C.state.chains.get(C.state.activeChain);
            t?.caipNetworks?.some((e) => e.id === A.activeCaipNetwork?.id) ||
              w.RouterController.goBack();
            let r = this.getNetworkControllerClient(e.chainNamespace);
            r &&
              (await r.switchCaipNetwork(e),
              f.X.sendEvent({
                type: "track",
                event: "SWITCH_NETWORK",
                properties: { network: e.caipNetworkId },
              }));
          },
          getNetworkControllerClient(e) {
            let t = e || A.activeChain,
              r = A.chains.get(t);
            if (!r) throw Error("Chain adapter not found");
            if (!r.networkControllerClient)
              throw Error("NetworkController client not set");
            return r.networkControllerClient;
          },
          getConnectionControllerClient(e) {
            let t = e || A.activeChain;
            if (!t)
              throw Error(
                "Chain is required to get connection controller client"
              );
            let r = A.chains.get(t);
            if (!r?.connectionControllerClient)
              throw Error("ConnectionController client not set");
            return r.connectionControllerClient;
          },
          getAccountProp(e, t) {
            let r = A.activeChain;
            if ((t && (r = t), !r)) return;
            let i = A.chains.get(r)?.accountState;
            if (i) return i[e];
          },
          getNetworkProp(e, t) {
            let r = A.chains.get(t)?.networkState;
            if (r) return r[e];
          },
          getRequestedCaipNetworks(e) {
            let t = A.chains.get(e),
              {
                approvedCaipNetworkIds: r = [],
                requestedCaipNetworks: i = [],
              } = t?.networkState || {};
            return u.j.sortRequestedNetworks(r, i);
          },
          getAllRequestedCaipNetworks() {
            let e = [];
            return (
              A.chains.forEach((t) => {
                let r = this.getRequestedCaipNetworks(t.namespace);
                e.push(...r);
              }),
              e
            );
          },
          setRequestedCaipNetworks(e, t) {
            this.setAdapterNetworkState(t, { requestedCaipNetworks: e });
          },
          getAllApprovedCaipNetworkIds() {
            let e = [];
            return (
              A.chains.forEach((t) => {
                let r = this.getApprovedCaipNetworkIds(t.namespace);
                e.push(...r);
              }),
              e
            );
          },
          getActiveCaipNetwork: () => A.activeCaipNetwork,
          getActiveCaipAddress: () => A.activeCaipAddress,
          getApprovedCaipNetworkIds(e) {
            let t = A.chains.get(e);
            return t?.networkState?.approvedCaipNetworkIds || [];
          },
          async setApprovedCaipNetworksData(e) {
            let t = this.getNetworkControllerClient(),
              r = await t?.getApprovedCaipNetworksData();
            this.setAdapterNetworkState(e, {
              approvedCaipNetworkIds: r?.approvedCaipNetworkIds,
              supportsAllNetworks: r?.supportsAllNetworks,
            });
          },
          checkIfSupportedNetwork(e, t) {
            let r = t || A.activeCaipNetwork,
              i = this.getRequestedCaipNetworks(e);
            return !i.length || i?.some((e) => e.id === r?.id);
          },
          checkIfSupportedChainId(e) {
            if (!A.activeChain) return !0;
            let t = this.getRequestedCaipNetworks(A.activeChain);
            return t?.some((t) => t.id === e);
          },
          setSmartAccountEnabledNetworks(e, t) {
            this.setAdapterNetworkState(t, { smartAccountEnabledNetworks: e });
          },
          checkIfSmartAccountEnabled() {
            let e = s.p.caipNetworkIdToNumber(
                A.activeCaipNetwork?.caipNetworkId
              ),
              t = A.activeChain;
            if (!t || !e) return !1;
            let r = this.getNetworkProp("smartAccountEnabledNetworks", t);
            return !!r?.includes(Number(e));
          },
          getActiveNetworkTokenAddress() {
            let e = A.activeCaipNetwork?.chainNamespace || "eip155",
              t = A.activeCaipNetwork?.id || 1,
              r = c.bq.NATIVE_TOKEN_ADDRESS[e];
            return `${e}:${t}:${r}`;
          },
          showUnsupportedChainUI() {
            g.I.open({ view: "UnsupportedChain" });
          },
          checkIfNamesSupported() {
            let e = A.activeCaipNetwork;
            return !!(
              e?.chainNamespace &&
              c.bq.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(e.chainNamespace)
            );
          },
          resetNetwork(e) {
            this.setAdapterNetworkState(e, {
              approvedCaipNetworkIds: void 0,
              supportsAllNetworks: !0,
              smartAccountEnabledNetworks: [],
            });
          },
          resetAccount(e) {
            if (!e) throw Error("Chain is required to set account prop");
            (A.activeCaipAddress = void 0),
              this.setChainAccountData(e, {
                smartAccountDeployed: !1,
                currentTab: 0,
                caipAddress: void 0,
                address: void 0,
                balance: void 0,
                balanceSymbol: void 0,
                profileName: void 0,
                profileImage: void 0,
                addressExplorerUrl: void 0,
                tokenBalance: [],
                connectedWalletInfo: void 0,
                preferredAccountType: void 0,
                socialProvider: void 0,
                socialWindow: void 0,
                farcasterUrl: void 0,
                allAccounts: [],
                user: void 0,
                status: "disconnected",
              }),
              o.ConnectorController.removeConnectorId(e);
          },
          async disconnect(e) {
            let t = (function (e) {
              let t = Array.from(C.state.chains.keys()),
                r = [];
              return (
                e
                  ? (r.push([e, C.state.chains.get(e)]),
                    l(e, a.b.CONNECTOR_ID.WALLET_CONNECT)
                      ? t.forEach((t) => {
                          t !== e &&
                            l(t, a.b.CONNECTOR_ID.WALLET_CONNECT) &&
                            r.push([t, C.state.chains.get(t)]);
                        })
                      : l(e, a.b.CONNECTOR_ID.AUTH) &&
                        t.forEach((t) => {
                          t !== e &&
                            l(t, a.b.CONNECTOR_ID.AUTH) &&
                            r.push([t, C.state.chains.get(t)]);
                        }))
                  : (r = Array.from(C.state.chains.entries())),
                r
              );
            })(e);
            try {
              b.S.resetSend();
              let r = await Promise.allSettled(
                t.map(async ([e, t]) => {
                  try {
                    let { caipAddress: r } = this.getAccountData(e) || {};
                    r &&
                      t.connectionControllerClient?.disconnect &&
                      (await t.connectionControllerClient.disconnect(e)),
                      this.resetAccount(e),
                      this.resetNetwork(e);
                  } catch (t) {
                    throw Error(
                      `Failed to disconnect chain ${e}: ${t.message}`
                    );
                  }
                })
              );
              p.ConnectionController.resetWcConnection();
              let i = r.filter((e) => "rejected" === e.status);
              if (i.length > 0)
                throw Error(i.map((e) => e.reason.message).join(", "));
              h.M.deleteConnectedSocialProvider(),
                e
                  ? o.ConnectorController.removeConnectorId(e)
                  : o.ConnectorController.resetConnectorIds(),
                f.X.sendEvent({
                  type: "track",
                  event: "DISCONNECT_SUCCESS",
                  properties: { namespace: e || "all" },
                });
            } catch (e) {
              console.error(e.message || "Failed to disconnect chains"),
                f.X.sendEvent({
                  type: "track",
                  event: "DISCONNECT_ERROR",
                  properties: {
                    message: e.message || "Failed to disconnect chains",
                  },
                });
            }
          },
          setIsSwitchingNamespace(e) {
            A.isSwitchingNamespace = e;
          },
          getFirstCaipNetworkSupportsAuthConnector() {
            let e = [];
            if (
              (A.chains.forEach((t) => {
                a.b.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(
                  (e) => e === t.namespace
                ) &&
                  t.namespace &&
                  e.push(t.namespace);
              }),
              e.length > 0)
            ) {
              let t = e[0];
              return t ? A.chains.get(t)?.caipNetworks?.[0] : void 0;
            }
          },
          getAccountData: (e) =>
            e ? C.state.chains.get(e)?.accountState : d.AccountController.state,
          getNetworkData(e) {
            let t = e || A.activeChain;
            if (t) return C.state.chains.get(t)?.networkState;
          },
          getCaipNetworkByNamespace(e, t) {
            if (!e) return;
            let r = C.state.chains.get(e);
            return (
              r?.caipNetworks?.find((e) => e.id === t) ||
              r?.networkState?.caipNetwork ||
              r?.caipNetworks?.[0]
            );
          },
          getRequestedCaipNetworkIds() {
            let e = o.ConnectorController.state.filterByNamespace;
            return (e ? [A.chains.get(e)] : Array.from(A.chains.values()))
              .flatMap((e) => e?.caipNetworks || [])
              .map((e) => e.caipNetworkId);
          },
        };
    },
    21278: function (e, t, r) {
      "use strict";
      let i;
      r.d(t, {
        ConnectionController: function () {
          return m;
        },
      });
      var n = r(15708),
        s = r(55543),
        a = r(53357),
        o = r(60389),
        l = r(36801),
        c = r(55372),
        u = r(54173),
        h = r(31929),
        d = r(89512),
        p = r(86777),
        f = r(70216);
      let g = (0, n.sj)({ wcError: !1, buffering: !1, status: "disconnected" }),
        m = {
          state: g,
          subscribeKey: (e, t) => (0, s.VW)(g, e, t),
          _getClient: () => g._client,
          setClient(e) {
            g._client = (0, n.iH)(e);
          },
          async connectWalletConnect() {
            if (a.j.isTelegram() || (a.j.isSafari() && a.j.isIos())) {
              if (i) {
                await i, (i = void 0);
                return;
              }
              if (!a.j.isPairingExpired(g?.wcPairingExpiry)) {
                let e = g.wcUri;
                g.wcUri = e;
                return;
              }
              (i = this._getClient()
                ?.connectWalletConnect?.()
                .catch(() => void 0)),
                (this.state.status = "connecting"),
                await i,
                (i = void 0),
                (g.wcPairingExpiry = void 0),
                (this.state.status = "connected");
            } else await this._getClient()?.connectWalletConnect?.();
          },
          async connectExternal(e, t, r = !0) {
            await this._getClient()?.connectExternal?.(e),
              r && c.R.setActiveNamespace(t);
          },
          async reconnectExternal(e) {
            await this._getClient()?.reconnectExternal?.(e);
            let t = e.chain || c.R.state.activeChain;
            t && u.ConnectorController.setConnectorId(e.id, t);
          },
          async setPreferredAccountType(e) {
            d.I.setLoading(!0, c.R.state.activeChain);
            let t = u.ConnectorController.getAuthConnector();
            t &&
              (await t?.provider.setPreferredAccount(e),
              await this.reconnectExternal(t),
              d.I.setLoading(!1, c.R.state.activeChain),
              h.X.sendEvent({
                type: "track",
                event: "SET_PREFERRED_ACCOUNT_TYPE",
                properties: {
                  accountType: e,
                  network: c.R.state.activeCaipNetwork?.caipNetworkId || "",
                },
              }));
          },
          async signMessage(e) {
            return this._getClient()?.signMessage(e);
          },
          parseUnits(e, t) {
            return this._getClient()?.parseUnits(e, t);
          },
          formatUnits(e, t) {
            return this._getClient()?.formatUnits(e, t);
          },
          async sendTransaction(e) {
            return this._getClient()?.sendTransaction(e);
          },
          async getCapabilities(e) {
            return this._getClient()?.getCapabilities(e);
          },
          async grantPermissions(e) {
            return this._getClient()?.grantPermissions(e);
          },
          async walletGetAssets(e) {
            return this._getClient()?.walletGetAssets(e) ?? {};
          },
          async estimateGas(e) {
            return this._getClient()?.estimateGas(e);
          },
          async writeContract(e) {
            return this._getClient()?.writeContract(e);
          },
          async getEnsAddress(e) {
            return this._getClient()?.getEnsAddress(e);
          },
          async getEnsAvatar(e) {
            return this._getClient()?.getEnsAvatar(e);
          },
          checkInstalled(e) {
            return this._getClient()?.checkInstalled?.(e) || !1;
          },
          resetWcConnection() {
            (g.wcUri = void 0),
              (g.wcPairingExpiry = void 0),
              (g.wcLinking = void 0),
              (g.recentWallet = void 0),
              (g.status = "disconnected"),
              f.s.resetTransactions(),
              l.M.deleteWalletConnectDeepLink();
          },
          resetUri() {
            (g.wcUri = void 0), (g.wcPairingExpiry = void 0);
          },
          finalizeWcConnection() {
            let { wcLinking: e, recentWallet: t } = m.state;
            e && l.M.setWalletConnectDeepLink(e),
              t && l.M.setAppKitRecent(t),
              h.X.sendEvent({
                type: "track",
                event: "CONNECT_SUCCESS",
                properties: {
                  method: e ? "mobile" : "qrcode",
                  name:
                    p.RouterController.state.data?.wallet?.name || "Unknown",
                },
              });
          },
          setWcBasic(e) {
            g.wcBasic = e;
          },
          setUri(e) {
            (g.wcUri = e), (g.wcPairingExpiry = a.j.getPairingExpiry());
          },
          setWcLinking(e) {
            g.wcLinking = e;
          },
          setWcError(e) {
            (g.wcError = e), (g.buffering = !1);
          },
          setRecentWallet(e) {
            g.recentWallet = e;
          },
          setBuffering(e) {
            g.buffering = e;
          },
          setStatus(e) {
            g.status = e;
          },
          async disconnect(e) {
            try {
              d.I.setLoading(!0, e),
                await o.w.clearSessions(),
                await c.R.disconnect(e),
                d.I.setLoading(!1, e),
                u.ConnectorController.setFilterByNamespace(void 0);
            } catch (e) {
              throw Error("Failed to disconnect");
            }
          },
        };
    },
    54173: function (e, t, r) {
      "use strict";
      r.d(t, {
        ConnectorController: function () {
          return m;
        },
      });
      var i = r(15708),
        n = r(55543),
        s = r(44649),
        a = r(62714),
        o = r(55372);
      let l = {
        handleSolanaDeeplinkRedirect(e) {
          if (o.R.state.activeChain === s.b.CHAIN.SOLANA) {
            let t = window.location.href,
              r = encodeURIComponent(t);
            if ("Phantom" === e && !("phantom" in window)) {
              let e = t.startsWith("https") ? "https" : "http",
                i = t.split("/")[2],
                n = encodeURIComponent(`${e}://${i}`);
              window.location.href = `https://phantom.app/ul/browse/${r}?ref=${n}`;
            }
            "Coinbase Wallet" !== e ||
              "coinbaseSolana" in window ||
              (window.location.href = `https://go.cb-w.com/dapp?cb_url=${r}`);
          }
        },
      };
      var c = r(36801),
        u = r(17766),
        h = r(48415),
        d = r(86777),
        p = r(52005);
      let f = {
          eip155: void 0,
          solana: void 0,
          polkadot: void 0,
          bip122: void 0,
        },
        g = (0, i.sj)({
          allConnectors: [],
          connectors: [],
          activeConnector: void 0,
          filterByNamespace: void 0,
          activeConnectorIds: { ...f },
        }),
        m = {
          state: g,
          subscribe: (e) =>
            (0, i.Ld)(g, () => {
              e(g);
            }),
          subscribeKey: (e, t) => (0, n.VW)(g, e, t),
          initialize(e) {
            e.forEach((e) => {
              let t = c.M.getConnectedConnectorId(e);
              t && this.setConnectorId(t, e);
            });
          },
          setActiveConnector(e) {
            e && (g.activeConnector = (0, i.iH)(e));
          },
          setConnectors(e) {
            e
              .filter(
                (e) =>
                  !g.allConnectors.some(
                    (t) =>
                      t.id === e.id &&
                      this.getConnectorName(t.name) ===
                        this.getConnectorName(e.name) &&
                      t.chain === e.chain
                  )
              )
              .forEach((e) => {
                "MULTI_CHAIN" !== e.type && g.allConnectors.push((0, i.iH)(e));
              }),
              (g.connectors = this.mergeMultiChainConnectors(g.allConnectors));
          },
          removeAdapter(e) {
            (g.allConnectors = g.allConnectors.filter((t) => t.chain !== e)),
              (g.connectors = this.mergeMultiChainConnectors(g.allConnectors));
          },
          mergeMultiChainConnectors(e) {
            let t = this.generateConnectorMapByName(e),
              r = [];
            return (
              t.forEach((e) => {
                let t = e[0],
                  i = t?.id === s.b.CONNECTOR_ID.AUTH;
                e.length > 1 && t
                  ? r.push({
                      name: t.name,
                      imageUrl: t.imageUrl,
                      imageId: t.imageId,
                      connectors: [...e],
                      type: i ? "AUTH" : "MULTI_CHAIN",
                      chain: "eip155",
                      id: t?.id || "",
                    })
                  : t && r.push(t);
              }),
              r
            );
          },
          generateConnectorMapByName(e) {
            let t = new Map();
            return (
              e.forEach((e) => {
                let { name: r } = e,
                  i = this.getConnectorName(r);
                if (!i) return;
                let n = t.get(i) || [];
                n.find((t) => t.chain === e.chain) || n.push(e), t.set(i, n);
              }),
              t
            );
          },
          getConnectorName: (e) => (e && { "Trust Wallet": "Trust" }[e]) || e,
          getUniqueConnectorsByName(e) {
            let t = [];
            return (
              e.forEach((e) => {
                t.find((t) => t.chain === e.chain) || t.push(e);
              }),
              t
            );
          },
          addConnector(e) {
            if (e.id === s.b.CONNECTOR_ID.AUTH) {
              let t = (0, i.CO)(h.OptionsController.state),
                r = p.ThemeController.getSnapshot().themeMode,
                n = p.ThemeController.getSnapshot().themeVariables;
              e?.provider?.syncDappData?.({
                metadata: t.metadata,
                sdkVersion: t.sdkVersion,
                projectId: t.projectId,
                sdkType: t.sdkType,
              }),
                e?.provider?.syncTheme({
                  themeMode: r,
                  themeVariables: n,
                  w3mThemeVariables: a.t(n, r),
                }),
                this.setConnectors([e]);
            } else this.setConnectors([e]);
          },
          getAuthConnector(e) {
            let t = e || o.R.state.activeChain,
              r = g.connectors.find((e) => e.id === s.b.CONNECTOR_ID.AUTH);
            return r
              ? r?.connectors?.length
                ? r.connectors.find((e) => e.chain === t)
                : r
              : void 0;
          },
          getAnnouncedConnectorRdns: () =>
            g.connectors
              .filter((e) => "ANNOUNCED" === e.type)
              .map((e) => e.info?.rdns),
          getConnectorById: (e) => g.allConnectors.find((t) => t.id === e),
          getConnector: (e, t) =>
            g.allConnectors
              .filter((e) => e.chain === o.R.state.activeChain)
              .find((r) => r.explorerId === e || r.info?.rdns === t),
          syncIfAuthConnector(e) {
            if ("ID_AUTH" !== e.id) return;
            let t = (0, i.CO)(h.OptionsController.state),
              r = p.ThemeController.getSnapshot().themeMode,
              n = p.ThemeController.getSnapshot().themeVariables;
            e?.provider?.syncDappData?.({
              metadata: t.metadata,
              sdkVersion: t.sdkVersion,
              sdkType: t.sdkType,
              projectId: t.projectId,
            }),
              e.provider.syncTheme({
                themeMode: r,
                themeVariables: n,
                w3mThemeVariables: (0, a.t)(n, r),
              });
          },
          getConnectorsByNamespace(e) {
            let t = g.allConnectors.filter((t) => t.chain === e);
            return this.mergeMultiChainConnectors(t);
          },
          selectWalletConnector(e) {
            let t = m.getConnector(e.id, e.rdns);
            o.R.state.activeChain === s.b.CHAIN.SOLANA &&
              l.handleSolanaDeeplinkRedirect(t?.name || e.name || ""),
              t
                ? d.RouterController.push("ConnectingExternal", {
                    connector: t,
                  })
                : d.RouterController.push("ConnectingWalletConnect", {
                    wallet: e,
                  });
          },
          getConnectors(e) {
            return e
              ? this.getConnectorsByNamespace(e)
              : this.mergeMultiChainConnectors(g.allConnectors);
          },
          setFilterByNamespace(e) {
            (g.filterByNamespace = e),
              (g.connectors = this.getConnectors(e)),
              u.ApiController.setFilterByNamespace(e);
          },
          setConnectorId(e, t) {
            e &&
              ((g.activeConnectorIds = { ...g.activeConnectorIds, [t]: e }),
              c.M.setConnectedConnectorId(t, e));
          },
          removeConnectorId(e) {
            (g.activeConnectorIds = { ...g.activeConnectorIds, [e]: void 0 }),
              c.M.deleteConnectedConnectorId(e);
          },
          getConnectorId(e) {
            if (e) return g.activeConnectorIds[e];
          },
          isConnected: (e) =>
            e
              ? !!g.activeConnectorIds[e]
              : Object.values(g.activeConnectorIds).some((e) => !!e),
          resetConnectorIds() {
            g.activeConnectorIds = { ...f };
          },
        };
    },
    12540: function (e, t, r) {
      "use strict";
      r.d(t, {
        a: function () {
          return f;
        },
      });
      var i = r(15708),
        n = r(55543);
      let s = {
        convertEVMChainIdToCoinType(e) {
          if (e >= 2147483648) throw Error("Invalid chainId");
          return (2147483648 | e) >>> 0;
        },
      };
      var a = r(36801),
        o = r(68584),
        l = r(61704),
        c = r(55372),
        u = r(21278),
        h = r(54173),
        d = r(86777);
      let p = (0, i.sj)({ suggestions: [], loading: !1 }),
        f = {
          state: p,
          subscribe: (e) => (0, i.Ld)(p, () => e(p)),
          subscribeKey: (e, t) => (0, n.VW)(p, e, t),
          async resolveName(e) {
            try {
              return await l.L.lookupEnsName(e);
            } catch (e) {
              throw Error(
                e?.reasons?.[0]?.description || "Error resolving name"
              );
            }
          },
          async isNameRegistered(e) {
            try {
              return await l.L.lookupEnsName(e), !0;
            } catch {
              return !1;
            }
          },
          async getSuggestions(e) {
            try {
              (p.loading = !0), (p.suggestions = []);
              let t = await l.L.getEnsNameSuggestions(e);
              return (
                (p.suggestions =
                  t.suggestions.map((e) => ({ ...e, name: e.name })) || []),
                p.suggestions
              );
            } catch (e) {
              throw Error(
                this.parseEnsApiError(e, "Error fetching name suggestions")
              );
            } finally {
              p.loading = !1;
            }
          },
          async getNamesForAddress(e) {
            try {
              if (!c.R.state.activeCaipNetwork) return [];
              let t = a.M.getEnsFromCacheForAddress(e);
              if (t) return t;
              let r = await l.L.reverseLookupEnsName({ address: e });
              return (
                a.M.updateEnsCache({
                  address: e,
                  ens: r,
                  timestamp: Date.now(),
                }),
                r
              );
            } catch (e) {
              throw Error(
                this.parseEnsApiError(e, "Error fetching names for address")
              );
            }
          },
          async registerName(e) {
            let t = c.R.state.activeCaipNetwork;
            if (!t) throw Error("Network not found");
            let r = o.AccountController.state.address,
              i = h.ConnectorController.getAuthConnector();
            if (!r || !i) throw Error("Address or auth connector not found");
            p.loading = !0;
            try {
              let i = JSON.stringify({
                name: e,
                attributes: {},
                timestamp: Math.floor(Date.now() / 1e3),
              });
              d.RouterController.pushTransactionStack({
                view: "RegisterAccountNameSuccess",
                goBack: !1,
                replace: !0,
                onCancel() {
                  p.loading = !1;
                },
              });
              let n = await u.ConnectionController.signMessage(i),
                a = t.id;
              if (!a) throw Error("Network not found");
              let c = s.convertEVMChainIdToCoinType(Number(a));
              await l.L.registerEnsName({
                coinType: c,
                address: r,
                signature: n,
                message: i,
              }),
                o.AccountController.setProfileName(e, t.chainNamespace),
                d.RouterController.replace("RegisterAccountNameSuccess");
            } catch (r) {
              let t = this.parseEnsApiError(r, `Error registering name ${e}`);
              throw (
                (d.RouterController.replace("RegisterAccountName"), Error(t))
              );
            } finally {
              p.loading = !1;
            }
          },
          validateName: (e) => /^[a-zA-Z0-9-]{4,}$/u.test(e),
          parseEnsApiError: (e, t) => e?.reasons?.[0]?.description || t,
        };
    },
    31929: function (e, t, r) {
      "use strict";
      r.d(t, {
        X: function () {
          return g;
        },
      });
      var i = r(15708),
        n = r(44649),
        s = r(61616),
        a = r(53357),
        o = r(39905),
        l = r(68584),
        c = r(72723),
        u = r(48415);
      let h = a.j.getAnalyticsUrl(),
        d = new o.V({ baseUrl: h, clientId: null }),
        p = ["MODAL_CREATED"],
        f = (0, i.sj)({
          timestamp: Date.now(),
          reportedErrors: {},
          data: { type: "track", event: "MODAL_CREATED" },
        }),
        g = {
          state: f,
          subscribe: (e) => (0, i.Ld)(f, () => e(f)),
          getSdkProperties() {
            let {
              projectId: e,
              sdkType: t,
              sdkVersion: r,
            } = u.OptionsController.state;
            return { projectId: e, st: t, sv: r || "html-wagmi-4.2.2" };
          },
          async _sendAnalyticsEvent(e) {
            try {
              let t = l.AccountController.state.address;
              if (p.includes(e.data.event) || "undefined" == typeof window)
                return;
              await d.post({
                path: "/e",
                params: g.getSdkProperties(),
                body: {
                  eventId: a.j.getUUID(),
                  url: window.location.href,
                  domain: window.location.hostname,
                  timestamp: e.timestamp,
                  props: { ...e.data, address: t },
                },
              }),
                (f.reportedErrors.FORBIDDEN = !1);
            } catch (e) {
              e instanceof Error &&
                e.cause instanceof Response &&
                e.cause.status === n.b.HTTP_STATUS_CODES.FORBIDDEN &&
                !f.reportedErrors.FORBIDDEN &&
                (c.AlertController.open(
                  {
                    shortMessage: "Invalid App Configuration",
                    longMessage: `Origin ${
                      (0, s.$U)() ? window.origin : "uknown"
                    } not found on Allowlist - update configuration on cloud.reown.com`,
                  },
                  "error"
                ),
                (f.reportedErrors.FORBIDDEN = !0));
            }
          },
          sendEvent(e) {
            (f.timestamp = Date.now()),
              (f.data = e),
              u.OptionsController.state.features?.analytics &&
                g._sendAnalyticsEvent(f);
          },
        };
    },
    89512: function (e, t, r) {
      "use strict";
      r.d(t, {
        I: function () {
          return m;
        },
      });
      var i = r(15708),
        n = r(55543),
        s = r(53357),
        a = r(68584),
        o = r(17766),
        l = r(55372),
        c = r(21278),
        u = r(54173),
        h = r(31929),
        d = r(48415),
        p = r(96986),
        f = r(86777);
      let g = (0, i.sj)({
          loading: !1,
          loadingNamespaceMap: new Map(),
          open: !1,
          shake: !1,
          namespace: void 0,
        }),
        m = {
          state: g,
          subscribe: (e) => (0, i.Ld)(g, () => e(g)),
          subscribeKey: (e, t) => (0, n.VW)(g, e, t),
          async open(e) {
            let t = "connected" === a.AccountController.state.status;
            c.ConnectionController.state.wcBasic
              ? o.ApiController.prefetch({
                  fetchNetworkImages: !1,
                  fetchConnectorImages: !1,
                })
              : await o.ApiController.prefetch({
                  fetchConnectorImages: !t,
                  fetchFeaturedWallets: !t,
                  fetchRecommendedWallets: !t,
                }),
              e?.namespace
                ? (await l.R.switchActiveNamespace(e.namespace),
                  m.setLoading(!0, e.namespace))
                : m.setLoading(!0),
              u.ConnectorController.setFilterByNamespace(e?.namespace);
            let r = l.R.getAccountData(e?.namespace)?.caipAddress;
            l.R.state.noAdapters && !r
              ? s.j.isMobile()
                ? f.RouterController.reset("AllWallets")
                : f.RouterController.reset("ConnectingWalletConnectBasic")
              : e?.view
              ? f.RouterController.reset(e.view)
              : r
              ? f.RouterController.reset("Account")
              : f.RouterController.reset("Connect"),
              (g.open = !0),
              p.I.set({ open: !0 }),
              h.X.sendEvent({
                type: "track",
                event: "MODAL_OPEN",
                properties: { connected: !!r },
              });
          },
          close() {
            let e = d.OptionsController.state.enableEmbedded,
              t = !!l.R.state.activeCaipAddress;
            g.open &&
              h.X.sendEvent({
                type: "track",
                event: "MODAL_CLOSE",
                properties: { connected: t },
              }),
              (g.open = !1),
              m.clearLoading(),
              e
                ? t
                  ? f.RouterController.replace("Account")
                  : f.RouterController.push("Connect")
                : p.I.set({ open: !1 }),
              c.ConnectionController.resetUri();
          },
          setLoading(e, t) {
            t && g.loadingNamespaceMap.set(t, e),
              (g.loading = e),
              p.I.set({ loading: e });
          },
          clearLoading() {
            g.loadingNamespaceMap.clear(), (g.loading = !1);
          },
          shake() {
            g.shake ||
              ((g.shake = !0),
              setTimeout(() => {
                g.shake = !1;
              }, 500));
          },
        };
    },
    48415: function (e, t, r) {
      "use strict";
      r.d(t, {
        OptionsController: function () {
          return c;
        },
      });
      var i = r(15708),
        n = r(55543),
        s = r(59712),
        a = r(53357);
      let o = {
          getFeatureValue(e, t) {
            let r = t?.[e];
            return void 0 === r ? s.bq.DEFAULT_FEATURES[e] : r;
          },
          filterSocialsByPlatform(e) {
            if (!e || !e.length) return e;
            if (a.j.isTelegram()) {
              if (a.j.isIos()) return e.filter((e) => "google" !== e);
              if (a.j.isMac()) return e.filter((e) => "x" !== e);
              if (a.j.isAndroid())
                return e.filter((e) => !["facebook", "x"].includes(e));
            }
            return e;
          },
        },
        l = (0, i.sj)({
          features: s.bq.DEFAULT_FEATURES,
          projectId: "",
          sdkType: "appkit",
          sdkVersion: "html-wagmi-undefined",
          defaultAccountTypes: s.bq.DEFAULT_ACCOUNT_TYPES,
        }),
        c = {
          state: l,
          subscribeKey: (e, t) => (0, n.VW)(l, e, t),
          setOptions(e) {
            Object.assign(l, e);
          },
          setFeatures(e) {
            if (!e) return;
            l.features || (l.features = s.bq.DEFAULT_FEATURES);
            let t = { ...l.features, ...e };
            (l.features = t),
              l.features.socials &&
                (l.features.socials = o.filterSocialsByPlatform(
                  l.features.socials
                ));
          },
          setProjectId(e) {
            l.projectId = e;
          },
          setCustomRpcUrls(e) {
            l.customRpcUrls = e;
          },
          setAllWallets(e) {
            l.allWallets = e;
          },
          setIncludeWalletIds(e) {
            l.includeWalletIds = e;
          },
          setExcludeWalletIds(e) {
            l.excludeWalletIds = e;
          },
          setFeaturedWalletIds(e) {
            l.featuredWalletIds = e;
          },
          setTokens(e) {
            l.tokens = e;
          },
          setTermsConditionsUrl(e) {
            l.termsConditionsUrl = e;
          },
          setPrivacyPolicyUrl(e) {
            l.privacyPolicyUrl = e;
          },
          setCustomWallets(e) {
            l.customWallets = e;
          },
          setIsSiweEnabled(e) {
            l.isSiweEnabled = e;
          },
          setIsUniversalProvider(e) {
            l.isUniversalProvider = e;
          },
          setSdkVersion(e) {
            l.sdkVersion = e;
          },
          setMetadata(e) {
            l.metadata = e;
          },
          setDisableAppend(e) {
            l.disableAppend = e;
          },
          setEIP6963Enabled(e) {
            l.enableEIP6963 = e;
          },
          setDebug(e) {
            l.debug = e;
          },
          setEnableWalletConnect(e) {
            l.enableWalletConnect = e;
          },
          setEnableWalletGuide(e) {
            l.enableWalletGuide = e;
          },
          setEnableAuthLogger(e) {
            l.enableAuthLogger = e;
          },
          setEnableWallets(e) {
            l.enableWallets = e;
          },
          setHasMultipleAddresses(e) {
            l.hasMultipleAddresses = e;
          },
          setSIWX(e) {
            l.siwx = e;
          },
          setConnectMethodsOrder(e) {
            l.features = { ...l.features, connectMethodsOrder: e };
          },
          setWalletFeaturesOrder(e) {
            l.features = { ...l.features, walletFeaturesOrder: e };
          },
          setSocialsOrder(e) {
            l.features = { ...l.features, socials: e };
          },
          setCollapseWallets(e) {
            l.features = { ...l.features, collapseWallets: e };
          },
          setEnableEmbedded(e) {
            l.enableEmbedded = e;
          },
          setAllowUnsupportedChain(e) {
            l.allowUnsupportedChain = e;
          },
          setManualWCControl(e) {
            l.manualWCControl = e;
          },
          setDefaultAccountTypes(e = {}) {
            Object.entries(e).forEach(([e, t]) => {
              t && (l.defaultAccountTypes[e] = t);
            });
          },
          getSnapshot: () => (0, i.CO)(l),
        };
    },
    96986: function (e, t, r) {
      "use strict";
      r.d(t, {
        I: function () {
          return s;
        },
      });
      var i = r(15708);
      let n = (0, i.sj)({
          loading: !1,
          open: !1,
          selectedNetworkId: void 0,
          activeChain: void 0,
          initialized: !1,
        }),
        s = {
          state: n,
          subscribe: (e) => (0, i.Ld)(n, () => e(n)),
          set(e) {
            Object.assign(n, { ...n, ...e });
          },
        };
    },
    86777: function (e, t, r) {
      "use strict";
      r.d(t, {
        RouterController: function () {
          return h;
        },
      });
      var i = r(15708),
        n = r(55543),
        s = r(68584),
        a = r(55372),
        o = r(54173),
        l = r(89512),
        c = r(48415);
      let u = (0, i.sj)({
          view: "Connect",
          history: ["Connect"],
          transactionStack: [],
        }),
        h = {
          state: u,
          subscribeKey: (e, t) => (0, n.VW)(u, e, t),
          pushTransactionStack(e) {
            u.transactionStack.push(e);
          },
          popTransactionStack(e) {
            let t = u.transactionStack.pop();
            if (t) {
              if (e) this.goBack(), t?.onCancel?.();
              else {
                if (t.goBack) this.goBack();
                else if (t.replace) {
                  let e = u.history.indexOf("ConnectingSiwe");
                  e > 0
                    ? this.goBackToIndex(e - 1)
                    : (l.I.close(), (u.history = []));
                } else t.view && this.reset(t.view);
                t?.onSuccess?.();
              }
            }
          },
          push(e, t) {
            e !== u.view && ((u.view = e), u.history.push(e), (u.data = t));
          },
          reset(e, t) {
            (u.view = e), (u.history = [e]), (u.data = t);
          },
          replace(e, t) {
            u.history.at(-1) !== e &&
              ((u.view = e),
              (u.history[u.history.length - 1] = e),
              (u.data = t));
          },
          goBack() {
            let e =
              !a.R.state.activeCaipAddress &&
              "ConnectingFarcaster" === this.state.view;
            if (
              u.history.length > 1 &&
              !u.history.includes("UnsupportedChain")
            ) {
              u.history.pop();
              let [e] = u.history.slice(-1);
              e && (u.view = e);
            } else l.I.close();
            u.data?.wallet && (u.data.wallet = void 0),
              setTimeout(() => {
                if (e) {
                  s.AccountController.setFarcasterUrl(
                    void 0,
                    a.R.state.activeChain
                  );
                  let e = o.ConnectorController.getAuthConnector();
                  e?.provider?.reload();
                  let t = (0, i.CO)(c.OptionsController.state);
                  e?.provider?.syncDappData?.({
                    metadata: t.metadata,
                    sdkVersion: t.sdkVersion,
                    projectId: t.projectId,
                    sdkType: t.sdkType,
                  });
                }
              }, 100);
          },
          goBackToIndex(e) {
            if (u.history.length > 1) {
              u.history = u.history.slice(0, e + 1);
              let [t] = u.history.slice(-1);
              t && (u.view = t);
            }
          },
        };
    },
    35212: function (e, t, r) {
      "use strict";
      r.d(t, {
        S: function () {
          return _;
        },
      });
      var i = r(15708),
        n = r(55543),
        s = r(23614);
      let a = [
          {
            type: "function",
            name: "transfer",
            stateMutability: "nonpayable",
            inputs: [
              { name: "_to", type: "address" },
              { name: "_value", type: "uint256" },
            ],
            outputs: [{ name: "", type: "bool" }],
          },
          {
            type: "function",
            name: "transferFrom",
            stateMutability: "nonpayable",
            inputs: [
              { name: "_from", type: "address" },
              { name: "_to", type: "address" },
              { name: "_value", type: "uint256" },
            ],
            outputs: [{ name: "", type: "bool" }],
          },
        ],
        o = [
          {
            type: "function",
            name: "transfer",
            stateMutability: "nonpayable",
            inputs: [
              { name: "recipient", type: "address" },
              { name: "amount", type: "uint256" },
            ],
            outputs: [],
          },
          {
            type: "function",
            name: "transferFrom",
            stateMutability: "nonpayable",
            inputs: [
              { name: "sender", type: "address" },
              { name: "recipient", type: "address" },
              { name: "amount", type: "uint256" },
            ],
            outputs: [{ name: "", type: "bool" }],
          },
        ];
      var l = r(44649);
      let c = {
        getERC20Abi: (e) => (l.b.USDT_CONTRACT_ADDRESSES.includes(e) ? o : a),
      };
      var u = r(4786),
        h = r(59712),
        d = r(53357),
        p = r(68584),
        f = r(61704),
        g = r(55372),
        m = r(21278),
        y = r(39502);
      let w = {
          createBalance(e, t) {
            let r = {
              name: e.metadata.name || "",
              symbol: e.metadata.symbol || "",
              decimals: e.metadata.decimals || 0,
              value: e.metadata.value || 0,
              price: e.metadata.price || 0,
              iconUrl: e.metadata.iconUrl || "",
            };
            return {
              name: r.name,
              symbol: r.symbol,
              chainId: t,
              address:
                "native" === e.address
                  ? void 0
                  : this.convertAddressToCAIP10Address(e.address, t),
              value: r.value,
              price: r.price,
              quantity: {
                decimals: r.decimals.toString(),
                numeric: this.convertHexToBalance({
                  hex: e.balance,
                  decimals: r.decimals,
                }),
              },
              iconUrl: r.iconUrl,
            };
          },
          convertHexToBalance: ({ hex: e, decimals: t }) =>
            (0, y.b)(BigInt(e), t),
          convertAddressToCAIP10Address: (e, t) => `${t}:${e}`,
          createCAIP2ChainId: (e, t) => `${t}:${parseInt(e, 16)}`,
          getChainIdHexFromCAIP2ChainId(e) {
            let t = e.split(":");
            if (t.length < 2 || !t[1]) return "0x0";
            let r = parseInt(t[1], 10);
            return isNaN(r) ? "0x0" : `0x${r.toString(16)}`;
          },
          isWalletGetAssetsResponse(e) {
            return (
              "object" == typeof e &&
              null !== e &&
              Object.values(e).every(
                (e) => Array.isArray(e) && e.every((e) => this.isValidAsset(e))
              )
            );
          },
          isValidAsset: (e) =>
            "object" == typeof e &&
            null !== e &&
            "string" == typeof e.address &&
            "string" == typeof e.balance &&
            ("ERC20" === e.type || "NATIVE" === e.type) &&
            "object" == typeof e.metadata &&
            null !== e.metadata &&
            "string" == typeof e.metadata.name &&
            "string" == typeof e.metadata.symbol &&
            "number" == typeof e.metadata.decimals &&
            "number" == typeof e.metadata.price &&
            "string" == typeof e.metadata.iconUrl,
        },
        b = {
          async getMyTokensWithBalance(e) {
            let t = p.AccountController.state.address,
              r = g.R.state.activeCaipNetwork;
            if (!t || !r) return [];
            if ("eip155" === r.chainNamespace) {
              let e = await this.getEIP155Balances(t, r);
              if (e) return this.filterLowQualityTokens(e);
            }
            let i = await f.L.getBalance(t, r.caipNetworkId, e);
            return this.filterLowQualityTokens(i.balances);
          },
          async getEIP155Balances(e, t) {
            try {
              let r = w.getChainIdHexFromCAIP2ChainId(t.caipNetworkId),
                i = await m.ConnectionController.getCapabilities(e);
              if (!i?.[r]?.assetDiscovery?.supported) return null;
              let n = await m.ConnectionController.walletGetAssets({
                account: e,
                chainFilter: [r],
              });
              if (!w.isWalletGetAssetsResponse(n)) return null;
              return (n[r] || []).map((e) =>
                w.createBalance(e, t.caipNetworkId)
              );
            } catch (e) {
              return null;
            }
          },
          filterLowQualityTokens: (e) =>
            e.filter((e) => "0" !== e.quantity.decimals),
          mapBalancesToSwapTokens: (e) =>
            e?.map((e) => ({
              ...e,
              address: e?.address
                ? e.address
                : g.R.getActiveNetworkTokenAddress(),
              decimals: parseInt(e.quantity.decimals, 10),
              logoUri: e.iconUrl,
              eip2612: !1,
            })) || [],
        };
      var v = r(31929),
        E = r(86777),
        A = r(66909);
      let C = (0, i.sj)({ tokenBalances: [], loading: !1 }),
        _ = {
          state: C,
          subscribe: (e) => (0, i.Ld)(C, () => e(C)),
          subscribeKey: (e, t) => (0, n.VW)(C, e, t),
          setToken(e) {
            e && (C.token = (0, i.iH)(e));
          },
          setTokenAmount(e) {
            C.sendTokenAmount = e;
          },
          setReceiverAddress(e) {
            C.receiverAddress = e;
          },
          setReceiverProfileImageUrl(e) {
            C.receiverProfileImageUrl = e;
          },
          setReceiverProfileName(e) {
            C.receiverProfileName = e;
          },
          setGasPrice(e) {
            C.gasPrice = e;
          },
          setGasPriceInUsd(e) {
            C.gasPriceInUSD = e;
          },
          setNetworkBalanceInUsd(e) {
            C.networkBalanceInUSD = e;
          },
          setLoading(e) {
            C.loading = e;
          },
          sendToken() {
            switch (g.R.state.activeCaipNetwork?.chainNamespace) {
              case "eip155":
                this.sendEvmToken();
                return;
              case "solana":
                this.sendSolanaToken();
                return;
              default:
                throw Error("Unsupported chain");
            }
          },
          sendEvmToken() {
            this.state.token?.address &&
            this.state.sendTokenAmount &&
            this.state.receiverAddress
              ? (v.X.sendEvent({
                  type: "track",
                  event: "SEND_INITIATED",
                  properties: {
                    isSmartAccount:
                      p.AccountController.state.preferredAccountType ===
                      u.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                    token: this.state.token.address,
                    amount: this.state.sendTokenAmount,
                    network: g.R.state.activeCaipNetwork?.caipNetworkId || "",
                  },
                }),
                this.sendERC20Token({
                  receiverAddress: this.state.receiverAddress,
                  tokenAddress: this.state.token.address,
                  sendTokenAmount: this.state.sendTokenAmount,
                  decimals: this.state.token.quantity.decimals,
                }))
              : this.state.receiverAddress &&
                this.state.sendTokenAmount &&
                this.state.gasPrice &&
                this.state.token?.quantity.decimals &&
                (v.X.sendEvent({
                  type: "track",
                  event: "SEND_INITIATED",
                  properties: {
                    isSmartAccount:
                      p.AccountController.state.preferredAccountType ===
                      u.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                    token: this.state.token?.symbol,
                    amount: this.state.sendTokenAmount,
                    network: g.R.state.activeCaipNetwork?.caipNetworkId || "",
                  },
                }),
                this.sendNativeToken({
                  receiverAddress: this.state.receiverAddress,
                  sendTokenAmount: this.state.sendTokenAmount,
                  gasPrice: this.state.gasPrice,
                  decimals: this.state.token.quantity.decimals,
                }));
          },
          async fetchTokenBalance(e) {
            C.loading = !0;
            let t = g.R.state.activeCaipNetwork?.caipNetworkId,
              r = g.R.state.activeCaipNetwork?.chainNamespace,
              i = g.R.state.activeCaipAddress,
              n = i ? d.j.getPlainAddress(i) : void 0;
            if (
              C.lastRetry &&
              !d.j.isAllowedRetry(C.lastRetry, 30 * h.bq.ONE_SEC_MS)
            )
              return (C.loading = !1), [];
            try {
              if (n && t && r) {
                let e = await b.getMyTokensWithBalance();
                return (C.tokenBalances = e), (C.lastRetry = void 0), e;
              }
            } catch (t) {
              (C.lastRetry = Date.now()),
                e?.(t),
                A.SnackController.showError("Token Balance Unavailable");
            } finally {
              C.loading = !1;
            }
            return [];
          },
          fetchNetworkBalance() {
            if (0 === C.tokenBalances.length) return;
            let e = b.mapBalancesToSwapTokens(C.tokenBalances);
            if (!e) return;
            let t = e.find(
              (e) => e.address === g.R.getActiveNetworkTokenAddress()
            );
            t &&
              (C.networkBalanceInUSD = t
                ? s.C.multiply(t.quantity.numeric, t.price).toString()
                : "0");
          },
          isInsufficientNetworkTokenForGas: (e, t) =>
            !!s.C.bigNumber(e).eq(0) ||
            s.C.bigNumber(s.C.bigNumber(t || "0")).gt(e),
          hasInsufficientGasFunds() {
            let e = !0;
            return (
              p.AccountController.state.preferredAccountType ===
              u.y_.ACCOUNT_TYPES.SMART_ACCOUNT
                ? (e = !1)
                : C.networkBalanceInUSD &&
                  (e = this.isInsufficientNetworkTokenForGas(
                    C.networkBalanceInUSD,
                    C.gasPriceInUSD
                  )),
              e
            );
          },
          async sendNativeToken(e) {
            E.RouterController.pushTransactionStack({
              view: "Account",
              goBack: !1,
            });
            let t = e.receiverAddress,
              r = p.AccountController.state.address,
              i = m.ConnectionController.parseUnits(
                e.sendTokenAmount.toString(),
                Number(e.decimals)
              );
            try {
              await m.ConnectionController.sendTransaction({
                chainNamespace: "eip155",
                to: t,
                address: r,
                data: "0x",
                value: i ?? BigInt(0),
                gasPrice: e.gasPrice,
              }),
                A.SnackController.showSuccess("Transaction started"),
                v.X.sendEvent({
                  type: "track",
                  event: "SEND_SUCCESS",
                  properties: {
                    isSmartAccount:
                      p.AccountController.state.preferredAccountType ===
                      u.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                    token: this.state.token?.symbol || "",
                    amount: e.sendTokenAmount,
                    network: g.R.state.activeCaipNetwork?.caipNetworkId || "",
                  },
                }),
                this.resetSend();
            } catch (r) {
              console.error(
                "SendController:sendERC20Token - failed to send native token",
                r
              );
              let t = r instanceof Error ? r.message : "Unknown error";
              v.X.sendEvent({
                type: "track",
                event: "SEND_ERROR",
                properties: {
                  message: t,
                  isSmartAccount:
                    p.AccountController.state.preferredAccountType ===
                    u.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                  token: this.state.token?.symbol || "",
                  amount: e.sendTokenAmount,
                  network: g.R.state.activeCaipNetwork?.caipNetworkId || "",
                },
              }),
                A.SnackController.showError("Something went wrong");
            }
          },
          async sendERC20Token(e) {
            E.RouterController.pushTransactionStack({
              view: "Account",
              goBack: !1,
            });
            let t = m.ConnectionController.parseUnits(
              e.sendTokenAmount.toString(),
              Number(e.decimals)
            );
            try {
              if (
                p.AccountController.state.address &&
                e.sendTokenAmount &&
                e.receiverAddress &&
                e.tokenAddress
              ) {
                let r = d.j.getPlainAddress(e.tokenAddress);
                await m.ConnectionController.writeContract({
                  fromAddress: p.AccountController.state.address,
                  tokenAddress: r,
                  args: [e.receiverAddress, t ?? BigInt(0)],
                  method: "transfer",
                  abi: c.getERC20Abi(r),
                  chainNamespace: "eip155",
                }),
                  A.SnackController.showSuccess("Transaction started"),
                  this.resetSend();
              }
            } catch (r) {
              console.error(
                "SendController:sendERC20Token - failed to send erc20 token",
                r
              );
              let t = r instanceof Error ? r.message : "Unknown error";
              v.X.sendEvent({
                type: "track",
                event: "SEND_ERROR",
                properties: {
                  message: t,
                  isSmartAccount:
                    p.AccountController.state.preferredAccountType ===
                    u.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                  token: this.state.token?.symbol || "",
                  amount: e.sendTokenAmount,
                  network: g.R.state.activeCaipNetwork?.caipNetworkId || "",
                },
              }),
                A.SnackController.showError("Something went wrong");
            }
          },
          sendSolanaToken() {
            if (!this.state.sendTokenAmount || !this.state.receiverAddress) {
              A.SnackController.showError(
                "Please enter a valid amount and receiver address"
              );
              return;
            }
            E.RouterController.pushTransactionStack({
              view: "Account",
              goBack: !1,
            }),
              m.ConnectionController.sendTransaction({
                chainNamespace: "solana",
                to: this.state.receiverAddress,
                value: this.state.sendTokenAmount,
              })
                .then(() => {
                  this.resetSend(), p.AccountController.fetchTokenBalance();
                })
                .catch((e) => {
                  A.SnackController.showError(
                    "Failed to send transaction. Please try again."
                  ),
                    console.error(
                      "SendController:sendToken - failed to send solana transaction",
                      e
                    );
                });
          },
          resetSend() {
            (C.token = void 0),
              (C.sendTokenAmount = void 0),
              (C.receiverAddress = void 0),
              (C.receiverProfileImageUrl = void 0),
              (C.receiverProfileName = void 0),
              (C.loading = !1),
              (C.tokenBalances = []);
          },
        };
    },
    66909: function (e, t, r) {
      "use strict";
      r.d(t, {
        SnackController: function () {
          return l;
        },
      });
      var i = r(15708),
        n = r(55543),
        s = r(53357);
      let a = Object.freeze({
          message: "",
          variant: "success",
          svg: void 0,
          open: !1,
          autoClose: !0,
        }),
        o = (0, i.sj)({ ...a }),
        l = {
          state: o,
          subscribeKey: (e, t) => (0, n.VW)(o, e, t),
          showLoading(e, t = {}) {
            this._showMessage({ message: e, variant: "loading", ...t });
          },
          showSuccess(e) {
            this._showMessage({ message: e, variant: "success" });
          },
          showSvg(e, t) {
            this._showMessage({ message: e, svg: t });
          },
          showError(e) {
            let t = s.j.parseError(e);
            this._showMessage({ message: t, variant: "error" });
          },
          hide() {
            (o.message = a.message),
              (o.variant = a.variant),
              (o.svg = a.svg),
              (o.open = a.open),
              (o.autoClose = a.autoClose);
          },
          _showMessage({
            message: e,
            svg: t,
            variant: r = "success",
            autoClose: i = a.autoClose,
          }) {
            o.open
              ? ((o.open = !1),
                setTimeout(() => {
                  (o.message = e),
                    (o.variant = r),
                    (o.svg = t),
                    (o.open = !0),
                    (o.autoClose = i);
                }, 150))
              : ((o.message = e),
                (o.variant = r),
                (o.svg = t),
                (o.open = !0),
                (o.autoClose = i));
          },
        };
    },
    41272: function (e, t, r) {
      "use strict";
      r.d(t, {
        nY: function () {
          return C;
        },
      });
      var i = r(15708),
        n = r(55543),
        s = r(23614),
        a = r(44649),
        o = r(4786),
        l = r(59712),
        c = r(53357),
        u = r(87280);
      let h = {
        getGasPriceInEther: (e, t) => Number(t * e) / 1e18,
        getGasPriceInUSD(e, t, r) {
          let i = h.getGasPriceInEther(t, r);
          return s.C.bigNumber(e).times(i).toNumber();
        },
        getPriceImpact({
          sourceTokenAmount: e,
          sourceTokenPriceInUSD: t,
          toTokenPriceInUSD: r,
          toTokenAmount: i,
        }) {
          let n = s.C.bigNumber(e).times(t),
            a = s.C.bigNumber(i).times(r);
          return n.minus(a).div(n).times(100).toNumber();
        },
        getMaxSlippage(e, t) {
          let r = s.C.bigNumber(e).div(100);
          return s.C.multiply(t, r).toNumber();
        },
        getProviderFee: (e, t = 0.0085) => s.C.bigNumber(e).times(t).toString(),
        isInsufficientNetworkTokenForGas: (e, t) =>
          !!s.C.bigNumber(e).eq(0) ||
          s.C.bigNumber(s.C.bigNumber(t || "0")).gt(e),
        isInsufficientSourceTokenForSwap(e, t, r) {
          let i = r?.find((e) => e.address === t)?.quantity?.numeric;
          return s.C.bigNumber(i || "0").lt(e);
        },
        getToTokenAmount({
          sourceToken: e,
          toToken: t,
          sourceTokenPrice: r,
          toTokenPrice: i,
          sourceTokenAmount: n,
        }) {
          if ("0" === n || !e || !t) return "0";
          let a = e.decimals,
            o = t.decimals;
          if (i <= 0) return "0";
          let l = s.C.bigNumber(n).times(0.0085),
            c = s.C.bigNumber(n).minus(l).times(s.C.bigNumber(10).pow(a)),
            u = s.C.bigNumber(r).div(i),
            h = a - o;
          return c
            .times(u)
            .div(s.C.bigNumber(10).pow(h))
            .div(s.C.bigNumber(10).pow(o))
            .toFixed(o)
            .toString();
        },
      };
      var d = r(68584),
        p = r(72723),
        f = r(61704),
        g = r(55372),
        m = r(21278),
        y = r(54173),
        w = r(31929),
        b = r(86777),
        v = r(66909);
      let E = {
          initializing: !1,
          initialized: !1,
          loadingPrices: !1,
          loadingQuote: !1,
          loadingApprovalTransaction: !1,
          loadingBuildTransaction: !1,
          loadingTransaction: !1,
          fetchError: !1,
          approvalTransaction: void 0,
          swapTransaction: void 0,
          transactionError: void 0,
          sourceToken: void 0,
          sourceTokenAmount: "",
          sourceTokenPriceInUSD: 0,
          toToken: void 0,
          toTokenAmount: "",
          toTokenPriceInUSD: 0,
          networkPrice: "0",
          networkBalanceInUSD: "0",
          networkTokenSymbol: "",
          inputError: void 0,
          slippage: l.bq.CONVERT_SLIPPAGE_TOLERANCE,
          tokens: void 0,
          popularTokens: void 0,
          suggestedTokens: void 0,
          foundTokens: void 0,
          myTokensWithBalance: void 0,
          tokensPriceMap: {},
          gasFee: "0",
          gasPriceInUSD: 0,
          priceImpact: void 0,
          maxSlippage: void 0,
          providerFee: void 0,
        },
        A = (0, i.sj)(E),
        C = {
          state: A,
          subscribe: (e) => (0, i.Ld)(A, () => e(A)),
          subscribeKey: (e, t) => (0, n.VW)(A, e, t),
          getParams() {
            let e = g.R.state.activeCaipAddress,
              t = g.R.state.activeChain,
              r = c.j.getPlainAddress(e),
              i = g.R.getActiveNetworkTokenAddress(),
              n = y.ConnectorController.getConnectorId(t);
            if (!r) throw Error("No address found to swap the tokens from.");
            let o = !A.toToken?.address || !A.toToken?.decimals,
              l =
                !A.sourceToken?.address ||
                !A.sourceToken?.decimals ||
                !s.C.bigNumber(A.sourceTokenAmount).gt(0),
              u = !A.sourceTokenAmount;
            return {
              networkAddress: i,
              fromAddress: r,
              fromCaipAddress: e,
              sourceTokenAddress: A.sourceToken?.address,
              toTokenAddress: A.toToken?.address,
              toTokenAmount: A.toTokenAmount,
              toTokenDecimals: A.toToken?.decimals,
              sourceTokenAmount: A.sourceTokenAmount,
              sourceTokenDecimals: A.sourceToken?.decimals,
              invalidToToken: o,
              invalidSourceToken: l,
              invalidSourceTokenAmount: u,
              availableToSwap: e && !o && !l && !u,
              isAuthConnector: n === a.b.CONNECTOR_ID.AUTH,
            };
          },
          setSourceToken(e) {
            if (!e) {
              (A.sourceToken = e),
                (A.sourceTokenAmount = ""),
                (A.sourceTokenPriceInUSD = 0);
              return;
            }
            (A.sourceToken = e), this.setTokenPrice(e.address, "sourceToken");
          },
          setSourceTokenAmount(e) {
            A.sourceTokenAmount = e;
          },
          setToToken(e) {
            if (!e) {
              (A.toToken = e),
                (A.toTokenAmount = ""),
                (A.toTokenPriceInUSD = 0);
              return;
            }
            (A.toToken = e), this.setTokenPrice(e.address, "toToken");
          },
          setToTokenAmount(e) {
            A.toTokenAmount = e ? s.C.formatNumberToLocalString(e, 6) : "";
          },
          async setTokenPrice(e, t) {
            let r = A.tokensPriceMap[e] || 0;
            r || ((A.loadingPrices = !0), (r = await this.getAddressPrice(e))),
              "sourceToken" === t
                ? (A.sourceTokenPriceInUSD = r)
                : "toToken" === t && (A.toTokenPriceInUSD = r),
              A.loadingPrices && (A.loadingPrices = !1),
              this.getParams().availableToSwap && this.swapTokens();
          },
          switchTokens() {
            if (A.initializing || !A.initialized) return;
            let e = A.toToken ? { ...A.toToken } : void 0,
              t = A.sourceToken ? { ...A.sourceToken } : void 0,
              r = e && "" === A.toTokenAmount ? "1" : A.toTokenAmount;
            this.setSourceToken(e),
              this.setToToken(t),
              this.setSourceTokenAmount(r),
              this.setToTokenAmount(""),
              this.swapTokens();
          },
          resetState() {
            (A.myTokensWithBalance = E.myTokensWithBalance),
              (A.tokensPriceMap = E.tokensPriceMap),
              (A.initialized = E.initialized),
              (A.sourceToken = E.sourceToken),
              (A.sourceTokenAmount = E.sourceTokenAmount),
              (A.sourceTokenPriceInUSD = E.sourceTokenPriceInUSD),
              (A.toToken = E.toToken),
              (A.toTokenAmount = E.toTokenAmount),
              (A.toTokenPriceInUSD = E.toTokenPriceInUSD),
              (A.networkPrice = E.networkPrice),
              (A.networkTokenSymbol = E.networkTokenSymbol),
              (A.networkBalanceInUSD = E.networkBalanceInUSD),
              (A.inputError = E.inputError);
          },
          resetValues() {
            let { networkAddress: e } = this.getParams(),
              t = A.tokens?.find((t) => t.address === e);
            this.setSourceToken(t), this.setToToken(void 0);
          },
          getApprovalLoadingState: () => A.loadingApprovalTransaction,
          clearError() {
            A.transactionError = void 0;
          },
          async initializeState() {
            if (!A.initializing) {
              if (((A.initializing = !0), !A.initialized))
                try {
                  await this.fetchTokens(), (A.initialized = !0);
                } catch (e) {
                  (A.initialized = !1),
                    v.SnackController.showError("Failed to initialize swap"),
                    b.RouterController.goBack();
                }
              A.initializing = !1;
            }
          },
          async fetchTokens() {
            let { networkAddress: e } = this.getParams();
            await this.getTokenList(),
              await this.getNetworkTokenPrice(),
              await this.getMyTokensWithBalance();
            let t = A.tokens?.find((t) => t.address === e);
            t &&
              ((A.networkTokenSymbol = t.symbol),
              this.setSourceToken(t),
              this.setSourceTokenAmount("1"));
          },
          async getTokenList() {
            let e = await u.n.getTokenList();
            (A.tokens = e),
              (A.popularTokens = e.sort((e, t) =>
                e.symbol < t.symbol ? -1 : e.symbol > t.symbol ? 1 : 0
              )),
              (A.suggestedTokens = e.filter(
                (e) => !!l.bq.SWAP_SUGGESTED_TOKENS.includes(e.symbol),
                {}
              ));
          },
          async getAddressPrice(e) {
            let t = A.tokensPriceMap[e];
            if (t) return t;
            let r = await f.L.fetchTokenPrice({ addresses: [e] }),
              i = r?.fungibles || [],
              n = [...(A.tokens || []), ...(A.myTokensWithBalance || [])],
              s = n?.find((t) => t.address === e)?.symbol,
              a = parseFloat(
                (
                  i.find((e) => e.symbol.toLowerCase() === s?.toLowerCase())
                    ?.price || 0
                ).toString()
              );
            return (A.tokensPriceMap[e] = a), a;
          },
          async getNetworkTokenPrice() {
            let { networkAddress: e } = this.getParams(),
              t = await f.L.fetchTokenPrice({ addresses: [e] }).catch(
                () => (
                  v.SnackController.showError(
                    "Failed to fetch network token price"
                  ),
                  { fungibles: [] }
                )
              ),
              r = t.fungibles?.[0],
              i = r?.price.toString() || "0";
            (A.tokensPriceMap[e] = parseFloat(i)),
              (A.networkTokenSymbol = r?.symbol || ""),
              (A.networkPrice = i);
          },
          async getMyTokensWithBalance(e) {
            let t = await u.n.getMyTokensWithBalance(e);
            t && (await this.getInitialGasPrice(), this.setBalances(t));
          },
          setBalances(e) {
            let { networkAddress: t } = this.getParams(),
              r = g.R.state.activeCaipNetwork;
            if (!r) return;
            let i = e.find((e) => e.address === t);
            e.forEach((e) => {
              A.tokensPriceMap[e.address] = e.price || 0;
            }),
              (A.myTokensWithBalance = e.filter((e) =>
                e.address.startsWith(r.caipNetworkId)
              )),
              (A.networkBalanceInUSD = i
                ? s.C.multiply(i.quantity.numeric, i.price).toString()
                : "0");
          },
          async getInitialGasPrice() {
            let e = await u.n.fetchGasPrice();
            if (!e) return { gasPrice: null, gasPriceInUSD: null };
            if (g.R.state?.activeCaipNetwork?.chainNamespace === "solana")
              return (
                (A.gasFee = e.standard ?? "0"),
                (A.gasPriceInUSD = s.C.multiply(e.standard, A.networkPrice)
                  .div(1e9)
                  .toNumber()),
                {
                  gasPrice: BigInt(A.gasFee),
                  gasPriceInUSD: Number(A.gasPriceInUSD),
                }
              );
            {
              let t = e.standard ?? "0",
                r = BigInt(t),
                i = BigInt(15e4),
                n = h.getGasPriceInUSD(A.networkPrice, i, r);
              return (
                (A.gasFee = t),
                (A.gasPriceInUSD = n),
                { gasPrice: r, gasPriceInUSD: n }
              );
            }
          },
          async swapTokens() {
            let e = d.AccountController.state.address,
              t = A.sourceToken,
              r = A.toToken,
              i = s.C.bigNumber(A.sourceTokenAmount).gt(0);
            if (
              (i || this.setToTokenAmount(""),
              !r || !t || A.loadingPrices || !i)
            )
              return;
            A.loadingQuote = !0;
            let n = s.C.bigNumber(A.sourceTokenAmount)
              .times(10 ** t.decimals)
              .round(0);
            try {
              let i = await f.L.fetchSwapQuote({
                userAddress: e,
                from: t.address,
                to: r.address,
                gasPrice: A.gasFee,
                amount: n.toString(),
              });
              A.loadingQuote = !1;
              let a = i?.quotes?.[0]?.toAmount;
              if (!a) {
                p.AlertController.open(
                  {
                    shortMessage: "Incorrect amount",
                    longMessage: "Please enter a valid amount",
                  },
                  "error"
                );
                return;
              }
              let o = s.C.bigNumber(a)
                .div(10 ** r.decimals)
                .toString();
              this.setToTokenAmount(o),
                this.hasInsufficientToken(A.sourceTokenAmount, t.address)
                  ? (A.inputError = "Insufficient balance")
                  : ((A.inputError = void 0), this.setTransactionDetails());
            } catch (e) {
              (A.loadingQuote = !1), (A.inputError = "Insufficient balance");
            }
          },
          async getTransaction() {
            let { fromCaipAddress: e, availableToSwap: t } = this.getParams(),
              r = A.sourceToken,
              i = A.toToken;
            if (e && t && r && i && !A.loadingQuote)
              try {
                let t;
                return (
                  (A.loadingBuildTransaction = !0),
                  (t = (await u.n.fetchSwapAllowance({
                    userAddress: e,
                    tokenAddress: r.address,
                    sourceTokenAmount: A.sourceTokenAmount,
                    sourceTokenDecimals: r.decimals,
                  }))
                    ? await this.createSwapTransaction()
                    : await this.createAllowanceTransaction()),
                  (A.loadingBuildTransaction = !1),
                  (A.fetchError = !1),
                  t
                );
              } catch (e) {
                b.RouterController.goBack(),
                  v.SnackController.showError("Failed to check allowance"),
                  (A.loadingBuildTransaction = !1),
                  (A.approvalTransaction = void 0),
                  (A.swapTransaction = void 0),
                  (A.fetchError = !0);
                return;
              }
          },
          async createAllowanceTransaction() {
            let {
              fromCaipAddress: e,
              fromAddress: t,
              sourceTokenAddress: r,
              toTokenAddress: i,
            } = this.getParams();
            if (e && i) {
              if (!r)
                throw Error(
                  "createAllowanceTransaction - No source token address found."
                );
              try {
                let n = await f.L.generateApproveCalldata({
                    from: r,
                    to: i,
                    userAddress: e,
                  }),
                  s = await m.ConnectionController.estimateGas({
                    chainNamespace: a.b.CHAIN.EVM,
                    address: t,
                    to: c.j.getPlainAddress(n.tx.to),
                    data: n.tx.data,
                  }),
                  o = {
                    data: n.tx.data,
                    to: c.j.getPlainAddress(n.tx.from),
                    gas: s,
                    gasPrice: BigInt(n.tx.eip155.gasPrice),
                    value: BigInt(n.tx.value),
                    toAmount: A.toTokenAmount,
                  };
                return (
                  (A.swapTransaction = void 0),
                  (A.approvalTransaction = {
                    data: o.data,
                    to: o.to,
                    gas: o.gas ?? BigInt(0),
                    gasPrice: o.gasPrice,
                    value: o.value,
                    toAmount: o.toAmount,
                  }),
                  {
                    data: o.data,
                    to: o.to,
                    gas: o.gas ?? BigInt(0),
                    gasPrice: o.gasPrice,
                    value: o.value,
                    toAmount: o.toAmount,
                  }
                );
              } catch (e) {
                b.RouterController.goBack(),
                  v.SnackController.showError(
                    "Failed to create approval transaction"
                  ),
                  (A.approvalTransaction = void 0),
                  (A.swapTransaction = void 0),
                  (A.fetchError = !0);
                return;
              }
            }
          },
          async createSwapTransaction() {
            let {
                networkAddress: e,
                fromCaipAddress: t,
                sourceTokenAmount: r,
              } = this.getParams(),
              i = A.sourceToken,
              n = A.toToken;
            if (!t || !r || !i || !n) return;
            let s = m.ConnectionController.parseUnits(
              r,
              i.decimals
            )?.toString();
            try {
              let r = await f.L.generateSwapCalldata({
                  userAddress: t,
                  from: i.address,
                  to: n.address,
                  amount: s,
                }),
                a = i.address === e,
                o = BigInt(r.tx.eip155.gas),
                l = BigInt(r.tx.eip155.gasPrice),
                u = {
                  data: r.tx.data,
                  to: c.j.getPlainAddress(r.tx.to),
                  gas: o,
                  gasPrice: l,
                  value: a ? BigInt(s ?? "0") : BigInt("0"),
                  toAmount: A.toTokenAmount,
                };
              return (
                (A.gasPriceInUSD = h.getGasPriceInUSD(A.networkPrice, o, l)),
                (A.approvalTransaction = void 0),
                (A.swapTransaction = u),
                u
              );
            } catch (e) {
              b.RouterController.goBack(),
                v.SnackController.showError("Failed to create transaction"),
                (A.approvalTransaction = void 0),
                (A.swapTransaction = void 0),
                (A.fetchError = !0);
              return;
            }
          },
          async sendTransactionForApproval(e) {
            let { fromAddress: t, isAuthConnector: r } = this.getParams();
            A.loadingApprovalTransaction = !0;
            let i = "Approve limit increase in your wallet";
            r
              ? b.RouterController.pushTransactionStack({
                  view: null,
                  goBack: !0,
                  onSuccess() {
                    v.SnackController.showLoading(i);
                  },
                })
              : v.SnackController.showLoading(i);
            try {
              await m.ConnectionController.sendTransaction({
                address: t,
                to: e.to,
                data: e.data,
                gas: e.gas,
                gasPrice: BigInt(e.gasPrice),
                value: e.value,
                chainNamespace: "eip155",
              }),
                await this.swapTokens(),
                await this.getTransaction(),
                (A.approvalTransaction = void 0),
                (A.loadingApprovalTransaction = !1);
            } catch (e) {
              (A.transactionError = e?.shortMessage),
                (A.loadingApprovalTransaction = !1),
                v.SnackController.showError(
                  e?.shortMessage || "Transaction error"
                ),
                w.X.sendEvent({
                  type: "track",
                  event: "SWAP_APPROVAL_ERROR",
                  properties: {
                    message: e?.shortMessage || e?.message || "Unknown",
                    network: g.R.state.activeCaipNetwork?.caipNetworkId || "",
                    swapFromToken: this.state.sourceToken?.symbol || "",
                    swapToToken: this.state.toToken?.symbol || "",
                    swapFromAmount: this.state.sourceTokenAmount || "",
                    swapToAmount: this.state.toTokenAmount || "",
                    isSmartAccount:
                      d.AccountController.state.preferredAccountType ===
                      o.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                  },
                });
            }
          },
          async sendTransactionForSwap(e) {
            if (!e) return;
            let {
              fromAddress: t,
              toTokenAmount: r,
              isAuthConnector: i,
            } = this.getParams();
            A.loadingTransaction = !0;
            let n = `Swapping ${
                A.sourceToken?.symbol
              } to ${s.C.formatNumberToLocalString(r, 3)} ${A.toToken?.symbol}`,
              a = `Swapped ${
                A.sourceToken?.symbol
              } to ${s.C.formatNumberToLocalString(r, 3)} ${A.toToken?.symbol}`;
            i
              ? b.RouterController.pushTransactionStack({
                  view: "Account",
                  goBack: !1,
                  onSuccess() {
                    v.SnackController.showLoading(n), C.resetState();
                  },
                })
              : v.SnackController.showLoading(
                  "Confirm transaction in your wallet"
                );
            try {
              let r = [A.sourceToken?.address, A.toToken?.address].join(","),
                n = await m.ConnectionController.sendTransaction({
                  address: t,
                  to: e.to,
                  data: e.data,
                  gas: e.gas,
                  gasPrice: BigInt(e.gasPrice),
                  value: e.value,
                  chainNamespace: "eip155",
                });
              return (
                (A.loadingTransaction = !1),
                v.SnackController.showSuccess(a),
                w.X.sendEvent({
                  type: "track",
                  event: "SWAP_SUCCESS",
                  properties: {
                    network: g.R.state.activeCaipNetwork?.caipNetworkId || "",
                    swapFromToken: this.state.sourceToken?.symbol || "",
                    swapToToken: this.state.toToken?.symbol || "",
                    swapFromAmount: this.state.sourceTokenAmount || "",
                    swapToAmount: this.state.toTokenAmount || "",
                    isSmartAccount:
                      d.AccountController.state.preferredAccountType ===
                      o.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                  },
                }),
                C.resetState(),
                i || b.RouterController.replace("Account"),
                C.getMyTokensWithBalance(r),
                n
              );
            } catch (e) {
              (A.transactionError = e?.shortMessage),
                (A.loadingTransaction = !1),
                v.SnackController.showError(
                  e?.shortMessage || "Transaction error"
                ),
                w.X.sendEvent({
                  type: "track",
                  event: "SWAP_ERROR",
                  properties: {
                    message: e?.shortMessage || e?.message || "Unknown",
                    network: g.R.state.activeCaipNetwork?.caipNetworkId || "",
                    swapFromToken: this.state.sourceToken?.symbol || "",
                    swapToToken: this.state.toToken?.symbol || "",
                    swapFromAmount: this.state.sourceTokenAmount || "",
                    swapToAmount: this.state.toTokenAmount || "",
                    isSmartAccount:
                      d.AccountController.state.preferredAccountType ===
                      o.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                  },
                });
              return;
            }
          },
          hasInsufficientToken(e, t) {
            let r = h.isInsufficientSourceTokenForSwap(
              e,
              t,
              A.myTokensWithBalance
            );
            return (
              (d.AccountController.state.preferredAccountType !==
                o.y_.ACCOUNT_TYPES.SMART_ACCOUNT &&
                h.isInsufficientNetworkTokenForGas(
                  A.networkBalanceInUSD,
                  A.gasPriceInUSD
                )) ||
              r
            );
          },
          setTransactionDetails() {
            let { toTokenAddress: e, toTokenDecimals: t } = this.getParams();
            e &&
              t &&
              ((A.gasPriceInUSD = h.getGasPriceInUSD(
                A.networkPrice,
                BigInt(A.gasFee),
                BigInt(15e4)
              )),
              (A.priceImpact = h.getPriceImpact({
                sourceTokenAmount: A.sourceTokenAmount,
                sourceTokenPriceInUSD: A.sourceTokenPriceInUSD,
                toTokenPriceInUSD: A.toTokenPriceInUSD,
                toTokenAmount: A.toTokenAmount,
              })),
              (A.maxSlippage = h.getMaxSlippage(A.slippage, A.toTokenAmount)),
              (A.providerFee = h.getProviderFee(A.sourceTokenAmount)));
          },
        };
    },
    52005: function (e, t, r) {
      "use strict";
      r.d(t, {
        ThemeController: function () {
          return o;
        },
      });
      var i = r(15708),
        n = r(62714),
        s = r(54173);
      let a = (0, i.sj)({
          themeMode: "dark",
          themeVariables: {},
          w3mThemeVariables: void 0,
        }),
        o = {
          state: a,
          subscribe: (e) => (0, i.Ld)(a, () => e(a)),
          setThemeMode(e) {
            a.themeMode = e;
            try {
              let t = s.ConnectorController.getAuthConnector();
              if (t) {
                let r = o.getSnapshot().themeVariables;
                t.provider.syncTheme({
                  themeMode: e,
                  themeVariables: r,
                  w3mThemeVariables: (0, n.t)(r, e),
                });
              }
            } catch {
              console.info("Unable to sync theme to auth connector");
            }
          },
          setThemeVariables(e) {
            a.themeVariables = { ...a.themeVariables, ...e };
            try {
              let e = s.ConnectorController.getAuthConnector();
              if (e) {
                let t = o.getSnapshot().themeVariables;
                e.provider.syncTheme({
                  themeVariables: t,
                  w3mThemeVariables: (0, n.t)(a.themeVariables, a.themeMode),
                });
              }
            } catch {
              console.info("Unable to sync theme to auth connector");
            }
          },
          getSnapshot: () => (0, i.CO)(a),
        };
    },
    70216: function (e, t, r) {
      "use strict";
      r.d(t, {
        s: function () {
          return d;
        },
      });
      var i = r(15708),
        n = r(4786),
        s = r(68584),
        a = r(61704),
        o = r(55372),
        l = r(31929),
        c = r(48415),
        u = r(66909);
      let h = (0, i.sj)({
          transactions: [],
          coinbaseTransactions: {},
          transactionsByYear: {},
          lastNetworkInView: void 0,
          loading: !1,
          empty: !1,
          next: void 0,
        }),
        d = {
          state: h,
          subscribe: (e) => (0, i.Ld)(h, () => e(h)),
          setLastNetworkInView(e) {
            h.lastNetworkInView = e;
          },
          async fetchTransactions(e, t) {
            if (!e)
              throw Error(
                "Transactions can't be fetched without an accountAddress"
              );
            h.loading = !0;
            try {
              let r = await a.L.fetchTransactions({
                  account: e,
                  cursor: h.next,
                  onramp: t,
                  cache: "coinbase" === t ? "no-cache" : void 0,
                  chainId: o.R.state.activeCaipNetwork?.caipNetworkId,
                }),
                i = this.filterSpamTransactions(r.data),
                n = this.filterByConnectedChain(i),
                s = [...h.transactions, ...n];
              (h.loading = !1),
                "coinbase" === t
                  ? (h.coinbaseTransactions =
                      this.groupTransactionsByYearAndMonth(
                        h.coinbaseTransactions,
                        r.data
                      ))
                  : ((h.transactions = s),
                    (h.transactionsByYear =
                      this.groupTransactionsByYearAndMonth(
                        h.transactionsByYear,
                        n
                      ))),
                (h.empty = 0 === s.length),
                (h.next = r.next ? r.next : void 0);
            } catch (t) {
              l.X.sendEvent({
                type: "track",
                event: "ERROR_FETCH_TRANSACTIONS",
                properties: {
                  address: e,
                  projectId: c.OptionsController.state.projectId,
                  cursor: h.next,
                  isSmartAccount:
                    s.AccountController.state.preferredAccountType ===
                    n.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                },
              }),
                u.SnackController.showError("Failed to fetch transactions"),
                (h.loading = !1),
                (h.empty = !0),
                (h.next = void 0);
            }
          },
          groupTransactionsByYearAndMonth: (e = {}, t = []) => (
            t.forEach((t) => {
              let r = new Date(t.metadata.minedAt).getFullYear(),
                i = new Date(t.metadata.minedAt).getMonth(),
                n = e[r] ?? {},
                s = (n[i] ?? []).filter((e) => e.id !== t.id);
              e[r] = {
                ...n,
                [i]: [...s, t].sort(
                  (e, t) =>
                    new Date(t.metadata.minedAt).getTime() -
                    new Date(e.metadata.minedAt).getTime()
                ),
              };
            }),
            e
          ),
          filterSpamTransactions: (e) =>
            e.filter(
              (e) => !e.transfers.every((e) => e.nft_info?.flags.is_spam === !0)
            ),
          filterByConnectedChain(e) {
            let t = o.R.state.activeCaipNetwork?.caipNetworkId;
            return e.filter((e) => e.metadata.chain === t);
          },
          clearCursor() {
            h.next = void 0;
          },
          resetTransactions() {
            (h.transactions = []),
              (h.transactionsByYear = {}),
              (h.lastNetworkInView = void 0),
              (h.loading = !1),
              (h.empty = !1),
              (h.next = void 0);
          },
        };
    },
    63043: function (e, t, r) {
      "use strict";
      r.d(t, {
        f: function () {
          return l;
        },
      });
      var i = r(15708),
        n = r(17766),
        s = r(22472);
      let a = {
          eip155: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
          solana: "a1b58899-f671-4276-6a5e-56ca5bd59700",
          polkadot: "",
          bip122: "0b4838db-0161-4ffe-022d-532bf03dba00",
        },
        o = (0, i.sj)({ networkImagePromises: {} }),
        l = {
          async fetchWalletImage(e) {
            if (e)
              return (
                await n.ApiController._fetchWalletImage(e),
                this.getWalletImageById(e)
              );
          },
          async fetchNetworkImage(e) {
            if (e)
              return (
                this.getNetworkImageById(e) ||
                (o.networkImagePromises[e] ||
                  (o.networkImagePromises[e] =
                    n.ApiController._fetchNetworkImage(e)),
                await o.networkImagePromises[e],
                this.getNetworkImageById(e))
              );
          },
          getWalletImageById(e) {
            if (e) return s.W.state.walletImages[e];
          },
          getWalletImage: (e) =>
            e?.image_url
              ? e?.image_url
              : e?.image_id
              ? s.W.state.walletImages[e.image_id]
              : void 0,
          getNetworkImage: (e) =>
            e?.assets?.imageUrl
              ? e?.assets?.imageUrl
              : e?.assets?.imageId
              ? s.W.state.networkImages[e.assets.imageId]
              : void 0,
          getNetworkImageById(e) {
            if (e) return s.W.state.networkImages[e];
          },
          getConnectorImage: (e) =>
            e?.imageUrl
              ? e.imageUrl
              : e?.imageId
              ? s.W.state.connectorImages[e.imageId]
              : void 0,
          getChainImage: (e) => s.W.state.networkImages[a[e]],
        };
    },
    59712: function (e, t, r) {
      "use strict";
      r.d(t, {
        a$: function () {
          return a;
        },
        bq: function () {
          return o;
        },
        gy: function () {
          return s;
        },
      });
      var i = r(40257);
      let n =
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_ORIGIN
            : void 0) || "https://secure.walletconnect.org",
        s = [
          {
            label: "Coinbase",
            name: "coinbase",
            feeRange: "1-2%",
            url: "",
            supportedChains: ["eip155"],
          },
          {
            label: "Meld.io",
            name: "meld",
            feeRange: "1-2%",
            url: "https://meldcrypto.com",
            supportedChains: ["eip155", "solana"],
          },
        ],
        a = "WXETMuFUQmqqybHuRkSgxv:25B8LJHSfpG6LVjR2ytU5Cwh7Z4Sch2ocoU",
        o = {
          FOUR_MINUTES_MS: 24e4,
          TEN_SEC_MS: 1e4,
          FIVE_SEC_MS: 5e3,
          THREE_SEC_MS: 3e3,
          ONE_SEC_MS: 1e3,
          SECURE_SITE: n,
          SECURE_SITE_DASHBOARD: `${n}/dashboard`,
          SECURE_SITE_FAVICON: `${n}/images/favicon.png`,
          RESTRICTED_TIMEZONES: [
            "ASIA/SHANGHAI",
            "ASIA/URUMQI",
            "ASIA/CHONGQING",
            "ASIA/HARBIN",
            "ASIA/KASHGAR",
            "ASIA/MACAU",
            "ASIA/HONG_KONG",
            "ASIA/MACAO",
            "ASIA/BEIJING",
            "ASIA/HARBIN",
          ],
          WC_COINBASE_PAY_SDK_CHAINS: [
            "ethereum",
            "arbitrum",
            "polygon",
            "berachain",
            "avalanche-c-chain",
            "optimism",
            "celo",
            "base",
          ],
          WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: "ethereum",
          WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
            Ethereum: "ethereum",
            "Arbitrum One": "arbitrum",
            Polygon: "polygon",
            Berachain: "berachain",
            Avalanche: "avalanche-c-chain",
            "OP Mainnet": "optimism",
            Celo: "celo",
            Base: "base",
          },
          WC_COINBASE_ONRAMP_APP_ID: "bf18c88d-495a-463b-b249-0b9d3656cf5e",
          SWAP_SUGGESTED_TOKENS: [
            "ETH",
            "UNI",
            "1INCH",
            "AAVE",
            "SOL",
            "ADA",
            "AVAX",
            "DOT",
            "LINK",
            "NITRO",
            "GAIA",
            "MILK",
            "TRX",
            "NEAR",
            "GNO",
            "WBTC",
            "DAI",
            "WETH",
            "USDC",
            "USDT",
            "ARB",
            "BAL",
            "BICO",
            "CRV",
            "ENS",
            "MATIC",
            "OP",
          ],
          SWAP_POPULAR_TOKENS: [
            "ETH",
            "UNI",
            "1INCH",
            "AAVE",
            "SOL",
            "ADA",
            "AVAX",
            "DOT",
            "LINK",
            "NITRO",
            "GAIA",
            "MILK",
            "TRX",
            "NEAR",
            "GNO",
            "WBTC",
            "DAI",
            "WETH",
            "USDC",
            "USDT",
            "ARB",
            "BAL",
            "BICO",
            "CRV",
            "ENS",
            "MATIC",
            "OP",
            "METAL",
            "DAI",
            "CHAMP",
            "WOLF",
            "SALE",
            "BAL",
            "BUSD",
            "MUST",
            "BTCpx",
            "ROUTE",
            "HEX",
            "WELT",
            "amDAI",
            "VSQ",
            "VISION",
            "AURUM",
            "pSP",
            "SNX",
            "VC",
            "LINK",
            "CHP",
            "amUSDT",
            "SPHERE",
            "FOX",
            "GIDDY",
            "GFC",
            "OMEN",
            "OX_OLD",
            "DE",
            "WNT",
          ],
          BALANCE_SUPPORTED_CHAINS: ["eip155", "solana"],
          SWAP_SUPPORTED_NETWORKS: [
            "eip155:1",
            "eip155:42161",
            "eip155:10",
            "eip155:324",
            "eip155:8453",
            "eip155:56",
            "eip155:137",
            "eip155:100",
            "eip155:43114",
            "eip155:250",
            "eip155:8217",
            "eip155:1313161554",
          ],
          NAMES_SUPPORTED_CHAIN_NAMESPACES: ["eip155"],
          ONRAMP_SUPPORTED_CHAIN_NAMESPACES: ["eip155", "solana"],
          ACTIVITY_ENABLED_CHAIN_NAMESPACES: ["eip155", "solana"],
          NATIVE_TOKEN_ADDRESS: {
            eip155: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
            solana: "So11111111111111111111111111111111111111111",
            polkadot: "0x",
            bip122: "0x",
          },
          CONVERT_SLIPPAGE_TOLERANCE: 1,
          CONNECT_LABELS: { MOBILE: "Open and continue in a new browser tab" },
          DEFAULT_FEATURES: {
            swaps: !0,
            onramp: !0,
            receive: !0,
            send: !0,
            email: !0,
            emailShowWallets: !0,
            socials: [
              "google",
              "x",
              "discord",
              "farcaster",
              "github",
              "apple",
              "facebook",
            ],
            connectorTypeOrder: [
              "walletConnect",
              "recent",
              "injected",
              "featured",
              "custom",
              "external",
              "recommended",
            ],
            history: !0,
            analytics: !0,
            allWallets: !0,
            legalCheckbox: !1,
            smartSessions: !1,
            collapseWallets: !1,
            walletFeaturesOrder: ["onramp", "swaps", "receive", "send"],
            connectMethodsOrder: void 0,
          },
          DEFAULT_ACCOUNT_TYPES: {
            bip122: "payment",
            eip155: "smartAccount",
            polkadot: "eoa",
            solana: "eoa",
          },
          ADAPTER_TYPES: {
            UNIVERSAL: "universal",
            SOLANA: "solana",
            WAGMI: "wagmi",
            ETHERS: "ethers",
            ETHERS5: "ethers5",
            BITCOIN: "bitcoin",
          },
        };
    },
    53357: function (e, t, r) {
      "use strict";
      r.d(t, {
        j: function () {
          return a;
        },
      });
      var i = r(44649),
        n = r(59712),
        s = r(36801);
      let a = {
        isMobile() {
          return (
            !!this.isClient() &&
            !!(
              window?.matchMedia("(pointer:coarse)")?.matches ||
              /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(
                navigator.userAgent
              )
            )
          );
        },
        checkCaipNetwork: (e, t = "") =>
          e?.caipNetworkId.toLocaleLowerCase().includes(t.toLowerCase()),
        isAndroid() {
          if (!this.isMobile()) return !1;
          let e = window?.navigator.userAgent.toLowerCase();
          return a.isMobile() && e.includes("android");
        },
        isIos() {
          if (!this.isMobile()) return !1;
          let e = window?.navigator.userAgent.toLowerCase();
          return e.includes("iphone") || e.includes("ipad");
        },
        isSafari() {
          return (
            !!this.isClient() &&
            window?.navigator.userAgent.toLowerCase().includes("safari")
          );
        },
        isClient: () => "undefined" != typeof window,
        isPairingExpired: (e) => !e || e - Date.now() <= n.bq.TEN_SEC_MS,
        isAllowedRetry: (e, t = n.bq.ONE_SEC_MS) => Date.now() - e >= t,
        copyToClopboard(e) {
          navigator.clipboard.writeText(e);
        },
        isIframe() {
          try {
            return window?.self !== window?.top;
          } catch (e) {
            return !1;
          }
        },
        getPairingExpiry: () => Date.now() + n.bq.FOUR_MINUTES_MS,
        getNetworkId: (e) => e?.split(":")[1],
        getPlainAddress: (e) => e?.split(":")[2],
        wait: async (e) =>
          new Promise((t) => {
            setTimeout(t, e);
          }),
        debounce(e, t = 500) {
          let r;
          return (...i) => {
            r && clearTimeout(r),
              (r = setTimeout(function () {
                e(...i);
              }, t));
          };
        },
        isHttpUrl: (e) => e.startsWith("http://") || e.startsWith("https://"),
        formatNativeUrl(e, t) {
          if (a.isHttpUrl(e)) return this.formatUniversalUrl(e, t);
          let r = e;
          r.includes("://") ||
            ((r = e.replaceAll("/", "").replaceAll(":", "")), (r = `${r}://`)),
            r.endsWith("/") || (r = `${r}/`),
            this.isTelegram() &&
              this.isAndroid() &&
              (t = encodeURIComponent(t));
          let i = encodeURIComponent(t);
          return { redirect: `${r}wc?uri=${i}`, href: r };
        },
        formatUniversalUrl(e, t) {
          if (!a.isHttpUrl(e)) return this.formatNativeUrl(e, t);
          let r = e;
          r.endsWith("/") || (r = `${r}/`);
          let i = encodeURIComponent(t);
          return { redirect: `${r}wc?uri=${i}`, href: r };
        },
        getOpenTargetForPlatform(e) {
          return "popupWindow" === e
            ? e
            : this.isTelegram()
            ? s.M.getTelegramSocialProvider()
              ? "_top"
              : "_blank"
            : e;
        },
        openHref(e, t, r) {
          window?.open(
            e,
            this.getOpenTargetForPlatform(t),
            r || "noreferrer noopener"
          );
        },
        returnOpenHref(e, t, r) {
          return window?.open(
            e,
            this.getOpenTargetForPlatform(t),
            r || "noreferrer noopener"
          );
        },
        isTelegram: () =>
          "undefined" != typeof window &&
          (!!window.TelegramWebviewProxy ||
            !!window.Telegram ||
            !!window.TelegramWebviewProxyProto),
        preloadImage: async (e) =>
          Promise.race([
            new Promise((t, r) => {
              let i = new Image();
              (i.onload = t),
                (i.onerror = r),
                (i.crossOrigin = "anonymous"),
                (i.src = e);
            }),
            a.wait(2e3),
          ]),
        formatBalance(e, t) {
          let r = "0.000";
          if ("string" == typeof e) {
            let t = Number(e);
            if (t) {
              let e = Math.floor(1e3 * t) / 1e3;
              e && (r = e.toString());
            }
          }
          return `${r}${t ? ` ${t}` : ""}`;
        },
        formatBalance2(e, t) {
          let r;
          if ("0" === e) r = "0";
          else if ("string" == typeof e) {
            let t = Number(e);
            t && (r = t.toString().match(/^-?\d+(?:\.\d{0,3})?/u)?.[0]);
          }
          return { value: r ?? "0", rest: "0" === r ? "000" : "", symbol: t };
        },
        getApiUrl: () => i.b.W3M_API_URL,
        getBlockchainApiUrl: () => i.b.BLOCKCHAIN_API_RPC_URL,
        getAnalyticsUrl: () => i.b.PULSE_API_URL,
        getUUID: () =>
          crypto?.randomUUID
            ? crypto.randomUUID()
            : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
                let t = (16 * Math.random()) | 0;
                return ("x" === e ? t : (3 & t) | 8).toString(16);
              }),
        parseError: (e) =>
          "string" == typeof e
            ? e
            : "string" == typeof e?.issues?.[0]?.message
            ? e.issues[0].message
            : e instanceof Error
            ? e.message
            : "Unknown error",
        sortRequestedNetworks(e, t = []) {
          let r = {};
          return (
            t &&
              e &&
              (e.forEach((e, t) => {
                r[e] = t;
              }),
              t.sort((e, t) => {
                let i = r[e.id],
                  n = r[t.id];
                return void 0 !== i && void 0 !== n
                  ? i - n
                  : void 0 !== i
                  ? -1
                  : void 0 !== n
                  ? 1
                  : 0;
              })),
            t
          );
        },
        calculateBalance(e) {
          let t = 0;
          for (let r of e) t += r.value ?? 0;
          return t;
        },
        formatTokenBalance(e) {
          let [t, r] = e.toFixed(2).split(".");
          return { dollars: t, pennies: r };
        },
        isAddress(e, t = "eip155") {
          switch (t) {
            case "eip155":
              if (
                /^(?:0x)?[0-9a-f]{40}$/iu.test(e) &&
                (/^(?:0x)?[0-9a-f]{40}$/iu.test(e) ||
                  /^(?:0x)?[0-9A-F]{40}$/iu.test(e))
              )
                return !0;
              return !1;
            case "solana":
              return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(e);
            default:
              return !1;
          }
        },
        uniqueBy(e, t) {
          let r = new Set();
          return e.filter((e) => {
            let i = e[t];
            return !r.has(i) && (r.add(i), !0);
          });
        },
        generateSdkVersion(e, t, r) {
          let i =
            0 === e.length
              ? n.bq.ADAPTER_TYPES.UNIVERSAL
              : e.map((e) => e.adapterType).join(",");
          return `${t}-${i}-${r}`;
        },
        createAccount: (e, t, r, i, n) => ({
          namespace: e,
          address: t,
          type: r,
          publicKey: i,
          path: n,
        }),
        isCaipAddress(e) {
          if ("string" != typeof e) return !1;
          let t = e.split(":"),
            r = t[0];
          return 3 === t.filter(Boolean).length && r in i.b.CHAIN_NAME_MAP;
        },
        isMac() {
          let e = window?.navigator.userAgent.toLowerCase();
          return e.includes("macintosh") && !e.includes("safari");
        },
        formatTelegramSocialLoginUrl(e) {
          let t = `--${encodeURIComponent(window?.location.href)}`,
            r = "state=";
          if ("auth.magic.link" === new URL(e).host) {
            let i = "provider_authorization_url=",
              n = e.substring(e.indexOf(i) + i.length),
              s = this.injectIntoUrl(decodeURIComponent(n), r, t);
            return e.replace(n, encodeURIComponent(s));
          }
          return this.injectIntoUrl(e, r, t);
        },
        injectIntoUrl(e, t, r) {
          let i = e.indexOf(t);
          if (-1 === i)
            throw Error(`${t} parameter not found in the URL: ${e}`);
          let n = e.indexOf("&", i),
            s = t.length,
            a = -1 !== n ? n : e.length,
            o = e.substring(0, i + s);
          return o + (e.substring(i + s, a) + r) + e.substring(n);
        },
      };
    },
    39905: function (e, t, r) {
      "use strict";
      async function i(...e) {
        let t = await fetch(...e);
        if (!t.ok) throw Error(`HTTP status code: ${t.status}`, { cause: t });
        return t;
      }
      r.d(t, {
        V: function () {
          return n;
        },
      });
      class n {
        constructor({ baseUrl: e, clientId: t }) {
          (this.baseUrl = e), (this.clientId = t);
        }
        async get({ headers: e, signal: t, cache: r, ...n }) {
          let s = this.createUrl(n);
          return (
            await i(s, { method: "GET", headers: e, signal: t, cache: r })
          ).json();
        }
        async getBlob({ headers: e, signal: t, ...r }) {
          let n = this.createUrl(r);
          return (await i(n, { method: "GET", headers: e, signal: t })).blob();
        }
        async post({ body: e, headers: t, signal: r, ...n }) {
          let s = this.createUrl(n);
          return (
            await i(s, {
              method: "POST",
              headers: t,
              body: e ? JSON.stringify(e) : void 0,
              signal: r,
            })
          ).json();
        }
        async put({ body: e, headers: t, signal: r, ...n }) {
          let s = this.createUrl(n);
          return (
            await i(s, {
              method: "PUT",
              headers: t,
              body: e ? JSON.stringify(e) : void 0,
              signal: r,
            })
          ).json();
        }
        async delete({ body: e, headers: t, signal: r, ...n }) {
          let s = this.createUrl(n);
          return (
            await i(s, {
              method: "DELETE",
              headers: t,
              body: e ? JSON.stringify(e) : void 0,
              signal: r,
            })
          ).json();
        }
        createUrl({ path: e, params: t }) {
          let r = new URL(e, this.baseUrl);
          return (
            t &&
              Object.entries(t).forEach(([e, t]) => {
                t && r.searchParams.append(e, t);
              }),
            this.clientId && r.searchParams.append("clientId", this.clientId),
            r
          );
        }
      }
    },
    60389: function (e, t, r) {
      "use strict";
      r.d(t, {
        w: function () {
          return g;
        },
      }),
        r(76356);
      var i = r(44649),
        n = r(4786),
        s = r(68584),
        a = r(55372),
        o = r(21278),
        l = r(54173),
        c = r(31929),
        u = r(89512),
        h = r(48415),
        d = r(86777),
        p = r(66909),
        f = r(53357);
      let g = {
        getSIWX: () => h.OptionsController.state.siwx,
        async initializeIfEnabled() {
          let e = h.OptionsController.state.siwx,
            t = a.R.getActiveCaipAddress();
          if (!(e && t)) return;
          let [r, i, n] = t.split(":");
          if (a.R.checkIfSupportedNetwork(r))
            try {
              if ((await e.getSessions(`${r}:${i}`, n)).length) return;
              await u.I.open({ view: "SIWXSignMessage" });
            } catch (e) {
              console.error("SIWXUtil:initializeIfEnabled", e),
                c.X.sendEvent({
                  type: "track",
                  event: "SIWX_AUTH_ERROR",
                  properties: this.getSIWXEventProperties(),
                }),
                await o.ConnectionController._getClient()
                  ?.disconnect()
                  .catch(console.error),
                d.RouterController.reset("Connect"),
                p.SnackController.showError(
                  "A problem occurred while trying initialize authentication"
                );
            }
        },
        async requestSignMessage() {
          let e = h.OptionsController.state.siwx,
            t = f.j.getPlainAddress(a.R.getActiveCaipAddress()),
            r = a.R.getActiveCaipNetwork(),
            n = o.ConnectionController._getClient();
          if (!e) throw Error("SIWX is not enabled");
          if (!t) throw Error("No ActiveCaipAddress found");
          if (!r) throw Error("No ActiveCaipNetwork or client found");
          if (!n) throw Error("No ConnectionController client found");
          try {
            let s = await e.createMessage({
                chainId: r.caipNetworkId,
                accountAddress: t,
              }),
              a = s.toString();
            l.ConnectorController.getConnectorId(r.chainNamespace) ===
              i.b.CONNECTOR_ID.AUTH &&
              d.RouterController.pushTransactionStack({
                view: null,
                goBack: !1,
                replace: !0,
              });
            let o = await n.signMessage(a);
            await e.addSession({ data: s, message: a, signature: o }),
              u.I.close(),
              c.X.sendEvent({
                type: "track",
                event: "SIWX_AUTH_SUCCESS",
                properties: this.getSIWXEventProperties(),
              });
          } catch (t) {
            let e = this.getSIWXEventProperties();
            (u.I.state.open &&
              "ApproveTransaction" !== d.RouterController.state.view) ||
              (await u.I.open({ view: "SIWXSignMessage" })),
              e.isSmartAccount
                ? p.SnackController.showError(
                    "This application might not support Smart Accounts"
                  )
                : p.SnackController.showError("Signature declined"),
              c.X.sendEvent({
                type: "track",
                event: "SIWX_AUTH_ERROR",
                properties: e,
              }),
              console.error("SWIXUtil:requestSignMessage", t);
          }
        },
        async cancelSignMessage() {
          try {
            let e = this.getSIWX();
            e?.getRequired?.()
              ? await o.ConnectionController.disconnect()
              : u.I.close(),
              d.RouterController.reset("Connect"),
              c.X.sendEvent({
                event: "CLICK_CANCEL_SIWX",
                type: "track",
                properties: this.getSIWXEventProperties(),
              });
          } catch (e) {
            console.error("SIWXUtil:cancelSignMessage", e);
          }
        },
        async getSessions() {
          let e = h.OptionsController.state.siwx,
            t = f.j.getPlainAddress(a.R.getActiveCaipAddress()),
            r = a.R.getActiveCaipNetwork();
          return e && t && r ? e.getSessions(r.caipNetworkId, t) : [];
        },
        async isSIWXCloseDisabled() {
          let e = this.getSIWX();
          if (e) {
            let t = "ApproveTransaction" === d.RouterController.state.view,
              r = "SIWXSignMessage" === d.RouterController.state.view;
            if (t || r)
              return (
                e.getRequired?.() && 0 === (await this.getSessions()).length
              );
          }
          return !1;
        },
        async universalProviderAuthenticate({
          universalProvider: e,
          chains: t,
          methods: r,
        }) {
          let i = g.getSIWX(),
            n = new Set(t.map((e) => e.split(":")[0]));
          if (!i || 1 !== n.size || !n.has("eip155")) return !1;
          let o = await i.createMessage({
              chainId: a.R.getActiveCaipNetwork()?.caipNetworkId || "",
              accountAddress: "",
            }),
            l = await e.authenticate({
              nonce: o.nonce,
              domain: o.domain,
              uri: o.uri,
              exp: o.expirationTime,
              iat: o.issuedAt,
              nbf: o.notBefore,
              requestId: o.requestId,
              version: o.version,
              resources: o.resources,
              statement: o.statement,
              chainId: o.chainId,
              methods: r,
              chains: [o.chainId, ...t.filter((e) => e !== o.chainId)],
            });
          if (
            (p.SnackController.showLoading("Authenticating...", {
              autoClose: !1,
            }),
            s.AccountController.setConnectedWalletInfo(
              {
                ...l.session.peer.metadata,
                name: l.session.peer.metadata.name,
                icon: l.session.peer.metadata.icons?.[0],
                type: "WALLET_CONNECT",
              },
              Array.from(n)[0]
            ),
            l?.auths?.length)
          ) {
            let t = l.auths.map((t) => {
              let r = e.client.formatAuthMessage({
                request: t.p,
                iss: t.p.iss,
              });
              return {
                data: {
                  ...t.p,
                  accountAddress: t.p.iss.split(":").slice(-1).join(""),
                  chainId: t.p.iss.split(":").slice(2, 4).join(":"),
                  uri: t.p.aud,
                  version: t.p.version || o.version,
                  expirationTime: t.p.exp,
                  issuedAt: t.p.iat,
                  notBefore: t.p.nbf,
                },
                message: r,
                signature: t.s.s,
                cacao: t,
              };
            });
            try {
              await i.setSessions(t),
                c.X.sendEvent({
                  type: "track",
                  event: "SIWX_AUTH_SUCCESS",
                  properties: g.getSIWXEventProperties(),
                });
            } catch (t) {
              throw (
                (console.error(
                  "SIWX:universalProviderAuth - failed to set sessions",
                  t
                ),
                c.X.sendEvent({
                  type: "track",
                  event: "SIWX_AUTH_ERROR",
                  properties: g.getSIWXEventProperties(),
                }),
                await e.disconnect().catch(console.error),
                t)
              );
            } finally {
              p.SnackController.hide();
            }
          }
          return !0;
        },
        getSIWXEventProperties: () => ({
          network: a.R.state.activeCaipNetwork?.caipNetworkId || "",
          isSmartAccount:
            s.AccountController.state.preferredAccountType ===
            n.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
        }),
        async clearSessions() {
          let e = this.getSIWX();
          e && (await e.setSessions([]));
        },
      };
    },
    36801: function (e, t, r) {
      "use strict";
      r.d(t, {
        M: function () {
          return n;
        },
      });
      var i = r(61616);
      let n = {
        cacheExpiry: {
          portfolio: 3e4,
          nativeBalance: 3e4,
          ens: 3e5,
          identity: 3e5,
        },
        isCacheExpired: (e, t) => Date.now() - e > t,
        getActiveNetworkProps() {
          let e = n.getActiveNamespace(),
            t = n.getActiveCaipNetworkId(),
            r = t ? t.split(":")[1] : void 0;
          return {
            namespace: e,
            caipNetworkId: t,
            chainId: r ? (isNaN(Number(r)) ? r : Number(r)) : void 0,
          };
        },
        setWalletConnectDeepLink({ name: e, href: t }) {
          try {
            i.mr.setItem(
              i.uJ.DEEPLINK_CHOICE,
              JSON.stringify({ href: t, name: e })
            );
          } catch {
            console.info("Unable to set WalletConnect deep link");
          }
        },
        getWalletConnectDeepLink() {
          try {
            let e = i.mr.getItem(i.uJ.DEEPLINK_CHOICE);
            if (e) return JSON.parse(e);
          } catch {
            console.info("Unable to get WalletConnect deep link");
          }
        },
        deleteWalletConnectDeepLink() {
          try {
            i.mr.removeItem(i.uJ.DEEPLINK_CHOICE);
          } catch {
            console.info("Unable to delete WalletConnect deep link");
          }
        },
        setActiveNamespace(e) {
          try {
            i.mr.setItem(i.uJ.ACTIVE_NAMESPACE, e);
          } catch {
            console.info("Unable to set active namespace");
          }
        },
        setActiveCaipNetworkId(e) {
          try {
            i.mr.setItem(i.uJ.ACTIVE_CAIP_NETWORK_ID, e),
              n.setActiveNamespace(e.split(":")[0]);
          } catch {
            console.info("Unable to set active caip network id");
          }
        },
        getActiveCaipNetworkId() {
          try {
            return i.mr.getItem(i.uJ.ACTIVE_CAIP_NETWORK_ID);
          } catch {
            console.info("Unable to get active caip network id");
            return;
          }
        },
        deleteActiveCaipNetworkId() {
          try {
            i.mr.removeItem(i.uJ.ACTIVE_CAIP_NETWORK_ID);
          } catch {
            console.info("Unable to delete active caip network id");
          }
        },
        deleteConnectedConnectorId(e) {
          try {
            let t = (0, i.Vk)(e);
            i.mr.removeItem(t);
          } catch {
            console.info("Unable to delete connected connector id");
          }
        },
        setAppKitRecent(e) {
          try {
            let t = n.getRecentWallets();
            t.find((t) => t.id === e.id) ||
              (t.unshift(e),
              t.length > 2 && t.pop(),
              i.mr.setItem(i.uJ.RECENT_WALLETS, JSON.stringify(t)));
          } catch {
            console.info("Unable to set AppKit recent");
          }
        },
        getRecentWallets() {
          try {
            let e = i.mr.getItem(i.uJ.RECENT_WALLETS);
            return e ? JSON.parse(e) : [];
          } catch {
            console.info("Unable to get AppKit recent");
          }
          return [];
        },
        setConnectedConnectorId(e, t) {
          try {
            let r = (0, i.Vk)(e);
            i.mr.setItem(r, t);
          } catch {
            console.info("Unable to set Connected Connector Id");
          }
        },
        getActiveNamespace() {
          try {
            return i.mr.getItem(i.uJ.ACTIVE_NAMESPACE);
          } catch {
            console.info("Unable to get active namespace");
          }
        },
        getConnectedConnectorId(e) {
          if (e)
            try {
              let t = (0, i.Vk)(e);
              return i.mr.getItem(t);
            } catch (t) {
              console.info(
                "Unable to get connected connector id in namespace ",
                e
              );
            }
        },
        setConnectedSocialProvider(e) {
          try {
            i.mr.setItem(i.uJ.CONNECTED_SOCIAL, e);
          } catch {
            console.info("Unable to set connected social provider");
          }
        },
        getConnectedSocialProvider() {
          try {
            return i.mr.getItem(i.uJ.CONNECTED_SOCIAL);
          } catch {
            console.info("Unable to get connected social provider");
          }
        },
        deleteConnectedSocialProvider() {
          try {
            i.mr.removeItem(i.uJ.CONNECTED_SOCIAL);
          } catch {
            console.info("Unable to delete connected social provider");
          }
        },
        getConnectedSocialUsername() {
          try {
            return i.mr.getItem(i.uJ.CONNECTED_SOCIAL_USERNAME);
          } catch {
            console.info("Unable to get connected social username");
          }
        },
        getStoredActiveCaipNetworkId() {
          let e = i.mr.getItem(i.uJ.ACTIVE_CAIP_NETWORK_ID);
          return e?.split(":")?.[1];
        },
        setConnectionStatus(e) {
          try {
            i.mr.setItem(i.uJ.CONNECTION_STATUS, e);
          } catch {
            console.info("Unable to set connection status");
          }
        },
        getConnectionStatus() {
          try {
            return i.mr.getItem(i.uJ.CONNECTION_STATUS);
          } catch {
            return;
          }
        },
        getConnectedNamespaces() {
          try {
            let e = i.mr.getItem(i.uJ.CONNECTED_NAMESPACES);
            if (!e?.length) return [];
            return e.split(",");
          } catch {
            return [];
          }
        },
        setConnectedNamespaces(e) {
          try {
            let t = Array.from(new Set(e));
            i.mr.setItem(i.uJ.CONNECTED_NAMESPACES, t.join(","));
          } catch {
            console.info("Unable to set namespaces in storage");
          }
        },
        addConnectedNamespace(e) {
          try {
            let t = n.getConnectedNamespaces();
            t.includes(e) || (t.push(e), n.setConnectedNamespaces(t));
          } catch {
            console.info("Unable to add connected namespace");
          }
        },
        removeConnectedNamespace(e) {
          try {
            let t = n.getConnectedNamespaces(),
              r = t.indexOf(e);
            r > -1 && (t.splice(r, 1), n.setConnectedNamespaces(t));
          } catch {
            console.info("Unable to remove connected namespace");
          }
        },
        getTelegramSocialProvider() {
          try {
            return i.mr.getItem(i.uJ.TELEGRAM_SOCIAL_PROVIDER);
          } catch {
            return console.info("Unable to get telegram social provider"), null;
          }
        },
        setTelegramSocialProvider(e) {
          try {
            i.mr.setItem(i.uJ.TELEGRAM_SOCIAL_PROVIDER, e);
          } catch {
            console.info("Unable to set telegram social provider");
          }
        },
        removeTelegramSocialProvider() {
          try {
            i.mr.removeItem(i.uJ.TELEGRAM_SOCIAL_PROVIDER);
          } catch {
            console.info("Unable to remove telegram social provider");
          }
        },
        getBalanceCache() {
          let e = {};
          try {
            let t = i.mr.getItem(i.uJ.PORTFOLIO_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info("Unable to get balance cache");
          }
          return e;
        },
        removeAddressFromBalanceCache(e) {
          try {
            let t = n.getBalanceCache();
            i.mr.setItem(
              i.uJ.PORTFOLIO_CACHE,
              JSON.stringify({ ...t, [e]: void 0 })
            );
          } catch {
            console.info("Unable to remove address from balance cache", e);
          }
        },
        getBalanceCacheForCaipAddress(e) {
          try {
            let t = n.getBalanceCache()[e];
            if (
              t &&
              !this.isCacheExpired(t.timestamp, this.cacheExpiry.portfolio)
            )
              return t.balance;
            n.removeAddressFromBalanceCache(e);
          } catch {
            console.info("Unable to get balance cache for address", e);
          }
        },
        updateBalanceCache(e) {
          try {
            let t = n.getBalanceCache();
            (t[e.caipAddress] = e),
              i.mr.setItem(i.uJ.PORTFOLIO_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update balance cache", e);
          }
        },
        getNativeBalanceCache() {
          let e = {};
          try {
            let t = i.mr.getItem(i.uJ.NATIVE_BALANCE_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info("Unable to get balance cache");
          }
          return e;
        },
        removeAddressFromNativeBalanceCache(e) {
          try {
            let t = n.getBalanceCache();
            i.mr.setItem(
              i.uJ.NATIVE_BALANCE_CACHE,
              JSON.stringify({ ...t, [e]: void 0 })
            );
          } catch {
            console.info("Unable to remove address from balance cache", e);
          }
        },
        getNativeBalanceCacheForCaipAddress(e) {
          try {
            let t = n.getNativeBalanceCache()[e];
            if (
              t &&
              !this.isCacheExpired(t.timestamp, this.cacheExpiry.nativeBalance)
            )
              return t;
            console.info("Discarding cache for address", e),
              n.removeAddressFromBalanceCache(e);
          } catch {
            console.info("Unable to get balance cache for address", e);
          }
        },
        updateNativeBalanceCache(e) {
          try {
            let t = n.getNativeBalanceCache();
            (t[e.caipAddress] = e),
              i.mr.setItem(i.uJ.NATIVE_BALANCE_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update balance cache", e);
          }
        },
        getEnsCache() {
          let e = {};
          try {
            let t = i.mr.getItem(i.uJ.ENS_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info("Unable to get ens name cache");
          }
          return e;
        },
        getEnsFromCacheForAddress(e) {
          try {
            let t = n.getEnsCache()[e];
            if (t && !this.isCacheExpired(t.timestamp, this.cacheExpiry.ens))
              return t.ens;
            n.removeEnsFromCache(e);
          } catch {
            console.info("Unable to get ens name from cache", e);
          }
        },
        updateEnsCache(e) {
          try {
            let t = n.getEnsCache();
            (t[e.address] = e), i.mr.setItem(i.uJ.ENS_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update ens name cache", e);
          }
        },
        removeEnsFromCache(e) {
          try {
            let t = n.getEnsCache();
            i.mr.setItem(i.uJ.ENS_CACHE, JSON.stringify({ ...t, [e]: void 0 }));
          } catch {
            console.info("Unable to remove ens name from cache", e);
          }
        },
        getIdentityCache() {
          let e = {};
          try {
            let t = i.mr.getItem(i.uJ.IDENTITY_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info("Unable to get identity cache");
          }
          return e;
        },
        getIdentityFromCacheForAddress(e) {
          try {
            let t = n.getIdentityCache()[e];
            if (
              t &&
              !this.isCacheExpired(t.timestamp, this.cacheExpiry.identity)
            )
              return t.identity;
            n.removeIdentityFromCache(e);
          } catch {
            console.info("Unable to get identity from cache", e);
          }
        },
        updateIdentityCache(e) {
          try {
            let t = n.getIdentityCache();
            (t[e.address] = { identity: e.identity, timestamp: e.timestamp }),
              i.mr.setItem(i.uJ.IDENTITY_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update identity cache", e);
          }
        },
        removeIdentityFromCache(e) {
          try {
            let t = n.getIdentityCache();
            i.mr.setItem(
              i.uJ.IDENTITY_CACHE,
              JSON.stringify({ ...t, [e]: void 0 })
            );
          } catch {
            console.info("Unable to remove identity from cache", e);
          }
        },
        clearAddressCache() {
          try {
            i.mr.removeItem(i.uJ.PORTFOLIO_CACHE),
              i.mr.removeItem(i.uJ.NATIVE_BALANCE_CACHE),
              i.mr.removeItem(i.uJ.ENS_CACHE),
              i.mr.removeItem(i.uJ.IDENTITY_CACHE);
          } catch {
            console.info("Unable to clear address cache");
          }
        },
      };
    },
    87280: function (e, t, r) {
      "use strict";
      r.d(t, {
        n: function () {
          return o;
        },
      });
      var i = r(68584),
        n = r(61704),
        s = r(55372),
        a = r(21278);
      let o = {
        async getTokenList() {
          let e = s.R.state.activeCaipNetwork,
            t = await n.L.fetchSwapTokens({ chainId: e?.caipNetworkId });
          return (
            t?.tokens?.map((e) => ({
              ...e,
              eip2612: !1,
              quantity: { decimals: "0", numeric: "0" },
              price: 0,
              value: 0,
            })) || []
          );
        },
        async fetchGasPrice() {
          let e = s.R.state.activeCaipNetwork;
          if (!e) return null;
          try {
            if ("solana" === e.chainNamespace) {
              let e = (
                await a.ConnectionController?.estimateGas({
                  chainNamespace: "solana",
                })
              )?.toString();
              return { standard: e, fast: e, instant: e };
            }
            return await n.L.fetchGasPrice({ chainId: e.caipNetworkId });
          } catch {
            return null;
          }
        },
        async fetchSwapAllowance({
          tokenAddress: e,
          userAddress: t,
          sourceTokenAmount: r,
          sourceTokenDecimals: i,
        }) {
          let s = await n.L.fetchSwapAllowance({
            tokenAddress: e,
            userAddress: t,
          });
          if (s?.allowance && r && i) {
            let e = a.ConnectionController.parseUnits(r, i) || 0;
            return BigInt(s.allowance) >= e;
          }
          return !1;
        },
        async getMyTokensWithBalance(e) {
          let t = i.AccountController.state.address,
            r = s.R.state.activeCaipNetwork;
          if (!t || !r) return [];
          let a = (await n.L.getBalance(t, r.caipNetworkId, e)).balances.filter(
            (e) => "0" !== e.quantity.decimals
          );
          return (
            i.AccountController.setTokenBalance(a, s.R.state.activeChain),
            this.mapBalancesToSwapTokens(a)
          );
        },
        mapBalancesToSwapTokens: (e) =>
          e?.map((e) => ({
            ...e,
            address: e?.address
              ? e.address
              : s.R.getActiveNetworkTokenAddress(),
            decimals: parseInt(e.quantity.decimals, 10),
            logoUri: e.iconUrl,
            eip2612: !1,
          })) || [],
      };
    },
    46773: function (e, t, r) {
      "use strict";
      r.d(t, {
        C: function () {
          return d;
        },
      });
      var i = r(44649),
        n = r(48415),
        s = r(36801),
        a = r(53357),
        o = r(21278),
        l = r(17766),
        c = r(55372),
        u = r(54173),
        h = r(70768);
      let d = {
        getConnectorsByType(e, t, r) {
          let { customWallets: i } = n.OptionsController.state,
            a = s.M.getRecentWallets(),
            o = h.J.filterOutDuplicateWallets(t),
            l = h.J.filterOutDuplicateWallets(r),
            c = e.filter((e) => "MULTI_CHAIN" === e.type),
            u = e.filter((e) => "ANNOUNCED" === e.type),
            d = e.filter((e) => "INJECTED" === e.type);
          return {
            custom: i,
            recent: a,
            external: e.filter((e) => "EXTERNAL" === e.type),
            multiChain: c,
            announced: u,
            injected: d,
            recommended: o,
            featured: l,
          };
        },
        showConnector(e) {
          if ("INJECTED" === e.type) {
            if (!a.j.isMobile() && "Browser Wallet" === e.name) return !1;
            let t = e.info?.rdns;
            if (
              (!t && !o.ConnectionController.checkInstalled()) ||
              (t &&
                l.ApiController.state.excludedRDNS &&
                l.ApiController.state.excludedRDNS.includes(t))
            )
              return !1;
          }
          if ("ANNOUNCED" === e.type) {
            let t = e.info?.rdns;
            if (t && l.ApiController.state.excludedRDNS.includes(t)) return !1;
          }
          return !0;
        },
        getIsConnectedWithWC: () =>
          Array.from(c.R.state.chains.values()).some(
            (e) =>
              u.ConnectorController.getConnectorId(e.namespace) ===
              i.b.CONNECTOR_ID.WALLET_CONNECT
          ),
        getConnectorTypeOrder({
          recommended: e,
          featured: t,
          custom: r,
          recent: i,
          announced: s,
          injected: a,
          multiChain: o,
          external: l,
          overriddenConnectors: c = n.OptionsController.state.features
            ?.connectorTypeOrder ?? [],
        }) {
          let u = d.getIsConnectedWithWC(),
            h = [
              {
                type: "walletConnect",
                isEnabled: n.OptionsController.state.enableWalletConnect && !u,
              },
              { type: "recent", isEnabled: i.length > 0 },
              { type: "injected", isEnabled: [...a, ...s, ...o].length > 0 },
              { type: "featured", isEnabled: t.length > 0 },
              { type: "custom", isEnabled: r && r.length > 0 },
              { type: "external", isEnabled: l.length > 0 },
              { type: "recommended", isEnabled: e.length > 0 },
            ].filter((e) => e.isEnabled),
            p = new Set(h.map((e) => e.type)),
            f = c
              .filter((e) => p.has(e))
              .map((e) => ({ type: e, isEnabled: !0 })),
            g = h.filter(({ type: e }) => !f.some(({ type: t }) => t === e));
          return Array.from(new Set([...f, ...g].map(({ type: e }) => e)));
        },
      };
    },
    54946: function (e, t, r) {
      "use strict";
      r.d(t, {
        b: function () {
          return n;
        },
      });
      var i = r(40257);
      let n = {
        ACCOUNT_TABS: [
          { label: "Tokens" },
          { label: "NFTs" },
          { label: "Activity" },
        ],
        SECURE_SITE_ORIGIN:
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_ORIGIN
            : void 0) || "https://secure.walletconnect.org",
        VIEW_DIRECTION: { Next: "next", Prev: "prev" },
        DEFAULT_CONNECT_METHOD_ORDER: ["email", "social", "wallet"],
        ANIMATION_DURATIONS: {
          HeaderText: 120,
          ModalHeight: 150,
          ViewTransition: 150,
        },
      };
    },
    70768: function (e, t, r) {
      "use strict";
      r.d(t, {
        J: function () {
          return u;
        },
      });
      var i = r(48415),
        n = r(54173),
        s = r(36801),
        a = r(53357),
        o = r(17766),
        l = r(46773),
        c = r(54946);
      let u = {
        filterOutDuplicatesByRDNS(e) {
          let t = i.OptionsController.state.enableEIP6963
              ? n.ConnectorController.state.connectors
              : [],
            r = s.M.getRecentWallets(),
            o = t.map((e) => e.info?.rdns).filter(Boolean),
            l = r.map((e) => e.rdns).filter(Boolean),
            c = o.concat(l);
          if (c.includes("io.metamask.mobile") && a.j.isMobile()) {
            let e = c.indexOf("io.metamask.mobile");
            c[e] = "io.metamask";
          }
          return e.filter((e) => !c.includes(String(e?.rdns)));
        },
        filterOutDuplicatesByIds(e) {
          let t = n.ConnectorController.state.connectors.filter(
              (e) => "ANNOUNCED" === e.type || "INJECTED" === e.type
            ),
            r = s.M.getRecentWallets(),
            i = t.map((e) => e.explorerId),
            a = r.map((e) => e.id),
            o = i.concat(a);
          return e.filter((e) => !o.includes(e?.id));
        },
        filterOutDuplicateWallets(e) {
          let t = this.filterOutDuplicatesByRDNS(e);
          return this.filterOutDuplicatesByIds(t);
        },
        markWalletsAsInstalled(e) {
          let { connectors: t } = n.ConnectorController.state,
            r = t
              .filter((e) => "ANNOUNCED" === e.type)
              .reduce((e, t) => (t.info?.rdns && (e[t.info.rdns] = !0), e), {});
          return e
            .map((e) => ({ ...e, installed: !!e.rdns && !!r[e.rdns ?? ""] }))
            .sort((e, t) => Number(t.installed) - Number(e.installed));
        },
        getConnectOrderMethod(e, t) {
          let r =
              e?.connectMethodsOrder ||
              i.OptionsController.state.features?.connectMethodsOrder,
            s = t || n.ConnectorController.state.connectors;
          if (r) return r;
          let { injected: a, announced: u } = l.C.getConnectorsByType(
              s,
              o.ApiController.state.recommended,
              o.ApiController.state.featured
            ),
            h = a.filter(l.C.showConnector),
            d = u.filter(l.C.showConnector);
          return h.length || d.length
            ? ["wallet", "email", "social"]
            : c.b.DEFAULT_CONNECT_METHOD_ORDER;
        },
      };
    },
    92413: function (e, t, r) {
      "use strict";
      r.d(t, {
        kj: function () {
          return i;
        },
        AI: function () {
          return c;
        },
        Hg: function () {
          return s.H;
        },
        Mo: function () {
          return u.M;
        },
        n: function () {
          return n.n;
        },
        Hs: function () {
          return n.Hs;
        },
        R: function () {
          return n.R;
        },
      });
      let i = {
        interpolate(e, t, r) {
          if (2 !== e.length || 2 !== t.length)
            throw Error(
              "inputRange and outputRange must be an array of length 2"
            );
          let i = e[0] || 0,
            n = e[1] || 0,
            s = t[0] || 0,
            a = t[1] || 0;
          return r < i ? s : r > n ? a : ((a - s) / (n - i)) * (r - i) + s;
        },
      };
      var n = r(84249),
        s = r(3874),
        a = r(41262);
      let o = ["receive", "deposit", "borrow", "claim"],
        l = ["withdraw", "repay", "burn"],
        c = {
          getTransactionGroupTitle(e, t) {
            let r = a.E.getYear(),
              i = a.E.getMonthNameByIndex(t);
            return e === r ? i : `${i} ${e}`;
          },
          getTransactionImages(e) {
            let [t, r] = e,
              i = !!t && e?.every((e) => !!e.nft_info),
              n = e?.length > 1;
            return e?.length !== 2 || i
              ? n
                ? e.map((e) => this.getTransactionImage(e))
                : [this.getTransactionImage(t)]
              : [this.getTransactionImage(t), this.getTransactionImage(r)];
          },
          getTransactionImage: (e) => ({
            type: c.getTransactionTransferTokenType(e),
            url: c.getTransactionImageURL(e),
          }),
          getTransactionImageURL(e) {
            let t;
            let r = !!e?.nft_info,
              i = !!e?.fungible_info;
            return (
              e && r
                ? (t = e?.nft_info?.content?.preview?.url)
                : e && i && (t = e?.fungible_info?.icon?.url),
              t
            );
          },
          getTransactionTransferTokenType: (e) =>
            e?.fungible_info ? "FUNGIBLE" : e?.nft_info ? "NFT" : void 0,
          getTransactionDescriptions(e) {
            let t = e?.metadata?.operationType,
              r = e?.transfers,
              i = e?.transfers?.length > 0,
              n = e?.transfers?.length > 1,
              a = i && r?.every((e) => !!e?.fungible_info),
              [c, u] = r,
              h = this.getTransferDescription(c);
            if ((this.getTransferDescription(u), !i))
              return ("send" === t || "receive" === t) && a
                ? [
                    (h = s.H.getTruncateString({
                      string: e?.metadata.sentFrom,
                      charsStart: 4,
                      charsEnd: 6,
                      truncate: "middle",
                    })),
                    s.H.getTruncateString({
                      string: e?.metadata.sentTo,
                      charsStart: 4,
                      charsEnd: 6,
                      truncate: "middle",
                    }),
                  ]
                : [e.metadata.status];
            if (n) return r.map((e) => this.getTransferDescription(e));
            let d = "";
            return (
              o.includes(t) ? (d = "+") : l.includes(t) && (d = "-"),
              [(h = d.concat(h))]
            );
          },
          getTransferDescription(e) {
            let t = "";
            return (
              e &&
                (e?.nft_info
                  ? (t = e?.nft_info?.name || "-")
                  : e?.fungible_info &&
                    (t = this.getFungibleTransferDescription(e) || "-")),
              t
            );
          },
          getFungibleTransferDescription(e) {
            return e
              ? [
                  this.getQuantityFixedValue(e?.quantity.numeric),
                  e?.fungible_info?.symbol,
                ]
                  .join(" ")
                  .trim()
              : null;
          },
          getQuantityFixedValue: (e) => (e ? parseFloat(e).toFixed(3) : null),
        };
      var u = r(57116);
    },
    84249: function (e, t, r) {
      "use strict";
      let i, n, s;
      r.d(t, {
        Bp: function () {
          return f;
        },
        ET: function () {
          return d;
        },
        Hs: function () {
          return c;
        },
        R: function () {
          return u;
        },
        ZM: function () {
          return p;
        },
        n: function () {
          return l;
        },
      });
      var a = r(31133),
        o = r(62714);
      function l(e, t) {
        (i = document.createElement("style")),
          (n = document.createElement("style")),
          (s = document.createElement("style")),
          (i.textContent = h(e).core.cssText),
          (n.textContent = h(e).dark.cssText),
          (s.textContent = h(e).light.cssText),
          document.head.appendChild(i),
          document.head.appendChild(n),
          document.head.appendChild(s),
          c(t);
      }
      function c(e) {
        n &&
          s &&
          ("light" === e
            ? (n.removeAttribute("media"), (s.media = "enabled"))
            : (s.removeAttribute("media"), (n.media = "enabled")));
      }
      function u(e) {
        i &&
          n &&
          s &&
          ((i.textContent = h(e).core.cssText),
          (n.textContent = h(e).dark.cssText),
          (s.textContent = h(e).light.cssText));
      }
      function h(e) {
        return {
          core: (0, a.iv)`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --w3m-modal-width: 360px;
        --w3m-color-mix-strength: ${(0, a.$m)(
          e?.["--w3m-color-mix-strength"]
            ? `${e["--w3m-color-mix-strength"]}%`
            : "0%"
        )};
        --w3m-font-family: ${(0, a.$m)(
          e?.["--w3m-font-family"] ||
            "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;"
        )};
        --w3m-font-size-master: ${(0, a.$m)(
          e?.["--w3m-font-size-master"] || "10px"
        )};
        --w3m-border-radius-master: ${(0, a.$m)(
          e?.["--w3m-border-radius-master"] || "4px"
        )};
        --w3m-z-index: ${(0, a.$m)(e?.["--w3m-z-index"] || 999)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-title-6: calc(var(--w3m-font-size-master) * 2.2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-title-6: -0.88px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;
        --wui-spacing-5xl: 95px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-mdl: 36px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-2lg: 48px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;
        --wui-icon-size-xxl: 28px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-success-125: var(--wui-color-success-base-125);

        --wui-color-warning-100: var(--wui-color-warning-base-100);

        --wui-color-error-100: var(--wui-color-error-base-100);
        --wui-color-error-125: var(--wui-color-error-base-125);

        --wui-color-blue-100: var(--wui-color-blue-base-100);
        --wui-color-blue-90: var(--wui-color-blue-base-90);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-wallet-button-bg: var(--wui-wallet-button-bg-base);

        --wui-box-shadow-blue: var(--wui-color-accent-glass-020);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 20%, transparent);

          --wui-color-accent-100: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 100%,
            transparent
          );
          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-color-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-color-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-color-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-300)
          );
          --wui-color-fg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-325)
          );
          --wui-color-fg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-350)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-300)
          );
          --wui-color-bg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-325)
          );
          --wui-color-bg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-350)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-success-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-125)
          );

          --wui-color-warning-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-warning-base-100)
          );

          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );
          --wui-color-blue-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-100)
          );
          --wui-color-blue-90: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-90)
          );
          --wui-color-error-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-125)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );

          --wui-wallet-button-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-wallet-button-bg-base)
          );
        }
      }
    `,
          light: (0, a.iv)`
      :root {
        --w3m-color-mix: ${(0, a.$m)(e?.["--w3m-color-mix"] || "#fff")};
        --w3m-accent: ${(0, a.$m)((0, o.t)(e, "dark")["--w3m-accent"])};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: ${(0, a.$m)(
          (0, o.t)(e, "dark")["--w3m-background"]
        )};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(230, 100%, 67%, 1);
        --wui-color-blueberry-090: hsla(231, 76%, 61%, 1);
        --wui-color-blueberry-080: hsla(230, 59%, 55%, 1);
        --wui-color-blueberry-050: hsla(231, 100%, 70%, 0.1);

        --wui-color-fg-100: #e4e7e7;
        --wui-color-fg-125: #d0d5d5;
        --wui-color-fg-150: #a8b1b1;
        --wui-color-fg-175: #a8b0b0;
        --wui-color-fg-200: #949e9e;
        --wui-color-fg-225: #868f8f;
        --wui-color-fg-250: #788080;
        --wui-color-fg-275: #788181;
        --wui-color-fg-300: #6e7777;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #363636;

        --wui-color-bg-100: #141414;
        --wui-color-bg-125: #191a1a;
        --wui-color-bg-150: #1e1f1f;
        --wui-color-bg-175: #222525;
        --wui-color-bg-200: #272a2a;
        --wui-color-bg-225: #2c3030;
        --wui-color-bg-250: #313535;
        --wui-color-bg-275: #363b3b;
        --wui-color-bg-300: #3b4040;
        --wui-color-bg-325: #252525;
        --wui-color-bg-350: #ffffff;

        --wui-color-success-base-100: #26d962;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f25a67;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-color-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-color-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-color-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-color-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-color-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-color-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-color-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-color-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-color-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-color-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-color-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-color-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-color-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-color-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-color-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-color-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-color-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-color-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-color-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-color-gray-glass-090: rgba(255, 255, 255, 0.9);

        --wui-color-dark-glass-100: rgba(42, 42, 42, 1);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --w3m-card-embedded-shadow-color: rgb(17 17 18 / 25%);
      }
    `,
          dark: (0, a.iv)`
      :root {
        --w3m-color-mix: ${(0, a.$m)(e?.["--w3m-color-mix"] || "#000")};
        --w3m-accent: ${(0, a.$m)((0, o.t)(e, "light")["--w3m-accent"])};
        --w3m-default: #000;

        --wui-color-modal-bg-base: ${(0, a.$m)(
          (0, o.t)(e, "light")["--w3m-background"]
        )};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(231, 100%, 70%, 1);
        --wui-color-blueberry-090: hsla(231, 97%, 72%, 1);
        --wui-color-blueberry-080: hsla(231, 92%, 74%, 1);

        --wui-color-fg-100: #141414;
        --wui-color-fg-125: #2d3131;
        --wui-color-fg-150: #474d4d;
        --wui-color-fg-175: #636d6d;
        --wui-color-fg-200: #798686;
        --wui-color-fg-225: #828f8f;
        --wui-color-fg-250: #8b9797;
        --wui-color-fg-275: #95a0a0;
        --wui-color-fg-300: #9ea9a9;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #d0d0d0;

        --wui-color-bg-100: #ffffff;
        --wui-color-bg-125: #f5fafa;
        --wui-color-bg-150: #f3f8f8;
        --wui-color-bg-175: #eef4f4;
        --wui-color-bg-200: #eaf1f1;
        --wui-color-bg-225: #e5eded;
        --wui-color-bg-250: #e1e9e9;
        --wui-color-bg-275: #dce7e7;
        --wui-color-bg-300: #d8e3e3;
        --wui-color-bg-325: #f3f3f3;
        --wui-color-bg-350: #202020;

        --wui-color-success-base-100: #26b562;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f05142;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-color-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-color-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-color-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-color-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-color-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-color-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-color-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-color-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-color-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --wui-color-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-color-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-color-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-color-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-color-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-color-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-color-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-color-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-color-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-color-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-color-gray-glass-090: rgba(0, 0, 0, 0.9);

        --wui-color-dark-glass-100: rgba(233, 233, 233, 1);

        --w3m-card-embedded-shadow-color: rgb(224 225 233 / 25%);
      }
    `,
        };
      }
      let d = (0, a.iv)`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`,
        p = (0, a.iv)`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      box-shadow var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border, box-shadow, border-radius;
    outline: none;
    border: none;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  wui-flex {
    transition: border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius;
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-005);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }
  }

  button:disabled > wui-icon-box {
    opacity: 0.5;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`,
        f = (0, a.iv)`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-blue-100 {
    color: var(--wui-color-blue-100);
  }

  .wui-color-blue-90 {
    color: var(--wui-color-blue-90);
  }

  .wui-color-error-125 {
    color: var(--wui-color-error-125);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-success-125 {
    color: var(--wui-color-success-125);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    color: var(--wui-color-fg-350);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-error-125 {
    background-color: var(--wui-color-error-125);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-success-125 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    background-color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    background-color: var(--wui-color-fg-350);
  }
`;
    },
    3874: function (e, t, r) {
      "use strict";
      r.d(t, {
        H: function () {
          return i;
        },
      });
      let i = {
        getSpacingStyles: (e, t) =>
          Array.isArray(e)
            ? e[t]
              ? `var(--wui-spacing-${e[t]})`
              : void 0
            : "string" == typeof e
            ? `var(--wui-spacing-${e})`
            : void 0,
        getFormattedDate: (e) =>
          new Intl.DateTimeFormat("en-US", {
            month: "short",
            day: "numeric",
          }).format(e),
        getHostName(e) {
          try {
            return new URL(e).hostname;
          } catch (e) {
            return "";
          }
        },
        getTruncateString: ({
          string: e,
          charsStart: t,
          charsEnd: r,
          truncate: i,
        }) =>
          e.length <= t + r
            ? e
            : "end" === i
            ? `${e.substring(0, t)}...`
            : "start" === i
            ? `...${e.substring(e.length - r)}`
            : `${e.substring(0, Math.floor(t))}...${e.substring(
                e.length - Math.floor(r)
              )}`,
        generateAvatarColors(e) {
          let t = e
              .toLowerCase()
              .replace(/^0x/iu, "")
              .replace(/[^a-f0-9]/gu, "")
              .substring(0, 6)
              .padEnd(6, "0"),
            r = this.hexToRgb(t),
            i = getComputedStyle(document.documentElement).getPropertyValue(
              "--w3m-border-radius-master"
            ),
            n = 100 - 3 * Number(i?.replace("px", "")),
            s = `${n}% ${n}% at 65% 40%`,
            a = [];
          for (let e = 0; e < 5; e += 1) {
            let t = this.tintColor(r, 0.15 * e);
            a.push(`rgb(${t[0]}, ${t[1]}, ${t[2]})`);
          }
          return `
    --local-color-1: ${a[0]};
    --local-color-2: ${a[1]};
    --local-color-3: ${a[2]};
    --local-color-4: ${a[3]};
    --local-color-5: ${a[4]};
    --local-radial-circle: ${s}
   `;
        },
        hexToRgb(e) {
          let t = parseInt(e, 16);
          return [(t >> 16) & 255, (t >> 8) & 255, 255 & t];
        },
        tintColor(e, t) {
          let [r, i, n] = e;
          return [
            Math.round(r + (255 - r) * t),
            Math.round(i + (255 - i) * t),
            Math.round(n + (255 - n) * t),
          ];
        },
        isNumber: (e) => /^[0-9]+$/u.test(e),
        getColorTheme: (e) =>
          e ||
          ("undefined" != typeof window && window.matchMedia
            ? window.matchMedia("(prefers-color-scheme: dark)")?.matches
              ? "dark"
              : "light"
            : "dark"),
        splitBalance(e) {
          let t = e.split(".");
          return 2 === t.length ? [t[0], t[1]] : ["0", "00"];
        },
        roundNumber: (e, t, r) =>
          e.toString().length >= t ? Number(e).toFixed(r) : e,
        formatNumberToLocalString: (e, t = 2) =>
          void 0 === e
            ? "0.00"
            : "number" == typeof e
            ? e.toLocaleString("en-US", {
                maximumFractionDigits: t,
                minimumFractionDigits: t,
              })
            : parseFloat(e).toLocaleString("en-US", {
                maximumFractionDigits: t,
                minimumFractionDigits: t,
              }),
      };
    },
    57116: function (e, t, r) {
      "use strict";
      function i(e) {
        return function (t) {
          return "function" == typeof t
            ? (customElements.get(e) || customElements.define(e, t), t)
            : (function (e, t) {
                let { kind: r, elements: i } = t;
                return {
                  kind: r,
                  elements: i,
                  finisher(t) {
                    customElements.get(e) || customElements.define(e, t);
                  },
                };
              })(e, t);
        };
      }
      r.d(t, {
        M: function () {
          return i;
        },
      });
    },
    88578: function (e, t, r) {
      "use strict";
      r.d(t, {
        b: function () {
          return i;
        },
      });
      let i = {
        METMASK_CONNECTOR_NAME: "MetaMask",
        TRUST_CONNECTOR_NAME: "Trust Wallet",
        SOLFLARE_CONNECTOR_NAME: "Solflare",
        PHANTOM_CONNECTOR_NAME: "Phantom",
        COIN98_CONNECTOR_NAME: "Coin98",
        MAGIC_EDEN_CONNECTOR_NAME: "Magic Eden",
        BACKPACK_CONNECTOR_NAME: "Backpack",
        BITGET_CONNECTOR_NAME: "Bitget Wallet",
        FRONTIER_CONNECTOR_NAME: "Frontier",
        XVERSE_CONNECTOR_NAME: "Xverse Wallet",
        LEATHER_CONNECTOR_NAME: "Leather",
        EIP155: "eip155",
        ADD_CHAIN_METHOD: "wallet_addEthereumChain",
        EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
        EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
        CONNECTOR_RDNS_MAP: {
          coinbaseWallet: "com.coinbase.wallet",
          coinbaseWalletSDK: "com.coinbase.wallet",
        },
        CONNECTOR_TYPE_EXTERNAL: "EXTERNAL",
        CONNECTOR_TYPE_WALLET_CONNECT: "WALLET_CONNECT",
        CONNECTOR_TYPE_INJECTED: "INJECTED",
        CONNECTOR_TYPE_ANNOUNCED: "ANNOUNCED",
        CONNECTOR_TYPE_AUTH: "AUTH",
        CONNECTOR_TYPE_MULTI_CHAIN: "MULTI_CHAIN",
        CONNECTOR_TYPE_W3M_AUTH: "ID_AUTH",
      };
    },
    91426: function (e, t, r) {
      "use strict";
      r.d(t, {
        C: function () {
          return s;
        },
      });
      var i = r(44649),
        n = r(88578);
      let s = {
        ConnectorExplorerIds: {
          [i.b.CONNECTOR_ID.COINBASE]:
            "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
          [i.b.CONNECTOR_ID.COINBASE_SDK]:
            "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
          [i.b.CONNECTOR_ID.SAFE]:
            "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
          [i.b.CONNECTOR_ID.LEDGER]:
            "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927",
          [i.b.CONNECTOR_ID.OKX]:
            "971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709",
          [n.b.METMASK_CONNECTOR_NAME]:
            "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96",
          [n.b.TRUST_CONNECTOR_NAME]:
            "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0",
          [n.b.SOLFLARE_CONNECTOR_NAME]:
            "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
          [n.b.PHANTOM_CONNECTOR_NAME]:
            "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
          [n.b.COIN98_CONNECTOR_NAME]:
            "2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01",
          [n.b.MAGIC_EDEN_CONNECTOR_NAME]:
            "8b830a2b724a9c3fbab63af6f55ed29c9dfa8a55e732dc88c80a196a2ba136c6",
          [n.b.BACKPACK_CONNECTOR_NAME]:
            "2bd8c14e035c2d48f184aaa168559e86b0e3433228d3c4075900a221785019b0",
          [n.b.BITGET_CONNECTOR_NAME]:
            "38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662",
          [n.b.FRONTIER_CONNECTOR_NAME]:
            "85db431492aa2e8672e93f4ea7acf10c88b97b867b0d373107af63dc4880f041",
          [n.b.XVERSE_CONNECTOR_NAME]:
            "2a87d74ae02e10bdd1f51f7ce6c4e1cc53cd5f2c0b6b5ad0d7b3007d2b13de7b",
          [n.b.LEATHER_CONNECTOR_NAME]:
            "483afe1df1df63daf313109971ff3ef8356ddf1cc4e45877d205eee0b7893a13",
        },
        NetworkImageIds: {
          1: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
          42161: "3bff954d-5cb0-47a0-9a23-d20192e74600",
          43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
          56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
          250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
          10: "ab9c186a-c52f-464b-2906-ca59d760a400",
          137: "41d04d42-da3b-4453-8506-668cc0727900",
          5e3: "e86fae9b-b770-4eea-e520-150e12c81100",
          295: "6a97d510-cac8-4e58-c7ce-e8681b044c00",
          11155111: "e909ea0a-f92a-4512-c8fc-748044ea6800",
          84532: "a18a7ecd-e307-4360-4746-283182228e00",
          1301: "4eeea7ef-0014-4649-5d1d-07271a80f600",
          130: "2257980a-3463-48c6-cbac-a42d2a956e00",
          10143: "0a728e83-bacb-46db-7844-948f05434900",
          100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
          9001: "f926ff41-260d-4028-635e-91913fc28e00",
          324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
          314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
          4689: "34e68754-e536-40da-c153-6ef2e7188a00",
          1088: "3897a66d-40b9-4833-162f-a2c90531c900",
          1284: "161038da-44ae-4ec7-1208-0ea569454b00",
          1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
          7777777: "845c60df-d429-4991-e687-91ae45791600",
          42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
          8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
          1313161554: "3ff73439-a619-4894-9262-4470c773a100",
          2020: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
          2021: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
          80094: "e329c2c9-59b0-4a02-83e4-212ff3779900",
          "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp":
            "a1b58899-f671-4276-6a5e-56ca5bd59700",
          "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z":
            "a1b58899-f671-4276-6a5e-56ca5bd59700",
          EtWTRABZaYq6iMfeYKouRu166VU2xqa1:
            "a1b58899-f671-4276-6a5e-56ca5bd59700",
          "000000000019d6689c085ae165831e93":
            "0b4838db-0161-4ffe-022d-532bf03dba00",
          "000000000933ea01ad0ee984209779ba":
            "39354064-d79b-420b-065d-f980c4b78200",
        },
        ConnectorImageIds: {
          [i.b.CONNECTOR_ID.COINBASE]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
          [i.b.CONNECTOR_ID.COINBASE_SDK]:
            "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
          [i.b.CONNECTOR_ID.SAFE]: "461db637-8616-43ce-035a-d89b8a1d5800",
          [i.b.CONNECTOR_ID.LEDGER]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
          [i.b.CONNECTOR_ID.WALLET_CONNECT]:
            "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
          [i.b.CONNECTOR_ID.INJECTED]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00",
        },
        ConnectorNamesMap: {
          [i.b.CONNECTOR_ID.INJECTED]: "Browser Wallet",
          [i.b.CONNECTOR_ID.WALLET_CONNECT]: "WalletConnect",
          [i.b.CONNECTOR_ID.COINBASE]: "Coinbase",
          [i.b.CONNECTOR_ID.COINBASE_SDK]: "Coinbase",
          [i.b.CONNECTOR_ID.LEDGER]: "Ledger",
          [i.b.CONNECTOR_ID.SAFE]: "Safe",
        },
        ConnectorTypesMap: {
          [i.b.CONNECTOR_ID.INJECTED]: "INJECTED",
          [i.b.CONNECTOR_ID.WALLET_CONNECT]: "WALLET_CONNECT",
          [i.b.CONNECTOR_ID.EIP6963]: "ANNOUNCED",
          [i.b.CONNECTOR_ID.AUTH]: "AUTH",
        },
        WalletConnectRpcChainIds: [
          1, 5, 11155111, 10, 420, 42161, 421613, 137, 80001, 42220, 1313161554,
          1313161555, 56, 97, 43114, 43113, 100, 8453, 84531, 7777777, 999, 324,
          280,
        ],
      };
    },
    24308: function (e, t, r) {
      "use strict";
      r.d(t, {
        h: function () {
          return o;
        },
      });
      var i = r(15708),
        n = r(55543);
      let s = {
          eip155: void 0,
          solana: void 0,
          polkadot: void 0,
          bip122: void 0,
        },
        a = (0, i.sj)({ providers: { ...s }, providerIds: { ...s } }),
        o = {
          state: a,
          subscribeKey: (e, t) => (0, n.VW)(a, e, t),
          subscribeProviders: (e) =>
            (0, i.Ld)(a.providers, () => e(a.providers)),
          setProvider(e, t) {
            t && (a.providers[e] = (0, i.iH)(t));
          },
          getProvider: (e) => a.providers[e],
          setProviderId(e, t) {
            t && (a.providerIds[e] = t);
          },
          getProviderId(e) {
            if (e) return a.providerIds[e];
          },
          reset() {
            (a.providers = { ...s }), (a.providerIds = { ...s });
          },
          resetChain(e) {
            (a.providers[e] = void 0), (a.providerIds[e] = void 0);
          },
        };
    },
    4786: function (e, t, r) {
      "use strict";
      r.d(t, {
        $0: function () {
          return o;
        },
        Dr: function () {
          return n;
        },
        jd: function () {
          return s;
        },
        y_: function () {
          return l;
        },
        zN: function () {
          return a;
        },
      });
      var i = r(40257);
      let n =
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_SDK_URL
            : void 0) || "https://secure.walletconnect.org/sdk",
        s =
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_DEFAULT_LOG_LEVEL
            : void 0) || "error",
        a =
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_SDK_VERSION
            : void 0) || "4",
        o = {
          APP_EVENT_KEY: "@w3m-app/",
          FRAME_EVENT_KEY: "@w3m-frame/",
          RPC_METHOD_KEY: "RPC_",
          STORAGE_KEY: "@appkit-wallet/",
          SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
          EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
          LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
          LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
          EMAIL: "EMAIL",
          PREFERRED_ACCOUNT_TYPE: "PREFERRED_ACCOUNT_TYPE",
          SMART_ACCOUNT_ENABLED: "SMART_ACCOUNT_ENABLED",
          SMART_ACCOUNT_ENABLED_NETWORKS: "SMART_ACCOUNT_ENABLED_NETWORKS",
          SOCIAL_USERNAME: "SOCIAL_USERNAME",
          APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
          APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
          APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
          APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
          APP_CONNECT_SOCIAL: "@w3m-app/CONNECT_SOCIAL",
          APP_GET_SOCIAL_REDIRECT_URI: "@w3m-app/GET_SOCIAL_REDIRECT_URI",
          APP_GET_USER: "@w3m-app/GET_USER",
          APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
          APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
          APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
          APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
          APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
          APP_UPDATE_EMAIL_PRIMARY_OTP: "@w3m-app/UPDATE_EMAIL_PRIMARY_OTP",
          APP_UPDATE_EMAIL_SECONDARY_OTP: "@w3m-app/UPDATE_EMAIL_SECONDARY_OTP",
          APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
          APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
          APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
          APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS:
            "@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS",
          APP_INIT_SMART_ACCOUNT: "@w3m-app/INIT_SMART_ACCOUNT",
          APP_SET_PREFERRED_ACCOUNT: "@w3m-app/SET_PREFERRED_ACCOUNT",
          APP_CONNECT_FARCASTER: "@w3m-app/CONNECT_FARCASTER",
          APP_GET_FARCASTER_URI: "@w3m-app/GET_FARCASTER_URI",
          APP_RELOAD: "@w3m-app/RELOAD",
          FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
          FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
          FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
          FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
          FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
          FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
          FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
          FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
          FRAME_CONNECT_SOCIAL_SUCCESS: "@w3m-frame/CONNECT_SOCIAL_SUCCESS",
          FRAME_CONNECT_SOCIAL_ERROR: "@w3m-frame/CONNECT_SOCIAL_ERROR",
          FRAME_CONNECT_FARCASTER_SUCCESS:
            "@w3m-frame/CONNECT_FARCASTER_SUCCESS",
          FRAME_CONNECT_FARCASTER_ERROR: "@w3m-frame/CONNECT_FARCASTER_ERROR",
          FRAME_GET_FARCASTER_URI_SUCCESS:
            "@w3m-frame/GET_FARCASTER_URI_SUCCESS",
          FRAME_GET_FARCASTER_URI_ERROR: "@w3m-frame/GET_FARCASTER_URI_ERROR",
          FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS:
            "@w3m-frame/GET_SOCIAL_REDIRECT_URI_SUCCESS",
          FRAME_GET_SOCIAL_REDIRECT_URI_ERROR:
            "@w3m-frame/GET_SOCIAL_REDIRECT_URI_ERROR",
          FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
          FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
          FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
          FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
          FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
          FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
          FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
          FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
          FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
          FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
          FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
          FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
          FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
          FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS:
            "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS",
          FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR:
            "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR",
          FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS:
            "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS",
          FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR:
            "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR",
          FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
          FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
          FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
          FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR",
          FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS:
            "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS",
          FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR:
            "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR",
          FRAME_INIT_SMART_ACCOUNT_SUCCESS:
            "@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS",
          FRAME_INIT_SMART_ACCOUNT_ERROR: "@w3m-frame/INIT_SMART_ACCOUNT_ERROR",
          FRAME_SET_PREFERRED_ACCOUNT_SUCCESS:
            "@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS",
          FRAME_SET_PREFERRED_ACCOUNT_ERROR:
            "@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR",
          FRAME_READY: "@w3m-frame/READY",
          FRAME_RELOAD_SUCCESS: "@w3m-frame/RELOAD_SUCCESS",
          FRAME_RELOAD_ERROR: "@w3m-frame/RELOAD_ERROR",
          RPC_RESPONSE_TYPE_ERROR: "RPC_RESPONSE_ERROR",
          RPC_RESPONSE_TYPE_TX: "RPC_RESPONSE_TRANSACTION_HASH",
          RPC_RESPONSE_TYPE_OBJECT: "RPC_RESPONSE_OBJECT",
        },
        l = {
          SAFE_RPC_METHODS: [
            "eth_accounts",
            "eth_blockNumber",
            "eth_call",
            "eth_chainId",
            "eth_estimateGas",
            "eth_feeHistory",
            "eth_gasPrice",
            "eth_getAccount",
            "eth_getBalance",
            "eth_getBlockByHash",
            "eth_getBlockByNumber",
            "eth_getBlockReceipts",
            "eth_getBlockTransactionCountByHash",
            "eth_getBlockTransactionCountByNumber",
            "eth_getCode",
            "eth_getFilterChanges",
            "eth_getFilterLogs",
            "eth_getLogs",
            "eth_getProof",
            "eth_getStorageAt",
            "eth_getTransactionByBlockHashAndIndex",
            "eth_getTransactionByBlockNumberAndIndex",
            "eth_getTransactionByHash",
            "eth_getTransactionCount",
            "eth_getTransactionReceipt",
            "eth_getUncleCountByBlockHash",
            "eth_getUncleCountByBlockNumber",
            "eth_maxPriorityFeePerGas",
            "eth_newBlockFilter",
            "eth_newFilter",
            "eth_newPendingTransactionFilter",
            "eth_sendRawTransaction",
            "eth_syncing",
            "eth_uninstallFilter",
            "wallet_getCapabilities",
            "wallet_getCallsStatus",
            "eth_getUserOperationReceipt",
            "eth_estimateUserOperationGas",
            "eth_getUserOperationByHash",
            "eth_supportedEntryPoints",
            "wallet_getAssets",
          ],
          NOT_SAFE_RPC_METHODS: [
            "personal_sign",
            "eth_signTypedData_v4",
            "eth_sendTransaction",
            "solana_signMessage",
            "solana_signTransaction",
            "solana_signAllTransactions",
            "solana_signAndSendTransaction",
            "wallet_sendCalls",
            "wallet_grantPermissions",
            "wallet_revokePermissions",
            "eth_sendUserOperation",
          ],
          GET_CHAIN_ID: "eth_chainId",
          RPC_METHOD_NOT_ALLOWED_MESSAGE: "Requested RPC call is not allowed",
          RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: "Action not allowed",
          ACCOUNT_TYPES: { EOA: "eoa", SMART_ACCOUNT: "smartAccount" },
        };
    },
    92764: function (e, t, r) {
      "use strict";
      r.d(t, {
        $: function () {
          return a;
        },
      });
      let i = {
        transactionHash: /^0x(?:[A-Fa-f0-9]{64})$/u,
        signedMessage: /^0x(?:[a-fA-F0-9]{62,})$/u,
      };
      var n = r(4786),
        s = r(63671);
      let a = {
        checkIfAllowedToTriggerEmail() {
          let e = s.e.get(n.$0.LAST_EMAIL_LOGIN_TIME);
          if (e) {
            let t = Date.now() - Number(e);
            if (t < 3e4)
              throw Error(
                `Please try again after ${Math.ceil((3e4 - t) / 1e3)} seconds`
              );
          }
        },
        getTimeToNextEmailLogin() {
          let e = s.e.get(n.$0.LAST_EMAIL_LOGIN_TIME);
          if (e) {
            let t = Date.now() - Number(e);
            if (t < 3e4) return Math.ceil((3e4 - t) / 1e3);
          }
          return 0;
        },
        checkIfRequestExists: (e) =>
          n.y_.NOT_SAFE_RPC_METHODS.includes(e.method) ||
          n.y_.SAFE_RPC_METHODS.includes(e.method),
        getResponseType: (e) =>
          "string" == typeof e &&
          (e?.match(i.transactionHash) || e?.match(i.signedMessage))
            ? n.$0.RPC_RESPONSE_TYPE_TX
            : n.$0.RPC_RESPONSE_TYPE_OBJECT,
        checkIfRequestIsSafe: (e) => n.y_.SAFE_RPC_METHODS.includes(e.method),
        isClient: "undefined" != typeof window,
      };
    },
    63671: function (e, t, r) {
      "use strict";
      r.d(t, {
        e: function () {
          return s;
        },
      });
      var i = r(4786),
        n = r(92764);
      let s = {
        set(e, t) {
          n.$.isClient && localStorage.setItem(`${i.$0.STORAGE_KEY}${e}`, t);
        },
        get: (e) =>
          n.$.isClient ? localStorage.getItem(`${i.$0.STORAGE_KEY}${e}`) : null,
        delete(e, t) {
          n.$.isClient &&
            (t
              ? localStorage.removeItem(e)
              : localStorage.removeItem(`${i.$0.STORAGE_KEY}${e}`));
        },
      };
    },
    90487: function (e, t, r) {
      "use strict";
      let i, n;
      r.d(t, {
        cz: function () {
          return _;
        },
        Ig: function () {
          return C;
        },
        Tj: function () {
          return w;
        },
        U_: function () {
          return I;
        },
        cB: function () {
          return A;
        },
        qL: function () {
          return b;
        },
      });
      var s = r(53357),
        a = r(2265),
        o = r(84716),
        l = r(82558),
        c = r(15708);
      let { use: u } = a,
        { useSyncExternalStore: h } = l,
        d = (e, t) => {
          let r = (0, a.useRef)();
          (0, a.useEffect)(() => {
            r.current = (0, o.h8)(e, t, !0);
          }),
            (0, a.useDebugValue)(r.current);
        },
        p = new WeakMap();
      function f(e, t) {
        let r = null == t ? void 0 : t.sync,
          i = (0, a.useRef)(),
          n = (0, a.useRef)(),
          s = !0,
          l = h(
            (0, a.useCallback)(
              (t) => {
                let i = (0, c.Ld)(e, t, r);
                return t(), i;
              },
              [e, r]
            ),
            () => {
              let t = (0, c.CO)(e, u);
              try {
                if (
                  !s &&
                  i.current &&
                  n.current &&
                  !(0, o.ln)(i.current, t, n.current, new WeakMap())
                )
                  return i.current;
              } catch (e) {}
              return t;
            },
            () => (0, c.CO)(e, u)
          );
        s = !1;
        let f = new WeakMap();
        (0, a.useEffect)(() => {
          (i.current = l), (n.current = f);
        }),
          d(l, f);
        let g = (0, a.useMemo)(() => new WeakMap(), []);
        return (0, o.DM)(l, f, g, p);
      }
      var g = r(55372),
        m = r(21278),
        y = r(54173);
      function w(e) {
        let t = f(g.R.state),
          r = e?.namespace || t.activeChain;
        if (!r)
          return {
            allAccounts: [],
            address: void 0,
            caipAddress: void 0,
            status: void 0,
            isConnected: !1,
            embeddedWalletInfo: void 0,
          };
        let i = t.chains.get(r)?.accountState,
          n = y.ConnectorController.getAuthConnector(r);
        return {
          allAccounts: i?.allAccounts || [],
          caipAddress: i?.caipAddress,
          address: s.j.getPlainAddress(i?.caipAddress),
          isConnected: !!i?.caipAddress,
          status: i?.status,
          embeddedWalletInfo: n
            ? {
                user: i?.user,
                authProvider: i?.socialProvider || "email",
                accountType: i?.preferredAccountType,
                isSmartAccountDeployed: !!i?.smartAccountDeployed,
              }
            : void 0,
        };
      }
      function b() {
        return {
          disconnect: async function (e) {
            await m.ConnectionController.disconnect(e?.namespace);
          },
        };
      }
      var v = r(14500),
        E = r(24308);
      function A(e) {
        let { providers: t, providerIds: r } = f(E.h.state);
        return { walletProvider: t[e], walletProviderType: r[e] };
      }
      function C() {
        if (!i)
          throw Error(
            'Please call "createAppKit" before using "useAppKit" hook'
          );
        return {
          open: async function (e) {
            await i?.open(e);
          },
          close: async function () {
            await i?.close();
          },
        };
      }
      function _(e) {
        return (
          !n &&
            (i = n =
              new v.b({
                ...e,
                sdkVersion: s.j.generateSdkVersion(
                  e.adapters ?? [],
                  "react",
                  "1.7.1"
                ),
              })),
          n
        );
      }
      function I() {
        let {
          caipNetwork: e,
          caipNetworkId: t,
          chainId: r,
        } = (function () {
          let { activeCaipNetwork: e } = f(g.R.state);
          return {
            caipNetwork: e,
            chainId: e?.id,
            caipNetworkId: e?.caipNetworkId,
          };
        })();
        return {
          caipNetwork: e,
          caipNetworkId: t,
          chainId: r,
          switchNetwork: function (e) {
            n?.switchNetwork(e);
          },
        };
      }
      r(89977);
    },
    19091: function (e, t, r) {
      "use strict";
      r.d(t, {
        q: function () {
          return l;
        },
      }),
        r(76356);
      var i = r(44649),
        n = r(68584),
        s = r(48415),
        a = r(91426),
        o = r(47319);
      class l {
        constructor(e) {
          (this.availableConnectors = []),
            (this.eventListeners = new Map()),
            e && this.construct(e);
        }
        construct(e) {
          (this.caipNetworks = e.networks),
            (this.projectId = e.projectId),
            (this.namespace = e.namespace);
        }
        get connectors() {
          return this.availableConnectors;
        }
        get networks() {
          return this.caipNetworks || [];
        }
        setAuthProvider(e) {
          this.addConnector({
            id: i.b.CONNECTOR_ID.AUTH,
            type: "AUTH",
            name: i.b.CONNECTOR_NAMES.AUTH,
            provider: e,
            imageId: a.C.ConnectorImageIds[i.b.CONNECTOR_ID.AUTH],
            chain: this.namespace,
            chains: [],
          });
        }
        addConnector(...e) {
          let t = new Set();
          (this.availableConnectors = [
            ...e,
            ...this.availableConnectors,
          ].filter((e) => !t.has(e.id) && (t.add(e.id), !0))),
            this.emit("connectors", this.availableConnectors);
        }
        setStatus(e, t) {
          n.AccountController.setStatus(e, t);
        }
        on(e, t) {
          this.eventListeners.has(e) || this.eventListeners.set(e, new Set()),
            this.eventListeners.get(e)?.add(t);
        }
        off(e, t) {
          let r = this.eventListeners.get(e);
          r && r.delete(t);
        }
        removeAllEventListeners() {
          this.eventListeners.forEach((e) => {
            e.clear();
          });
        }
        emit(e, t) {
          let r = this.eventListeners.get(e);
          r && r.forEach((e) => e(t));
        }
        async connectWalletConnect(e) {
          let t = this.getWalletConnectConnector();
          return { clientId: (await t.connectWalletConnect()).clientId };
        }
        async switchNetwork(e) {
          let { caipNetwork: t, providerType: r } = e;
          if (!e.provider) return;
          let i = "provider" in e.provider ? e.provider.provider : e.provider;
          if ("WALLET_CONNECT" === r) {
            i.setDefaultChain(t.caipNetworkId);
            return;
          }
          if (i && "AUTH" === r) {
            await i.switchNetwork(t.caipNetworkId);
            let e = await i.getUser({
              chainId: t.caipNetworkId,
              preferredAccountType:
                s.OptionsController.state.defaultAccountTypes[t.chainNamespace],
            });
            this.emit("switchNetwork", e);
          }
        }
        getWalletConnectConnector() {
          let e = this.connectors.find((e) => e instanceof o.z);
          if (!e) throw Error("WalletConnectConnector not found");
          return e;
        }
      }
    },
    14500: function (e, t, r) {
      "use strict";
      let i, n;
      r.d(t, {
        b: function () {
          return iH;
        },
      });
      var s,
        a,
        o,
        l,
        c,
        u,
        h,
        d = r(44649),
        p = r(62714),
        f = r(54173),
        g = r(21278),
        m = r(31929),
        y = r(59712),
        w = r(17766),
        b = r(68584),
        v = r(55372),
        E = r(48415),
        A = r(53357),
        C = r(52005),
        _ = r(36801),
        I = r(72723),
        N = r(88578);
      let S = {
          getCaipTokens(e) {
            if (!e) return;
            let t = {};
            return (
              Object.entries(e).forEach(([e, r]) => {
                t[`${N.b.EIP155}:${e}`] = r;
              }),
              t
            );
          },
          isLowerCaseMatch: (e, t) => e?.toLowerCase() === t?.toLowerCase(),
        },
        T = {
          UniversalProviderErrors: {
            UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
              message: "Unauthorized: origin not allowed",
              alertErrorKey: "INVALID_APP_CONFIGURATION",
            },
            JWT_VALIDATION_ERROR: {
              message: "JWT validation error: JWT Token is not yet valid",
              alertErrorKey: "JWT_TOKEN_NOT_VALID",
            },
            INVALID_KEY: {
              message: "Unauthorized: invalid key",
              alertErrorKey: "INVALID_PROJECT_ID",
            },
          },
          ALERT_ERRORS: {
            SWITCH_NETWORK_NOT_FOUND: {
              shortMessage: "Network Not Found",
              longMessage:
                "Network not found - please make sure it is included in 'networks' array in createAppKit function",
            },
            INVALID_APP_CONFIGURATION: {
              shortMessage: "Invalid App Configuration",
              longMessage: () =>
                `Origin ${
                  "undefined" != typeof window ? window.origin : "unknown"
                } not found on Allowlist - update configuration on cloud.reown.com`,
            },
            SOCIALS_TIMEOUT: {
              shortMessage: "Invalid App Configuration",
              longMessage: () =>
                "There was an issue loading the embedded wallet. Please verify that your domain is allowed at cloud.reown.com",
            },
            JWT_TOKEN_NOT_VALID: {
              shortMessage: "Session Expired",
              longMessage:
                "Invalid session found on UniversalProvider - please check your time settings and connect again",
            },
            INVALID_PROJECT_ID: {
              shortMessage: "Invalid App Configuration",
              longMessage: "Invalid Project ID - update configuration",
            },
            PROJECT_ID_NOT_CONFIGURED: {
              shortMessage: "Project ID Not Configured",
              longMessage:
                "Project ID Not Configured - update configuration on cloud.reown.com",
            },
          },
        };
      var P = r(24308),
        O = r(92764),
        x = r(4786);
      ((s = l || (l = {})).assertEqual = (e) => e),
        (s.assertIs = function (e) {}),
        (s.assertNever = function (e) {
          throw Error();
        }),
        (s.arrayToEnum = (e) => {
          let t = {};
          for (let r of e) t[r] = r;
          return t;
        }),
        (s.getValidEnumValues = (e) => {
          let t = s.objectKeys(e).filter((t) => "number" != typeof e[e[t]]),
            r = {};
          for (let i of t) r[i] = e[i];
          return s.objectValues(r);
        }),
        (s.objectValues = (e) =>
          s.objectKeys(e).map(function (t) {
            return e[t];
          })),
        (s.objectKeys =
          "function" == typeof Object.keys
            ? (e) => Object.keys(e)
            : (e) => {
                let t = [];
                for (let r in e)
                  Object.prototype.hasOwnProperty.call(e, r) && t.push(r);
                return t;
              }),
        (s.find = (e, t) => {
          for (let r of e) if (t(r)) return r;
        }),
        (s.isInteger =
          "function" == typeof Number.isInteger
            ? (e) => Number.isInteger(e)
            : (e) =>
                "number" == typeof e && isFinite(e) && Math.floor(e) === e),
        (s.joinValues = function (e, t = " | ") {
          return e.map((e) => ("string" == typeof e ? `'${e}'` : e)).join(t);
        }),
        (s.jsonStringifyReplacer = (e, t) =>
          "bigint" == typeof t ? t.toString() : t),
        ((c || (c = {})).mergeShapes = (e, t) => ({ ...e, ...t }));
      let k = l.arrayToEnum([
          "string",
          "nan",
          "number",
          "integer",
          "float",
          "boolean",
          "date",
          "bigint",
          "symbol",
          "function",
          "undefined",
          "null",
          "array",
          "object",
          "unknown",
          "promise",
          "void",
          "never",
          "map",
          "set",
        ]),
        R = (e) => {
          switch (typeof e) {
            case "undefined":
              return k.undefined;
            case "string":
              return k.string;
            case "number":
              return isNaN(e) ? k.nan : k.number;
            case "boolean":
              return k.boolean;
            case "function":
              return k.function;
            case "bigint":
              return k.bigint;
            case "symbol":
              return k.symbol;
            case "object":
              if (Array.isArray(e)) return k.array;
              if (null === e) return k.null;
              if (
                e.then &&
                "function" == typeof e.then &&
                e.catch &&
                "function" == typeof e.catch
              )
                return k.promise;
              if ("undefined" != typeof Map && e instanceof Map) return k.map;
              if ("undefined" != typeof Set && e instanceof Set) return k.set;
              if ("undefined" != typeof Date && e instanceof Date)
                return k.date;
              return k.object;
            default:
              return k.unknown;
          }
        },
        D = l.arrayToEnum([
          "invalid_type",
          "invalid_literal",
          "custom",
          "invalid_union",
          "invalid_union_discriminator",
          "invalid_enum_value",
          "unrecognized_keys",
          "invalid_arguments",
          "invalid_return_type",
          "invalid_date",
          "invalid_string",
          "too_small",
          "too_big",
          "invalid_intersection_types",
          "not_multiple_of",
          "not_finite",
        ]);
      class U extends Error {
        constructor(e) {
          super(),
            (this.issues = []),
            (this.addIssue = (e) => {
              this.issues = [...this.issues, e];
            }),
            (this.addIssues = (e = []) => {
              this.issues = [...this.issues, ...e];
            });
          let t = new.target.prototype;
          Object.setPrototypeOf
            ? Object.setPrototypeOf(this, t)
            : (this.__proto__ = t),
            (this.name = "ZodError"),
            (this.issues = e);
        }
        get errors() {
          return this.issues;
        }
        format(e) {
          let t =
              e ||
              function (e) {
                return e.message;
              },
            r = { _errors: [] },
            i = (e) => {
              for (let n of e.issues)
                if ("invalid_union" === n.code) n.unionErrors.map(i);
                else if ("invalid_return_type" === n.code) i(n.returnTypeError);
                else if ("invalid_arguments" === n.code) i(n.argumentsError);
                else if (0 === n.path.length) r._errors.push(t(n));
                else {
                  let e = r,
                    i = 0;
                  for (; i < n.path.length; ) {
                    let r = n.path[i];
                    i === n.path.length - 1
                      ? ((e[r] = e[r] || { _errors: [] }),
                        e[r]._errors.push(t(n)))
                      : (e[r] = e[r] || { _errors: [] }),
                      (e = e[r]),
                      i++;
                  }
                }
            };
          return i(this), r;
        }
        toString() {
          return this.message;
        }
        get message() {
          return JSON.stringify(this.issues, l.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
          return 0 === this.issues.length;
        }
        flatten(e = (e) => e.message) {
          let t = {},
            r = [];
          for (let i of this.issues)
            i.path.length > 0
              ? ((t[i.path[0]] = t[i.path[0]] || []), t[i.path[0]].push(e(i)))
              : r.push(e(i));
          return { formErrors: r, fieldErrors: t };
        }
        get formErrors() {
          return this.flatten();
        }
      }
      U.create = (e) => new U(e);
      let L = (e, t) => {
          let r;
          switch (e.code) {
            case D.invalid_type:
              r =
                e.received === k.undefined
                  ? "Required"
                  : `Expected ${e.expected}, received ${e.received}`;
              break;
            case D.invalid_literal:
              r = `Invalid literal value, expected ${JSON.stringify(
                e.expected,
                l.jsonStringifyReplacer
              )}`;
              break;
            case D.unrecognized_keys:
              r = `Unrecognized key(s) in object: ${l.joinValues(
                e.keys,
                ", "
              )}`;
              break;
            case D.invalid_union:
              r = "Invalid input";
              break;
            case D.invalid_union_discriminator:
              r = `Invalid discriminator value. Expected ${l.joinValues(
                e.options
              )}`;
              break;
            case D.invalid_enum_value:
              r = `Invalid enum value. Expected ${l.joinValues(
                e.options
              )}, received '${e.received}'`;
              break;
            case D.invalid_arguments:
              r = "Invalid function arguments";
              break;
            case D.invalid_return_type:
              r = "Invalid function return type";
              break;
            case D.invalid_date:
              r = "Invalid date";
              break;
            case D.invalid_string:
              "object" == typeof e.validation
                ? "includes" in e.validation
                  ? ((r = `Invalid input: must include "${e.validation.includes}"`),
                    "number" == typeof e.validation.position &&
                      (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`))
                  : "startsWith" in e.validation
                  ? (r = `Invalid input: must start with "${e.validation.startsWith}"`)
                  : "endsWith" in e.validation
                  ? (r = `Invalid input: must end with "${e.validation.endsWith}"`)
                  : l.assertNever(e.validation)
                : (r =
                    "regex" !== e.validation
                      ? `Invalid ${e.validation}`
                      : "Invalid");
              break;
            case D.too_small:
              r =
                "array" === e.type
                  ? `Array must contain ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "at least"
                        : "more than"
                    } ${e.minimum} element(s)`
                  : "string" === e.type
                  ? `String must contain ${
                      e.exact ? "exactly" : e.inclusive ? "at least" : "over"
                    } ${e.minimum} character(s)`
                  : "number" === e.type
                  ? `Number must be ${
                      e.exact
                        ? "exactly equal to "
                        : e.inclusive
                        ? "greater than or equal to "
                        : "greater than "
                    }${e.minimum}`
                  : "date" === e.type
                  ? `Date must be ${
                      e.exact
                        ? "exactly equal to "
                        : e.inclusive
                        ? "greater than or equal to "
                        : "greater than "
                    }${new Date(Number(e.minimum))}`
                  : "Invalid input";
              break;
            case D.too_big:
              r =
                "array" === e.type
                  ? `Array must contain ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "at most"
                        : "less than"
                    } ${e.maximum} element(s)`
                  : "string" === e.type
                  ? `String must contain ${
                      e.exact ? "exactly" : e.inclusive ? "at most" : "under"
                    } ${e.maximum} character(s)`
                  : "number" === e.type
                  ? `Number must be ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "less than or equal to"
                        : "less than"
                    } ${e.maximum}`
                  : "bigint" === e.type
                  ? `BigInt must be ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "less than or equal to"
                        : "less than"
                    } ${e.maximum}`
                  : "date" === e.type
                  ? `Date must be ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "smaller than or equal to"
                        : "smaller than"
                    } ${new Date(Number(e.maximum))}`
                  : "Invalid input";
              break;
            case D.custom:
              r = "Invalid input";
              break;
            case D.invalid_intersection_types:
              r = "Intersection results could not be merged";
              break;
            case D.not_multiple_of:
              r = `Number must be a multiple of ${e.multipleOf}`;
              break;
            case D.not_finite:
              r = "Number must be finite";
              break;
            default:
              (r = t.defaultError), l.assertNever(e);
          }
          return { message: r };
        },
        M = L;
      function B() {
        return M;
      }
      let j = (e) => {
        let { data: t, path: r, errorMaps: i, issueData: n } = e,
          s = [...r, ...(n.path || [])],
          a = { ...n, path: s },
          o = "";
        for (let e of i
          .filter((e) => !!e)
          .slice()
          .reverse())
          o = e(a, { data: t, defaultError: o }).message;
        return { ...n, path: s, message: n.message || o };
      };
      function F(e, t) {
        let r = j({
          issueData: t,
          data: e.data,
          path: e.path,
          errorMaps: [
            e.common.contextualErrorMap,
            e.schemaErrorMap,
            B(),
            L,
          ].filter((e) => !!e),
        });
        e.common.issues.push(r);
      }
      class $ {
        constructor() {
          this.value = "valid";
        }
        dirty() {
          "valid" === this.value && (this.value = "dirty");
        }
        abort() {
          "aborted" !== this.value && (this.value = "aborted");
        }
        static mergeArray(e, t) {
          let r = [];
          for (let i of t) {
            if ("aborted" === i.status) return H;
            "dirty" === i.status && e.dirty(), r.push(i.value);
          }
          return { status: e.value, value: r };
        }
        static async mergeObjectAsync(e, t) {
          let r = [];
          for (let e of t) r.push({ key: await e.key, value: await e.value });
          return $.mergeObjectSync(e, r);
        }
        static mergeObjectSync(e, t) {
          let r = {};
          for (let i of t) {
            let { key: t, value: n } = i;
            if ("aborted" === t.status || "aborted" === n.status) return H;
            "dirty" === t.status && e.dirty(),
              "dirty" === n.status && e.dirty(),
              "__proto__" !== t.value &&
                (void 0 !== n.value || i.alwaysSet) &&
                (r[t.value] = n.value);
          }
          return { status: e.value, value: r };
        }
      }
      let H = Object.freeze({ status: "aborted" }),
        z = (e) => ({ status: "dirty", value: e }),
        q = (e) => ({ status: "valid", value: e }),
        V = (e) => "aborted" === e.status,
        G = (e) => "dirty" === e.status,
        W = (e) => "valid" === e.status,
        K = (e) => "undefined" != typeof Promise && e instanceof Promise;
      ((a = u || (u = {})).errToObj = (e) =>
        "string" == typeof e ? { message: e } : e || {}),
        (a.toString = (e) =>
          "string" == typeof e ? e : null == e ? void 0 : e.message);
      class Z {
        constructor(e, t, r, i) {
          (this._cachedPath = []),
            (this.parent = e),
            (this.data = t),
            (this._path = r),
            (this._key = i);
        }
        get path() {
          return (
            this._cachedPath.length ||
              (this._key instanceof Array
                ? this._cachedPath.push(...this._path, ...this._key)
                : this._cachedPath.push(...this._path, this._key)),
            this._cachedPath
          );
        }
      }
      let J = (e, t) => {
        if (W(t)) return { success: !0, data: t.value };
        if (!e.common.issues.length)
          throw Error("Validation failed but no issues detected.");
        return {
          success: !1,
          get error() {
            if (this._error) return this._error;
            let t = new U(e.common.issues);
            return (this._error = t), this._error;
          },
        };
      };
      function Q(e) {
        if (!e) return {};
        let {
          errorMap: t,
          invalid_type_error: r,
          required_error: i,
          description: n,
        } = e;
        if (t && (r || i))
          throw Error(
            'Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.'
          );
        return t
          ? { errorMap: t, description: n }
          : {
              errorMap: (e, t) =>
                "invalid_type" !== e.code
                  ? { message: t.defaultError }
                  : void 0 === t.data
                  ? { message: null != i ? i : t.defaultError }
                  : { message: null != r ? r : t.defaultError },
              description: n,
            };
      }
      class Y {
        constructor(e) {
          (this.spa = this.safeParseAsync),
            (this._def = e),
            (this.parse = this.parse.bind(this)),
            (this.safeParse = this.safeParse.bind(this)),
            (this.parseAsync = this.parseAsync.bind(this)),
            (this.safeParseAsync = this.safeParseAsync.bind(this)),
            (this.spa = this.spa.bind(this)),
            (this.refine = this.refine.bind(this)),
            (this.refinement = this.refinement.bind(this)),
            (this.superRefine = this.superRefine.bind(this)),
            (this.optional = this.optional.bind(this)),
            (this.nullable = this.nullable.bind(this)),
            (this.nullish = this.nullish.bind(this)),
            (this.array = this.array.bind(this)),
            (this.promise = this.promise.bind(this)),
            (this.or = this.or.bind(this)),
            (this.and = this.and.bind(this)),
            (this.transform = this.transform.bind(this)),
            (this.brand = this.brand.bind(this)),
            (this.default = this.default.bind(this)),
            (this.catch = this.catch.bind(this)),
            (this.describe = this.describe.bind(this)),
            (this.pipe = this.pipe.bind(this)),
            (this.readonly = this.readonly.bind(this)),
            (this.isNullable = this.isNullable.bind(this)),
            (this.isOptional = this.isOptional.bind(this));
        }
        get description() {
          return this._def.description;
        }
        _getType(e) {
          return R(e.data);
        }
        _getOrReturnCtx(e, t) {
          return (
            t || {
              common: e.parent.common,
              data: e.data,
              parsedType: R(e.data),
              schemaErrorMap: this._def.errorMap,
              path: e.path,
              parent: e.parent,
            }
          );
        }
        _processInputParams(e) {
          return {
            status: new $(),
            ctx: {
              common: e.parent.common,
              data: e.data,
              parsedType: R(e.data),
              schemaErrorMap: this._def.errorMap,
              path: e.path,
              parent: e.parent,
            },
          };
        }
        _parseSync(e) {
          let t = this._parse(e);
          if (K(t)) throw Error("Synchronous parse encountered promise.");
          return t;
        }
        _parseAsync(e) {
          return Promise.resolve(this._parse(e));
        }
        parse(e, t) {
          let r = this.safeParse(e, t);
          if (r.success) return r.data;
          throw r.error;
        }
        safeParse(e, t) {
          var r;
          let i = {
              common: {
                issues: [],
                async:
                  null !== (r = null == t ? void 0 : t.async) &&
                  void 0 !== r &&
                  r,
                contextualErrorMap: null == t ? void 0 : t.errorMap,
              },
              path: (null == t ? void 0 : t.path) || [],
              schemaErrorMap: this._def.errorMap,
              parent: null,
              data: e,
              parsedType: R(e),
            },
            n = this._parseSync({ data: e, path: i.path, parent: i });
          return J(i, n);
        }
        async parseAsync(e, t) {
          let r = await this.safeParseAsync(e, t);
          if (r.success) return r.data;
          throw r.error;
        }
        async safeParseAsync(e, t) {
          let r = {
              common: {
                issues: [],
                contextualErrorMap: null == t ? void 0 : t.errorMap,
                async: !0,
              },
              path: (null == t ? void 0 : t.path) || [],
              schemaErrorMap: this._def.errorMap,
              parent: null,
              data: e,
              parsedType: R(e),
            },
            i = this._parse({ data: e, path: r.path, parent: r });
          return J(r, await (K(i) ? i : Promise.resolve(i)));
        }
        refine(e, t) {
          let r = (e) =>
            "string" == typeof t || void 0 === t
              ? { message: t }
              : "function" == typeof t
              ? t(e)
              : t;
          return this._refinement((t, i) => {
            let n = e(t),
              s = () => i.addIssue({ code: D.custom, ...r(t) });
            return "undefined" != typeof Promise && n instanceof Promise
              ? n.then((e) => !!e || (s(), !1))
              : !!n || (s(), !1);
          });
        }
        refinement(e, t) {
          return this._refinement(
            (r, i) =>
              !!e(r) || (i.addIssue("function" == typeof t ? t(r, i) : t), !1)
          );
        }
        _refinement(e) {
          return new eL({
            schema: this,
            typeName: h.ZodEffects,
            effect: { type: "refinement", refinement: e },
          });
        }
        superRefine(e) {
          return this._refinement(e);
        }
        optional() {
          return eM.create(this, this._def);
        }
        nullable() {
          return eB.create(this, this._def);
        }
        nullish() {
          return this.nullable().optional();
        }
        array() {
          return eb.create(this, this._def);
        }
        promise() {
          return eU.create(this, this._def);
        }
        or(e) {
          return eE.create([this, e], this._def);
        }
        and(e) {
          return e_.create(this, e, this._def);
        }
        transform(e) {
          return new eL({
            ...Q(this._def),
            schema: this,
            typeName: h.ZodEffects,
            effect: { type: "transform", transform: e },
          });
        }
        default(e) {
          return new ej({
            ...Q(this._def),
            innerType: this,
            defaultValue: "function" == typeof e ? e : () => e,
            typeName: h.ZodDefault,
          });
        }
        brand() {
          return new ez({
            typeName: h.ZodBranded,
            type: this,
            ...Q(this._def),
          });
        }
        catch(e) {
          return new eF({
            ...Q(this._def),
            innerType: this,
            catchValue: "function" == typeof e ? e : () => e,
            typeName: h.ZodCatch,
          });
        }
        describe(e) {
          return new this.constructor({ ...this._def, description: e });
        }
        pipe(e) {
          return eq.create(this, e);
        }
        readonly() {
          return eV.create(this);
        }
        isOptional() {
          return this.safeParse(void 0).success;
        }
        isNullable() {
          return this.safeParse(null).success;
        }
      }
      let X = /^c[^\s-]{8,}$/i,
        ee = /^[a-z][a-z0-9]*$/,
        et = /^[0-9A-HJKMNP-TV-Z]{26}$/,
        er =
          /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
        ei =
          /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
        en =
          /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,
        es =
          /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
        ea = (e) =>
          e.precision
            ? e.offset
              ? RegExp(
                  `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
                )
              : RegExp(
                  `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`
                )
            : 0 === e.precision
            ? e.offset
              ? RegExp(
                  "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$"
                )
              : RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$")
            : e.offset
            ? RegExp(
                "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$"
              )
            : RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
      class eo extends Y {
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = String(e.data)),
            this._getType(e) !== k.string)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              F(t, {
                code: D.invalid_type,
                expected: k.string,
                received: t.parsedType,
              }),
              H
            );
          }
          let r = new $();
          for (let a of this._def.checks)
            if ("min" === a.kind)
              e.data.length < a.value &&
                (F((t = this._getOrReturnCtx(e, t)), {
                  code: D.too_small,
                  minimum: a.value,
                  type: "string",
                  inclusive: !0,
                  exact: !1,
                  message: a.message,
                }),
                r.dirty());
            else if ("max" === a.kind)
              e.data.length > a.value &&
                (F((t = this._getOrReturnCtx(e, t)), {
                  code: D.too_big,
                  maximum: a.value,
                  type: "string",
                  inclusive: !0,
                  exact: !1,
                  message: a.message,
                }),
                r.dirty());
            else if ("length" === a.kind) {
              let i = e.data.length > a.value,
                n = e.data.length < a.value;
              (i || n) &&
                ((t = this._getOrReturnCtx(e, t)),
                i
                  ? F(t, {
                      code: D.too_big,
                      maximum: a.value,
                      type: "string",
                      inclusive: !0,
                      exact: !0,
                      message: a.message,
                    })
                  : n &&
                    F(t, {
                      code: D.too_small,
                      minimum: a.value,
                      type: "string",
                      inclusive: !0,
                      exact: !0,
                      message: a.message,
                    }),
                r.dirty());
            } else if ("email" === a.kind)
              ei.test(e.data) ||
                (F((t = this._getOrReturnCtx(e, t)), {
                  validation: "email",
                  code: D.invalid_string,
                  message: a.message,
                }),
                r.dirty());
            else if ("emoji" === a.kind)
              i ||
                (i = RegExp(
                  "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
                  "u"
                )),
                i.test(e.data) ||
                  (F((t = this._getOrReturnCtx(e, t)), {
                    validation: "emoji",
                    code: D.invalid_string,
                    message: a.message,
                  }),
                  r.dirty());
            else if ("uuid" === a.kind)
              er.test(e.data) ||
                (F((t = this._getOrReturnCtx(e, t)), {
                  validation: "uuid",
                  code: D.invalid_string,
                  message: a.message,
                }),
                r.dirty());
            else if ("cuid" === a.kind)
              X.test(e.data) ||
                (F((t = this._getOrReturnCtx(e, t)), {
                  validation: "cuid",
                  code: D.invalid_string,
                  message: a.message,
                }),
                r.dirty());
            else if ("cuid2" === a.kind)
              ee.test(e.data) ||
                (F((t = this._getOrReturnCtx(e, t)), {
                  validation: "cuid2",
                  code: D.invalid_string,
                  message: a.message,
                }),
                r.dirty());
            else if ("ulid" === a.kind)
              et.test(e.data) ||
                (F((t = this._getOrReturnCtx(e, t)), {
                  validation: "ulid",
                  code: D.invalid_string,
                  message: a.message,
                }),
                r.dirty());
            else if ("url" === a.kind)
              try {
                new URL(e.data);
              } catch (i) {
                F((t = this._getOrReturnCtx(e, t)), {
                  validation: "url",
                  code: D.invalid_string,
                  message: a.message,
                }),
                  r.dirty();
              }
            else if ("regex" === a.kind)
              (a.regex.lastIndex = 0),
                a.regex.test(e.data) ||
                  (F((t = this._getOrReturnCtx(e, t)), {
                    validation: "regex",
                    code: D.invalid_string,
                    message: a.message,
                  }),
                  r.dirty());
            else if ("trim" === a.kind) e.data = e.data.trim();
            else if ("includes" === a.kind)
              e.data.includes(a.value, a.position) ||
                (F((t = this._getOrReturnCtx(e, t)), {
                  code: D.invalid_string,
                  validation: { includes: a.value, position: a.position },
                  message: a.message,
                }),
                r.dirty());
            else if ("toLowerCase" === a.kind) e.data = e.data.toLowerCase();
            else if ("toUpperCase" === a.kind) e.data = e.data.toUpperCase();
            else if ("startsWith" === a.kind)
              e.data.startsWith(a.value) ||
                (F((t = this._getOrReturnCtx(e, t)), {
                  code: D.invalid_string,
                  validation: { startsWith: a.value },
                  message: a.message,
                }),
                r.dirty());
            else if ("endsWith" === a.kind)
              e.data.endsWith(a.value) ||
                (F((t = this._getOrReturnCtx(e, t)), {
                  code: D.invalid_string,
                  validation: { endsWith: a.value },
                  message: a.message,
                }),
                r.dirty());
            else if ("datetime" === a.kind)
              ea(a).test(e.data) ||
                (F((t = this._getOrReturnCtx(e, t)), {
                  code: D.invalid_string,
                  validation: "datetime",
                  message: a.message,
                }),
                r.dirty());
            else if ("ip" === a.kind) {
              var n, s;
              (n = e.data),
                (("v4" === (s = a.version) || !s) && en.test(n)) ||
                  (("v6" === s || !s) && es.test(n)) ||
                  (F((t = this._getOrReturnCtx(e, t)), {
                    validation: "ip",
                    code: D.invalid_string,
                    message: a.message,
                  }),
                  r.dirty());
            } else l.assertNever(a);
          return { status: r.value, value: e.data };
        }
        _regex(e, t, r) {
          return this.refinement((t) => e.test(t), {
            validation: t,
            code: D.invalid_string,
            ...u.errToObj(r),
          });
        }
        _addCheck(e) {
          return new eo({ ...this._def, checks: [...this._def.checks, e] });
        }
        email(e) {
          return this._addCheck({ kind: "email", ...u.errToObj(e) });
        }
        url(e) {
          return this._addCheck({ kind: "url", ...u.errToObj(e) });
        }
        emoji(e) {
          return this._addCheck({ kind: "emoji", ...u.errToObj(e) });
        }
        uuid(e) {
          return this._addCheck({ kind: "uuid", ...u.errToObj(e) });
        }
        cuid(e) {
          return this._addCheck({ kind: "cuid", ...u.errToObj(e) });
        }
        cuid2(e) {
          return this._addCheck({ kind: "cuid2", ...u.errToObj(e) });
        }
        ulid(e) {
          return this._addCheck({ kind: "ulid", ...u.errToObj(e) });
        }
        ip(e) {
          return this._addCheck({ kind: "ip", ...u.errToObj(e) });
        }
        datetime(e) {
          var t;
          return "string" == typeof e
            ? this._addCheck({
                kind: "datetime",
                precision: null,
                offset: !1,
                message: e,
              })
            : this._addCheck({
                kind: "datetime",
                precision:
                  void 0 === (null == e ? void 0 : e.precision)
                    ? null
                    : null == e
                    ? void 0
                    : e.precision,
                offset:
                  null !== (t = null == e ? void 0 : e.offset) &&
                  void 0 !== t &&
                  t,
                ...u.errToObj(null == e ? void 0 : e.message),
              });
        }
        regex(e, t) {
          return this._addCheck({ kind: "regex", regex: e, ...u.errToObj(t) });
        }
        includes(e, t) {
          return this._addCheck({
            kind: "includes",
            value: e,
            position: null == t ? void 0 : t.position,
            ...u.errToObj(null == t ? void 0 : t.message),
          });
        }
        startsWith(e, t) {
          return this._addCheck({
            kind: "startsWith",
            value: e,
            ...u.errToObj(t),
          });
        }
        endsWith(e, t) {
          return this._addCheck({
            kind: "endsWith",
            value: e,
            ...u.errToObj(t),
          });
        }
        min(e, t) {
          return this._addCheck({ kind: "min", value: e, ...u.errToObj(t) });
        }
        max(e, t) {
          return this._addCheck({ kind: "max", value: e, ...u.errToObj(t) });
        }
        length(e, t) {
          return this._addCheck({ kind: "length", value: e, ...u.errToObj(t) });
        }
        nonempty(e) {
          return this.min(1, u.errToObj(e));
        }
        trim() {
          return new eo({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
          });
        }
        toLowerCase() {
          return new eo({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
          });
        }
        toUpperCase() {
          return new eo({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
          });
        }
        get isDatetime() {
          return !!this._def.checks.find((e) => "datetime" === e.kind);
        }
        get isEmail() {
          return !!this._def.checks.find((e) => "email" === e.kind);
        }
        get isURL() {
          return !!this._def.checks.find((e) => "url" === e.kind);
        }
        get isEmoji() {
          return !!this._def.checks.find((e) => "emoji" === e.kind);
        }
        get isUUID() {
          return !!this._def.checks.find((e) => "uuid" === e.kind);
        }
        get isCUID() {
          return !!this._def.checks.find((e) => "cuid" === e.kind);
        }
        get isCUID2() {
          return !!this._def.checks.find((e) => "cuid2" === e.kind);
        }
        get isULID() {
          return !!this._def.checks.find((e) => "ulid" === e.kind);
        }
        get isIP() {
          return !!this._def.checks.find((e) => "ip" === e.kind);
        }
        get minLength() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxLength() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
      }
      eo.create = (e) => {
        var t;
        return new eo({
          checks: [],
          typeName: h.ZodString,
          coerce:
            null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t,
          ...Q(e),
        });
      };
      class el extends Y {
        constructor() {
          super(...arguments),
            (this.min = this.gte),
            (this.max = this.lte),
            (this.step = this.multipleOf);
        }
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = Number(e.data)),
            this._getType(e) !== k.number)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              F(t, {
                code: D.invalid_type,
                expected: k.number,
                received: t.parsedType,
              }),
              H
            );
          }
          let r = new $();
          for (let i of this._def.checks)
            "int" === i.kind
              ? l.isInteger(e.data) ||
                (F((t = this._getOrReturnCtx(e, t)), {
                  code: D.invalid_type,
                  expected: "integer",
                  received: "float",
                  message: i.message,
                }),
                r.dirty())
              : "min" === i.kind
              ? (i.inclusive ? e.data < i.value : e.data <= i.value) &&
                (F((t = this._getOrReturnCtx(e, t)), {
                  code: D.too_small,
                  minimum: i.value,
                  type: "number",
                  inclusive: i.inclusive,
                  exact: !1,
                  message: i.message,
                }),
                r.dirty())
              : "max" === i.kind
              ? (i.inclusive ? e.data > i.value : e.data >= i.value) &&
                (F((t = this._getOrReturnCtx(e, t)), {
                  code: D.too_big,
                  maximum: i.value,
                  type: "number",
                  inclusive: i.inclusive,
                  exact: !1,
                  message: i.message,
                }),
                r.dirty())
              : "multipleOf" === i.kind
              ? 0 !==
                  (function (e, t) {
                    let r = (e.toString().split(".")[1] || "").length,
                      i = (t.toString().split(".")[1] || "").length,
                      n = r > i ? r : i;
                    return (
                      (parseInt(e.toFixed(n).replace(".", "")) %
                        parseInt(t.toFixed(n).replace(".", ""))) /
                      Math.pow(10, n)
                    );
                  })(e.data, i.value) &&
                (F((t = this._getOrReturnCtx(e, t)), {
                  code: D.not_multiple_of,
                  multipleOf: i.value,
                  message: i.message,
                }),
                r.dirty())
              : "finite" === i.kind
              ? Number.isFinite(e.data) ||
                (F((t = this._getOrReturnCtx(e, t)), {
                  code: D.not_finite,
                  message: i.message,
                }),
                r.dirty())
              : l.assertNever(i);
          return { status: r.value, value: e.data };
        }
        gte(e, t) {
          return this.setLimit("min", e, !0, u.toString(t));
        }
        gt(e, t) {
          return this.setLimit("min", e, !1, u.toString(t));
        }
        lte(e, t) {
          return this.setLimit("max", e, !0, u.toString(t));
        }
        lt(e, t) {
          return this.setLimit("max", e, !1, u.toString(t));
        }
        setLimit(e, t, r, i) {
          return new el({
            ...this._def,
            checks: [
              ...this._def.checks,
              { kind: e, value: t, inclusive: r, message: u.toString(i) },
            ],
          });
        }
        _addCheck(e) {
          return new el({ ...this._def, checks: [...this._def.checks, e] });
        }
        int(e) {
          return this._addCheck({ kind: "int", message: u.toString(e) });
        }
        positive(e) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: u.toString(e),
          });
        }
        negative(e) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: u.toString(e),
          });
        }
        nonpositive(e) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: u.toString(e),
          });
        }
        nonnegative(e) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: u.toString(e),
          });
        }
        multipleOf(e, t) {
          return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: u.toString(t),
          });
        }
        finite(e) {
          return this._addCheck({ kind: "finite", message: u.toString(e) });
        }
        safe(e) {
          return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: u.toString(e),
          })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: u.toString(e),
          });
        }
        get minValue() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxValue() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
        get isInt() {
          return !!this._def.checks.find(
            (e) =>
              "int" === e.kind ||
              ("multipleOf" === e.kind && l.isInteger(e.value))
          );
        }
        get isFinite() {
          let e = null,
            t = null;
          for (let r of this._def.checks) {
            if (
              "finite" === r.kind ||
              "int" === r.kind ||
              "multipleOf" === r.kind
            )
              return !0;
            "min" === r.kind
              ? (null === t || r.value > t) && (t = r.value)
              : "max" === r.kind &&
                (null === e || r.value < e) &&
                (e = r.value);
          }
          return Number.isFinite(t) && Number.isFinite(e);
        }
      }
      el.create = (e) =>
        new el({
          checks: [],
          typeName: h.ZodNumber,
          coerce: (null == e ? void 0 : e.coerce) || !1,
          ...Q(e),
        });
      class ec extends Y {
        constructor() {
          super(...arguments), (this.min = this.gte), (this.max = this.lte);
        }
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = BigInt(e.data)),
            this._getType(e) !== k.bigint)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              F(t, {
                code: D.invalid_type,
                expected: k.bigint,
                received: t.parsedType,
              }),
              H
            );
          }
          let r = new $();
          for (let i of this._def.checks)
            "min" === i.kind
              ? (i.inclusive ? e.data < i.value : e.data <= i.value) &&
                (F((t = this._getOrReturnCtx(e, t)), {
                  code: D.too_small,
                  type: "bigint",
                  minimum: i.value,
                  inclusive: i.inclusive,
                  message: i.message,
                }),
                r.dirty())
              : "max" === i.kind
              ? (i.inclusive ? e.data > i.value : e.data >= i.value) &&
                (F((t = this._getOrReturnCtx(e, t)), {
                  code: D.too_big,
                  type: "bigint",
                  maximum: i.value,
                  inclusive: i.inclusive,
                  message: i.message,
                }),
                r.dirty())
              : "multipleOf" === i.kind
              ? e.data % i.value !== BigInt(0) &&
                (F((t = this._getOrReturnCtx(e, t)), {
                  code: D.not_multiple_of,
                  multipleOf: i.value,
                  message: i.message,
                }),
                r.dirty())
              : l.assertNever(i);
          return { status: r.value, value: e.data };
        }
        gte(e, t) {
          return this.setLimit("min", e, !0, u.toString(t));
        }
        gt(e, t) {
          return this.setLimit("min", e, !1, u.toString(t));
        }
        lte(e, t) {
          return this.setLimit("max", e, !0, u.toString(t));
        }
        lt(e, t) {
          return this.setLimit("max", e, !1, u.toString(t));
        }
        setLimit(e, t, r, i) {
          return new ec({
            ...this._def,
            checks: [
              ...this._def.checks,
              { kind: e, value: t, inclusive: r, message: u.toString(i) },
            ],
          });
        }
        _addCheck(e) {
          return new ec({ ...this._def, checks: [...this._def.checks, e] });
        }
        positive(e) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: u.toString(e),
          });
        }
        negative(e) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: u.toString(e),
          });
        }
        nonpositive(e) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: u.toString(e),
          });
        }
        nonnegative(e) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: u.toString(e),
          });
        }
        multipleOf(e, t) {
          return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: u.toString(t),
          });
        }
        get minValue() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxValue() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
      }
      ec.create = (e) => {
        var t;
        return new ec({
          checks: [],
          typeName: h.ZodBigInt,
          coerce:
            null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t,
          ...Q(e),
        });
      };
      class eu extends Y {
        _parse(e) {
          if (
            (this._def.coerce && (e.data = !!e.data),
            this._getType(e) !== k.boolean)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              F(t, {
                code: D.invalid_type,
                expected: k.boolean,
                received: t.parsedType,
              }),
              H
            );
          }
          return q(e.data);
        }
      }
      eu.create = (e) =>
        new eu({
          typeName: h.ZodBoolean,
          coerce: (null == e ? void 0 : e.coerce) || !1,
          ...Q(e),
        });
      class eh extends Y {
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = new Date(e.data)),
            this._getType(e) !== k.date)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              F(t, {
                code: D.invalid_type,
                expected: k.date,
                received: t.parsedType,
              }),
              H
            );
          }
          if (isNaN(e.data.getTime()))
            return F(this._getOrReturnCtx(e), { code: D.invalid_date }), H;
          let r = new $();
          for (let i of this._def.checks)
            "min" === i.kind
              ? e.data.getTime() < i.value &&
                (F((t = this._getOrReturnCtx(e, t)), {
                  code: D.too_small,
                  message: i.message,
                  inclusive: !0,
                  exact: !1,
                  minimum: i.value,
                  type: "date",
                }),
                r.dirty())
              : "max" === i.kind
              ? e.data.getTime() > i.value &&
                (F((t = this._getOrReturnCtx(e, t)), {
                  code: D.too_big,
                  message: i.message,
                  inclusive: !0,
                  exact: !1,
                  maximum: i.value,
                  type: "date",
                }),
                r.dirty())
              : l.assertNever(i);
          return { status: r.value, value: new Date(e.data.getTime()) };
        }
        _addCheck(e) {
          return new eh({ ...this._def, checks: [...this._def.checks, e] });
        }
        min(e, t) {
          return this._addCheck({
            kind: "min",
            value: e.getTime(),
            message: u.toString(t),
          });
        }
        max(e, t) {
          return this._addCheck({
            kind: "max",
            value: e.getTime(),
            message: u.toString(t),
          });
        }
        get minDate() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return null != e ? new Date(e) : null;
        }
        get maxDate() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return null != e ? new Date(e) : null;
        }
      }
      eh.create = (e) =>
        new eh({
          checks: [],
          coerce: (null == e ? void 0 : e.coerce) || !1,
          typeName: h.ZodDate,
          ...Q(e),
        });
      class ed extends Y {
        _parse(e) {
          if (this._getType(e) !== k.symbol) {
            let t = this._getOrReturnCtx(e);
            return (
              F(t, {
                code: D.invalid_type,
                expected: k.symbol,
                received: t.parsedType,
              }),
              H
            );
          }
          return q(e.data);
        }
      }
      ed.create = (e) => new ed({ typeName: h.ZodSymbol, ...Q(e) });
      class ep extends Y {
        _parse(e) {
          if (this._getType(e) !== k.undefined) {
            let t = this._getOrReturnCtx(e);
            return (
              F(t, {
                code: D.invalid_type,
                expected: k.undefined,
                received: t.parsedType,
              }),
              H
            );
          }
          return q(e.data);
        }
      }
      ep.create = (e) => new ep({ typeName: h.ZodUndefined, ...Q(e) });
      class ef extends Y {
        _parse(e) {
          if (this._getType(e) !== k.null) {
            let t = this._getOrReturnCtx(e);
            return (
              F(t, {
                code: D.invalid_type,
                expected: k.null,
                received: t.parsedType,
              }),
              H
            );
          }
          return q(e.data);
        }
      }
      ef.create = (e) => new ef({ typeName: h.ZodNull, ...Q(e) });
      class eg extends Y {
        constructor() {
          super(...arguments), (this._any = !0);
        }
        _parse(e) {
          return q(e.data);
        }
      }
      eg.create = (e) => new eg({ typeName: h.ZodAny, ...Q(e) });
      class em extends Y {
        constructor() {
          super(...arguments), (this._unknown = !0);
        }
        _parse(e) {
          return q(e.data);
        }
      }
      em.create = (e) => new em({ typeName: h.ZodUnknown, ...Q(e) });
      class ey extends Y {
        _parse(e) {
          let t = this._getOrReturnCtx(e);
          return (
            F(t, {
              code: D.invalid_type,
              expected: k.never,
              received: t.parsedType,
            }),
            H
          );
        }
      }
      ey.create = (e) => new ey({ typeName: h.ZodNever, ...Q(e) });
      class ew extends Y {
        _parse(e) {
          if (this._getType(e) !== k.undefined) {
            let t = this._getOrReturnCtx(e);
            return (
              F(t, {
                code: D.invalid_type,
                expected: k.void,
                received: t.parsedType,
              }),
              H
            );
          }
          return q(e.data);
        }
      }
      ew.create = (e) => new ew({ typeName: h.ZodVoid, ...Q(e) });
      class eb extends Y {
        _parse(e) {
          let { ctx: t, status: r } = this._processInputParams(e),
            i = this._def;
          if (t.parsedType !== k.array)
            return (
              F(t, {
                code: D.invalid_type,
                expected: k.array,
                received: t.parsedType,
              }),
              H
            );
          if (null !== i.exactLength) {
            let e = t.data.length > i.exactLength.value,
              n = t.data.length < i.exactLength.value;
            (e || n) &&
              (F(t, {
                code: e ? D.too_big : D.too_small,
                minimum: n ? i.exactLength.value : void 0,
                maximum: e ? i.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i.exactLength.message,
              }),
              r.dirty());
          }
          if (
            (null !== i.minLength &&
              t.data.length < i.minLength.value &&
              (F(t, {
                code: D.too_small,
                minimum: i.minLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.minLength.message,
              }),
              r.dirty()),
            null !== i.maxLength &&
              t.data.length > i.maxLength.value &&
              (F(t, {
                code: D.too_big,
                maximum: i.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.maxLength.message,
              }),
              r.dirty()),
            t.common.async)
          )
            return Promise.all(
              [...t.data].map((e, r) =>
                i.type._parseAsync(new Z(t, e, t.path, r))
              )
            ).then((e) => $.mergeArray(r, e));
          let n = [...t.data].map((e, r) =>
            i.type._parseSync(new Z(t, e, t.path, r))
          );
          return $.mergeArray(r, n);
        }
        get element() {
          return this._def.type;
        }
        min(e, t) {
          return new eb({
            ...this._def,
            minLength: { value: e, message: u.toString(t) },
          });
        }
        max(e, t) {
          return new eb({
            ...this._def,
            maxLength: { value: e, message: u.toString(t) },
          });
        }
        length(e, t) {
          return new eb({
            ...this._def,
            exactLength: { value: e, message: u.toString(t) },
          });
        }
        nonempty(e) {
          return this.min(1, e);
        }
      }
      eb.create = (e, t) =>
        new eb({
          type: e,
          minLength: null,
          maxLength: null,
          exactLength: null,
          typeName: h.ZodArray,
          ...Q(t),
        });
      class ev extends Y {
        constructor() {
          super(...arguments),
            (this._cached = null),
            (this.nonstrict = this.passthrough),
            (this.augment = this.extend);
        }
        _getCached() {
          if (null !== this._cached) return this._cached;
          let e = this._def.shape(),
            t = l.objectKeys(e);
          return (this._cached = { shape: e, keys: t });
        }
        _parse(e) {
          if (this._getType(e) !== k.object) {
            let t = this._getOrReturnCtx(e);
            return (
              F(t, {
                code: D.invalid_type,
                expected: k.object,
                received: t.parsedType,
              }),
              H
            );
          }
          let { status: t, ctx: r } = this._processInputParams(e),
            { shape: i, keys: n } = this._getCached(),
            s = [];
          if (
            !(
              this._def.catchall instanceof ey &&
              "strip" === this._def.unknownKeys
            )
          )
            for (let e in r.data) n.includes(e) || s.push(e);
          let a = [];
          for (let e of n) {
            let t = i[e],
              n = r.data[e];
            a.push({
              key: { status: "valid", value: e },
              value: t._parse(new Z(r, n, r.path, e)),
              alwaysSet: e in r.data,
            });
          }
          if (this._def.catchall instanceof ey) {
            let e = this._def.unknownKeys;
            if ("passthrough" === e)
              for (let e of s)
                a.push({
                  key: { status: "valid", value: e },
                  value: { status: "valid", value: r.data[e] },
                });
            else if ("strict" === e)
              s.length > 0 &&
                (F(r, { code: D.unrecognized_keys, keys: s }), t.dirty());
            else if ("strip" === e);
            else
              throw Error(
                "Internal ZodObject error: invalid unknownKeys value."
              );
          } else {
            let e = this._def.catchall;
            for (let t of s) {
              let i = r.data[t];
              a.push({
                key: { status: "valid", value: t },
                value: e._parse(new Z(r, i, r.path, t)),
                alwaysSet: t in r.data,
              });
            }
          }
          return r.common.async
            ? Promise.resolve()
                .then(async () => {
                  let e = [];
                  for (let t of a) {
                    let r = await t.key;
                    e.push({
                      key: r,
                      value: await t.value,
                      alwaysSet: t.alwaysSet,
                    });
                  }
                  return e;
                })
                .then((e) => $.mergeObjectSync(t, e))
            : $.mergeObjectSync(t, a);
        }
        get shape() {
          return this._def.shape();
        }
        strict(e) {
          return (
            u.errToObj,
            new ev({
              ...this._def,
              unknownKeys: "strict",
              ...(void 0 !== e
                ? {
                    errorMap: (t, r) => {
                      var i, n, s, a;
                      let o =
                        null !==
                          (s =
                            null === (n = (i = this._def).errorMap) ||
                            void 0 === n
                              ? void 0
                              : n.call(i, t, r).message) && void 0 !== s
                          ? s
                          : r.defaultError;
                      return "unrecognized_keys" === t.code
                        ? {
                            message:
                              null !== (a = u.errToObj(e).message) &&
                              void 0 !== a
                                ? a
                                : o,
                          }
                        : { message: o };
                    },
                  }
                : {}),
            })
          );
        }
        strip() {
          return new ev({ ...this._def, unknownKeys: "strip" });
        }
        passthrough() {
          return new ev({ ...this._def, unknownKeys: "passthrough" });
        }
        extend(e) {
          return new ev({
            ...this._def,
            shape: () => ({ ...this._def.shape(), ...e }),
          });
        }
        merge(e) {
          return new ev({
            unknownKeys: e._def.unknownKeys,
            catchall: e._def.catchall,
            shape: () => ({ ...this._def.shape(), ...e._def.shape() }),
            typeName: h.ZodObject,
          });
        }
        setKey(e, t) {
          return this.augment({ [e]: t });
        }
        catchall(e) {
          return new ev({ ...this._def, catchall: e });
        }
        pick(e) {
          let t = {};
          return (
            l.objectKeys(e).forEach((r) => {
              e[r] && this.shape[r] && (t[r] = this.shape[r]);
            }),
            new ev({ ...this._def, shape: () => t })
          );
        }
        omit(e) {
          let t = {};
          return (
            l.objectKeys(this.shape).forEach((r) => {
              e[r] || (t[r] = this.shape[r]);
            }),
            new ev({ ...this._def, shape: () => t })
          );
        }
        deepPartial() {
          return (function e(t) {
            if (t instanceof ev) {
              let r = {};
              for (let i in t.shape) {
                let n = t.shape[i];
                r[i] = eM.create(e(n));
              }
              return new ev({ ...t._def, shape: () => r });
            }
            return t instanceof eb
              ? new eb({ ...t._def, type: e(t.element) })
              : t instanceof eM
              ? eM.create(e(t.unwrap()))
              : t instanceof eB
              ? eB.create(e(t.unwrap()))
              : t instanceof eI
              ? eI.create(t.items.map((t) => e(t)))
              : t;
          })(this);
        }
        partial(e) {
          let t = {};
          return (
            l.objectKeys(this.shape).forEach((r) => {
              let i = this.shape[r];
              e && !e[r] ? (t[r] = i) : (t[r] = i.optional());
            }),
            new ev({ ...this._def, shape: () => t })
          );
        }
        required(e) {
          let t = {};
          return (
            l.objectKeys(this.shape).forEach((r) => {
              if (e && !e[r]) t[r] = this.shape[r];
              else {
                let e = this.shape[r];
                for (; e instanceof eM; ) e = e._def.innerType;
                t[r] = e;
              }
            }),
            new ev({ ...this._def, shape: () => t })
          );
        }
        keyof() {
          return ek(l.objectKeys(this.shape));
        }
      }
      (ev.create = (e, t) =>
        new ev({
          shape: () => e,
          unknownKeys: "strip",
          catchall: ey.create(),
          typeName: h.ZodObject,
          ...Q(t),
        })),
        (ev.strictCreate = (e, t) =>
          new ev({
            shape: () => e,
            unknownKeys: "strict",
            catchall: ey.create(),
            typeName: h.ZodObject,
            ...Q(t),
          })),
        (ev.lazycreate = (e, t) =>
          new ev({
            shape: e,
            unknownKeys: "strip",
            catchall: ey.create(),
            typeName: h.ZodObject,
            ...Q(t),
          }));
      class eE extends Y {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = this._def.options;
          if (t.common.async)
            return Promise.all(
              r.map(async (e) => {
                let r = {
                  ...t,
                  common: { ...t.common, issues: [] },
                  parent: null,
                };
                return {
                  result: await e._parseAsync({
                    data: t.data,
                    path: t.path,
                    parent: r,
                  }),
                  ctx: r,
                };
              })
            ).then(function (e) {
              for (let t of e) if ("valid" === t.result.status) return t.result;
              for (let r of e)
                if ("dirty" === r.result.status)
                  return t.common.issues.push(...r.ctx.common.issues), r.result;
              let r = e.map((e) => new U(e.ctx.common.issues));
              return F(t, { code: D.invalid_union, unionErrors: r }), H;
            });
          {
            let e;
            let i = [];
            for (let n of r) {
              let r = {
                  ...t,
                  common: { ...t.common, issues: [] },
                  parent: null,
                },
                s = n._parseSync({ data: t.data, path: t.path, parent: r });
              if ("valid" === s.status) return s;
              "dirty" !== s.status || e || (e = { result: s, ctx: r }),
                r.common.issues.length && i.push(r.common.issues);
            }
            if (e)
              return t.common.issues.push(...e.ctx.common.issues), e.result;
            let n = i.map((e) => new U(e));
            return F(t, { code: D.invalid_union, unionErrors: n }), H;
          }
        }
        get options() {
          return this._def.options;
        }
      }
      eE.create = (e, t) =>
        new eE({ options: e, typeName: h.ZodUnion, ...Q(t) });
      let eA = (e) => {
        if (e instanceof eO) return eA(e.schema);
        if (e instanceof eL) return eA(e.innerType());
        if (e instanceof ex) return [e.value];
        if (e instanceof eR) return e.options;
        if (e instanceof eD) return Object.keys(e.enum);
        if (e instanceof ej) return eA(e._def.innerType);
        if (e instanceof ep) return [void 0];
        else if (e instanceof ef) return [null];
        else return null;
      };
      class eC extends Y {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          if (t.parsedType !== k.object)
            return (
              F(t, {
                code: D.invalid_type,
                expected: k.object,
                received: t.parsedType,
              }),
              H
            );
          let r = this.discriminator,
            i = t.data[r],
            n = this.optionsMap.get(i);
          return n
            ? t.common.async
              ? n._parseAsync({ data: t.data, path: t.path, parent: t })
              : n._parseSync({ data: t.data, path: t.path, parent: t })
            : (F(t, {
                code: D.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [r],
              }),
              H);
        }
        get discriminator() {
          return this._def.discriminator;
        }
        get options() {
          return this._def.options;
        }
        get optionsMap() {
          return this._def.optionsMap;
        }
        static create(e, t, r) {
          let i = new Map();
          for (let r of t) {
            let t = eA(r.shape[e]);
            if (!t)
              throw Error(
                `A discriminator value for key \`${e}\` could not be extracted from all schema options`
              );
            for (let n of t) {
              if (i.has(n))
                throw Error(
                  `Discriminator property ${String(
                    e
                  )} has duplicate value ${String(n)}`
                );
              i.set(n, r);
            }
          }
          return new eC({
            typeName: h.ZodDiscriminatedUnion,
            discriminator: e,
            options: t,
            optionsMap: i,
            ...Q(r),
          });
        }
      }
      class e_ extends Y {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e),
            i = (e, i) => {
              if (V(e) || V(i)) return H;
              let n = (function e(t, r) {
                let i = R(t),
                  n = R(r);
                if (t === r) return { valid: !0, data: t };
                if (i === k.object && n === k.object) {
                  let i = l.objectKeys(r),
                    n = l.objectKeys(t).filter((e) => -1 !== i.indexOf(e)),
                    s = { ...t, ...r };
                  for (let i of n) {
                    let n = e(t[i], r[i]);
                    if (!n.valid) return { valid: !1 };
                    s[i] = n.data;
                  }
                  return { valid: !0, data: s };
                }
                if (i === k.array && n === k.array) {
                  if (t.length !== r.length) return { valid: !1 };
                  let i = [];
                  for (let n = 0; n < t.length; n++) {
                    let s = e(t[n], r[n]);
                    if (!s.valid) return { valid: !1 };
                    i.push(s.data);
                  }
                  return { valid: !0, data: i };
                }
                return i === k.date && n === k.date && +t == +r
                  ? { valid: !0, data: t }
                  : { valid: !1 };
              })(e.value, i.value);
              return n.valid
                ? ((G(e) || G(i)) && t.dirty(),
                  { status: t.value, value: n.data })
                : (F(r, { code: D.invalid_intersection_types }), H);
            };
          return r.common.async
            ? Promise.all([
                this._def.left._parseAsync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                }),
                this._def.right._parseAsync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                }),
              ]).then(([e, t]) => i(e, t))
            : i(
                this._def.left._parseSync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                }),
                this._def.right._parseSync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                })
              );
        }
      }
      e_.create = (e, t, r) =>
        new e_({ left: e, right: t, typeName: h.ZodIntersection, ...Q(r) });
      class eI extends Y {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== k.array)
            return (
              F(r, {
                code: D.invalid_type,
                expected: k.array,
                received: r.parsedType,
              }),
              H
            );
          if (r.data.length < this._def.items.length)
            return (
              F(r, {
                code: D.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array",
              }),
              H
            );
          !this._def.rest &&
            r.data.length > this._def.items.length &&
            (F(r, {
              code: D.too_big,
              maximum: this._def.items.length,
              inclusive: !0,
              exact: !1,
              type: "array",
            }),
            t.dirty());
          let i = [...r.data]
            .map((e, t) => {
              let i = this._def.items[t] || this._def.rest;
              return i ? i._parse(new Z(r, e, r.path, t)) : null;
            })
            .filter((e) => !!e);
          return r.common.async
            ? Promise.all(i).then((e) => $.mergeArray(t, e))
            : $.mergeArray(t, i);
        }
        get items() {
          return this._def.items;
        }
        rest(e) {
          return new eI({ ...this._def, rest: e });
        }
      }
      eI.create = (e, t) => {
        if (!Array.isArray(e))
          throw Error("You must pass an array of schemas to z.tuple([ ... ])");
        return new eI({ items: e, typeName: h.ZodTuple, rest: null, ...Q(t) });
      };
      class eN extends Y {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== k.object)
            return (
              F(r, {
                code: D.invalid_type,
                expected: k.object,
                received: r.parsedType,
              }),
              H
            );
          let i = [],
            n = this._def.keyType,
            s = this._def.valueType;
          for (let e in r.data)
            i.push({
              key: n._parse(new Z(r, e, r.path, e)),
              value: s._parse(new Z(r, r.data[e], r.path, e)),
            });
          return r.common.async
            ? $.mergeObjectAsync(t, i)
            : $.mergeObjectSync(t, i);
        }
        get element() {
          return this._def.valueType;
        }
        static create(e, t, r) {
          return new eN(
            t instanceof Y
              ? { keyType: e, valueType: t, typeName: h.ZodRecord, ...Q(r) }
              : {
                  keyType: eo.create(),
                  valueType: e,
                  typeName: h.ZodRecord,
                  ...Q(t),
                }
          );
        }
      }
      class eS extends Y {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== k.map)
            return (
              F(r, {
                code: D.invalid_type,
                expected: k.map,
                received: r.parsedType,
              }),
              H
            );
          let i = this._def.keyType,
            n = this._def.valueType,
            s = [...r.data.entries()].map(([e, t], s) => ({
              key: i._parse(new Z(r, e, r.path, [s, "key"])),
              value: n._parse(new Z(r, t, r.path, [s, "value"])),
            }));
          if (r.common.async) {
            let e = new Map();
            return Promise.resolve().then(async () => {
              for (let r of s) {
                let i = await r.key,
                  n = await r.value;
                if ("aborted" === i.status || "aborted" === n.status) return H;
                ("dirty" === i.status || "dirty" === n.status) && t.dirty(),
                  e.set(i.value, n.value);
              }
              return { status: t.value, value: e };
            });
          }
          {
            let e = new Map();
            for (let r of s) {
              let i = r.key,
                n = r.value;
              if ("aborted" === i.status || "aborted" === n.status) return H;
              ("dirty" === i.status || "dirty" === n.status) && t.dirty(),
                e.set(i.value, n.value);
            }
            return { status: t.value, value: e };
          }
        }
      }
      eS.create = (e, t, r) =>
        new eS({ valueType: t, keyType: e, typeName: h.ZodMap, ...Q(r) });
      class eT extends Y {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== k.set)
            return (
              F(r, {
                code: D.invalid_type,
                expected: k.set,
                received: r.parsedType,
              }),
              H
            );
          let i = this._def;
          null !== i.minSize &&
            r.data.size < i.minSize.value &&
            (F(r, {
              code: D.too_small,
              minimum: i.minSize.value,
              type: "set",
              inclusive: !0,
              exact: !1,
              message: i.minSize.message,
            }),
            t.dirty()),
            null !== i.maxSize &&
              r.data.size > i.maxSize.value &&
              (F(r, {
                code: D.too_big,
                maximum: i.maxSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: i.maxSize.message,
              }),
              t.dirty());
          let n = this._def.valueType;
          function s(e) {
            let r = new Set();
            for (let i of e) {
              if ("aborted" === i.status) return H;
              "dirty" === i.status && t.dirty(), r.add(i.value);
            }
            return { status: t.value, value: r };
          }
          let a = [...r.data.values()].map((e, t) =>
            n._parse(new Z(r, e, r.path, t))
          );
          return r.common.async ? Promise.all(a).then((e) => s(e)) : s(a);
        }
        min(e, t) {
          return new eT({
            ...this._def,
            minSize: { value: e, message: u.toString(t) },
          });
        }
        max(e, t) {
          return new eT({
            ...this._def,
            maxSize: { value: e, message: u.toString(t) },
          });
        }
        size(e, t) {
          return this.min(e, t).max(e, t);
        }
        nonempty(e) {
          return this.min(1, e);
        }
      }
      eT.create = (e, t) =>
        new eT({
          valueType: e,
          minSize: null,
          maxSize: null,
          typeName: h.ZodSet,
          ...Q(t),
        });
      class eP extends Y {
        constructor() {
          super(...arguments), (this.validate = this.implement);
        }
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          if (t.parsedType !== k.function)
            return (
              F(t, {
                code: D.invalid_type,
                expected: k.function,
                received: t.parsedType,
              }),
              H
            );
          function r(e, r) {
            return j({
              data: e,
              path: t.path,
              errorMaps: [
                t.common.contextualErrorMap,
                t.schemaErrorMap,
                B(),
                L,
              ].filter((e) => !!e),
              issueData: { code: D.invalid_arguments, argumentsError: r },
            });
          }
          function i(e, r) {
            return j({
              data: e,
              path: t.path,
              errorMaps: [
                t.common.contextualErrorMap,
                t.schemaErrorMap,
                B(),
                L,
              ].filter((e) => !!e),
              issueData: { code: D.invalid_return_type, returnTypeError: r },
            });
          }
          let n = { errorMap: t.common.contextualErrorMap },
            s = t.data;
          if (this._def.returns instanceof eU) {
            let e = this;
            return q(async function (...t) {
              let a = new U([]),
                o = await e._def.args.parseAsync(t, n).catch((e) => {
                  throw (a.addIssue(r(t, e)), a);
                }),
                l = await Reflect.apply(s, this, o);
              return await e._def.returns._def.type
                .parseAsync(l, n)
                .catch((e) => {
                  throw (a.addIssue(i(l, e)), a);
                });
            });
          }
          {
            let e = this;
            return q(function (...t) {
              let a = e._def.args.safeParse(t, n);
              if (!a.success) throw new U([r(t, a.error)]);
              let o = Reflect.apply(s, this, a.data),
                l = e._def.returns.safeParse(o, n);
              if (!l.success) throw new U([i(o, l.error)]);
              return l.data;
            });
          }
        }
        parameters() {
          return this._def.args;
        }
        returnType() {
          return this._def.returns;
        }
        args(...e) {
          return new eP({ ...this._def, args: eI.create(e).rest(em.create()) });
        }
        returns(e) {
          return new eP({ ...this._def, returns: e });
        }
        implement(e) {
          return this.parse(e);
        }
        strictImplement(e) {
          return this.parse(e);
        }
        static create(e, t, r) {
          return new eP({
            args: e || eI.create([]).rest(em.create()),
            returns: t || em.create(),
            typeName: h.ZodFunction,
            ...Q(r),
          });
        }
      }
      class eO extends Y {
        get schema() {
          return this._def.getter();
        }
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          return this._def
            .getter()
            ._parse({ data: t.data, path: t.path, parent: t });
        }
      }
      eO.create = (e, t) => new eO({ getter: e, typeName: h.ZodLazy, ...Q(t) });
      class ex extends Y {
        _parse(e) {
          if (e.data !== this._def.value) {
            let t = this._getOrReturnCtx(e);
            return (
              F(t, {
                received: t.data,
                code: D.invalid_literal,
                expected: this._def.value,
              }),
              H
            );
          }
          return { status: "valid", value: e.data };
        }
        get value() {
          return this._def.value;
        }
      }
      function ek(e, t) {
        return new eR({ values: e, typeName: h.ZodEnum, ...Q(t) });
      }
      ex.create = (e, t) =>
        new ex({ value: e, typeName: h.ZodLiteral, ...Q(t) });
      class eR extends Y {
        _parse(e) {
          if ("string" != typeof e.data) {
            let t = this._getOrReturnCtx(e),
              r = this._def.values;
            return (
              F(t, {
                expected: l.joinValues(r),
                received: t.parsedType,
                code: D.invalid_type,
              }),
              H
            );
          }
          if (-1 === this._def.values.indexOf(e.data)) {
            let t = this._getOrReturnCtx(e),
              r = this._def.values;
            return (
              F(t, {
                received: t.data,
                code: D.invalid_enum_value,
                options: r,
              }),
              H
            );
          }
          return q(e.data);
        }
        get options() {
          return this._def.values;
        }
        get enum() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        get Values() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        get Enum() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        extract(e) {
          return eR.create(e);
        }
        exclude(e) {
          return eR.create(this.options.filter((t) => !e.includes(t)));
        }
      }
      eR.create = ek;
      class eD extends Y {
        _parse(e) {
          let t = l.getValidEnumValues(this._def.values),
            r = this._getOrReturnCtx(e);
          if (r.parsedType !== k.string && r.parsedType !== k.number) {
            let e = l.objectValues(t);
            return (
              F(r, {
                expected: l.joinValues(e),
                received: r.parsedType,
                code: D.invalid_type,
              }),
              H
            );
          }
          if (-1 === t.indexOf(e.data)) {
            let e = l.objectValues(t);
            return (
              F(r, {
                received: r.data,
                code: D.invalid_enum_value,
                options: e,
              }),
              H
            );
          }
          return q(e.data);
        }
        get enum() {
          return this._def.values;
        }
      }
      eD.create = (e, t) =>
        new eD({ values: e, typeName: h.ZodNativeEnum, ...Q(t) });
      class eU extends Y {
        unwrap() {
          return this._def.type;
        }
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          return t.parsedType !== k.promise && !1 === t.common.async
            ? (F(t, {
                code: D.invalid_type,
                expected: k.promise,
                received: t.parsedType,
              }),
              H)
            : q(
                (t.parsedType === k.promise
                  ? t.data
                  : Promise.resolve(t.data)
                ).then((e) =>
                  this._def.type.parseAsync(e, {
                    path: t.path,
                    errorMap: t.common.contextualErrorMap,
                  })
                )
              );
        }
      }
      eU.create = (e, t) =>
        new eU({ type: e, typeName: h.ZodPromise, ...Q(t) });
      class eL extends Y {
        innerType() {
          return this._def.schema;
        }
        sourceType() {
          return this._def.schema._def.typeName === h.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
        }
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e),
            i = this._def.effect || null,
            n = {
              addIssue: (e) => {
                F(r, e), e.fatal ? t.abort() : t.dirty();
              },
              get path() {
                return r.path;
              },
            };
          if (((n.addIssue = n.addIssue.bind(n)), "preprocess" === i.type)) {
            let e = i.transform(r.data, n);
            return r.common.issues.length
              ? { status: "dirty", value: r.data }
              : r.common.async
              ? Promise.resolve(e).then((e) =>
                  this._def.schema._parseAsync({
                    data: e,
                    path: r.path,
                    parent: r,
                  })
                )
              : this._def.schema._parseSync({
                  data: e,
                  path: r.path,
                  parent: r,
                });
          }
          if ("refinement" === i.type) {
            let e = (e) => {
              let t = i.refinement(e, n);
              if (r.common.async) return Promise.resolve(t);
              if (t instanceof Promise)
                throw Error(
                  "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
                );
              return e;
            };
            if (!1 !== r.common.async)
              return this._def.schema
                ._parseAsync({ data: r.data, path: r.path, parent: r })
                .then((r) =>
                  "aborted" === r.status
                    ? H
                    : ("dirty" === r.status && t.dirty(),
                      e(r.value).then(() => ({
                        status: t.value,
                        value: r.value,
                      })))
                );
            {
              let i = this._def.schema._parseSync({
                data: r.data,
                path: r.path,
                parent: r,
              });
              return "aborted" === i.status
                ? H
                : ("dirty" === i.status && t.dirty(),
                  e(i.value),
                  { status: t.value, value: i.value });
            }
          }
          if ("transform" === i.type) {
            if (!1 !== r.common.async)
              return this._def.schema
                ._parseAsync({ data: r.data, path: r.path, parent: r })
                .then((e) =>
                  W(e)
                    ? Promise.resolve(i.transform(e.value, n)).then((e) => ({
                        status: t.value,
                        value: e,
                      }))
                    : e
                );
            {
              let e = this._def.schema._parseSync({
                data: r.data,
                path: r.path,
                parent: r,
              });
              if (!W(e)) return e;
              let s = i.transform(e.value, n);
              if (s instanceof Promise)
                throw Error(
                  "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
                );
              return { status: t.value, value: s };
            }
          }
          l.assertNever(i);
        }
      }
      (eL.create = (e, t, r) =>
        new eL({ schema: e, typeName: h.ZodEffects, effect: t, ...Q(r) })),
        (eL.createWithPreprocess = (e, t, r) =>
          new eL({
            schema: t,
            effect: { type: "preprocess", transform: e },
            typeName: h.ZodEffects,
            ...Q(r),
          }));
      class eM extends Y {
        _parse(e) {
          return this._getType(e) === k.undefined
            ? q(void 0)
            : this._def.innerType._parse(e);
        }
        unwrap() {
          return this._def.innerType;
        }
      }
      eM.create = (e, t) =>
        new eM({ innerType: e, typeName: h.ZodOptional, ...Q(t) });
      class eB extends Y {
        _parse(e) {
          return this._getType(e) === k.null
            ? q(null)
            : this._def.innerType._parse(e);
        }
        unwrap() {
          return this._def.innerType;
        }
      }
      eB.create = (e, t) =>
        new eB({ innerType: e, typeName: h.ZodNullable, ...Q(t) });
      class ej extends Y {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = t.data;
          return (
            t.parsedType === k.undefined && (r = this._def.defaultValue()),
            this._def.innerType._parse({ data: r, path: t.path, parent: t })
          );
        }
        removeDefault() {
          return this._def.innerType;
        }
      }
      ej.create = (e, t) =>
        new ej({
          innerType: e,
          typeName: h.ZodDefault,
          defaultValue:
            "function" == typeof t.default ? t.default : () => t.default,
          ...Q(t),
        });
      class eF extends Y {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = { ...t, common: { ...t.common, issues: [] } },
            i = this._def.innerType._parse({
              data: r.data,
              path: r.path,
              parent: { ...r },
            });
          return K(i)
            ? i.then((e) => ({
                status: "valid",
                value:
                  "valid" === e.status
                    ? e.value
                    : this._def.catchValue({
                        get error() {
                          return new U(r.common.issues);
                        },
                        input: r.data,
                      }),
              }))
            : {
                status: "valid",
                value:
                  "valid" === i.status
                    ? i.value
                    : this._def.catchValue({
                        get error() {
                          return new U(r.common.issues);
                        },
                        input: r.data,
                      }),
              };
        }
        removeCatch() {
          return this._def.innerType;
        }
      }
      eF.create = (e, t) =>
        new eF({
          innerType: e,
          typeName: h.ZodCatch,
          catchValue: "function" == typeof t.catch ? t.catch : () => t.catch,
          ...Q(t),
        });
      class e$ extends Y {
        _parse(e) {
          if (this._getType(e) !== k.nan) {
            let t = this._getOrReturnCtx(e);
            return (
              F(t, {
                code: D.invalid_type,
                expected: k.nan,
                received: t.parsedType,
              }),
              H
            );
          }
          return { status: "valid", value: e.data };
        }
      }
      e$.create = (e) => new e$({ typeName: h.ZodNaN, ...Q(e) });
      let eH = Symbol("zod_brand");
      class ez extends Y {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = t.data;
          return this._def.type._parse({ data: r, path: t.path, parent: t });
        }
        unwrap() {
          return this._def.type;
        }
      }
      class eq extends Y {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.common.async)
            return (async () => {
              let e = await this._def.in._parseAsync({
                data: r.data,
                path: r.path,
                parent: r,
              });
              return "aborted" === e.status
                ? H
                : "dirty" === e.status
                ? (t.dirty(), z(e.value))
                : this._def.out._parseAsync({
                    data: e.value,
                    path: r.path,
                    parent: r,
                  });
            })();
          {
            let e = this._def.in._parseSync({
              data: r.data,
              path: r.path,
              parent: r,
            });
            return "aborted" === e.status
              ? H
              : "dirty" === e.status
              ? (t.dirty(), { status: "dirty", value: e.value })
              : this._def.out._parseSync({
                  data: e.value,
                  path: r.path,
                  parent: r,
                });
          }
        }
        static create(e, t) {
          return new eq({ in: e, out: t, typeName: h.ZodPipeline });
        }
      }
      class eV extends Y {
        _parse(e) {
          let t = this._def.innerType._parse(e);
          return W(t) && (t.value = Object.freeze(t.value)), t;
        }
      }
      eV.create = (e, t) =>
        new eV({ innerType: e, typeName: h.ZodReadonly, ...Q(t) });
      let eG = (e, t = {}, r) =>
          e
            ? eg.create().superRefine((i, n) => {
                var s, a;
                if (!e(i)) {
                  let e =
                      "function" == typeof t
                        ? t(i)
                        : "string" == typeof t
                        ? { message: t }
                        : t,
                    o =
                      null ===
                        (a = null !== (s = e.fatal) && void 0 !== s ? s : r) ||
                      void 0 === a ||
                      a;
                  n.addIssue({
                    code: "custom",
                    ...("string" == typeof e ? { message: e } : e),
                    fatal: o,
                  });
                }
              })
            : eg.create(),
        eW = { object: ev.lazycreate };
      ((o = h || (h = {})).ZodString = "ZodString"),
        (o.ZodNumber = "ZodNumber"),
        (o.ZodNaN = "ZodNaN"),
        (o.ZodBigInt = "ZodBigInt"),
        (o.ZodBoolean = "ZodBoolean"),
        (o.ZodDate = "ZodDate"),
        (o.ZodSymbol = "ZodSymbol"),
        (o.ZodUndefined = "ZodUndefined"),
        (o.ZodNull = "ZodNull"),
        (o.ZodAny = "ZodAny"),
        (o.ZodUnknown = "ZodUnknown"),
        (o.ZodNever = "ZodNever"),
        (o.ZodVoid = "ZodVoid"),
        (o.ZodArray = "ZodArray"),
        (o.ZodObject = "ZodObject"),
        (o.ZodUnion = "ZodUnion"),
        (o.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
        (o.ZodIntersection = "ZodIntersection"),
        (o.ZodTuple = "ZodTuple"),
        (o.ZodRecord = "ZodRecord"),
        (o.ZodMap = "ZodMap"),
        (o.ZodSet = "ZodSet"),
        (o.ZodFunction = "ZodFunction"),
        (o.ZodLazy = "ZodLazy"),
        (o.ZodLiteral = "ZodLiteral"),
        (o.ZodEnum = "ZodEnum"),
        (o.ZodEffects = "ZodEffects"),
        (o.ZodNativeEnum = "ZodNativeEnum"),
        (o.ZodOptional = "ZodOptional"),
        (o.ZodNullable = "ZodNullable"),
        (o.ZodDefault = "ZodDefault"),
        (o.ZodCatch = "ZodCatch"),
        (o.ZodPromise = "ZodPromise"),
        (o.ZodBranded = "ZodBranded"),
        (o.ZodPipeline = "ZodPipeline"),
        (o.ZodReadonly = "ZodReadonly");
      let eK = eo.create,
        eZ = el.create,
        eJ = e$.create,
        eQ = ec.create,
        eY = eu.create,
        eX = eh.create,
        e0 = ed.create,
        e1 = ep.create,
        e2 = ef.create,
        e3 = eg.create,
        e5 = em.create,
        e8 = ey.create,
        e4 = ew.create,
        e6 = eb.create,
        e9 = ev.create,
        e7 = ev.strictCreate,
        te = eE.create,
        tt = eC.create,
        tr = e_.create,
        ti = eI.create,
        tn = eN.create,
        ts = eS.create,
        ta = eT.create,
        to = eP.create,
        tl = eO.create,
        tc = ex.create,
        tu = eR.create,
        th = eD.create,
        td = eU.create,
        tp = eL.create,
        tf = eM.create,
        tg = eB.create,
        tm = eL.createWithPreprocess,
        ty = eq.create;
      var tw = Object.freeze({
        __proto__: null,
        defaultErrorMap: L,
        setErrorMap: function (e) {
          M = e;
        },
        getErrorMap: B,
        makeIssue: j,
        EMPTY_PATH: [],
        addIssueToContext: F,
        ParseStatus: $,
        INVALID: H,
        DIRTY: z,
        OK: q,
        isAborted: V,
        isDirty: G,
        isValid: W,
        isAsync: K,
        get util() {
          return l;
        },
        get objectUtil() {
          return c;
        },
        ZodParsedType: k,
        getParsedType: R,
        ZodType: Y,
        ZodString: eo,
        ZodNumber: el,
        ZodBigInt: ec,
        ZodBoolean: eu,
        ZodDate: eh,
        ZodSymbol: ed,
        ZodUndefined: ep,
        ZodNull: ef,
        ZodAny: eg,
        ZodUnknown: em,
        ZodNever: ey,
        ZodVoid: ew,
        ZodArray: eb,
        ZodObject: ev,
        ZodUnion: eE,
        ZodDiscriminatedUnion: eC,
        ZodIntersection: e_,
        ZodTuple: eI,
        ZodRecord: eN,
        ZodMap: eS,
        ZodSet: eT,
        ZodFunction: eP,
        ZodLazy: eO,
        ZodLiteral: ex,
        ZodEnum: eR,
        ZodNativeEnum: eD,
        ZodPromise: eU,
        ZodEffects: eL,
        ZodTransformer: eL,
        ZodOptional: eM,
        ZodNullable: eB,
        ZodDefault: ej,
        ZodCatch: eF,
        ZodNaN: e$,
        BRAND: eH,
        ZodBranded: ez,
        ZodPipeline: eq,
        ZodReadonly: eV,
        custom: eG,
        Schema: Y,
        ZodSchema: Y,
        late: eW,
        get ZodFirstPartyTypeKind() {
          return h;
        },
        coerce: {
          string: (e) => eo.create({ ...e, coerce: !0 }),
          number: (e) => el.create({ ...e, coerce: !0 }),
          boolean: (e) => eu.create({ ...e, coerce: !0 }),
          bigint: (e) => ec.create({ ...e, coerce: !0 }),
          date: (e) => eh.create({ ...e, coerce: !0 }),
        },
        any: e3,
        array: e6,
        bigint: eQ,
        boolean: eY,
        date: eX,
        discriminatedUnion: tt,
        effect: tp,
        enum: tu,
        function: to,
        instanceof: (e, t = { message: `Input not instance of ${e.name}` }) =>
          eG((t) => t instanceof e, t),
        intersection: tr,
        lazy: tl,
        literal: tc,
        map: ts,
        nan: eJ,
        nativeEnum: th,
        never: e8,
        null: e2,
        nullable: tg,
        number: eZ,
        object: e9,
        oboolean: () => eY().optional(),
        onumber: () => eZ().optional(),
        optional: tf,
        ostring: () => eK().optional(),
        pipeline: ty,
        preprocess: tm,
        promise: td,
        record: tn,
        set: ta,
        strictObject: e7,
        string: eK,
        symbol: e0,
        transformer: tp,
        tuple: ti,
        undefined: e1,
        union: te,
        unknown: e5,
        void: e4,
        NEVER: H,
        ZodIssueCode: D,
        quotelessJson: (e) =>
          JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:"),
        ZodError: U,
      });
      let tb = tw.object({ message: tw.string() });
      function tv(e) {
        return tw.literal(x.$0[e]);
      }
      tw.object({
        accessList: tw.array(tw.string()),
        blockHash: tw.string().nullable(),
        blockNumber: tw.string().nullable(),
        chainId: tw.string().or(tw.number()),
        from: tw.string(),
        gas: tw.string(),
        hash: tw.string(),
        input: tw.string().nullable(),
        maxFeePerGas: tw.string(),
        maxPriorityFeePerGas: tw.string(),
        nonce: tw.string(),
        r: tw.string(),
        s: tw.string(),
        to: tw.string(),
        transactionIndex: tw.string().nullable(),
        type: tw.string(),
        v: tw.string(),
        value: tw.string(),
      });
      let tE = tw.object({ chainId: tw.string().or(tw.number()) }),
        tA = tw.object({ email: tw.string().email() }),
        tC = tw.object({ otp: tw.string() }),
        t_ = tw.object({ uri: tw.string() }),
        tI = tw.object({
          chainId: tw.optional(tw.string().or(tw.number())),
          preferredAccountType: tw.optional(tw.string()),
        }),
        tN = tw.object({
          provider: tw.enum([
            "google",
            "github",
            "apple",
            "facebook",
            "x",
            "discord",
          ]),
        }),
        tS = tw.object({ email: tw.string().email() }),
        tT = tw.object({ otp: tw.string() }),
        tP = tw.object({ otp: tw.string() }),
        tO = tw.object({
          themeMode: tw.optional(tw.enum(["light", "dark"])),
          themeVariables: tw.optional(
            tw.record(tw.string(), tw.string().or(tw.number()))
          ),
          w3mThemeVariables: tw.optional(tw.record(tw.string(), tw.string())),
        }),
        tx = tw.object({
          metadata: tw
            .object({
              name: tw.string(),
              description: tw.string(),
              url: tw.string(),
              icons: tw.array(tw.string()),
            })
            .optional(),
          sdkVersion: tw.string().optional(),
          sdkType: tw.string().optional(),
          projectId: tw.string(),
        }),
        tk = tw.object({ type: tw.string() }),
        tR = tw.object({
          action: tw.enum(["VERIFY_DEVICE", "VERIFY_OTP", "CONNECT"]),
        }),
        tD = tw.object({ url: tw.string() }),
        tU = tw.object({ userName: tw.string() }),
        tL = tw.object({
          email: tw.string().optional().nullable(),
          address: tw.string(),
          chainId: tw.string().or(tw.number()),
          accounts: tw
            .array(
              tw.object({
                address: tw.string(),
                type: tw.enum([
                  x.y_.ACCOUNT_TYPES.EOA,
                  x.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                ]),
              })
            )
            .optional(),
          userName: tw.string().optional().nullable(),
        }),
        tM = tw.object({
          action: tw.enum(["VERIFY_PRIMARY_OTP", "VERIFY_SECONDARY_OTP"]),
        }),
        tB = tw.object({
          email: tw.string().email().optional().nullable(),
          address: tw.string(),
          chainId: tw.string().or(tw.number()),
          smartAccountDeployed: tw.optional(tw.boolean()),
          accounts: tw
            .array(
              tw.object({
                address: tw.string(),
                type: tw.enum([
                  x.y_.ACCOUNT_TYPES.EOA,
                  x.y_.ACCOUNT_TYPES.SMART_ACCOUNT,
                ]),
              })
            )
            .optional(),
          preferredAccountType: tw.optional(tw.string()),
        }),
        tj = tw.object({ uri: tw.string() }),
        tF = tw.object({ isConnected: tw.boolean() }),
        t$ = tw.object({ chainId: tw.string().or(tw.number()) }),
        tH = tw.object({ chainId: tw.string().or(tw.number()) }),
        tz = tw.object({ newEmail: tw.string().email() }),
        tq = tw.object({ smartAccountEnabledNetworks: tw.array(tw.number()) });
      tw.object({ address: tw.string(), isDeployed: tw.boolean() });
      let tV = tw.object({ version: tw.string().optional() }),
        tG = tw.object({ type: tw.string(), address: tw.string() }),
        tW = tw.any(),
        tK = tw.object({ method: tw.literal("eth_accounts") }),
        tZ = tw.object({ method: tw.literal("eth_blockNumber") }),
        tJ = tw.object({
          method: tw.literal("eth_call"),
          params: tw.array(tw.any()),
        }),
        tQ = tw.object({ method: tw.literal("eth_chainId") }),
        tY = tw.object({
          method: tw.literal("eth_estimateGas"),
          params: tw.array(tw.any()),
        }),
        tX = tw.object({
          method: tw.literal("eth_feeHistory"),
          params: tw.array(tw.any()),
        }),
        t0 = tw.object({ method: tw.literal("eth_gasPrice") }),
        t1 = tw.object({
          method: tw.literal("eth_getAccount"),
          params: tw.array(tw.any()),
        }),
        t2 = tw.object({
          method: tw.literal("eth_getBalance"),
          params: tw.array(tw.any()),
        }),
        t3 = tw.object({
          method: tw.literal("eth_getBlockByHash"),
          params: tw.array(tw.any()),
        }),
        t5 = tw.object({
          method: tw.literal("eth_getBlockByNumber"),
          params: tw.array(tw.any()),
        }),
        t8 = tw.object({
          method: tw.literal("eth_getBlockReceipts"),
          params: tw.array(tw.any()),
        }),
        t4 = tw.object({
          method: tw.literal("eth_getBlockTransactionCountByHash"),
          params: tw.array(tw.any()),
        }),
        t6 = tw.object({
          method: tw.literal("eth_getBlockTransactionCountByNumber"),
          params: tw.array(tw.any()),
        }),
        t9 = tw.object({
          method: tw.literal("eth_getCode"),
          params: tw.array(tw.any()),
        }),
        t7 = tw.object({
          method: tw.literal("eth_getFilterChanges"),
          params: tw.array(tw.any()),
        }),
        re = tw.object({
          method: tw.literal("eth_getFilterLogs"),
          params: tw.array(tw.any()),
        }),
        rt = tw.object({
          method: tw.literal("eth_getLogs"),
          params: tw.array(tw.any()),
        }),
        rr = tw.object({
          method: tw.literal("eth_getProof"),
          params: tw.array(tw.any()),
        }),
        ri = tw.object({
          method: tw.literal("eth_getStorageAt"),
          params: tw.array(tw.any()),
        }),
        rn = tw.object({
          method: tw.literal("eth_getTransactionByBlockHashAndIndex"),
          params: tw.array(tw.any()),
        }),
        rs = tw.object({
          method: tw.literal("eth_getTransactionByBlockNumberAndIndex"),
          params: tw.array(tw.any()),
        }),
        ra = tw.object({
          method: tw.literal("eth_getTransactionByHash"),
          params: tw.array(tw.any()),
        }),
        ro = tw.object({
          method: tw.literal("eth_getTransactionCount"),
          params: tw.array(tw.any()),
        }),
        rl = tw.object({
          method: tw.literal("eth_getTransactionReceipt"),
          params: tw.array(tw.any()),
        }),
        rc = tw.object({
          method: tw.literal("eth_getUncleCountByBlockHash"),
          params: tw.array(tw.any()),
        }),
        ru = tw.object({
          method: tw.literal("eth_getUncleCountByBlockNumber"),
          params: tw.array(tw.any()),
        }),
        rh = tw.object({ method: tw.literal("eth_maxPriorityFeePerGas") }),
        rd = tw.object({ method: tw.literal("eth_newBlockFilter") }),
        rp = tw.object({
          method: tw.literal("eth_newFilter"),
          params: tw.array(tw.any()),
        }),
        rf = tw.object({
          method: tw.literal("eth_newPendingTransactionFilter"),
        }),
        rg = tw.object({
          method: tw.literal("eth_sendRawTransaction"),
          params: tw.array(tw.any()),
        }),
        rm = tw.object({
          method: tw.literal("eth_syncing"),
          params: tw.array(tw.any()),
        }),
        ry = tw.object({
          method: tw.literal("eth_uninstallFilter"),
          params: tw.array(tw.any()),
        }),
        rw = tw.object({
          method: tw.literal("personal_sign"),
          params: tw.array(tw.any()),
        }),
        rb = tw.object({
          method: tw.literal("eth_signTypedData_v4"),
          params: tw.array(tw.any()),
        }),
        rv = tw.object({
          method: tw.literal("eth_sendTransaction"),
          params: tw.array(tw.any()),
        }),
        rE = tw.object({
          method: tw.literal("solana_signMessage"),
          params: tw.object({ message: tw.string(), pubkey: tw.string() }),
        }),
        rA = tw.object({
          method: tw.literal("solana_signTransaction"),
          params: tw.object({ transaction: tw.string() }),
        }),
        rC = tw.object({
          method: tw.literal("solana_signAllTransactions"),
          params: tw.object({ transactions: tw.array(tw.string()) }),
        }),
        r_ = tw.object({
          method: tw.literal("solana_signAndSendTransaction"),
          params: tw.object({
            transaction: tw.string(),
            options: tw
              .object({
                skipPreflight: tw.boolean().optional(),
                preflightCommitment: tw
                  .enum([
                    "processed",
                    "confirmed",
                    "finalized",
                    "recent",
                    "single",
                    "singleGossip",
                    "root",
                    "max",
                  ])
                  .optional(),
                maxRetries: tw.number().optional(),
                minContextSlot: tw.number().optional(),
              })
              .optional(),
          }),
        }),
        rI = tw.object({
          method: tw.literal("wallet_sendCalls"),
          params: tw.array(
            tw.object({
              chainId: tw.string().or(tw.number()).optional(),
              from: tw.string().optional(),
              version: tw.string().optional(),
              capabilities: tw.any().optional(),
              calls: tw.array(
                tw.object({
                  to: tw.string().startsWith("0x"),
                  data: tw.string().startsWith("0x").optional(),
                  value: tw.string().optional(),
                })
              ),
            })
          ),
        }),
        rN = tw.object({
          method: tw.literal("wallet_getCallsStatus"),
          params: tw.array(tw.string()),
        }),
        rS = tw.object({ method: tw.literal("wallet_getCapabilities") }),
        rT = tw.object({
          method: tw.literal("wallet_grantPermissions"),
          params: tw.array(tw.any()),
        }),
        rP = tw.object({
          method: tw.literal("wallet_revokePermissions"),
          params: tw.any(),
        }),
        rO = tw.object({
          method: tw.literal("wallet_getAssets"),
          params: tw.any(),
        }),
        rx = tw.object({ token: tw.string() }),
        rk = tw.object({ id: tw.string().optional() }),
        rR = {
          appEvent: rk
            .extend({ type: tv("APP_SWITCH_NETWORK"), payload: tE })
            .or(rk.extend({ type: tv("APP_CONNECT_EMAIL"), payload: tA }))
            .or(rk.extend({ type: tv("APP_CONNECT_DEVICE") }))
            .or(rk.extend({ type: tv("APP_CONNECT_OTP"), payload: tC }))
            .or(rk.extend({ type: tv("APP_CONNECT_SOCIAL"), payload: t_ }))
            .or(rk.extend({ type: tv("APP_GET_FARCASTER_URI") }))
            .or(rk.extend({ type: tv("APP_CONNECT_FARCASTER") }))
            .or(
              rk.extend({ type: tv("APP_GET_USER"), payload: tw.optional(tI) })
            )
            .or(
              rk.extend({
                type: tv("APP_GET_SOCIAL_REDIRECT_URI"),
                payload: tN,
              })
            )
            .or(rk.extend({ type: tv("APP_SIGN_OUT") }))
            .or(
              rk.extend({
                type: tv("APP_IS_CONNECTED"),
                payload: tw.optional(rx),
              })
            )
            .or(rk.extend({ type: tv("APP_GET_CHAIN_ID") }))
            .or(
              rk.extend({ type: tv("APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS") })
            )
            .or(rk.extend({ type: tv("APP_INIT_SMART_ACCOUNT") }))
            .or(
              rk.extend({ type: tv("APP_SET_PREFERRED_ACCOUNT"), payload: tk })
            )
            .or(
              rk.extend({
                type: tv("APP_RPC_REQUEST"),
                payload: rw
                  .or(rO)
                  .or(tK)
                  .or(tZ)
                  .or(tJ)
                  .or(tQ)
                  .or(tY)
                  .or(tX)
                  .or(t0)
                  .or(t1)
                  .or(t2)
                  .or(t3)
                  .or(t5)
                  .or(t8)
                  .or(t4)
                  .or(t6)
                  .or(t9)
                  .or(t7)
                  .or(re)
                  .or(rt)
                  .or(rr)
                  .or(ri)
                  .or(rn)
                  .or(rs)
                  .or(ra)
                  .or(ro)
                  .or(rl)
                  .or(rc)
                  .or(ru)
                  .or(rh)
                  .or(rd)
                  .or(rp)
                  .or(rf)
                  .or(rg)
                  .or(rm)
                  .or(ry)
                  .or(rw)
                  .or(rb)
                  .or(rv)
                  .or(rE)
                  .or(rA)
                  .or(rC)
                  .or(r_)
                  .or(rN)
                  .or(rI)
                  .or(rS)
                  .or(rT)
                  .or(rP),
              })
            )
            .or(rk.extend({ type: tv("APP_UPDATE_EMAIL"), payload: tS }))
            .or(
              rk.extend({
                type: tv("APP_UPDATE_EMAIL_PRIMARY_OTP"),
                payload: tT,
              })
            )
            .or(
              rk.extend({
                type: tv("APP_UPDATE_EMAIL_SECONDARY_OTP"),
                payload: tP,
              })
            )
            .or(rk.extend({ type: tv("APP_SYNC_THEME"), payload: tO }))
            .or(rk.extend({ type: tv("APP_SYNC_DAPP_DATA"), payload: tx }))
            .or(rk.extend({ type: tv("APP_RELOAD") })),
          frameEvent: rk
            .extend({ type: tv("FRAME_SWITCH_NETWORK_ERROR"), payload: tb })
            .or(
              rk.extend({
                type: tv("FRAME_SWITCH_NETWORK_SUCCESS"),
                payload: tH,
              })
            )
            .or(
              rk.extend({
                type: tv("FRAME_CONNECT_EMAIL_SUCCESS"),
                payload: tR,
              })
            )
            .or(
              rk.extend({ type: tv("FRAME_CONNECT_EMAIL_ERROR"), payload: tb })
            )
            .or(
              rk.extend({
                type: tv("FRAME_GET_FARCASTER_URI_SUCCESS"),
                payload: tD,
              })
            )
            .or(
              rk.extend({
                type: tv("FRAME_GET_FARCASTER_URI_ERROR"),
                payload: tb,
              })
            )
            .or(
              rk.extend({
                type: tv("FRAME_CONNECT_FARCASTER_SUCCESS"),
                payload: tU,
              })
            )
            .or(
              rk.extend({
                type: tv("FRAME_CONNECT_FARCASTER_ERROR"),
                payload: tb,
              })
            )
            .or(rk.extend({ type: tv("FRAME_CONNECT_OTP_ERROR"), payload: tb }))
            .or(rk.extend({ type: tv("FRAME_CONNECT_OTP_SUCCESS") }))
            .or(
              rk.extend({ type: tv("FRAME_CONNECT_DEVICE_ERROR"), payload: tb })
            )
            .or(rk.extend({ type: tv("FRAME_CONNECT_DEVICE_SUCCESS") }))
            .or(
              rk.extend({
                type: tv("FRAME_CONNECT_SOCIAL_SUCCESS"),
                payload: tL,
              })
            )
            .or(
              rk.extend({ type: tv("FRAME_CONNECT_SOCIAL_ERROR"), payload: tb })
            )
            .or(rk.extend({ type: tv("FRAME_GET_USER_ERROR"), payload: tb }))
            .or(rk.extend({ type: tv("FRAME_GET_USER_SUCCESS"), payload: tB }))
            .or(
              rk.extend({
                type: tv("FRAME_GET_SOCIAL_REDIRECT_URI_ERROR"),
                payload: tb,
              })
            )
            .or(
              rk.extend({
                type: tv("FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS"),
                payload: tj,
              })
            )
            .or(rk.extend({ type: tv("FRAME_SIGN_OUT_ERROR"), payload: tb }))
            .or(rk.extend({ type: tv("FRAME_SIGN_OUT_SUCCESS") }))
            .or(
              rk.extend({ type: tv("FRAME_IS_CONNECTED_ERROR"), payload: tb })
            )
            .or(
              rk.extend({ type: tv("FRAME_IS_CONNECTED_SUCCESS"), payload: tF })
            )
            .or(
              rk.extend({ type: tv("FRAME_GET_CHAIN_ID_ERROR"), payload: tb })
            )
            .or(
              rk.extend({ type: tv("FRAME_GET_CHAIN_ID_SUCCESS"), payload: t$ })
            )
            .or(rk.extend({ type: tv("FRAME_RPC_REQUEST_ERROR"), payload: tb }))
            .or(
              rk.extend({ type: tv("FRAME_RPC_REQUEST_SUCCESS"), payload: tW })
            )
            .or(rk.extend({ type: tv("FRAME_SESSION_UPDATE"), payload: rx }))
            .or(
              rk.extend({ type: tv("FRAME_UPDATE_EMAIL_ERROR"), payload: tb })
            )
            .or(
              rk.extend({ type: tv("FRAME_UPDATE_EMAIL_SUCCESS"), payload: tM })
            )
            .or(
              rk.extend({
                type: tv("FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR"),
                payload: tb,
              })
            )
            .or(
              rk.extend({ type: tv("FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS") })
            )
            .or(
              rk.extend({
                type: tv("FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR"),
                payload: tb,
              })
            )
            .or(
              rk.extend({
                type: tv("FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS"),
                payload: tz,
              })
            )
            .or(rk.extend({ type: tv("FRAME_SYNC_THEME_ERROR"), payload: tb }))
            .or(rk.extend({ type: tv("FRAME_SYNC_THEME_SUCCESS") }))
            .or(
              rk.extend({ type: tv("FRAME_SYNC_DAPP_DATA_ERROR"), payload: tb })
            )
            .or(rk.extend({ type: tv("FRAME_SYNC_DAPP_DATA_SUCCESS") }))
            .or(
              rk.extend({
                type: tv("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS"),
                payload: tq,
              })
            )
            .or(
              rk.extend({
                type: tv("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR"),
                payload: tb,
              })
            )
            .or(
              rk.extend({
                type: tv("FRAME_INIT_SMART_ACCOUNT_ERROR"),
                payload: tb,
              })
            )
            .or(
              rk.extend({
                type: tv("FRAME_SET_PREFERRED_ACCOUNT_SUCCESS"),
                payload: tG,
              })
            )
            .or(
              rk.extend({
                type: tv("FRAME_SET_PREFERRED_ACCOUNT_ERROR"),
                payload: tb,
              })
            )
            .or(rk.extend({ type: tv("FRAME_READY"), payload: tV }))
            .or(rk.extend({ type: tv("FRAME_RELOAD_ERROR"), payload: tb }))
            .or(rk.extend({ type: tv("FRAME_RELOAD_SUCCESS") })),
        };
      function rD(e, t = {}) {
        return "string" == typeof t?.type && t?.type?.includes(e);
      }
      class rU {
        constructor({
          projectId: e,
          isAppClient: t = !1,
          chainId: r = "eip155:1",
          enableLogger: i = !0,
        }) {
          if (
            ((this.iframe = null),
            (this.rpcUrl = d.b.BLOCKCHAIN_API_RPC_URL),
            (this.initFrame = () => {
              let e = document.getElementById("w3m-iframe");
              this.iframe && !e && document.body.appendChild(this.iframe);
            }),
            (this.events = {
              registerFrameEventHandler: (e, t, r) => {
                function i({ data: r }) {
                  if (!rD(x.$0.FRAME_EVENT_KEY, r)) return;
                  let n = rR.frameEvent.parse(r);
                  n.id === e &&
                    (t(n), window.removeEventListener("message", i));
                }
                O.$.isClient &&
                  (window.addEventListener("message", i),
                  r.addEventListener("abort", () => {
                    window.removeEventListener("message", i);
                  }));
              },
              onFrameEvent: (e) => {
                O.$.isClient &&
                  window.addEventListener("message", ({ data: t }) => {
                    rD(x.$0.FRAME_EVENT_KEY, t) && e(rR.frameEvent.parse(t));
                  });
              },
              onAppEvent: (e) => {
                O.$.isClient &&
                  window.addEventListener("message", ({ data: t }) => {
                    rD(x.$0.APP_EVENT_KEY, t) && e(rR.appEvent.parse(t));
                  });
              },
              postAppEvent: (e) => {
                if (O.$.isClient) {
                  if (!this.iframe?.contentWindow)
                    throw Error("W3mFrame: iframe is not set");
                  rR.appEvent.parse(e),
                    this.iframe.contentWindow.postMessage(e, "*");
                }
              },
              postFrameEvent: (e) => {
                if (O.$.isClient) {
                  if (!parent) throw Error("W3mFrame: parent is not set");
                  rR.frameEvent.parse(e), parent.postMessage(e, "*");
                }
              },
            }),
            (this.projectId = e),
            (this.frameLoadPromise = new Promise((e, t) => {
              this.frameLoadPromiseResolver = { resolve: e, reject: t };
            })),
            t &&
              ((this.frameLoadPromise = new Promise((e, t) => {
                this.frameLoadPromiseResolver = { resolve: e, reject: t };
              })),
              O.$.isClient))
          ) {
            let t = document.createElement("iframe");
            (t.id = "w3m-iframe"),
              (t.src = `${x.Dr}?projectId=${e}&chainId=${r}&version=${x.zN}&enableLogger=${i}`),
              (t.name = "w3m-secure-iframe"),
              (t.style.position = "fixed"),
              (t.style.zIndex = "999999"),
              (t.style.display = "none"),
              (t.style.animationDelay = "0s, 50ms"),
              (t.style.borderBottomLeftRadius =
                "clamp(0px, var(--wui-border-radius-l), 44px)"),
              (t.style.borderBottomRightRadius =
                "clamp(0px, var(--wui-border-radius-l), 44px)"),
              (this.iframe = t),
              (this.iframe.onerror = () => {
                this.frameLoadPromiseResolver?.reject(
                  "Unable to load email login dependency"
                );
              }),
              this.events.onFrameEvent((e) => {
                "@w3m-frame/READY" === e.type &&
                  this.frameLoadPromiseResolver?.resolve(void 0);
              });
          }
        }
        get networks() {
          return Object.assign(
            {},
            ...[
              "eip155:1",
              "eip155:5",
              "eip155:11155111",
              "eip155:10",
              "eip155:420",
              "eip155:42161",
              "eip155:421613",
              "eip155:137",
              "eip155:80001",
              "eip155:42220",
              "eip155:1313161554",
              "eip155:1313161555",
              "eip155:56",
              "eip155:97",
              "eip155:43114",
              "eip155:43113",
              "eip155:324",
              "eip155:280",
              "eip155:100",
              "eip155:8453",
              "eip155:84531",
              "eip155:84532",
              "eip155:7777777",
              "eip155:999",
              "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
              "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
              "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
            ].map((e) => ({
              [e]: {
                rpcUrl: `${this.rpcUrl}/v1/?chainId=${e}&projectId=${this.projectId}`,
                chainId: e,
              },
            }))
          );
        }
      }
      var rL = r(15133);
      class rM {
        constructor(e) {
          let t = (0, rL.jI)({ level: x.jd }),
            { logger: r, chunkLoggerController: i } = (0, rL.Rt)({ opts: t });
          (this.logger = (0, rL.Ep)(r, this.constructor.name)),
            (this.chunkLoggerController = i),
            "undefined" != typeof window &&
              this.chunkLoggerController?.downloadLogsBlobInBrowser &&
              (window.downloadAppKitLogsBlob ||
                (window.downloadAppKitLogsBlob = {}),
              (window.downloadAppKitLogsBlob.sdk = () => {
                this.chunkLoggerController?.downloadLogsBlobInBrowser &&
                  this.chunkLoggerController.downloadLogsBlobInBrowser({
                    projectId: e,
                  });
              }));
        }
      }
      var rB = r(63671);
      class rj {
        constructor({
          projectId: e,
          chainId: t,
          enableLogger: r = !0,
          onTimeout: i,
        }) {
          (this.openRpcRequests = []),
            r && (this.w3mLogger = new rM(e)),
            (this.w3mFrame = new rU({
              projectId: e,
              isAppClient: !0,
              chainId: t,
              enableLogger: r,
            })),
            (this.onTimeout = i),
            this.getLoginEmailUsed() && this.w3mFrame.initFrame(),
            (this.initPromise = new Promise((e) => {
              this.w3mFrame.events.onFrameEvent((t) => {
                t.type === x.$0.FRAME_READY &&
                  ((this.initPromise = void 0), e());
              });
            }));
        }
        async init() {
          this.w3mFrame.initFrame(),
            this.initPromise && (await this.initPromise);
        }
        getLoginEmailUsed() {
          return !!rB.e.get(x.$0.EMAIL_LOGIN_USED_KEY);
        }
        getEmail() {
          return rB.e.get(x.$0.EMAIL);
        }
        getUsername() {
          return rB.e.get(x.$0.SOCIAL_USERNAME);
        }
        async reload() {
          try {
            this.w3mFrame.initFrame(),
              await this.appEvent({ type: x.$0.APP_RELOAD });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error reloading iframe"
              ),
              e)
            );
          }
        }
        async connectEmail(e) {
          try {
            O.$.checkIfAllowedToTriggerEmail(), this.w3mFrame.initFrame();
            let t = await this.appEvent({
              type: x.$0.APP_CONNECT_EMAIL,
              payload: e,
            });
            return this.setNewLastEmailLoginTime(), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting email"
              ),
              e)
            );
          }
        }
        async connectDevice() {
          try {
            return this.appEvent({ type: x.$0.APP_CONNECT_DEVICE });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting device"
              ),
              e)
            );
          }
        }
        async connectOtp(e) {
          try {
            return this.appEvent({ type: x.$0.APP_CONNECT_OTP, payload: e });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting otp"
              ),
              e)
            );
          }
        }
        async isConnected() {
          try {
            if (!this.getLoginEmailUsed()) return { isConnected: !1 };
            let e = await this.appEvent({ type: x.$0.APP_IS_CONNECTED });
            return e.isConnected || this.deleteAuthLoginCache(), e;
          } catch (e) {
            throw (
              (this.deleteAuthLoginCache(),
              this.w3mLogger?.logger.error(
                { error: e },
                "Error checking connection"
              ),
              e)
            );
          }
        }
        async getChainId() {
          try {
            let e = await this.appEvent({ type: x.$0.APP_GET_CHAIN_ID });
            return this.setLastUsedChainId(e.chainId), e;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error getting chain id"
              ),
              e)
            );
          }
        }
        async getSocialRedirectUri(e) {
          try {
            return (
              this.w3mFrame.initFrame(),
              this.appEvent({
                type: x.$0.APP_GET_SOCIAL_REDIRECT_URI,
                payload: e,
              })
            );
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error getting social redirect uri"
              ),
              e)
            );
          }
        }
        async updateEmail(e) {
          try {
            let t = await this.appEvent({
              type: x.$0.APP_UPDATE_EMAIL,
              payload: e,
            });
            return this.setNewLastEmailLoginTime(), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error updating email"
              ),
              e)
            );
          }
        }
        async updateEmailPrimaryOtp(e) {
          try {
            return this.appEvent({
              type: x.$0.APP_UPDATE_EMAIL_PRIMARY_OTP,
              payload: e,
            });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error updating email primary otp"
              ),
              e)
            );
          }
        }
        async updateEmailSecondaryOtp(e) {
          try {
            let t = await this.appEvent({
              type: x.$0.APP_UPDATE_EMAIL_SECONDARY_OTP,
              payload: e,
            });
            return this.setLoginSuccess(t.newEmail), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error updating email secondary otp"
              ),
              e)
            );
          }
        }
        async syncTheme(e) {
          try {
            return this.appEvent({ type: x.$0.APP_SYNC_THEME, payload: e });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error syncing theme"
              ),
              e)
            );
          }
        }
        async syncDappData(e) {
          try {
            return this.appEvent({ type: x.$0.APP_SYNC_DAPP_DATA, payload: e });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error syncing dapp data"
              ),
              e)
            );
          }
        }
        async getSmartAccountEnabledNetworks() {
          try {
            let e = await this.appEvent({
              type: x.$0.APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS,
            });
            return (
              this.persistSmartAccountEnabledNetworks(
                e.smartAccountEnabledNetworks
              ),
              e
            );
          } catch (e) {
            throw (
              (this.persistSmartAccountEnabledNetworks([]),
              this.w3mLogger?.logger.error(
                { error: e },
                "Error getting smart account enabled networks"
              ),
              e)
            );
          }
        }
        async setPreferredAccount(e) {
          try {
            return this.appEvent({
              type: x.$0.APP_SET_PREFERRED_ACCOUNT,
              payload: { type: e },
            });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error setting preferred account"
              ),
              e)
            );
          }
        }
        async connect(e) {
          try {
            let t = e?.chainId || this.getLastUsedChainId() || 1,
              r = await this.appEvent({
                type: x.$0.APP_GET_USER,
                payload: { ...e, chainId: t },
              });
            return (
              this.setLoginSuccess(r.email),
              this.setLastUsedChainId(r.chainId),
              (this.user = r),
              r
            );
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error({ error: e }, "Error connecting"),
              e)
            );
          }
        }
        async getUser(e) {
          try {
            let t = e?.chainId || this.getLastUsedChainId() || 1,
              r = await this.appEvent({
                type: x.$0.APP_GET_USER,
                payload: { ...e, chainId: t },
              });
            return (this.user = r), r;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error({ error: e }, "Error connecting"),
              e)
            );
          }
        }
        async connectSocial(e) {
          try {
            this.w3mFrame.initFrame();
            let t = await this.appEvent({
              type: x.$0.APP_CONNECT_SOCIAL,
              payload: { uri: e },
            });
            return t.userName && this.setSocialLoginSuccess(t.userName), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting social"
              ),
              e)
            );
          }
        }
        async getFarcasterUri() {
          try {
            return (
              this.w3mFrame.initFrame(),
              await this.appEvent({ type: x.$0.APP_GET_FARCASTER_URI })
            );
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error getting farcaster uri"
              ),
              e)
            );
          }
        }
        async connectFarcaster() {
          try {
            let e = await this.appEvent({ type: x.$0.APP_CONNECT_FARCASTER });
            return e.userName && this.setSocialLoginSuccess(e.userName), e;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting farcaster"
              ),
              e)
            );
          }
        }
        async switchNetwork(e) {
          try {
            let t = await this.appEvent({
              type: x.$0.APP_SWITCH_NETWORK,
              payload: { chainId: e },
            });
            return this.setLastUsedChainId(t.chainId), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error switching network"
              ),
              e)
            );
          }
        }
        async disconnect() {
          try {
            let e = await this.appEvent({ type: x.$0.APP_SIGN_OUT });
            return this.deleteAuthLoginCache(), e;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error disconnecting"
              ),
              e)
            );
          }
        }
        async request(e) {
          try {
            if (x.y_.GET_CHAIN_ID === e.method)
              return this.getLastUsedChainId();
            this.rpcRequestHandler?.(e);
            let t = await this.appEvent({
              type: x.$0.APP_RPC_REQUEST,
              payload: e,
            });
            return this.rpcSuccessHandler?.(t, e), t;
          } catch (t) {
            throw (
              (this.rpcErrorHandler?.(t, e),
              this.w3mLogger?.logger.error({ error: t }, "Error requesting"),
              t)
            );
          }
        }
        onRpcRequest(e) {
          this.rpcRequestHandler = e;
        }
        onRpcSuccess(e) {
          this.rpcSuccessHandler = e;
        }
        onRpcError(e) {
          this.rpcErrorHandler = e;
        }
        onIsConnected(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === x.$0.FRAME_IS_CONNECTED_SUCCESS &&
              t.payload.isConnected &&
              e();
          });
        }
        onNotConnected(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === x.$0.FRAME_IS_CONNECTED_ERROR && e(),
              t.type !== x.$0.FRAME_IS_CONNECTED_SUCCESS ||
                t.payload.isConnected ||
                e();
          });
        }
        onConnect(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === x.$0.FRAME_GET_USER_SUCCESS && e(t.payload);
          });
        }
        onSocialConnected(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === x.$0.FRAME_CONNECT_SOCIAL_SUCCESS && e(t.payload);
          });
        }
        async getCapabilities() {
          try {
            return (
              (await this.request({ method: "wallet_getCapabilities" })) || {}
            );
          } catch {
            return {};
          }
        }
        onSetPreferredAccount(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === x.$0.FRAME_SET_PREFERRED_ACCOUNT_SUCCESS
              ? e(t.payload)
              : t.type === x.$0.FRAME_SET_PREFERRED_ACCOUNT_ERROR &&
                e({ type: x.y_.ACCOUNT_TYPES.EOA });
          });
        }
        onGetSmartAccountEnabledNetworks(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === x.$0.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS
              ? e(t.payload.smartAccountEnabledNetworks)
              : t.type ===
                  x.$0.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR && e([]);
          });
        }
        getAvailableChainIds() {
          return Object.keys(this.w3mFrame.networks);
        }
        rejectRpcRequests() {
          try {
            this.openRpcRequests.forEach(
              ({ abortController: e, method: t }) => {
                x.y_.SAFE_RPC_METHODS.includes(t) || e.abort();
              }
            ),
              (this.openRpcRequests = []);
          } catch (e) {
            this.w3mLogger?.logger.error(
              { error: e },
              "Error aborting RPC request"
            );
          }
        }
        async appEvent(e) {
          let t;
          function r(e) {
            return e.replace("@w3m-app/", "");
          }
          await this.w3mFrame.frameLoadPromise;
          let i = new AbortController(),
            n = r(e.type);
          return (
            [
              x.$0.APP_CONNECT_EMAIL,
              x.$0.APP_CONNECT_DEVICE,
              x.$0.APP_CONNECT_OTP,
              x.$0.APP_CONNECT_SOCIAL,
              x.$0.APP_GET_SOCIAL_REDIRECT_URI,
            ]
              .map(r)
              .includes(n) &&
              (t = setTimeout(() => {
                this.onTimeout?.(), i.abort();
              }, 3e4)),
            new Promise((r, s) => {
              let a = Math.random().toString(36).substring(7);
              this.w3mLogger?.logger.info?.(
                { event: e, id: a },
                "Sending app event"
              ),
                this.w3mFrame.events.postAppEvent({ ...e, id: a }),
                "RPC_REQUEST" === n &&
                  (this.openRpcRequests = [
                    ...this.openRpcRequests,
                    { ...e.payload, abortController: i },
                  ]),
                i.signal.addEventListener("abort", () => {
                  "RPC_REQUEST" === n
                    ? s(Error("Request was aborted"))
                    : "GET_FARCASTER_URI" !== n &&
                      s(Error("Something went wrong"));
                }),
                this.w3mFrame.events.registerFrameEventHandler(
                  a,
                  (e) => {
                    var i;
                    return (
                      (i = this.w3mLogger),
                      void (
                        e.id === a &&
                        (i?.logger.info?.(
                          { framEvent: e, id: a },
                          "Received frame response"
                        ),
                        e.type === `@w3m-frame/${n}_SUCCESS`
                          ? (t && clearTimeout(t),
                            "payload" in e && r(e.payload),
                            r(void 0))
                          : e.type === `@w3m-frame/${n}_ERROR` &&
                            (t && clearTimeout(t),
                            "payload" in e &&
                              s(
                                Error(e.payload?.message || "An error occurred")
                              ),
                            s(Error("An error occurred"))))
                      )
                    );
                  },
                  i.signal
                );
            })
          );
        }
        setNewLastEmailLoginTime() {
          rB.e.set(x.$0.LAST_EMAIL_LOGIN_TIME, Date.now().toString());
        }
        setSocialLoginSuccess(e) {
          rB.e.set(x.$0.SOCIAL_USERNAME, e);
        }
        setLoginSuccess(e) {
          e && rB.e.set(x.$0.EMAIL, e),
            rB.e.set(x.$0.EMAIL_LOGIN_USED_KEY, "true"),
            rB.e.delete(x.$0.LAST_EMAIL_LOGIN_TIME);
        }
        deleteAuthLoginCache() {
          rB.e.delete(x.$0.EMAIL_LOGIN_USED_KEY),
            rB.e.delete(x.$0.EMAIL),
            rB.e.delete(x.$0.LAST_USED_CHAIN_KEY),
            rB.e.delete(x.$0.SOCIAL_USERNAME);
        }
        setLastUsedChainId(e) {
          e && rB.e.set(x.$0.LAST_USED_CHAIN_KEY, String(e));
        }
        getLastUsedChainId() {
          let e = rB.e.get(x.$0.LAST_USED_CHAIN_KEY) ?? void 0,
            t = Number(e);
          return isNaN(t) ? e : t;
        }
        persistSmartAccountEnabledNetworks(e) {
          rB.e.set(x.$0.SMART_ACCOUNT_ENABLED_NETWORKS, e.join(","));
        }
      }
      class rF {
        constructor() {}
        static getInstance({
          projectId: e,
          chainId: t,
          enableLogger: r,
          onTimeout: i,
        }) {
          return (
            rF.instance ||
              (rF.instance = new rj({
                projectId: e,
                chainId: t,
                enableLogger: r,
                onTimeout: i,
              })),
            rF.instance
          );
        }
      }
      var r$ = r(76356),
        rH = r(86988),
        rz = r(68903),
        rq = r(61704),
        rV = r(89512),
        rG = r(12540),
        rW = r(63043),
        rK = r(96986),
        rZ = r(66909),
        rJ = r(86777);
      r(46773), r(54946);
      var rQ = r(70768),
        rY = r(92413);
      let rX = (e, t, r) =>
        JSON.stringify(
          e,
          (e, r) => {
            let i = "bigint" == typeof r ? r.toString() : r;
            return "function" == typeof t ? t(e, i) : i;
          },
          r
        );
      var r0 = r(81544);
      let r1 = (e) => e;
      class r2 extends r0.G {
        constructor({
          body: e,
          cause: t,
          details: r,
          headers: i,
          status: n,
          url: s,
        }) {
          super("HTTP request failed.", {
            cause: t,
            details: r,
            metaMessages: [
              n && `Status: ${n}`,
              `URL: ${r1(s)}`,
              e && `Request body: ${rX(e)}`,
            ].filter(Boolean),
            name: "HttpRequestError",
          }),
            Object.defineProperty(this, "body", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "headers", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "status", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "url", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.body = e),
            (this.headers = i),
            (this.status = n),
            (this.url = s);
        }
      }
      class r3 extends r0.G {
        constructor({ body: e, error: t, url: r }) {
          super("RPC Request failed.", {
            cause: t,
            details: t.message,
            metaMessages: [`URL: ${r1(r)}`, `Request body: ${rX(e)}`],
            name: "RpcRequestError",
          }),
            Object.defineProperty(this, "code", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "data", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.code = t.code),
            (this.data = t.data);
        }
      }
      class r5 extends r0.G {
        constructor({ body: e, url: t }) {
          super("The request took too long to respond.", {
            details: "The request timed out.",
            metaMessages: [`URL: ${r1(t)}`, `Request body: ${rX(e)}`],
            name: "TimeoutError",
          });
        }
      }
      class r8 extends r0.G {
        constructor() {
          super(
            "No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.",
            { docsPath: "/docs/clients/intro", name: "UrlRequiredError" }
          );
        }
      }
      let r4 = new Map(),
        r6 = {
          current: 0,
          take() {
            return this.current++;
          },
          reset() {
            this.current = 0;
          },
        };
      class r9 extends r0.G {
        constructor(
          e,
          { code: t, docsPath: r, metaMessages: i, name: n, shortMessage: s }
        ) {
          super(s, {
            cause: e,
            docsPath: r,
            metaMessages: i || e?.metaMessages,
            name: n || "RpcError",
          }),
            Object.defineProperty(this, "code", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.name = n || e.name),
            (this.code = e instanceof r3 ? e.code : t ?? -1);
        }
      }
      class r7 extends r9 {
        constructor(e, t) {
          super(e, t),
            Object.defineProperty(this, "data", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.data = t.data);
        }
      }
      class ie extends r9 {
        constructor(e) {
          super(e, {
            code: ie.code,
            name: "ParseRpcError",
            shortMessage:
              "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.",
          });
        }
      }
      Object.defineProperty(ie, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32700,
      });
      class it extends r9 {
        constructor(e) {
          super(e, {
            code: it.code,
            name: "InvalidRequestRpcError",
            shortMessage: "JSON is not a valid request object.",
          });
        }
      }
      Object.defineProperty(it, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32600,
      });
      class ir extends r9 {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: ir.code,
            name: "MethodNotFoundRpcError",
            shortMessage: `The method${
              t ? ` "${t}"` : ""
            } does not exist / is not available.`,
          });
        }
      }
      Object.defineProperty(ir, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32601,
      });
      class ii extends r9 {
        constructor(e) {
          super(e, {
            code: ii.code,
            name: "InvalidParamsRpcError",
            shortMessage:
              "Invalid parameters were provided to the RPC method.\nDouble check you have provided the correct parameters.",
          });
        }
      }
      Object.defineProperty(ii, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32602,
      });
      class is extends r9 {
        constructor(e) {
          super(e, {
            code: is.code,
            name: "InternalRpcError",
            shortMessage: "An internal error was received.",
          });
        }
      }
      Object.defineProperty(is, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32603,
      });
      class ia extends r9 {
        constructor(e) {
          super(e, {
            code: ia.code,
            name: "InvalidInputRpcError",
            shortMessage:
              "Missing or invalid parameters.\nDouble check you have provided the correct parameters.",
          });
        }
      }
      Object.defineProperty(ia, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32e3,
      });
      class io extends r9 {
        constructor(e) {
          super(e, {
            code: io.code,
            name: "ResourceNotFoundRpcError",
            shortMessage: "Requested resource not found.",
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ResourceNotFoundRpcError",
            });
        }
      }
      Object.defineProperty(io, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32001,
      });
      class il extends r9 {
        constructor(e) {
          super(e, {
            code: il.code,
            name: "ResourceUnavailableRpcError",
            shortMessage: "Requested resource not available.",
          });
        }
      }
      Object.defineProperty(il, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32002,
      });
      class ic extends r9 {
        constructor(e) {
          super(e, {
            code: ic.code,
            name: "TransactionRejectedRpcError",
            shortMessage: "Transaction creation failed.",
          });
        }
      }
      Object.defineProperty(ic, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32003,
      });
      class iu extends r9 {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: iu.code,
            name: "MethodNotSupportedRpcError",
            shortMessage: `Method${t ? ` "${t}"` : ""} is not supported.`,
          });
        }
      }
      Object.defineProperty(iu, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32004,
      });
      class ih extends r9 {
        constructor(e) {
          super(e, {
            code: ih.code,
            name: "LimitExceededRpcError",
            shortMessage: "Request exceeds defined limit.",
          });
        }
      }
      Object.defineProperty(ih, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32005,
      });
      class id extends r9 {
        constructor(e) {
          super(e, {
            code: id.code,
            name: "JsonRpcVersionUnsupportedError",
            shortMessage: "Version of JSON-RPC protocol is not supported.",
          });
        }
      }
      Object.defineProperty(id, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32006,
      });
      class ip extends r7 {
        constructor(e) {
          super(e, {
            code: ip.code,
            name: "UserRejectedRequestError",
            shortMessage: "User rejected the request.",
          });
        }
      }
      Object.defineProperty(ip, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4001,
      });
      class ig extends r7 {
        constructor(e) {
          super(e, {
            code: ig.code,
            name: "UnauthorizedProviderError",
            shortMessage:
              "The requested method and/or account has not been authorized by the user.",
          });
        }
      }
      Object.defineProperty(ig, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4100,
      });
      class im extends r7 {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: im.code,
            name: "UnsupportedProviderMethodError",
            shortMessage: `The Provider does not support the requested method${
              t ? ` " ${t}"` : ""
            }.`,
          });
        }
      }
      Object.defineProperty(im, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4200,
      });
      class iy extends r7 {
        constructor(e) {
          super(e, {
            code: iy.code,
            name: "ProviderDisconnectedError",
            shortMessage: "The Provider is disconnected from all chains.",
          });
        }
      }
      Object.defineProperty(iy, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4900,
      });
      class iw extends r7 {
        constructor(e) {
          super(e, {
            code: iw.code,
            name: "ChainDisconnectedError",
            shortMessage:
              "The Provider is not connected to the requested chain.",
          });
        }
      }
      Object.defineProperty(iw, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4901,
      });
      class ib extends r7 {
        constructor(e) {
          super(e, {
            code: ib.code,
            name: "SwitchChainError",
            shortMessage: "An error occurred when attempting to switch chain.",
          });
        }
      }
      Object.defineProperty(ib, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4902,
      });
      class iv extends r9 {
        constructor(e) {
          super(e, {
            name: "UnknownRpcError",
            shortMessage: "An unknown RPC error occurred.",
          });
        }
      }
      var iE = r(59455);
      let iA = new (r(82061).k)(8192);
      async function iC(e) {
        return new Promise((t) => setTimeout(t, e));
      }
      let i_ = 256;
      function iI(
        {
          key: e,
          methods: t,
          name: r,
          request: i,
          retryCount: s = 3,
          retryDelay: a = 150,
          timeout: o,
          type: l,
        },
        c
      ) {
        return {
          config: {
            key: e,
            methods: t,
            name: r,
            request: i,
            retryCount: s,
            retryDelay: a,
            timeout: o,
            type: l,
          },
          request: (function (e, t = {}) {
            return async (r, i = {}) => {
              let {
                  dedupe: n = !1,
                  methods: s,
                  retryDelay: a = 150,
                  retryCount: o = 3,
                  uid: l,
                } = { ...t, ...i },
                { method: c } = r;
              if (
                s?.exclude?.includes(c) ||
                (s?.include && !s.include.includes(c))
              )
                throw new iu(Error("method not supported"), { method: c });
              let u = n ? (0, iE.$G)(`${l}.${rX(r)}`) : void 0;
              return (function (e, { enabled: t = !0, id: r }) {
                if (!t || !r) return e();
                if (iA.get(r)) return iA.get(r);
                let i = e().finally(() => iA.delete(r));
                return iA.set(r, i), i;
              })(
                () =>
                  (function (
                    e,
                    {
                      delay: t = 100,
                      retryCount: r = 2,
                      shouldRetry: i = () => !0,
                    } = {}
                  ) {
                    return new Promise((n, s) => {
                      let a = async ({ count: o = 0 } = {}) => {
                        let l = async ({ error: e }) => {
                          let r =
                            "function" == typeof t
                              ? t({ count: o, error: e })
                              : t;
                          r && (await iC(r)), a({ count: o + 1 });
                        };
                        try {
                          let t = await e();
                          n(t);
                        } catch (e) {
                          if (o < r && (await i({ count: o, error: e })))
                            return l({ error: e });
                          s(e);
                        }
                      };
                      a();
                    });
                  })(
                    async () => {
                      try {
                        return await e(r);
                      } catch (e) {
                        switch (e.code) {
                          case ie.code:
                            throw new ie(e);
                          case it.code:
                            throw new it(e);
                          case ir.code:
                            throw new ir(e, { method: r.method });
                          case ii.code:
                            throw new ii(e);
                          case is.code:
                            throw new is(e);
                          case ia.code:
                            throw new ia(e);
                          case io.code:
                            throw new io(e);
                          case il.code:
                            throw new il(e);
                          case ic.code:
                            throw new ic(e);
                          case iu.code:
                            throw new iu(e, { method: r.method });
                          case ih.code:
                            throw new ih(e);
                          case id.code:
                            throw new id(e);
                          case ip.code:
                            throw new ip(e);
                          case ig.code:
                            throw new ig(e);
                          case im.code:
                            throw new im(e);
                          case iy.code:
                            throw new iy(e);
                          case iw.code:
                            throw new iw(e);
                          case ib.code:
                            throw new ib(e);
                          case 5e3:
                            throw new ip(e);
                          default:
                            if (e instanceof r0.G) throw e;
                            throw new iv(e);
                        }
                      }
                    },
                    {
                      delay: ({ count: e, error: t }) => {
                        if (t && t instanceof r2) {
                          let e = t?.headers?.get("Retry-After");
                          if (e?.match(/\d/)) return 1e3 * Number.parseInt(e);
                        }
                        return ~~(1 << e) * a;
                      },
                      retryCount: o,
                      shouldRetry: ({ error: e }) =>
                        "code" in e && "number" == typeof e.code
                          ? -1 === e.code ||
                            e.code === ih.code ||
                            e.code === is.code
                          : !(e instanceof r2) ||
                            !e.status ||
                            403 === e.status ||
                            408 === e.status ||
                            413 === e.status ||
                            429 === e.status ||
                            500 === e.status ||
                            502 === e.status ||
                            503 === e.status ||
                            504 === e.status,
                    }
                  ),
                { enabled: n, id: u }
              );
            };
          })(i, {
            methods: t,
            retryCount: s,
            retryDelay: a,
            uid: (function (e = 11) {
              if (!n || i_ + e > 512) {
                (n = ""), (i_ = 0);
                for (let e = 0; e < 256; e++)
                  n += ((256 + 256 * Math.random()) | 0)
                    .toString(16)
                    .substring(1);
              }
              return n.substring(i_, i_++ + e);
            })(),
          }),
          value: c,
        };
      }
      function iN(e, t = {}) {
        let {
          batch: r,
          fetchOptions: i,
          key: n = "http",
          methods: s,
          name: a = "HTTP JSON-RPC",
          onFetchRequest: o,
          onFetchResponse: l,
          retryDelay: c,
          raw: u,
        } = t;
        return ({ chain: h, retryCount: d, timeout: p }) => {
          let { batchSize: f = 1e3, wait: g = 0 } =
              "object" == typeof r ? r : {},
            m = t.retryCount ?? d,
            y = p ?? t.timeout ?? 1e4,
            w = e || h?.rpcUrls.default.http[0];
          if (!w) throw new r8();
          let b = (function (e, t = {}) {
            return {
              async request(r) {
                let {
                    body: i,
                    onRequest: n = t.onRequest,
                    onResponse: s = t.onResponse,
                    timeout: a = t.timeout ?? 1e4,
                  } = r,
                  o = { ...(t.fetchOptions ?? {}), ...(r.fetchOptions ?? {}) },
                  { headers: l, method: c, signal: u } = o;
                try {
                  let t;
                  let r = await (function (
                    e,
                    {
                      errorInstance: t = Error("timed out"),
                      timeout: r,
                      signal: i,
                    }
                  ) {
                    return new Promise((n, s) => {
                      (async () => {
                        let a;
                        try {
                          let o = new AbortController();
                          r > 0 &&
                            (a = setTimeout(() => {
                              i ? o.abort() : s(t);
                            }, r)),
                            n(await e({ signal: o?.signal || null }));
                        } catch (e) {
                          e?.name === "AbortError" && s(t), s(e);
                        } finally {
                          clearTimeout(a);
                        }
                      })();
                    });
                  })(
                    async ({ signal: t }) => {
                      let r = {
                          ...o,
                          body: Array.isArray(i)
                            ? rX(
                                i.map((e) => ({
                                  jsonrpc: "2.0",
                                  id: e.id ?? r6.take(),
                                  ...e,
                                }))
                              )
                            : rX({
                                jsonrpc: "2.0",
                                id: i.id ?? r6.take(),
                                ...i,
                              }),
                          headers: { "Content-Type": "application/json", ...l },
                          method: c || "POST",
                          signal: u || (a > 0 ? t : null),
                        },
                        s = new Request(e, r),
                        h = (await n?.(s, r)) ?? { ...r, url: e };
                      return await fetch(h.url ?? e, h);
                    },
                    {
                      errorInstance: new r5({ body: i, url: e }),
                      timeout: a,
                      signal: !0,
                    }
                  );
                  if (
                    (s && (await s(r)),
                    r.headers
                      .get("Content-Type")
                      ?.startsWith("application/json"))
                  )
                    t = await r.json();
                  else {
                    t = await r.text();
                    try {
                      t = JSON.parse(t || "{}");
                    } catch (e) {
                      if (r.ok) throw e;
                      t = { error: t };
                    }
                  }
                  if (!r.ok)
                    throw new r2({
                      body: i,
                      details: rX(t.error) || r.statusText,
                      headers: r.headers,
                      status: r.status,
                      url: e,
                    });
                  return t;
                } catch (t) {
                  if (t instanceof r2 || t instanceof r5) throw t;
                  throw new r2({ body: i, cause: t, url: e });
                }
              },
            };
          })(w, { fetchOptions: i, onRequest: o, onResponse: l, timeout: y });
          return iI(
            {
              key: n,
              methods: s,
              name: a,
              async request({ method: e, params: t }) {
                let i = { method: e, params: t },
                  { schedule: n } = (function ({
                    fn: e,
                    id: t,
                    shouldSplitBatch: r,
                    wait: i = 0,
                    sort: n,
                  }) {
                    let s = async () => {
                        let t = l();
                        a();
                        let r = t.map(({ args: e }) => e);
                        0 !== r.length &&
                          e(r)
                            .then((e) => {
                              n && Array.isArray(e) && e.sort(n);
                              for (let r = 0; r < t.length; r++) {
                                let { resolve: i } = t[r];
                                i?.([e[r], e]);
                              }
                            })
                            .catch((e) => {
                              for (let r = 0; r < t.length; r++) {
                                let { reject: i } = t[r];
                                i?.(e);
                              }
                            });
                      },
                      a = () => r4.delete(t),
                      o = () => l().map(({ args: e }) => e),
                      l = () => r4.get(t) || [],
                      c = (e) => r4.set(t, [...l(), e]);
                    return {
                      flush: a,
                      async schedule(e) {
                        let t, n;
                        let {
                          promise: a,
                          resolve: u,
                          reject: h,
                        } = ((t = () => void 0),
                        (n = () => void 0),
                        {
                          promise: new Promise((e, r) => {
                            (t = e), (n = r);
                          }),
                          resolve: t,
                          reject: n,
                        });
                        return (
                          (r?.([...o(), e]) && s(), l().length > 0)
                            ? c({ args: e, resolve: u, reject: h })
                            : (c({ args: e, resolve: u, reject: h }),
                              setTimeout(s, i)),
                          a
                        );
                      },
                    };
                  })({
                    id: w,
                    wait: g,
                    shouldSplitBatch: (e) => e.length > f,
                    fn: (e) => b.request({ body: e }),
                    sort: (e, t) => e.id - t.id,
                  }),
                  s = async (e) => (r ? n(e) : [await b.request({ body: e })]),
                  [{ error: a, result: o }] = await s(i);
                if (u) return { error: a, result: o };
                if (a) throw new r3({ body: i, error: a, url: w });
                return o;
              },
              retryCount: m,
              retryDelay: c,
              timeout: y,
              type: "http",
            },
            { fetchOptions: i, url: w }
          );
        };
      }
      var iS = r(78125);
      function iT(e, t = {}) {
        let {
          key: r = "fallback",
          name: i = "Fallback",
          rank: n = !1,
          shouldThrow: s = iP,
          retryCount: a,
          retryDelay: o,
        } = t;
        return ({ chain: t, pollingInterval: l = 4e3, timeout: c, ...u }) => {
          let h = e,
            d = () => {},
            p = iI(
              {
                key: r,
                name: i,
                async request({ method: e, params: r }) {
                  let i;
                  let n = async (a = 0) => {
                    let o = h[a]({ ...u, chain: t, retryCount: 0, timeout: c });
                    try {
                      let t = await o.request({ method: e, params: r });
                      return (
                        d({
                          method: e,
                          params: r,
                          response: t,
                          transport: o,
                          status: "success",
                        }),
                        t
                      );
                    } catch (l) {
                      if (
                        (d({
                          error: l,
                          method: e,
                          params: r,
                          transport: o,
                          status: "error",
                        }),
                        s(l) ||
                          a === h.length - 1 ||
                          !(i ??= h.slice(a + 1).some((r) => {
                            let { include: i, exclude: n } =
                              r({ chain: t }).config.methods || {};
                            return i ? i.includes(e) : !n || !n.includes(e);
                          })))
                      )
                        throw l;
                      return n(a + 1);
                    }
                  };
                  return n();
                },
                retryCount: a,
                retryDelay: o,
                type: "fallback",
              },
              {
                onResponse: (e) => (d = e),
                transports: h.map((e) => e({ chain: t, retryCount: 0 })),
              }
            );
          if (n) {
            let e = "object" == typeof n ? n : {};
            !(function ({
              chain: e,
              interval: t = 4e3,
              onTransports: r,
              ping: i,
              sampleCount: n = 10,
              timeout: s = 1e3,
              transports: a,
              weights: o = {},
            }) {
              let { stability: l = 0.7, latency: c = 0.3 } = o,
                u = [],
                h = async () => {
                  let o = await Promise.all(
                    a.map(async (t) => {
                      let r, n;
                      let a = t({ chain: e, retryCount: 0, timeout: s }),
                        o = Date.now();
                      try {
                        await (i
                          ? i({ transport: a })
                          : a.request({ method: "net_listening" })),
                          (n = 1);
                      } catch {
                        n = 0;
                      } finally {
                        r = Date.now();
                      }
                      return { latency: r - o, success: n };
                    })
                  );
                  u.push(o), u.length > n && u.shift();
                  let d = Math.max(
                    ...u.map((e) => Math.max(...e.map(({ latency: e }) => e)))
                  );
                  r(
                    a
                      .map((e, t) => {
                        let r = u.map((e) => e[t].latency),
                          i = r.reduce((e, t) => e + t, 0) / r.length,
                          n = u.map((e) => e[t].success),
                          s = n.reduce((e, t) => e + t, 0) / n.length;
                        return 0 === s ? [0, t] : [c * (1 - i / d) + l * s, t];
                      })
                      .sort((e, t) => t[0] - e[0])
                      .map(([, e]) => a[e])
                  ),
                    await iC(t),
                    h();
                };
              h();
            })({
              chain: t,
              interval: e.interval ?? l,
              onTransports: (e) => (h = e),
              ping: e.ping,
              sampleCount: e.sampleCount,
              timeout: e.timeout,
              transports: h,
              weights: e.weights,
            });
          }
          return p;
        };
      }
      function iP(e) {
        return !!(
          "code" in e &&
          "number" == typeof e.code &&
          (e.code === ic.code ||
            e.code === ip.code ||
            iS.M_.nodeMessage.test(e.message) ||
            5e3 === e.code)
        );
      }
      var iO = r(91426);
      let ix = [
          "near:mainnet",
          "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
          "eip155:1101",
          "eip155:56",
          "eip155:42161",
          "eip155:7777777",
          "eip155:59144",
          "eip155:324",
          "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
          "eip155:5000",
          "solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz",
          "eip155:80084",
          "eip155:5003",
          "eip155:100",
          "eip155:8453",
          "eip155:42220",
          "eip155:1313161555",
          "eip155:17000",
          "eip155:1",
          "eip155:300",
          "eip155:1313161554",
          "eip155:1329",
          "eip155:84532",
          "eip155:421614",
          "eip155:11155111",
          "eip155:8217",
          "eip155:43114",
          "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
          "eip155:999999999",
          "eip155:11155420",
          "eip155:80002",
          "eip155:97",
          "eip155:43113",
          "eip155:137",
          "eip155:10",
          "eip155:1301",
          "bip122:000000000019d6689c085ae165831e93",
          "bip122:000000000933ea01ad0ee984209779ba",
        ],
        ik = {
          extendRpcUrlWithProjectId(e, t) {
            let r = !1;
            try {
              r = "rpc.walletconnect.org" === new URL(e).host;
            } catch (e) {
              r = !1;
            }
            if (r) {
              let r = new URL(e);
              return (
                r.searchParams.has("projectId") ||
                  r.searchParams.set("projectId", t),
                r.toString()
              );
            }
            return e;
          },
          isCaipNetwork: (e) => "chainNamespace" in e && "caipNetworkId" in e,
          getChainNamespace(e) {
            return this.isCaipNetwork(e) ? e.chainNamespace : d.b.CHAIN.EVM;
          },
          getCaipNetworkId(e) {
            return this.isCaipNetwork(e)
              ? e.caipNetworkId
              : `${d.b.CHAIN.EVM}:${e.id}`;
          },
          getDefaultRpcUrl(e, t, r) {
            let i = e.rpcUrls?.default?.http?.[0];
            return ix.includes(t)
              ? (function (e, t) {
                  let r = new URL("https://rpc.walletconnect.org/v1/");
                  return (
                    r.searchParams.set("chainId", e),
                    r.searchParams.set("projectId", t),
                    r.toString()
                  );
                })(t, r)
              : i || "";
          },
          extendCaipNetwork(
            e,
            { customNetworkImageUrls: t, projectId: r, customRpcUrls: i }
          ) {
            let n = this.getChainNamespace(e),
              s = this.getCaipNetworkId(e),
              a = e.rpcUrls.default.http?.[0],
              o = this.getDefaultRpcUrl(e, s, r),
              l = e?.rpcUrls?.chainDefault?.http?.[0] || a,
              c = i?.[s]?.map((e) => e.url) || [],
              u = [...c, o],
              h = [...c];
            return (
              l && !h.includes(l) && h.push(l),
              {
                ...e,
                chainNamespace: n,
                caipNetworkId: s,
                assets: {
                  imageId: iO.C.NetworkImageIds[e.id],
                  imageUrl: t?.[e.id],
                },
                rpcUrls: {
                  ...e.rpcUrls,
                  default: { http: u },
                  chainDefault: { http: h },
                },
              }
            );
          },
          extendCaipNetworks: (
            e,
            { customNetworkImageUrls: t, projectId: r, customRpcUrls: i }
          ) =>
            e.map((e) =>
              ik.extendCaipNetwork(e, {
                customNetworkImageUrls: t,
                customRpcUrls: i,
                projectId: r,
              })
            ),
          getViemTransport(e, t, r) {
            let i = [];
            if (
              (r?.forEach((e) => {
                i.push(iN(e.url, e.config));
              }),
              ix.includes(e.caipNetworkId))
            ) {
              let r = this.getDefaultRpcUrl(e, e.caipNetworkId, t);
              i.push(
                iN(r, {
                  fetchOptions: { headers: { "Content-Type": "text/plain" } },
                })
              );
            }
            return iT(i);
          },
          extendWagmiTransports(e, t, r) {
            return ix.includes(e.caipNetworkId)
              ? iT([r, iN(this.getDefaultRpcUrl(e, e.caipNetworkId, t))])
              : r;
          },
        },
        iR = {
          createLogger(e, t = "error") {
            let r = (0, rL.jI)({ level: t }),
              { logger: i } = (0, rL.Rt)({ opts: r });
            return (
              (i.error = (...t) => {
                for (let r of t)
                  if (r instanceof Error) {
                    e(r, ...t);
                    return;
                  }
                e(void 0, ...t);
              }),
              i
            );
          },
        };
      var iD = r(13057),
        iU = r(19091),
        iL = r(47319),
        iM = r(98686);
      class iB extends iU.q {
        setUniversalProvider(e) {
          this.addConnector(
            new iL.z({
              provider: e,
              caipNetworks: this.caipNetworks || [],
              namespace: this.namespace,
            })
          );
        }
        async connect(e) {
          return Promise.resolve({
            id: "WALLET_CONNECT",
            type: "WALLET_CONNECT",
            chainId: Number(e.chainId),
            provider: this.provider,
            address: "",
          });
        }
        async disconnect() {
          try {
            let e = this.getWalletConnectConnector();
            await e.disconnect();
          } catch (e) {
            console.warn("UniversalAdapter:disconnect - error", e);
          }
        }
        async getAccounts({ namespace: e }) {
          let t = this.provider;
          return Promise.resolve({
            accounts: (
              t?.session?.namespaces?.[e]?.accounts
                ?.map((e) => {
                  let [, , t] = e.split(":");
                  return t;
                })
                .filter((e, t, r) => r.indexOf(e) === t) || []
            ).map((t) =>
              A.j.createAccount(e, t, "bip122" === e ? "payment" : "eoa")
            ),
          });
        }
        async syncConnectors() {
          return Promise.resolve();
        }
        async getBalance(e) {
          if (
            !(
              e.caipNetwork &&
              y.bq.BALANCE_SUPPORTED_CHAINS.includes(
                e.caipNetwork?.chainNamespace
              )
            ) ||
            e.caipNetwork?.testnet
          )
            return {
              balance: "0.00",
              symbol: e.caipNetwork?.nativeCurrency.symbol || "",
            };
          if (
            b.AccountController.state.balanceLoading &&
            e.chainId === v.R.state.activeCaipNetwork?.id
          )
            return {
              balance: b.AccountController.state.balance || "0.00",
              symbol: b.AccountController.state.balanceSymbol || "",
            };
          let t = (await b.AccountController.fetchTokenBalance()).find(
            (t) =>
              t.chainId === `${e.caipNetwork?.chainNamespace}:${e.chainId}` &&
              t.symbol === e.caipNetwork?.nativeCurrency.symbol
          );
          return {
            balance: t?.quantity.numeric || "0.00",
            symbol: t?.symbol || e.caipNetwork?.nativeCurrency.symbol || "",
          };
        }
        async signMessage(e) {
          let { provider: t, message: r, address: i } = e;
          if (!t)
            throw Error("UniversalAdapter:signMessage - provider is undefined");
          return {
            signature:
              v.R.state.activeCaipNetwork?.chainNamespace === d.b.CHAIN.SOLANA
                ? (
                    await t.request(
                      {
                        method: "solana_signMessage",
                        params: {
                          message: iD.Z.encode(new TextEncoder().encode(r)),
                          pubkey: i,
                        },
                      },
                      v.R.state.activeCaipNetwork?.caipNetworkId
                    )
                  ).signature
                : await t.request(
                    { method: "personal_sign", params: [r, i] },
                    v.R.state.activeCaipNetwork?.caipNetworkId
                  ),
          };
        }
        async estimateGas() {
          return Promise.resolve({ gas: BigInt(0) });
        }
        async getProfile() {
          return Promise.resolve({ profileImage: "", profileName: "" });
        }
        async sendTransaction() {
          return Promise.resolve({ hash: "" });
        }
        walletGetAssets(e) {
          return Promise.resolve({});
        }
        async writeContract() {
          return Promise.resolve({ hash: "" });
        }
        async getEnsAddress() {
          return Promise.resolve({ address: !1 });
        }
        parseUnits() {
          return 0n;
        }
        formatUnits() {
          return "0";
        }
        async getCapabilities() {
          return Promise.resolve({});
        }
        async grantPermissions() {
          return Promise.resolve({});
        }
        async revokePermissions() {
          return Promise.resolve("0x");
        }
        async syncConnection() {
          return Promise.resolve({
            id: "WALLET_CONNECT",
            type: "WALLET_CONNECT",
            chainId: 1,
            provider: this.provider,
            address: "",
          });
        }
        async switchNetwork(e) {
          let { caipNetwork: t } = e,
            r = this.getWalletConnectConnector();
          if (t.chainNamespace === d.b.CHAIN.EVM)
            try {
              await r.provider?.request({
                method: "wallet_switchEthereumChain",
                params: [{ chainId: iE.NC(t.id) }],
              });
            } catch (e) {
              if (
                e.code === iM.T.ERROR_CODE_UNRECOGNIZED_CHAIN_ID ||
                e.code === iM.T.ERROR_INVALID_CHAIN_ID ||
                e.code === iM.T.ERROR_CODE_DEFAULT ||
                e?.data?.originalError?.code ===
                  iM.T.ERROR_CODE_UNRECOGNIZED_CHAIN_ID
              )
                try {
                  await r.provider?.request({
                    method: "wallet_addEthereumChain",
                    params: [
                      {
                        chainId: iE.NC(t.id),
                        rpcUrls: [t?.rpcUrls.chainDefault?.http],
                        chainName: t.name,
                        nativeCurrency: t.nativeCurrency,
                        blockExplorerUrls: [t.blockExplorers?.default.url],
                      },
                    ],
                  });
                } catch (e) {
                  throw Error("Chain is not supported");
                }
            }
          r.provider.setDefaultChain(t.caipNetworkId);
        }
        getWalletConnectProvider() {
          let e = this.connectors.find((e) => "WALLET_CONNECT" === e.type);
          return e?.provider;
        }
      }
      var ij = r(89977);
      class iF {
        constructor(e) {
          (this.chainNamespaces = []),
            (this.reportedAlertErrors = {}),
            (this.getCaipNetwork = (e) =>
              e
                ? v.R.getNetworkData(e)?.caipNetwork ||
                  v.R.getRequestedCaipNetworks(e).filter(
                    (t) => t.chainNamespace === e
                  )?.[0]
                : v.R.state.activeCaipNetwork || this.defaultCaipNetwork),
            (this.getCaipNetworkId = () => {
              let e = this.getCaipNetwork();
              if (e) return e.id;
            }),
            (this.getCaipNetworks = (e) => v.R.getRequestedCaipNetworks(e)),
            (this.getActiveChainNamespace = () => v.R.state.activeChain),
            (this.setRequestedCaipNetworks = (e, t) => {
              v.R.setRequestedCaipNetworks(e, t);
            }),
            (this.getApprovedCaipNetworkIds = () =>
              v.R.getAllApprovedCaipNetworkIds()),
            (this.getCaipAddress = (e) =>
              v.R.state.activeChain !== e && e
                ? v.R.getAccountProp("caipAddress", e)
                : v.R.state.activeCaipAddress),
            (this.setClientId = (e) => {
              rq.L.setClientId(e);
            }),
            (this.getProvider = (e) => P.h.getProvider(e)),
            (this.getProviderType = (e) => P.h.getProviderId(e)),
            (this.getPreferredAccountType = () =>
              b.AccountController.state.preferredAccountType),
            (this.setCaipAddress = (e, t) => {
              b.AccountController.setCaipAddress(e, t);
            }),
            (this.setBalance = (e, t, r) => {
              b.AccountController.setBalance(e, t, r);
            }),
            (this.setProfileName = (e, t) => {
              b.AccountController.setProfileName(e, t);
            }),
            (this.setProfileImage = (e, t) => {
              b.AccountController.setProfileImage(e, t);
            }),
            (this.setUser = (e, t) => {
              b.AccountController.setUser(e, t),
                E.OptionsController.state.enableEmbedded && rV.I.close();
            }),
            (this.resetAccount = (e) => {
              b.AccountController.resetAccount(e);
            }),
            (this.setCaipNetwork = (e) => {
              v.R.setActiveCaipNetwork(e);
            }),
            (this.setCaipNetworkOfNamespace = (e, t) => {
              v.R.setChainNetworkData(t, { caipNetwork: e });
            }),
            (this.setAllAccounts = (e, t) => {
              b.AccountController.setAllAccounts(e, t),
                E.OptionsController.setHasMultipleAddresses(e?.length > 1);
            }),
            (this.setStatus = (e, t) => {
              b.AccountController.setStatus(e, t),
                f.ConnectorController.isConnected()
                  ? _.M.setConnectionStatus("connected")
                  : _.M.setConnectionStatus("disconnected");
            }),
            (this.getAddressByChainNamespace = (e) =>
              v.R.getAccountProp("address", e)),
            (this.setConnectors = (e) => {
              let t = [...f.ConnectorController.getConnectors(), ...e];
              f.ConnectorController.setConnectors(t);
            }),
            (this.fetchIdentity = (e) => rq.L.fetchIdentity(e)),
            (this.getReownName = (e) => rG.a.getNamesForAddress(e)),
            (this.getConnectors = () => f.ConnectorController.getConnectors()),
            (this.getConnectorImage = (e) => rW.f.getConnectorImage(e)),
            (this.setConnectedWalletInfo = (e, t) => {
              let r = P.h.getProviderId(t),
                i = e ? { ...e, type: r } : void 0;
              b.AccountController.setConnectedWalletInfo(i, t);
            }),
            (this.getIsConnectedState = () => !!v.R.state.activeCaipAddress),
            (this.addAddressLabel = (e, t, r) => {
              b.AccountController.addAddressLabel(e, t, r);
            }),
            (this.removeAddressLabel = (e, t) => {
              b.AccountController.removeAddressLabel(e, t);
            }),
            (this.getAddress = (e) =>
              v.R.state.activeChain !== e && e
                ? v.R.getAccountProp("address", e)
                : b.AccountController.state.address),
            (this.setApprovedCaipNetworksData = (e) =>
              v.R.setApprovedCaipNetworksData(e)),
            (this.resetNetwork = (e) => {
              v.R.resetNetwork(e);
            }),
            (this.addConnector = (e) => {
              f.ConnectorController.addConnector(e);
            }),
            (this.resetWcConnection = () => {
              g.ConnectionController.resetWcConnection();
            }),
            (this.setAddressExplorerUrl = (e, t) => {
              b.AccountController.setAddressExplorerUrl(e, t);
            }),
            (this.setSmartAccountDeployed = (e, t) => {
              b.AccountController.setSmartAccountDeployed(e, t);
            }),
            (this.setSmartAccountEnabledNetworks = (e, t) => {
              v.R.setSmartAccountEnabledNetworks(e, t);
            }),
            (this.setPreferredAccountType = (e, t) => {
              b.AccountController.setPreferredAccountType(e, t);
            }),
            (this.setEIP6963Enabled = (e) => {
              E.OptionsController.setEIP6963Enabled(e);
            }),
            (this.handleUnsafeRPCRequest = () => {
              this.isOpen()
                ? this.isTransactionStackEmpty() ||
                  this.redirect("ApproveTransaction")
                : this.open({ view: "ApproveTransaction" });
            }),
            (this.options = e),
            (this.version = e.sdkVersion),
            (this.caipNetworks = this.extendCaipNetworks(e)),
            (this.chainNamespaces = [
              ...new Set(this.caipNetworks?.map((e) => e.chainNamespace)),
            ]),
            (this.defaultCaipNetwork = this.extendDefaultCaipNetwork(e)),
            (this.chainAdapters = this.createAdapters(e.adapters)),
            this.initialize(e),
            this.sendInitializeEvent(e);
        }
        async initialize(e) {
          this.initControllers(e),
            await this.initChainAdapters(),
            await this.injectModalUi(),
            await this.syncExistingConnection(),
            rK.I.set({ initialized: !0 });
        }
        sendInitializeEvent(e) {
          let { ...t } = e;
          delete t.adapters,
            m.X.sendEvent({
              type: "track",
              event: "INITIALIZE",
              properties: {
                ...t,
                networks: e.networks.map((e) => e.id),
                siweConfig: { options: e.siweConfig?.options || {} },
              },
            });
        }
        initControllers(e) {
          this.initializeOptionsController(e),
            this.initializeChainController(e),
            this.initializeThemeController(e),
            this.initializeConnectionController(e),
            this.initializeConnectorController();
        }
        initializeThemeController(e) {
          e.themeMode && C.ThemeController.setThemeMode(e.themeMode),
            e.themeVariables &&
              C.ThemeController.setThemeVariables(e.themeVariables);
        }
        initializeChainController(e) {
          if (!this.connectionControllerClient || !this.networkControllerClient)
            throw Error(
              "ConnectionControllerClient and NetworkControllerClient must be set"
            );
          v.R.initialize(e.adapters ?? [], this.caipNetworks, {
            connectionControllerClient: this.connectionControllerClient,
            networkControllerClient: this.networkControllerClient,
          });
          let t = this.getDefaultNetwork();
          t && v.R.setActiveCaipNetwork(t);
        }
        initializeConnectionController(e) {
          g.ConnectionController.setWcBasic(e.basic ?? !1);
        }
        initializeConnectorController() {
          f.ConnectorController.initialize(this.chainNamespaces);
        }
        initializeOptionsController(e) {
          E.OptionsController.setDebug(!1 !== e.debug),
            E.OptionsController.setEnableWalletConnect(
              !1 !== e.enableWalletConnect
            ),
            E.OptionsController.setEnableWalletGuide(
              !1 !== e.enableWalletGuide
            ),
            E.OptionsController.setEnableWallets(!1 !== e.enableWallets),
            E.OptionsController.setEIP6963Enabled(!1 !== e.enableEIP6963),
            E.OptionsController.setEnableAuthLogger(!1 !== e.enableAuthLogger),
            E.OptionsController.setCustomRpcUrls(e.customRpcUrls),
            E.OptionsController.setSdkVersion(e.sdkVersion),
            E.OptionsController.setProjectId(e.projectId),
            E.OptionsController.setEnableEmbedded(e.enableEmbedded),
            E.OptionsController.setAllWallets(e.allWallets),
            E.OptionsController.setIncludeWalletIds(e.includeWalletIds),
            E.OptionsController.setExcludeWalletIds(e.excludeWalletIds),
            E.OptionsController.setFeaturedWalletIds(e.featuredWalletIds),
            E.OptionsController.setTokens(e.tokens),
            E.OptionsController.setTermsConditionsUrl(e.termsConditionsUrl),
            E.OptionsController.setPrivacyPolicyUrl(e.privacyPolicyUrl),
            E.OptionsController.setCustomWallets(e.customWallets),
            E.OptionsController.setFeatures(e.features),
            E.OptionsController.setAllowUnsupportedChain(
              e.allowUnsupportedChain
            ),
            E.OptionsController.setDefaultAccountTypes(e.defaultAccountTypes);
          let t = this.getDefaultMetaData();
          if (
            (!e.metadata && t && (e.metadata = t),
            E.OptionsController.setMetadata(e.metadata),
            E.OptionsController.setDisableAppend(e.disableAppend),
            E.OptionsController.setEnableEmbedded(e.enableEmbedded),
            E.OptionsController.setSIWX(e.siwx),
            !e.projectId)
          ) {
            I.AlertController.open(
              T.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED,
              "error"
            );
            return;
          }
          if (
            e.adapters?.find((e) => e.namespace === d.b.CHAIN.EVM) &&
            e.siweConfig
          ) {
            if (e.siwx)
              throw Error("Cannot set both `siweConfig` and `siwx` options");
            E.OptionsController.setSIWX(e.siweConfig.mapToSIWX());
          }
        }
        getDefaultMetaData() {
          return "undefined" != typeof window && "undefined" != typeof document
            ? {
                name:
                  document.getElementsByTagName("title")?.[0]?.textContent ||
                  "",
                description:
                  document.querySelector('meta[property="og:description"]')
                    ?.content || "",
                url: window.location.origin,
                icons: [
                  document.querySelector('link[rel~="icon"]')?.href || "",
                ],
              }
            : null;
        }
        getUnsupportedNetwork(e) {
          return {
            id: e.split(":")[1],
            caipNetworkId: e,
            name: d.b.UNSUPPORTED_NETWORK_NAME,
            chainNamespace: e.split(":")[0],
            nativeCurrency: { name: "", decimals: 0, symbol: "" },
            rpcUrls: { default: { http: [] } },
          };
        }
        setUnsupportedNetwork(e) {
          let t = this.getActiveChainNamespace();
          if (t) {
            let r = this.getUnsupportedNetwork(`${t}:${e}`);
            v.R.setActiveCaipNetwork(r);
          }
        }
        getDefaultNetwork() {
          let e = _.M.getActiveCaipNetworkId();
          return e
            ? this.caipNetworks?.find((t) => t.caipNetworkId === e) ||
                (this.defaultCaipNetwork
                  ? this.defaultCaipNetwork
                  : this.getUnsupportedNetwork(e))
            : this.defaultCaipNetwork
            ? this.defaultCaipNetwork
            : this.caipNetworks?.[0];
        }
        extendCaipNetwork(e, t) {
          return ik.extendCaipNetwork(e, {
            customNetworkImageUrls: t.chainImages,
            projectId: t.projectId,
          });
        }
        extendCaipNetworks(e) {
          return ik.extendCaipNetworks(e.networks, {
            customNetworkImageUrls: e.chainImages,
            customRpcUrls: e.customRpcUrls,
            projectId: e.projectId,
          });
        }
        extendDefaultCaipNetwork(e) {
          let t = e.networks.find((t) => t.id === e.defaultNetwork?.id);
          return t
            ? ik.extendCaipNetwork(t, {
                customNetworkImageUrls: e.chainImages,
                customRpcUrls: e.customRpcUrls,
                projectId: e.projectId,
              })
            : void 0;
        }
        createClients() {
          (this.connectionControllerClient = {
            connectWalletConnect: async () => {
              let e = v.R.state.activeChain,
                t = this.getAdapter(e),
                r = this.getCaipNetwork(e)?.id;
              if (!t) throw Error("Adapter not found");
              let i = await t.connectWalletConnect(r);
              this.close(),
                this.setClientId(i?.clientId || null),
                _.M.setConnectedNamespaces([...v.R.state.chains.keys()]),
                this.chainNamespaces.forEach((e) => {
                  f.ConnectorController.setConnectorId(
                    N.b.CONNECTOR_TYPE_WALLET_CONNECT,
                    e
                  );
                }),
                await this.syncWalletConnectAccount();
            },
            connectExternal: async ({
              id: e,
              info: t,
              type: r,
              provider: i,
              chain: n,
              caipNetwork: s,
            }) => {
              let a = v.R.state.activeChain,
                o = n || a,
                l = this.getAdapter(o);
              if (n && n !== a && !s) {
                let e = this.caipNetworks?.find((e) => e.chainNamespace === n);
                e && this.setCaipNetwork(e);
              }
              if (!l) throw Error("Adapter not found");
              let c = this.getCaipNetwork(o),
                u = await l.connect({
                  id: e,
                  info: t,
                  type: r,
                  provider: i,
                  chainId: s?.id || c?.id,
                  rpcUrl:
                    s?.rpcUrls?.default?.http?.[0] ||
                    c?.rpcUrls?.default?.http?.[0],
                });
              if (!u) return;
              _.M.addConnectedNamespace(o),
                this.syncProvider({ ...u, chainNamespace: o }),
                await this.syncAccount({ ...u, chainNamespace: o });
              let { accounts: h } = await l.getAccounts({
                namespace: o,
                id: e,
              });
              this.setAllAccounts(h, o);
            },
            reconnectExternal: async ({
              id: e,
              info: t,
              type: r,
              provider: i,
            }) => {
              let n = v.R.state.activeChain,
                s = this.getAdapter(n);
              s?.reconnect &&
                (await s?.reconnect({
                  id: e,
                  info: t,
                  type: r,
                  provider: i,
                  chainId: this.getCaipNetwork()?.id,
                }),
                _.M.addConnectedNamespace(n));
            },
            disconnect: async (e) => {
              let t = e || v.R.state.activeChain,
                r = this.getAdapter(t),
                i = P.h.getProvider(t),
                n = P.h.getProviderId(t);
              await r?.disconnect({ provider: i, providerType: n }),
                _.M.removeConnectedNamespace(t),
                P.h.resetChain(t),
                this.setUser(void 0, t),
                this.setStatus("disconnected", t);
            },
            checkInstalled: (e) =>
              e
                ? e.some((e) => !!window.ethereum?.[String(e)])
                : !!window.ethereum,
            signMessage: async (e) => {
              let t = this.getAdapter(v.R.state.activeChain),
                r = await t?.signMessage({
                  message: e,
                  address: b.AccountController.state.address,
                  provider: P.h.getProvider(v.R.state.activeChain),
                });
              return r?.signature || "";
            },
            sendTransaction: async (e) => {
              if (e.chainNamespace === d.b.CHAIN.EVM) {
                let t = this.getAdapter(v.R.state.activeChain),
                  r = P.h.getProvider(v.R.state.activeChain),
                  i = await t?.sendTransaction({ ...e, provider: r });
                return i?.hash || "";
              }
              return "";
            },
            estimateGas: async (e) => {
              if (e.chainNamespace === d.b.CHAIN.EVM) {
                let t = this.getAdapter(v.R.state.activeChain),
                  r = P.h.getProvider(v.R.state.activeChain),
                  i = this.getCaipNetwork();
                if (!i) throw Error("CaipNetwork is undefined");
                let n = await t?.estimateGas({
                  ...e,
                  provider: r,
                  caipNetwork: i,
                });
                return n?.gas || 0n;
              }
              return 0n;
            },
            getEnsAvatar: async () => {
              let e = this.getAdapter(v.R.state.activeChain),
                t = await e?.getProfile({
                  address: b.AccountController.state.address,
                  chainId: Number(this.getCaipNetwork()?.id),
                });
              return t?.profileImage || !1;
            },
            getEnsAddress: async (e) => {
              let t = this.getAdapter(v.R.state.activeChain),
                r = this.getCaipNetwork();
              if (!r) return !1;
              let i = await t?.getEnsAddress({ name: e, caipNetwork: r });
              return i?.address || !1;
            },
            writeContract: async (e) => {
              let t = this.getAdapter(v.R.state.activeChain),
                r = this.getCaipNetwork(),
                i = this.getCaipAddress(),
                n = P.h.getProvider(v.R.state.activeChain);
              if (!r || !i)
                throw Error("CaipNetwork or CaipAddress is undefined");
              let s = await t?.writeContract({
                ...e,
                caipNetwork: r,
                provider: n,
                caipAddress: i,
              });
              return s?.hash;
            },
            parseUnits: (e, t) => {
              let r = this.getAdapter(v.R.state.activeChain);
              return r?.parseUnits({ value: e, decimals: t }) ?? 0n;
            },
            formatUnits: (e, t) => {
              let r = this.getAdapter(v.R.state.activeChain);
              return r?.formatUnits({ value: e, decimals: t }) ?? "0";
            },
            getCapabilities: async (e) => {
              let t = this.getAdapter(v.R.state.activeChain);
              return await t?.getCapabilities(e);
            },
            grantPermissions: async (e) => {
              let t = this.getAdapter(v.R.state.activeChain);
              return await t?.grantPermissions(e);
            },
            revokePermissions: async (e) => {
              let t = this.getAdapter(v.R.state.activeChain);
              return t?.revokePermissions ? await t.revokePermissions(e) : "0x";
            },
            walletGetAssets: async (e) => {
              let t = this.getAdapter(v.R.state.activeChain);
              return (await t?.walletGetAssets(e)) ?? {};
            },
          }),
            (this.networkControllerClient = {
              switchCaipNetwork: async (e) => await this.switchCaipNetwork(e),
              getApprovedCaipNetworksData: async () =>
                this.getApprovedCaipNetworksData(),
            }),
            g.ConnectionController.setClient(this.connectionControllerClient);
        }
        getApprovedCaipNetworksData() {
          if (
            P.h.getProviderId(v.R.state.activeChain) ===
            N.b.CONNECTOR_TYPE_WALLET_CONNECT
          ) {
            let e = this.universalProvider?.session?.namespaces;
            return {
              supportsAllNetworks:
                this.universalProvider?.session?.peer?.metadata.name ===
                "MetaMask Wallet",
              approvedCaipNetworkIds: this.getChainsFromNamespaces(e),
            };
          }
          return { supportsAllNetworks: !0, approvedCaipNetworkIds: [] };
        }
        async switchCaipNetwork(e) {
          if (!e) return;
          let t = e.chainNamespace;
          if (this.getAddressByChainNamespace(e.chainNamespace)) {
            let r = P.h.getProvider(t),
              i = P.h.getProviderId(t);
            if (e.chainNamespace === v.R.state.activeChain) {
              let n = this.getAdapter(t);
              await n?.switchNetwork({
                caipNetwork: e,
                provider: r,
                providerType: i,
              });
            } else if (
              (this.setCaipNetwork(e), i === N.b.CONNECTOR_TYPE_WALLET_CONNECT)
            )
              this.syncWalletConnectAccount();
            else {
              let r = this.getAddressByChainNamespace(t);
              r &&
                this.syncAccount({
                  address: r,
                  chainId: e.id,
                  chainNamespace: t,
                });
            }
          } else this.setCaipNetwork(e);
        }
        getChainsFromNamespaces(e = {}) {
          return Object.values(e).flatMap((e) =>
            Array.from(
              new Set([
                ...(e.chains || []),
                ...e.accounts.map((e) => {
                  let { chainId: t, chainNamespace: r } =
                    rH.u.parseCaipAddress(e);
                  return `${r}:${t}`;
                }),
              ])
            )
          );
        }
        createAdapters(e) {
          return (
            this.createClients(),
            this.chainNamespaces.reduce((t, r) => {
              let i = e?.find((e) => e.namespace === r);
              return (
                i
                  ? ((t[r] = i),
                    (t[r].namespace = r),
                    t[r].construct({
                      namespace: r,
                      projectId: this.options?.projectId,
                      networks: this.caipNetworks,
                    }))
                  : (t[r] = new iB({
                      namespace: r,
                      networks: this.caipNetworks,
                    })),
                t
              );
            }, {})
          );
        }
        async initChainAdapter(e) {
          this.onConnectors(e),
            this.listenAdapter(e),
            this.chainAdapters?.[e].syncConnectors(this.options, this),
            await this.createUniversalProviderForAdapter(e);
        }
        async initChainAdapters() {
          await Promise.all(
            this.chainNamespaces.map(async (e) => {
              await this.initChainAdapter(e);
            })
          );
        }
        onConnectors(e) {
          let t = this.getAdapter(e);
          t?.on("connectors", this.setConnectors.bind(this));
        }
        listenAdapter(e) {
          let t = this.getAdapter(e);
          if (!t) return;
          let r = _.M.getConnectionStatus();
          "connected" === r
            ? this.setStatus("connecting", e)
            : ("disconnected" === r && _.M.clearAddressCache(),
              this.setStatus(r, e)),
            t.on("switchNetwork", ({ address: t, chainId: r }) => {
              let i = this.caipNetworks?.find(
                  (e) => e.id === r || e.caipNetworkId === r
                ),
                n = v.R.state.activeChain === e,
                s = v.R.getAccountProp("address", e);
              if (i) {
                let i = n && t ? t : s;
                i &&
                  this.syncAccount({
                    address: i,
                    chainId: r,
                    chainNamespace: e,
                  });
              } else this.setUnsupportedNetwork(r);
            }),
            t.on("disconnect", this.disconnect.bind(this, e)),
            t.on("pendingTransactions", () => {
              let e = b.AccountController.state.address,
                t = v.R.state.activeCaipNetwork;
              e && t?.id && this.updateNativeBalance(e, t.id, t.chainNamespace);
            }),
            t.on("accountChanged", ({ address: t, chainId: r }) => {
              let i = v.R.state.activeChain === e;
              i && r
                ? this.syncAccount({
                    address: t,
                    chainId: r,
                    chainNamespace: e,
                  })
                : i && v.R.state.activeCaipNetwork?.id
                ? this.syncAccount({
                    address: t,
                    chainId: v.R.state.activeCaipNetwork?.id,
                    chainNamespace: e,
                  })
                : this.syncAccountInfo(t, r, e);
            });
        }
        async createUniversalProviderForAdapter(e) {
          await this.getUniversalProvider(),
            this.universalProvider &&
              this.chainAdapters?.[e]?.setUniversalProvider?.(
                this.universalProvider
              );
        }
        async syncExistingConnection() {
          await Promise.allSettled(
            this.chainNamespaces.map((e) => this.syncNamespaceConnection(e))
          );
        }
        async syncNamespaceConnection(e) {
          try {
            let t = f.ConnectorController.getConnectorId(e);
            switch ((this.setStatus("connecting", e), t)) {
              case d.b.CONNECTOR_ID.WALLET_CONNECT:
                await this.syncWalletConnectAccount();
                break;
              case d.b.CONNECTOR_ID.AUTH:
                break;
              default:
                await this.syncAdapterConnection(e);
            }
          } catch (t) {
            console.warn("AppKit couldn't sync existing connection", t),
              this.setStatus("disconnected", e);
          }
        }
        async syncAdapterConnection(e) {
          let t = this.getAdapter(e),
            r = f.ConnectorController.getConnectorId(e),
            i = this.getCaipNetwork(e),
            n = f.ConnectorController.getConnectors(e).find((e) => e.id === r);
          try {
            if (!t || !n)
              throw Error(`Adapter or connector not found for namespace ${e}`);
            if (!i?.id) throw Error("CaipNetwork not found");
            let r = await t?.syncConnection({
              namespace: e,
              id: n.id,
              chainId: i.id,
              rpcUrl: i?.rpcUrls?.default?.http?.[0],
            });
            if (r) {
              let i = await t?.getAccounts({ namespace: e, id: n.id });
              i && i.accounts.length > 0
                ? this.setAllAccounts(i.accounts, e)
                : this.setAllAccounts(
                    [A.j.createAccount(e, r.address, "eoa")],
                    e
                  ),
                this.syncProvider({ ...r, chainNamespace: e }),
                await this.syncAccount({ ...r, chainNamespace: e }),
                this.setStatus("connected", e);
            } else this.setStatus("disconnected", e);
          } catch (t) {
            this.setStatus("disconnected", e);
          }
        }
        async syncWalletConnectAccount() {
          let e = this.chainNamespaces.map(async (e) => {
            let t = this.getAdapter(e),
              r =
                this.universalProvider?.session?.namespaces?.[e]?.accounts ||
                [],
              i = v.R.state.activeCaipNetwork?.id,
              n =
                r.find((e) => {
                  let { chainId: t } = rH.u.parseCaipAddress(e);
                  return t === i?.toString();
                }) || r[0];
            if (n) {
              let r = rH.u.validateCaipAddress(n),
                { chainId: i, address: s } = rH.u.parseCaipAddress(r);
              if (
                (P.h.setProviderId(e, N.b.CONNECTOR_TYPE_WALLET_CONNECT),
                this.caipNetworks &&
                  v.R.state.activeCaipNetwork &&
                  t?.namespace !== d.b.CHAIN.EVM)
              ) {
                let r = t?.getWalletConnectProvider({
                  caipNetworks: this.caipNetworks,
                  provider: this.universalProvider,
                  activeCaipNetwork: v.R.state.activeCaipNetwork,
                });
                P.h.setProvider(e, r);
              } else P.h.setProvider(e, this.universalProvider);
              f.ConnectorController.setConnectorId(
                d.b.CONNECTOR_ID.WALLET_CONNECT,
                e
              ),
                _.M.addConnectedNamespace(e),
                this.syncWalletConnectAccounts(e),
                await this.syncAccount({
                  address: s,
                  chainId: i,
                  chainNamespace: e,
                });
            } else this.setStatus("disconnected", e);
            await v.R.setApprovedCaipNetworksData(e);
          });
          await Promise.all(e);
        }
        syncWalletConnectAccounts(e) {
          let t = this.universalProvider?.session?.namespaces?.[e]?.accounts
            ?.map((e) => {
              let { address: t } = rH.u.parseCaipAddress(e);
              return t;
            })
            .filter((e, t, r) => r.indexOf(e) === t);
          t &&
            this.setAllAccounts(
              t.map((t) =>
                A.j.createAccount(e, t, "bip122" === e ? "payment" : "eoa")
              ),
              e
            );
        }
        syncProvider({ type: e, provider: t, id: r, chainNamespace: i }) {
          P.h.setProviderId(i, e),
            P.h.setProvider(i, t),
            f.ConnectorController.setConnectorId(r, i);
        }
        async syncAccount(e) {
          let t = e.chainNamespace === v.R.state.activeChain,
            r = v.R.getCaipNetworkByNamespace(e.chainNamespace, e.chainId),
            { address: i, chainId: n, chainNamespace: s } = e,
            { chainId: a } = _.M.getActiveNetworkProps(),
            o = n || a,
            l =
              v.R.state.activeCaipNetwork?.name ===
              d.b.UNSUPPORTED_NETWORK_NAME,
            c = v.R.getNetworkProp("supportsAllNetworks", s);
          if ((this.setStatus("connected", s), (!l || c) && o)) {
            let e = this.caipNetworks?.find(
                (e) => e.id.toString() === o.toString()
              ),
              n = this.caipNetworks?.find((e) => e.chainNamespace === s);
            if (!c && !e && !n) {
              let t = this.getApprovedCaipNetworkIds() || [],
                r = t.find(
                  (e) => rH.u.parseCaipNetworkId(e)?.chainId === o.toString()
                ),
                i = t.find(
                  (e) => rH.u.parseCaipNetworkId(e)?.chainNamespace === s
                );
              (e = this.caipNetworks?.find((e) => e.caipNetworkId === r)),
                (n = this.caipNetworks?.find(
                  (e) =>
                    e.caipNetworkId === i ||
                    ("deprecatedCaipNetworkId" in e &&
                      e.deprecatedCaipNetworkId === i)
                ));
            }
            let a = e || n;
            a?.chainNamespace === v.R.state.activeChain
              ? E.OptionsController.state.allowUnsupportedChain ||
                v.R.state.activeCaipNetwork?.name !==
                  d.b.UNSUPPORTED_NETWORK_NAME
                ? this.setCaipNetwork(a)
                : v.R.showUnsupportedChainUI()
              : !t && r && this.setCaipNetworkOfNamespace(r, s),
              this.syncConnectedWalletInfo(s),
              S.isLowerCaseMatch(i, b.AccountController.state.address) ||
                this.syncAccountInfo(i, a?.id, s),
              t
                ? await this.syncBalance({
                    address: i,
                    chainId: a?.id,
                    chainNamespace: s,
                  })
                : await this.syncBalance({
                    address: i,
                    chainId: r?.id,
                    chainNamespace: s,
                  });
          }
        }
        async syncAccountInfo(e, t, r) {
          let i = this.getCaipAddress(r),
            n = t || i?.split(":")[1];
          if (!n) return;
          let s = `${r}:${n}:${e}`;
          this.setCaipAddress(s, r),
            await this.syncIdentity({
              address: e,
              chainId: n,
              chainNamespace: r,
            });
        }
        async syncReownName(e, t) {
          try {
            let r = await this.getReownName(e);
            if (r[0]) {
              let e = r[0];
              this.setProfileName(e.name, t);
            } else this.setProfileName(null, t);
          } catch {
            this.setProfileName(null, t);
          }
        }
        syncConnectedWalletInfo(e) {
          let t = f.ConnectorController.getConnectorId(e),
            r = P.h.getProviderId(e);
          if (
            r === N.b.CONNECTOR_TYPE_ANNOUNCED ||
            r === N.b.CONNECTOR_TYPE_INJECTED
          ) {
            if (t) {
              let r = this.getConnectors().find((e) => e.id === t);
              if (r) {
                let { info: t, name: i, imageUrl: n } = r,
                  s = n || this.getConnectorImage(r);
                this.setConnectedWalletInfo({ name: i, icon: s, ...t }, e);
              }
            }
          } else if (r === N.b.CONNECTOR_TYPE_WALLET_CONNECT) {
            let t = P.h.getProvider(e);
            t?.session &&
              this.setConnectedWalletInfo(
                {
                  ...t.session.peer.metadata,
                  name: t.session.peer.metadata.name,
                  icon: t.session.peer.metadata.icons?.[0],
                },
                e
              );
          } else if (t) {
            if (t === d.b.CONNECTOR_ID.COINBASE) {
              let t = this.getConnectors().find(
                (e) => e.id === d.b.CONNECTOR_ID.COINBASE
              );
              this.setConnectedWalletInfo(
                { name: "Coinbase Wallet", icon: this.getConnectorImage(t) },
                e
              );
            } else this.setConnectedWalletInfo({ name: t }, e);
          }
        }
        async syncBalance(e) {
          rz.p
            .getNetworksByNamespace(this.caipNetworks, e.chainNamespace)
            .find((t) => t.id.toString() === e.chainId?.toString()) &&
            e.chainId &&
            (await this.updateNativeBalance(
              e.address,
              e.chainId,
              e.chainNamespace
            ));
        }
        async updateNativeBalance(e, t, r) {
          let i = this.getAdapter(r);
          if (i) {
            let n = await i.getBalance({
              address: e,
              chainId: t,
              caipNetwork: this.getCaipNetwork(r),
              tokens: this.options.tokens,
            });
            this.setBalance(n.balance, n.symbol, r);
          }
        }
        async initializeUniversalAdapter() {
          let e = iR.createLogger((e, ...t) => {
              e && this.handleAlertError(e), console.error(...t);
            }),
            t = {
              projectId: this.options?.projectId,
              metadata: {
                name: this.options?.metadata ? this.options?.metadata.name : "",
                description: this.options?.metadata
                  ? this.options?.metadata.description
                  : "",
                url: this.options?.metadata ? this.options?.metadata.url : "",
                icons: this.options?.metadata
                  ? this.options?.metadata.icons
                  : [""],
              },
              logger: e,
            };
          E.OptionsController.setManualWCControl(
            !!this.options?.manualWCControl
          ),
            (this.universalProvider =
              this.options.universalProvider ?? (await r$.Z.init(t))),
            this.listenWalletConnect();
        }
        listenWalletConnect() {
          this.universalProvider &&
            (this.universalProvider.on("display_uri", (e) => {
              g.ConnectionController.setUri(e);
            }),
            this.universalProvider.on(
              "connect",
              g.ConnectionController.finalizeWcConnection
            ),
            this.universalProvider.on("disconnect", () => {
              this.chainNamespaces.forEach((e) => {
                this.resetAccount(e);
              }),
                g.ConnectionController.resetWcConnection();
            }),
            this.universalProvider.on("chainChanged", (e) => {
              let t = this.caipNetworks?.find((t) => t.id == e),
                r = this.getCaipNetwork();
              if (!t) {
                this.setUnsupportedNetwork(e);
                return;
              }
              r?.id !== t?.id && this.setCaipNetwork(t);
            }),
            this.universalProvider.on("session_event", (e) => {
              if (ij.s.isSessionEventData(e)) {
                let { name: t, data: r } = e.params.event;
                "accountsChanged" === t &&
                  Array.isArray(r) &&
                  A.j.isCaipAddress(r[0]) &&
                  this.syncAccount(rH.u.parseCaipAddress(r[0]));
              }
            }));
        }
        createUniversalProvider() {
          return (
            !this.universalProviderInitPromise &&
              A.j.isClient() &&
              this.options?.projectId &&
              (this.universalProviderInitPromise =
                this.initializeUniversalAdapter()),
            this.universalProviderInitPromise
          );
        }
        async getUniversalProvider() {
          if (!this.universalProvider)
            try {
              await this.createUniversalProvider();
            } catch (e) {
              throw Error(
                "AppKit:getUniversalProvider - Cannot create provider"
              );
            }
          return this.universalProvider;
        }
        handleAlertError(e) {
          let [t, r] =
              Object.entries(T.UniversalProviderErrors).find(
                ([, { message: t }]) => e.message.includes(t)
              ) ?? [],
            { message: i, alertErrorKey: n } = r ?? {};
          if (t && i && !this.reportedAlertErrors[t]) {
            let e = T.ALERT_ERRORS[n];
            e &&
              (I.AlertController.open(e, "error"),
              (this.reportedAlertErrors[t] = !0));
          }
        }
        getAdapter(e) {
          if (e) return this.chainAdapters?.[e];
        }
        createAdapter(e) {
          if (!e) return;
          let t = e.namespace;
          t &&
            (this.createClients(),
            (e.namespace = t),
            e.construct({
              namespace: t,
              projectId: this.options?.projectId,
              networks: this.caipNetworks,
            }),
            this.chainNamespaces.includes(t) || this.chainNamespaces.push(t),
            this.chainAdapters && (this.chainAdapters[t] = e));
        }
        async open(e) {
          await this.injectModalUi(),
            e?.uri && g.ConnectionController.setUri(e.uri),
            await rV.I.open(e);
        }
        async close() {
          await this.injectModalUi(), rV.I.close();
        }
        setLoading(e, t) {
          rV.I.setLoading(e, t);
        }
        async disconnect(e) {
          await g.ConnectionController.disconnect(e);
        }
        getError() {
          return "";
        }
        getChainId() {
          return v.R.state.activeCaipNetwork?.id;
        }
        async switchNetwork(e) {
          let t = this.caipNetworks?.find((t) => t.id === e.id);
          if (!t) {
            I.AlertController.open(
              T.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND,
              "error"
            );
            return;
          }
          await v.R.switchActiveNetwork(t);
        }
        getWalletProvider() {
          return v.R.state.activeChain
            ? P.h.state.providers[v.R.state.activeChain]
            : null;
        }
        getWalletProviderType() {
          return P.h.getProviderId(v.R.state.activeChain);
        }
        subscribeProviders(e) {
          return P.h.subscribeProviders(e);
        }
        getThemeMode() {
          return C.ThemeController.state.themeMode;
        }
        getThemeVariables() {
          return C.ThemeController.state.themeVariables;
        }
        setThemeMode(e) {
          C.ThemeController.setThemeMode(e),
            (0, rY.Hs)(C.ThemeController.state.themeMode);
        }
        setTermsConditionsUrl(e) {
          E.OptionsController.setTermsConditionsUrl(e);
        }
        setPrivacyPolicyUrl(e) {
          E.OptionsController.setPrivacyPolicyUrl(e);
        }
        setThemeVariables(e) {
          C.ThemeController.setThemeVariables(e),
            (0, rY.R)(C.ThemeController.state.themeVariables);
        }
        subscribeTheme(e) {
          return C.ThemeController.subscribe(e);
        }
        getWalletInfo() {
          return b.AccountController.state.connectedWalletInfo;
        }
        getAccount(e) {
          let t = f.ConnectorController.getAuthConnector(e),
            r = v.R.getAccountData(e);
          if (r)
            return {
              allAccounts: r.allAccounts,
              caipAddress: r.caipAddress,
              address: A.j.getPlainAddress(r.caipAddress),
              isConnected: !!r.caipAddress,
              status: r.status,
              embeddedWalletInfo: t
                ? {
                    user: r.user,
                    authProvider: r.socialProvider || "email",
                    accountType: r.preferredAccountType,
                    isSmartAccountDeployed: !!r.smartAccountDeployed,
                  }
                : void 0,
            };
        }
        subscribeAccount(e, t) {
          let r = () => {
            let r = this.getAccount(t);
            r && e(r);
          };
          t ? v.R.subscribeChainProp("accountState", r, t) : v.R.subscribe(r),
            f.ConnectorController.subscribe(r);
        }
        subscribeNetwork(e) {
          return v.R.subscribe(({ activeCaipNetwork: t }) => {
            e({
              caipNetwork: t,
              chainId: t?.id,
              caipNetworkId: t?.caipNetworkId,
            });
          });
        }
        subscribeWalletInfo(e) {
          return b.AccountController.subscribeKey("connectedWalletInfo", e);
        }
        subscribeShouldUpdateToAddress(e) {
          b.AccountController.subscribeKey("shouldUpdateToAddress", e);
        }
        subscribeCaipNetworkChange(e) {
          v.R.subscribeKey("activeCaipNetwork", e);
        }
        getState() {
          return rK.I.state;
        }
        subscribeState(e) {
          return rK.I.subscribe(e);
        }
        showErrorMessage(e) {
          rZ.SnackController.showError(e);
        }
        showSuccessMessage(e) {
          rZ.SnackController.showSuccess(e);
        }
        getEvent() {
          return { ...m.X.state };
        }
        subscribeEvents(e) {
          return m.X.subscribe(e);
        }
        replace(e) {
          rJ.RouterController.replace(e);
        }
        redirect(e) {
          rJ.RouterController.push(e);
        }
        popTransactionStack(e) {
          rJ.RouterController.popTransactionStack(e);
        }
        isOpen() {
          return rV.I.state.open;
        }
        isTransactionStackEmpty() {
          return 0 === rJ.RouterController.state.transactionStack.length;
        }
        isTransactionShouldReplaceView() {
          return rJ.RouterController.state.transactionStack[
            rJ.RouterController.state.transactionStack.length - 1
          ]?.replace;
        }
        static getInstance() {
          return this.instance;
        }
        updateFeatures(e) {
          E.OptionsController.setFeatures(e);
        }
        updateOptions(e) {
          let t = { ...(E.OptionsController.state || {}), ...e };
          E.OptionsController.setOptions(t);
        }
        setConnectMethodsOrder(e) {
          E.OptionsController.setConnectMethodsOrder(e);
        }
        setWalletFeaturesOrder(e) {
          E.OptionsController.setWalletFeaturesOrder(e);
        }
        setCollapseWallets(e) {
          E.OptionsController.setCollapseWallets(e);
        }
        setSocialsOrder(e) {
          E.OptionsController.setSocialsOrder(e);
        }
        getConnectMethodsOrder() {
          return rQ.J.getConnectOrderMethod(
            E.OptionsController.state.features,
            f.ConnectorController.getConnectors()
          );
        }
        removeAdapter(e) {
          let t = this.getIsConnectedState(),
            r = this.getAdapter(e);
          if (!r || !this.chainAdapters || t) return;
          let i = this.caipNetworks?.filter((t) => t.chainNamespace !== e);
          v.R.removeAdapter(e),
            f.ConnectorController.removeAdapter(e),
            (this.chainNamespaces = this.chainNamespaces.filter(
              (t) => t !== e
            )),
            (this.caipNetworks = i),
            r.removeAllEventListeners(),
            Reflect.deleteProperty(this.chainAdapters, e);
        }
        addAdapter(e, t) {
          let r = e.namespace;
          if (
            !this.connectionControllerClient ||
            !this.networkControllerClient ||
            !this.chainAdapters ||
            !r
          )
            return;
          let i = this.extendCaipNetworks({ ...this.options, networks: t });
          (this.caipNetworks = [...(this.caipNetworks || []), ...i]),
            this.createAdapter(e),
            this.initChainAdapter(r),
            v.R.addAdapter(
              e,
              {
                connectionControllerClient: this.connectionControllerClient,
                networkControllerClient: this.networkControllerClient,
              },
              i
            );
        }
        addNetwork(e, t) {
          if (this.chainAdapters && !this.chainAdapters[e])
            throw Error(`Adapter for namespace ${e} doesn't exist`);
          let r = this.extendCaipNetwork(t, this.options);
          v.R.addNetwork(r),
            this.caipNetworks &&
              !this.caipNetworks?.find((e) => e.id === r.id) &&
              this.caipNetworks.push(r);
        }
        removeNetwork(e, t) {
          if (this.chainAdapters && !this.chainAdapters[e])
            throw Error(`Adapter for namespace ${e} doesn't exist`);
          if (!this.caipNetworks?.find((e) => e.id === t))
            throw Error(`Network with ID ${t} not found`);
          if (!this.caipNetworks) return;
          let r = this.caipNetworks.filter(
            (r) => r.chainNamespace === e && r.id !== t
          );
          if (!r?.length)
            throw Error("Cannot remove last network for a namespace");
          v.R.removeNetwork(e, t), (this.caipNetworks = [...r]);
        }
      }
      let i$ = !1;
      class iH extends iF {
        setupAuthConnectorListeners(e) {
          e.onRpcRequest((t) => {
            O.$.checkIfRequestExists(t)
              ? O.$.checkIfRequestIsSafe(t) || this.handleUnsafeRPCRequest()
              : (this.open(),
                console.error(x.y_.RPC_METHOD_NOT_ALLOWED_MESSAGE, {
                  method: t.method,
                }),
                setTimeout(() => {
                  this.showErrorMessage(x.y_.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
                }, 300),
                e.rejectRpcRequests());
          }),
            e.onRpcError(() => {
              this.isOpen() &&
                (this.isTransactionStackEmpty()
                  ? this.close()
                  : this.popTransactionStack(!0));
            }),
            e.onRpcSuccess((e, t) => {
              let r = O.$.checkIfRequestIsSafe(t),
                i = b.AccountController.state.address,
                n = v.R.state.activeCaipNetwork;
              !r &&
                (this.isTransactionStackEmpty()
                  ? this.close()
                  : this.popTransactionStack(),
                i &&
                  n?.id &&
                  this.updateNativeBalance(i, n.id, n.chainNamespace));
            }),
            e.onNotConnected(() => {
              let e = v.R.state.activeChain;
              f.ConnectorController.getConnectorId(e) ===
                d.b.CONNECTOR_ID.AUTH &&
                (this.setCaipAddress(void 0, e), this.setLoading(!1, e));
            }),
            e.onConnect(async (t) => {
              let r = v.R.state.activeChain,
                i =
                  r === d.b.CHAIN.EVM
                    ? `eip155:${t.chainId}:${t.address}`
                    : `${t.chainId}:${t.address}`;
              this.setSmartAccountDeployed(!!t.smartAccountDeployed, r),
                S.isLowerCaseMatch(
                  t.address,
                  b.AccountController.state.address
                ) ||
                  this.syncIdentity({
                    address: t.address,
                    chainId: t.chainId,
                    chainNamespace: r,
                  }),
                this.setCaipAddress(i, r),
                this.setUser(
                  { ...(b.AccountController.state.user || {}), email: t.email },
                  r
                );
              let n =
                t.preferredAccountType ||
                E.OptionsController.state.defaultAccountTypes[r];
              this.setPreferredAccountType(n, r);
              let s = t.accounts?.map((e) =>
                A.j.createAccount(
                  r,
                  e.address,
                  e.type || E.OptionsController.state.defaultAccountTypes[r]
                )
              );
              this.setAllAccounts(s || [A.j.createAccount(r, t.address, n)], r),
                await e.getSmartAccountEnabledNetworks(),
                this.setLoading(!1, r);
            }),
            e.onSocialConnected(({ userName: e }) => {
              this.setUser(
                { ...(b.AccountController.state.user || {}), username: e },
                v.R.state.activeChain
              );
            }),
            e.onGetSmartAccountEnabledNetworks((e) => {
              this.setSmartAccountEnabledNetworks(e, v.R.state.activeChain);
            }),
            e.onSetPreferredAccount(({ address: e, type: t }) => {
              e && this.setPreferredAccountType(t, v.R.state.activeChain);
            });
        }
        async syncAuthConnector(e, t) {
          let r = d.b.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(t);
          if (!r) return;
          this.setLoading(!0, t);
          let i = e.getLoginEmailUsed();
          this.setLoading(i, t), i && this.setStatus("connecting", t);
          let n = e.getEmail(),
            s = e.getUsername();
          this.setUser(
            {
              ...(b.AccountController.state?.user || {}),
              username: s,
              email: n,
            },
            v.R.state.activeChain
          ),
            this.setupAuthConnectorListeners(e);
          let { isConnected: a } = await e.isConnected(),
            o = C.ThemeController.getSnapshot(),
            l = E.OptionsController.getSnapshot();
          e.syncDappData({
            metadata: l.metadata,
            sdkVersion: l.sdkVersion,
            projectId: l.projectId,
            sdkType: l.sdkType,
          }),
            e.syncTheme({
              themeMode: o.themeMode,
              themeVariables: o.themeVariables,
              w3mThemeVariables: (0, p.t)(o.themeVariables, o.themeMode),
            }),
            t &&
              r &&
              (a && this.connectionControllerClient?.connectExternal
                ? (await this.connectionControllerClient?.connectExternal({
                    id: d.b.CONNECTOR_ID.AUTH,
                    info: { name: d.b.CONNECTOR_ID.AUTH },
                    type: N.b.CONNECTOR_TYPE_AUTH,
                    provider: e,
                    chainId: v.R.state.activeCaipNetwork?.id,
                    chain: t,
                  }),
                  this.setStatus("connected", t))
                : f.ConnectorController.getConnectorId(t) ===
                    d.b.CONNECTOR_ID.AUTH &&
                  (this.setStatus("disconnected", t),
                  _.M.removeConnectedNamespace(t))),
            this.setLoading(!1, t);
        }
        async checkExistingTelegramSocialConnection(e) {
          try {
            if (!A.j.isTelegram()) return;
            let t = _.M.getTelegramSocialProvider();
            if (
              !t ||
              "undefined" == typeof window ||
              "undefined" == typeof document
            )
              return;
            let r = new URL(window.location.href).searchParams.get(
              "result_uri"
            );
            if (!r) return;
            b.AccountController.setSocialProvider(t, e),
              await this.authProvider?.init();
            let i = f.ConnectorController.getAuthConnector();
            t &&
              i &&
              (this.setLoading(!0, e),
              await i.provider.connectSocial(r),
              await g.ConnectionController.connectExternal(i, i.chain),
              _.M.setConnectedSocialProvider(t),
              _.M.removeTelegramSocialProvider(),
              m.X.sendEvent({
                type: "track",
                event: "SOCIAL_LOGIN_SUCCESS",
                properties: { provider: t },
              }));
          } catch (t) {
            this.setLoading(!1, e),
              console.error("checkExistingSTelegramocialConnection error", t);
          }
          try {
            let e = new URL(window.location.href);
            e.searchParams.delete("result_uri"),
              window.history.replaceState({}, document.title, e.toString());
          } catch (e) {
            console.error("tma social login failed", e);
          }
        }
        createAuthProvider(e) {
          if (!d.b.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(e)) return;
          let t =
              this.options?.features?.email === void 0
                ? y.bq.DEFAULT_FEATURES.email
                : this.options?.features?.email,
            r = this.options?.features?.socials
              ? this.options?.features?.socials?.length > 0
              : y.bq.DEFAULT_FEATURES.socials;
          !this.authProvider &&
            this.options?.projectId &&
            (t || r) &&
            ((this.authProvider = rF.getInstance({
              projectId: this.options.projectId,
              enableLogger: this.options.enableAuthLogger,
              chainId: this.getCaipNetwork(e)?.caipNetworkId,
              onTimeout: () => {
                I.AlertController.open(T.ALERT_ERRORS.SOCIALS_TIMEOUT, "error");
              },
            })),
            this.subscribeState((e) => {
              e.open || this.authProvider?.rejectRpcRequests();
            }),
            this.syncAuthConnector(this.authProvider, e),
            this.checkExistingTelegramSocialConnection(e));
        }
        createAuthProviderForAdapter(e) {
          this.createAuthProvider(e),
            this.authProvider &&
              this.chainAdapters?.[e]?.setAuthProvider?.(this.authProvider);
        }
        initControllers(e) {
          super.initControllers(e),
            this.options.excludeWalletIds &&
              w.ApiController.initializeExcludedWalletRdns({
                ids: this.options.excludeWalletIds,
              });
        }
        async switchCaipNetwork(e) {
          if (!e) return;
          let t = v.R.state.activeChain,
            r = e.chainNamespace,
            i = this.getAddressByChainNamespace(e.chainNamespace);
          if (e.chainNamespace === v.R.state.activeChain && i) {
            let t = this.getAdapter(r),
              i = P.h.getProvider(r),
              n = P.h.getProviderId(r);
            await t?.switchNetwork({
              caipNetwork: e,
              provider: i,
              providerType: n,
            }),
              this.setCaipNetwork(e);
          } else {
            let n = P.h.getProviderId(t) === N.b.CONNECTOR_TYPE_AUTH,
              s = P.h.getProviderId(r),
              a = s === N.b.CONNECTOR_TYPE_AUTH,
              o = d.b.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(r);
            if ((n || a) && o)
              try {
                (v.R.state.activeChain = e.chainNamespace),
                  await this.connectionControllerClient?.connectExternal?.({
                    id: d.b.CONNECTOR_ID.AUTH,
                    provider: this.authProvider,
                    chain: r,
                    chainId: e.id,
                    type: N.b.CONNECTOR_TYPE_AUTH,
                    caipNetwork: e,
                  }),
                  this.setCaipNetwork(e);
              } catch (i) {
                let t = this.getAdapter(r);
                await t?.switchNetwork({
                  caipNetwork: e,
                  provider: this.authProvider,
                  providerType: s,
                });
              }
            else
              s === N.b.CONNECTOR_TYPE_WALLET_CONNECT
                ? (this.setCaipNetwork(e), this.syncWalletConnectAccount())
                : (this.setCaipNetwork(e),
                  i &&
                    this.syncAccount({
                      address: i,
                      chainId: e.id,
                      chainNamespace: r,
                    }));
          }
        }
        async initChainAdapter(e) {
          await super.initChainAdapter(e), this.createAuthProviderForAdapter(e);
        }
        async syncIdentity({ address: e, chainId: t, chainNamespace: r }) {
          let i = `${r}:${t}`,
            n = this.caipNetworks?.find((e) => e.caipNetworkId === i);
          if (r !== d.b.CHAIN.EVM || n?.testnet) {
            this.setProfileName(null, r), this.setProfileImage(null, r);
            return;
          }
          try {
            let { name: n, avatar: s } = await this.fetchIdentity({
              address: e,
              caipNetworkId: i,
            });
            if ((this.setProfileName(n, r), this.setProfileImage(s, r), !n)) {
              let i = this.getAdapter(r),
                n = await i?.getProfile({ address: e, chainId: Number(t) });
              n?.profileName
                ? (this.setProfileName(n.profileName, r),
                  n.profileImage && this.setProfileImage(n.profileImage, r))
                : (await this.syncReownName(e, r),
                  this.setProfileImage(null, r));
            }
          } catch {
            await this.syncReownName(e, r),
              1 !== t && this.setProfileImage(null, r);
          }
        }
        syncConnectedWalletInfo(e) {
          let t = P.h.getProviderId(e);
          if (t === N.b.CONNECTOR_TYPE_AUTH) {
            let r = this.authProvider;
            if (r) {
              let i = _.M.getConnectedSocialProvider() ?? "email",
                n = r.getEmail() ?? r.getUsername();
              this.setConnectedWalletInfo(
                { name: t, identifier: n, social: i },
                e
              );
            }
          } else super.syncConnectedWalletInfo(e);
        }
        async injectModalUi() {
          if (!i$ && A.j.isClient()) {
            let e = { ...y.bq.DEFAULT_FEATURES, ...this.options.features },
              t = [];
            if (
              (e &&
                ((e.email || (e.socials && e.socials.length)) &&
                  t.push(
                    Promise.all([r.e(7106), r.e(4238), r.e(4685)]).then(
                      r.bind(r, 24685)
                    )
                  ),
                e.email &&
                  t.push(
                    Promise.all([r.e(7106), r.e(4238), r.e(1741)]).then(
                      r.bind(r, 41741)
                    )
                  ),
                e.socials &&
                  t.push(
                    Promise.all([r.e(7106), r.e(930), r.e(8867)]).then(
                      r.bind(r, 76654)
                    )
                  ),
                e.swaps &&
                  t.push(
                    Promise.all([r.e(7106), r.e(4238), r.e(6268)]).then(
                      r.bind(r, 96268)
                    )
                  ),
                e.send &&
                  t.push(
                    Promise.all([r.e(7106), r.e(4238), r.e(4285)]).then(
                      r.bind(r, 34285)
                    )
                  ),
                e.receive &&
                  t.push(
                    Promise.all([r.e(7106), r.e(930), r.e(6141)]).then(
                      r.bind(r, 50443)
                    )
                  ),
                e.onramp &&
                  t.push(
                    Promise.all([
                      r.e(7106),
                      r.e(4238),
                      r.e(3156),
                      r.e(1029),
                    ]).then(r.bind(r, 71029))
                  ),
                e.history &&
                  t.push(
                    Promise.all([r.e(7106), r.e(5557), r.e(4839)]).then(
                      r.bind(r, 23227)
                    )
                  )),
              await Promise.all([
                ...t,
                Promise.all([
                  r.e(7106),
                  r.e(4238),
                  r.e(930),
                  r.e(3156),
                  r.e(5557),
                  r.e(443),
                  r.e(4474),
                ]).then(r.bind(r, 24474)),
                Promise.all([r.e(7106), r.e(443), r.e(996)]).then(
                  r.bind(r, 53869)
                ),
              ]),
              !document.querySelector("w3m-modal"))
            ) {
              let e = document.createElement("w3m-modal");
              E.OptionsController.state.disableAppend ||
                E.OptionsController.state.enableEmbedded ||
                document.body.insertAdjacentElement("beforeend", e);
            }
            i$ = !0;
          }
        }
      }
    },
    47319: function (e, t, r) {
      "use strict";
      r.d(t, {
        z: function () {
          return o;
        },
      }),
        r(76356);
      var i = r(44649),
        n = r(60389),
        s = r(91426),
        a = r(89977);
      class o {
        constructor({ provider: e, caipNetworks: t, namespace: r }) {
          (this.id = i.b.CONNECTOR_ID.WALLET_CONNECT),
            (this.name =
              s.C.ConnectorNamesMap[i.b.CONNECTOR_ID.WALLET_CONNECT]),
            (this.type = "WALLET_CONNECT"),
            (this.imageId =
              s.C.ConnectorImageIds[i.b.CONNECTOR_ID.WALLET_CONNECT]),
            (this.caipNetworks = t),
            (this.provider = e),
            (this.chain = r);
        }
        get chains() {
          return this.caipNetworks;
        }
        async connectWalletConnect() {
          return (
            (await this.authenticate()) ||
              (await this.provider.connect({
                optionalNamespaces: a.s.createNamespaces(this.caipNetworks),
              })),
            {
              clientId: await this.provider.client.core.crypto.getClientId(),
              session: this.provider.session,
            }
          );
        }
        async disconnect() {
          await this.provider.disconnect();
        }
        async authenticate() {
          let e = this.chains.map((e) => e.caipNetworkId);
          return n.w.universalProviderAuthenticate({
            universalProvider: this.provider,
            chains: e,
            methods: l,
          });
        }
      }
      let l = [
        "eth_accounts",
        "eth_requestAccounts",
        "eth_sendRawTransaction",
        "eth_sign",
        "eth_signTransaction",
        "eth_signTypedData",
        "eth_signTypedData_v3",
        "eth_signTypedData_v4",
        "eth_sendTransaction",
        "personal_sign",
        "wallet_switchEthereumChain",
        "wallet_addEthereumChain",
        "wallet_getPermissions",
        "wallet_requestPermissions",
        "wallet_registerOnboarding",
        "wallet_watchAsset",
        "wallet_scanQRCode",
        "wallet_getCallsStatus",
        "wallet_sendCalls",
        "wallet_getCapabilities",
        "wallet_grantPermissions",
        "wallet_revokePermissions",
        "wallet_getAssets",
      ];
    },
    54170: function (e, t, r) {
      "use strict";
      function i(e) {
        return { formatters: void 0, fees: void 0, serializers: void 0, ...e };
      }
      r.d(t, {
        yXc: function () {
          return n;
        },
        Zkw: function () {
          return s;
        },
        ueV: function () {
          return el;
        },
        eGR: function () {
          return ec;
        },
        RdO: function () {
          return eu;
        },
        MF$: function () {
          return eh;
        },
        RJ0: function () {
          return ed;
        },
        Fox: function () {
          return ep;
        },
        Zjg: function () {
          return eg;
        },
        ol5: function () {
          return em;
        },
      });
      let n = i({
          id: 42161,
          name: "Arbitrum One",
          nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
          rpcUrls: { default: { http: ["https://arb1.arbitrum.io/rpc"] } },
          blockExplorers: {
            default: {
              name: "Arbiscan",
              url: "https://arbiscan.io",
              apiUrl: "https://api.arbiscan.io/api",
            },
          },
          contracts: {
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 7654707,
            },
          },
        }),
        s = i({
          id: 421614,
          name: "Arbitrum Sepolia",
          nativeCurrency: {
            name: "Arbitrum Sepolia Ether",
            symbol: "ETH",
            decimals: 18,
          },
          rpcUrls: {
            default: { http: ["https://sepolia-rollup.arbitrum.io/rpc"] },
          },
          blockExplorers: {
            default: {
              name: "Arbiscan",
              url: "https://sepolia.arbiscan.io",
              apiUrl: "https://api-sepolia.arbiscan.io/api",
            },
          },
          contracts: {
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 81930,
            },
          },
          testnet: !0,
        });
      var a = r(72932);
      function o(e, t) {
        return ({ exclude: r, format: i }) => ({
          exclude: r,
          format: (e) => {
            let n = t(e);
            if (r) for (let e of r) delete n[e];
            return { ...n, ...i(e) };
          },
          type: e,
        });
      }
      let l = {
        "0x0": "legacy",
        "0x1": "eip2930",
        "0x2": "eip1559",
        "0x3": "eip4844",
        "0x4": "eip7702",
      };
      function c(e) {
        let t = {
          ...e,
          blockHash: e.blockHash ? e.blockHash : null,
          blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
          chainId: e.chainId ? (0, a.ly)(e.chainId) : void 0,
          gas: e.gas ? BigInt(e.gas) : void 0,
          gasPrice: e.gasPrice ? BigInt(e.gasPrice) : void 0,
          maxFeePerBlobGas: e.maxFeePerBlobGas
            ? BigInt(e.maxFeePerBlobGas)
            : void 0,
          maxFeePerGas: e.maxFeePerGas ? BigInt(e.maxFeePerGas) : void 0,
          maxPriorityFeePerGas: e.maxPriorityFeePerGas
            ? BigInt(e.maxPriorityFeePerGas)
            : void 0,
          nonce: e.nonce ? (0, a.ly)(e.nonce) : void 0,
          to: e.to ? e.to : null,
          transactionIndex: e.transactionIndex
            ? Number(e.transactionIndex)
            : null,
          type: e.type ? l[e.type] : void 0,
          typeHex: e.type ? e.type : void 0,
          value: e.value ? BigInt(e.value) : void 0,
          v: e.v ? BigInt(e.v) : void 0,
        };
        return (
          e.authorizationList &&
            (t.authorizationList = e.authorizationList.map((e) => ({
              address: e.address,
              chainId: Number(e.chainId),
              nonce: Number(e.nonce),
              r: e.r,
              s: e.s,
              yParity: Number(e.yParity),
            }))),
          (t.yParity = (() => {
            if (e.yParity) return Number(e.yParity);
            if ("bigint" == typeof t.v) {
              if (0n === t.v || 27n === t.v) return 0;
              if (1n === t.v || 28n === t.v) return 1;
              if (t.v >= 35n) return t.v % 2n === 0n ? 1 : 0;
            }
          })()),
          "legacy" === t.type &&
            (delete t.accessList,
            delete t.maxFeePerBlobGas,
            delete t.maxFeePerGas,
            delete t.maxPriorityFeePerGas,
            delete t.yParity),
          "eip2930" === t.type &&
            (delete t.maxFeePerBlobGas,
            delete t.maxFeePerGas,
            delete t.maxPriorityFeePerGas),
          "eip1559" === t.type && delete t.maxFeePerBlobGas,
          t
        );
      }
      let u = o("transaction", c),
        h = o("block", function (e) {
          let t = (e.transactions ?? []).map((e) =>
            "string" == typeof e ? e : c(e)
          );
          return {
            ...e,
            baseFeePerGas: e.baseFeePerGas ? BigInt(e.baseFeePerGas) : null,
            blobGasUsed: e.blobGasUsed ? BigInt(e.blobGasUsed) : void 0,
            difficulty: e.difficulty ? BigInt(e.difficulty) : void 0,
            excessBlobGas: e.excessBlobGas ? BigInt(e.excessBlobGas) : void 0,
            gasLimit: e.gasLimit ? BigInt(e.gasLimit) : void 0,
            gasUsed: e.gasUsed ? BigInt(e.gasUsed) : void 0,
            hash: e.hash ? e.hash : null,
            logsBloom: e.logsBloom ? e.logsBloom : null,
            nonce: e.nonce ? e.nonce : null,
            number: e.number ? BigInt(e.number) : null,
            size: e.size ? BigInt(e.size) : void 0,
            timestamp: e.timestamp ? BigInt(e.timestamp) : void 0,
            transactions: t,
            totalDifficulty: e.totalDifficulty
              ? BigInt(e.totalDifficulty)
              : null,
          };
        }),
        d = { "0x0": "reverted", "0x1": "success" },
        p = o("transactionReceipt", function (e) {
          let t = {
            ...e,
            blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
            contractAddress: e.contractAddress ? e.contractAddress : null,
            cumulativeGasUsed: e.cumulativeGasUsed
              ? BigInt(e.cumulativeGasUsed)
              : null,
            effectiveGasPrice: e.effectiveGasPrice
              ? BigInt(e.effectiveGasPrice)
              : null,
            gasUsed: e.gasUsed ? BigInt(e.gasUsed) : null,
            logs: e.logs
              ? e.logs.map((e) =>
                  (function (e, { args: t, eventName: r } = {}) {
                    return {
                      ...e,
                      blockHash: e.blockHash ? e.blockHash : null,
                      blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
                      logIndex: e.logIndex ? Number(e.logIndex) : null,
                      transactionHash: e.transactionHash
                        ? e.transactionHash
                        : null,
                      transactionIndex: e.transactionIndex
                        ? Number(e.transactionIndex)
                        : null,
                      ...(r ? { args: t, eventName: r } : {}),
                    };
                  })(e)
                )
              : null,
            to: e.to ? e.to : null,
            transactionIndex: e.transactionIndex
              ? (0, a.ly)(e.transactionIndex)
              : null,
            status: e.status ? d[e.status] : null,
            type: e.type ? l[e.type] || e.type : null,
          };
          return (
            e.blobGasPrice && (t.blobGasPrice = BigInt(e.blobGasPrice)),
            e.blobGasUsed && (t.blobGasUsed = BigInt(e.blobGasUsed)),
            t
          );
        }),
        f = {
          block: h({
            format: (e) => ({
              transactions: e.transactions?.map((e) => {
                if ("string" == typeof e) return e;
                let t = c(e);
                return (
                  "0x7e" === t.typeHex &&
                    ((t.isSystemTx = e.isSystemTx),
                    (t.mint = e.mint ? a.y_(e.mint) : void 0),
                    (t.sourceHash = e.sourceHash),
                    (t.type = "deposit")),
                  t
                );
              }),
              stateRoot: e.stateRoot,
            }),
          }),
          transaction: u({
            format(e) {
              let t = {};
              return (
                "0x7e" === e.type &&
                  ((t.isSystemTx = e.isSystemTx),
                  (t.mint = e.mint ? (0, a.y_)(e.mint) : void 0),
                  (t.sourceHash = e.sourceHash),
                  (t.type = "deposit")),
                t
              );
            },
          }),
          transactionReceipt: p({
            format: (e) => ({
              l1GasPrice: e.l1GasPrice ? (0, a.y_)(e.l1GasPrice) : null,
              l1GasUsed: e.l1GasUsed ? (0, a.y_)(e.l1GasUsed) : null,
              l1Fee: e.l1Fee ? (0, a.y_)(e.l1Fee) : null,
              l1FeeScalar: e.l1FeeScalar ? Number(e.l1FeeScalar) : null,
            }),
          }),
        };
      var g = r(81544);
      class m extends g.G {
        constructor({ address: e }) {
          super(`Address "${e}" is invalid.`, {
            metaMessages: [
              "- Address must be a hex value of 20 bytes (40 hex characters).",
              "- Address must match its checksum counterpart.",
            ],
            name: "InvalidAddressError",
          });
        }
      }
      var y = r(82061),
        w = r(93610),
        b = r(8796),
        v = r(59455);
      let E = new TextEncoder();
      function A(e, t = {}) {
        return "number" == typeof e || "bigint" == typeof e
          ? I((0, v.eC)(e, t))
          : "boolean" == typeof e
          ? (function (e, t = {}) {
              let r = new Uint8Array(1);
              return ((r[0] = Number(e)), "number" == typeof t.size)
                ? ((0, a.Yf)(r, { size: t.size }),
                  (0, b.vk)(r, { size: t.size }))
                : r;
            })(e, t)
          : (0, w.v)(e)
          ? I(e, t)
          : N(e, t);
      }
      let C = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
      function _(e) {
        return e >= C.zero && e <= C.nine
          ? e - C.zero
          : e >= C.A && e <= C.F
          ? e - (C.A - 10)
          : e >= C.a && e <= C.f
          ? e - (C.a - 10)
          : void 0;
      }
      function I(e, t = {}) {
        let r = e;
        t.size &&
          ((0, a.Yf)(r, { size: t.size }),
          (r = (0, b.vk)(r, { dir: "right", size: t.size })));
        let i = r.slice(2);
        i.length % 2 && (i = `0${i}`);
        let n = i.length / 2,
          s = new Uint8Array(n);
        for (let e = 0, t = 0; e < n; e++) {
          let r = _(i.charCodeAt(t++)),
            n = _(i.charCodeAt(t++));
          if (void 0 === r || void 0 === n)
            throw new g.G(
              `Invalid byte sequence ("${i[t - 2]}${i[t - 1]}" in "${i}").`
            );
          s[e] = 16 * r + n;
        }
        return s;
      }
      function N(e, t = {}) {
        let r = E.encode(e);
        return "number" == typeof t.size
          ? ((0, a.Yf)(r, { size: t.size }),
            (0, b.vk)(r, { dir: "right", size: t.size }))
          : r;
      }
      var S = r(86691);
      let T = new y.k(8192),
        P = /^0x[a-fA-F0-9]{40}$/,
        O = new y.k(8192);
      function x(e, t) {
        let { strict: r = !0 } = t ?? {},
          i = `${e}.${r}`;
        if (O.has(i)) return O.get(i);
        let n =
          !!P.test(e) &&
          (e.toLowerCase() === e ||
            !r ||
            (function (e, t) {
              if (T.has(`${e}.undefined`)) return T.get(`${e}.undefined`);
              let r = e.substring(2).toLowerCase(),
                i = (function (e, t) {
                  let r = (0, S.fr)((0, w.v)(e, { strict: !1 }) ? A(e) : e);
                  return "bytes" === (t || "hex") ? r : (0, v.NC)(r);
                })(N(r), "bytes"),
                n = (t ? r.substring(`${t}0x`.length) : r).split("");
              for (let e = 0; e < 40; e += 2)
                i[e >> 1] >> 4 >= 8 && n[e] && (n[e] = n[e].toUpperCase()),
                  (15 & i[e >> 1]) >= 8 &&
                    n[e + 1] &&
                    (n[e + 1] = n[e + 1].toUpperCase());
              let s = `0x${n.join("")}`;
              return T.set(`${e}.${t}`, s), s;
            })(e) === e);
        return O.set(i, n), n;
      }
      function k(e) {
        return `0x${e.reduce((e, t) => e + t.replace("0x", ""), "")}`;
      }
      class R extends g.G {
        constructor({ offset: e }) {
          super(`Offset \`${e}\` cannot be negative.`, {
            name: "NegativeOffsetError",
          });
        }
      }
      class D extends g.G {
        constructor({ length: e, position: t }) {
          super(
            `Position \`${t}\` is out of bounds (\`0 < position < ${e}\`).`,
            { name: "PositionOutOfBoundsError" }
          );
        }
      }
      class U extends g.G {
        constructor({ count: e, limit: t }) {
          super(
            `Recursive read limit of \`${t}\` exceeded (recursive read count: \`${e}\`).`,
            { name: "RecursiveReadLimitExceededError" }
          );
        }
      }
      let L = {
        bytes: new Uint8Array(),
        dataView: new DataView(new ArrayBuffer(0)),
        position: 0,
        positionReadCount: new Map(),
        recursiveReadCount: 0,
        recursiveReadLimit: Number.POSITIVE_INFINITY,
        assertReadLimit() {
          if (this.recursiveReadCount >= this.recursiveReadLimit)
            throw new U({
              count: this.recursiveReadCount + 1,
              limit: this.recursiveReadLimit,
            });
        },
        assertPosition(e) {
          if (e < 0 || e > this.bytes.length - 1)
            throw new D({ length: this.bytes.length, position: e });
        },
        decrementPosition(e) {
          if (e < 0) throw new R({ offset: e });
          let t = this.position - e;
          this.assertPosition(t), (this.position = t);
        },
        getReadCount(e) {
          return this.positionReadCount.get(e || this.position) || 0;
        },
        incrementPosition(e) {
          if (e < 0) throw new R({ offset: e });
          let t = this.position + e;
          this.assertPosition(t), (this.position = t);
        },
        inspectByte(e) {
          let t = e ?? this.position;
          return this.assertPosition(t), this.bytes[t];
        },
        inspectBytes(e, t) {
          let r = t ?? this.position;
          return this.assertPosition(r + e - 1), this.bytes.subarray(r, r + e);
        },
        inspectUint8(e) {
          let t = e ?? this.position;
          return this.assertPosition(t), this.bytes[t];
        },
        inspectUint16(e) {
          let t = e ?? this.position;
          return this.assertPosition(t + 1), this.dataView.getUint16(t);
        },
        inspectUint24(e) {
          let t = e ?? this.position;
          return (
            this.assertPosition(t + 2),
            (this.dataView.getUint16(t) << 8) + this.dataView.getUint8(t + 2)
          );
        },
        inspectUint32(e) {
          let t = e ?? this.position;
          return this.assertPosition(t + 3), this.dataView.getUint32(t);
        },
        pushByte(e) {
          this.assertPosition(this.position),
            (this.bytes[this.position] = e),
            this.position++;
        },
        pushBytes(e) {
          this.assertPosition(this.position + e.length - 1),
            this.bytes.set(e, this.position),
            (this.position += e.length);
        },
        pushUint8(e) {
          this.assertPosition(this.position),
            (this.bytes[this.position] = e),
            this.position++;
        },
        pushUint16(e) {
          this.assertPosition(this.position + 1),
            this.dataView.setUint16(this.position, e),
            (this.position += 2);
        },
        pushUint24(e) {
          this.assertPosition(this.position + 2),
            this.dataView.setUint16(this.position, e >> 8),
            this.dataView.setUint8(this.position + 2, 255 & e),
            (this.position += 3);
        },
        pushUint32(e) {
          this.assertPosition(this.position + 3),
            this.dataView.setUint32(this.position, e),
            (this.position += 4);
        },
        readByte() {
          this.assertReadLimit(), this._touch();
          let e = this.inspectByte();
          return this.position++, e;
        },
        readBytes(e, t) {
          this.assertReadLimit(), this._touch();
          let r = this.inspectBytes(e);
          return (this.position += t ?? e), r;
        },
        readUint8() {
          this.assertReadLimit(), this._touch();
          let e = this.inspectUint8();
          return (this.position += 1), e;
        },
        readUint16() {
          this.assertReadLimit(), this._touch();
          let e = this.inspectUint16();
          return (this.position += 2), e;
        },
        readUint24() {
          this.assertReadLimit(), this._touch();
          let e = this.inspectUint24();
          return (this.position += 3), e;
        },
        readUint32() {
          this.assertReadLimit(), this._touch();
          let e = this.inspectUint32();
          return (this.position += 4), e;
        },
        get remaining() {
          return this.bytes.length - this.position;
        },
        setPosition(e) {
          let t = this.position;
          return (
            this.assertPosition(e),
            (this.position = e),
            () => (this.position = t)
          );
        },
        _touch() {
          if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;
          let e = this.getReadCount();
          this.positionReadCount.set(this.position, e + 1),
            e > 0 && this.recursiveReadCount++;
        },
      };
      function M(e, { recursiveReadLimit: t = 8192 } = {}) {
        let r = Object.create(L);
        return (
          (r.bytes = e),
          (r.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength)),
          (r.positionReadCount = new Map()),
          (r.recursiveReadLimit = t),
          r
        );
      }
      function B(e, t = "hex") {
        let r = (function e(t) {
            return Array.isArray(t)
              ? (function (e) {
                  let t = e.reduce((e, t) => e + t.length, 0),
                    r = j(t);
                  return {
                    length: t <= 55 ? 1 + t : 1 + r + t,
                    encode(i) {
                      for (let { encode: n } of (t <= 55
                        ? i.pushByte(192 + t)
                        : (i.pushByte(247 + r),
                          1 === r
                            ? i.pushUint8(t)
                            : 2 === r
                            ? i.pushUint16(t)
                            : 3 === r
                            ? i.pushUint24(t)
                            : i.pushUint32(t)),
                      e))
                        n(i);
                    },
                  };
                })(t.map((t) => e(t)))
              : (function (e) {
                  let t = "string" == typeof e ? I(e) : e,
                    r = j(t.length);
                  return {
                    length:
                      1 === t.length && t[0] < 128
                        ? 1
                        : t.length <= 55
                        ? 1 + t.length
                        : 1 + r + t.length,
                    encode(e) {
                      (1 === t.length && t[0] < 128) ||
                        (t.length <= 55
                          ? e.pushByte(128 + t.length)
                          : (e.pushByte(183 + r),
                            1 === r
                              ? e.pushUint8(t.length)
                              : 2 === r
                              ? e.pushUint16(t.length)
                              : 3 === r
                              ? e.pushUint24(t.length)
                              : e.pushUint32(t.length))),
                        e.pushBytes(t);
                    },
                  };
                })(t);
          })(e),
          i = M(new Uint8Array(r.length));
        return (r.encode(i), "hex" === t) ? (0, v.ci)(i.bytes) : i.bytes;
      }
      function j(e) {
        if (e < 256) return 1;
        if (e < 65536) return 2;
        if (e < 16777216) return 3;
        if (e < 4294967296) return 4;
        throw new g.G("Length is too large.");
      }
      r(98173), r(39502), r(29707);
      class F extends g.G {
        constructor({ v: e }) {
          super(`Invalid \`v\` value "${e}". Expected 27 or 28.`, {
            name: "InvalidLegacyVError",
          });
        }
      }
      class $ extends g.G {
        constructor({ transaction: e }) {
          super("Cannot infer a transaction type from provided transaction.", {
            metaMessages: [
              "Provided Transaction:",
              "{",
              (function (e) {
                let t = Object.entries(e)
                    .map(([e, t]) => (void 0 === t || !1 === t ? null : [e, t]))
                    .filter(Boolean),
                  r = t.reduce((e, [t]) => Math.max(e, t.length), 0);
                return t
                  .map(([e, t]) => `  ${`${e}:`.padEnd(r + 1)}  ${t}`)
                  .join("\n");
              })(e),
              "}",
              "",
              "To infer the type, either provide:",
              "- a `type` to the Transaction, or",
              "- an EIP-1559 Transaction with `maxFeePerGas`, or",
              "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
              "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
              "- an EIP-7702 Transaction with `authorizationList`, or",
              "- a Legacy Transaction with `gasPrice`",
            ],
            name: "InvalidSerializableTransactionError",
          });
        }
      }
      class H extends g.G {
        constructor({ storageKey: e }) {
          super(
            `Size for storage key "${e}" is invalid. Expected 32 bytes. Got ${Math.floor(
              (e.length - 2) / 2
            )} bytes.`,
            { name: "InvalidStorageKeySizeError" }
          );
        }
      }
      function z(e) {
        let { kzg: t } = e,
          r = e.to ?? ("string" == typeof e.blobs[0] ? "hex" : "bytes"),
          i =
            "string" == typeof e.blobs[0] ? e.blobs.map((e) => I(e)) : e.blobs,
          n = [];
        for (let e of i) n.push(Uint8Array.from(t.blobToKzgCommitment(e)));
        return "bytes" === r ? n : n.map((e) => (0, v.ci)(e));
      }
      function q(e) {
        let { kzg: t } = e,
          r = e.to ?? ("string" == typeof e.blobs[0] ? "hex" : "bytes"),
          i =
            "string" == typeof e.blobs[0] ? e.blobs.map((e) => I(e)) : e.blobs,
          n =
            "string" == typeof e.commitments[0]
              ? e.commitments.map((e) => I(e))
              : e.commitments,
          s = [];
        for (let e = 0; e < i.length; e++) {
          let r = i[e],
            a = n[e];
          s.push(Uint8Array.from(t.computeBlobKzgProof(r, a)));
        }
        return "bytes" === r ? s : s.map((e) => (0, v.ci)(e));
      }
      var V = r(21512);
      class G extends g.G {
        constructor({ maxSize: e, size: t }) {
          super("Blob size is too large.", {
            metaMessages: [`Max: ${e} bytes`, `Given: ${t} bytes`],
            name: "BlobSizeTooLargeError",
          });
        }
      }
      class W extends g.G {
        constructor() {
          super("Blob data must not be empty.", { name: "EmptyBlobError" });
        }
      }
      class K extends g.G {
        constructor({ hash: e, size: t }) {
          super(`Versioned hash "${e}" size is invalid.`, {
            metaMessages: ["Expected: 32", `Received: ${t}`],
            name: "InvalidVersionedHashSizeError",
          });
        }
      }
      class Z extends g.G {
        constructor({ hash: e, version: t }) {
          super(`Versioned hash "${e}" version is invalid.`, {
            metaMessages: ["Expected: 1", `Received: ${t}`],
            name: "InvalidVersionedHashVersionError",
          });
        }
      }
      var J = r(20556);
      function Q(e, { dir: t = "left" } = {}) {
        let r = "string" == typeof e ? e.replace("0x", "") : e,
          i = 0;
        for (
          let e = 0;
          e < r.length - 1 &&
          "0" === r["left" === t ? e : r.length - e - 1].toString();
          e++
        )
          i++;
        return ((r = "left" === t ? r.slice(i) : r.slice(0, r.length - i)),
        "string" == typeof e)
          ? (1 === r.length && "right" === t && (r = `${r}0`),
            `0x${r.length % 2 == 1 ? `0${r}` : r}`)
          : r;
      }
      let Y = 2n ** 256n - 1n;
      class X extends g.G {
        constructor({ chainId: e }) {
          super(
            "number" == typeof e
              ? `Chain ID "${e}" is invalid.`
              : "Chain ID is invalid.",
            { name: "InvalidChainIdError" }
          );
        }
      }
      var ee = r(78125),
        et = r(47116);
      function er(e, t) {
        if ("number" == typeof t && t > 0 && t > (0, J.d)(e) - 1)
          throw new et.mV({ offset: t, position: "start", size: (0, J.d)(e) });
      }
      function ei(e, t, r) {
        if (
          "number" == typeof t &&
          "number" == typeof r &&
          (0, J.d)(e) !== r - t
        )
          throw new et.mV({ offset: r, position: "end", size: (0, J.d)(e) });
      }
      function en(e) {
        let { chainId: t, maxPriorityFeePerGas: r, maxFeePerGas: i, to: n } = e;
        if (t <= 0) throw new X({ chainId: t });
        if (n && !x(n)) throw new m({ address: n });
        if (i && i > Y) throw new ee.Hh({ maxFeePerGas: i });
        if (r && i && r > i)
          throw new ee.cs({ maxFeePerGas: i, maxPriorityFeePerGas: r });
      }
      function es(e) {
        if (!e || 0 === e.length) return [];
        let t = [];
        for (let r = 0; r < e.length; r++) {
          let { address: i, storageKeys: n } = e[r];
          for (let e = 0; e < n.length; e++)
            if (n[e].length - 2 != 64) throw new H({ storageKey: n[e] });
          if (!x(i, { strict: !1 })) throw new m({ address: i });
          t.push([i, n]);
        }
        return t;
      }
      function ea(e, t) {
        let r = t ?? e,
          { v: i, yParity: n } = r;
        if (void 0 === r.r || void 0 === r.s || (void 0 === i && void 0 === n))
          return [];
        let s = Q(r.r),
          a = Q(r.s);
        return [
          "number" == typeof n
            ? n
              ? (0, v.NC)(1)
              : "0x"
            : 0n === i
            ? "0x"
            : 1n === i
            ? (0, v.NC)(1)
            : 27n === i
            ? "0x"
            : (0, v.NC)(1),
          "0x00" === s ? "0x" : s,
          "0x00" === a ? "0x" : a,
        ];
      }
      let eo = {
          contracts: {
            gasPriceOracle: {
              address: "0x420000000000000000000000000000000000000F",
            },
            l1Block: { address: "0x4200000000000000000000000000000000000015" },
            l2CrossDomainMessenger: {
              address: "0x4200000000000000000000000000000000000007",
            },
            l2Erc721Bridge: {
              address: "0x4200000000000000000000000000000000000014",
            },
            l2StandardBridge: {
              address: "0x4200000000000000000000000000000000000010",
            },
            l2ToL1MessagePasser: {
              address: "0x4200000000000000000000000000000000000016",
            },
          },
          formatters: f,
          serializers: {
            transaction: function (e, t) {
              return "deposit" === e.type || void 0 !== e.sourceHash
                ? (function (e) {
                    !(function (e) {
                      let { from: t, to: r } = e;
                      if (t && !x(t)) throw new m({ address: t });
                      if (r && !x(r)) throw new m({ address: r });
                    })(e);
                    let {
                      sourceHash: t,
                      data: r,
                      from: i,
                      gas: n,
                      isSystemTx: s,
                      mint: a,
                      to: o,
                      value: l,
                    } = e;
                    return k([
                      "0x7e",
                      B([
                        t,
                        i,
                        o ?? "0x",
                        a ? (0, v.NC)(a) : "0x",
                        l ? (0, v.NC)(l) : "0x",
                        n ? (0, v.NC)(n) : "0x",
                        s ? "0x1" : "0x",
                        r ?? "0x",
                      ]),
                    ]);
                  })(e)
                : (function (e, t) {
                    let r = (function (e) {
                      if (e.type) return e.type;
                      if (void 0 !== e.authorizationList) return "eip7702";
                      if (
                        void 0 !== e.blobs ||
                        void 0 !== e.blobVersionedHashes ||
                        void 0 !== e.maxFeePerBlobGas ||
                        void 0 !== e.sidecars
                      )
                        return "eip4844";
                      if (
                        void 0 !== e.maxFeePerGas ||
                        void 0 !== e.maxPriorityFeePerGas
                      )
                        return "eip1559";
                      if (void 0 !== e.gasPrice)
                        return void 0 !== e.accessList ? "eip2930" : "legacy";
                      throw new $({ transaction: e });
                    })(e);
                    return "eip1559" === r
                      ? (function (e, t) {
                          let {
                            chainId: r,
                            gas: i,
                            nonce: n,
                            to: s,
                            value: a,
                            maxFeePerGas: o,
                            maxPriorityFeePerGas: l,
                            accessList: c,
                            data: u,
                          } = e;
                          en(e);
                          let h = es(c);
                          return k([
                            "0x02",
                            B([
                              (0, v.NC)(r),
                              n ? (0, v.NC)(n) : "0x",
                              l ? (0, v.NC)(l) : "0x",
                              o ? (0, v.NC)(o) : "0x",
                              i ? (0, v.NC)(i) : "0x",
                              s ?? "0x",
                              a ? (0, v.NC)(a) : "0x",
                              u ?? "0x",
                              h,
                              ...ea(e, t),
                            ]),
                          ]);
                        })(e, t)
                      : "eip2930" === r
                      ? (function (e, t) {
                          let {
                            chainId: r,
                            gas: i,
                            data: n,
                            nonce: s,
                            to: a,
                            value: o,
                            accessList: l,
                            gasPrice: c,
                          } = e;
                          !(function (e) {
                            let {
                              chainId: t,
                              maxPriorityFeePerGas: r,
                              gasPrice: i,
                              maxFeePerGas: n,
                              to: s,
                            } = e;
                            if (t <= 0) throw new X({ chainId: t });
                            if (s && !x(s)) throw new m({ address: s });
                            if (r || n)
                              throw new g.G(
                                "`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute."
                              );
                            if (i && i > Y)
                              throw new ee.Hh({ maxFeePerGas: i });
                          })(e);
                          let u = es(l);
                          return k([
                            "0x01",
                            B([
                              (0, v.NC)(r),
                              s ? (0, v.NC)(s) : "0x",
                              c ? (0, v.NC)(c) : "0x",
                              i ? (0, v.NC)(i) : "0x",
                              a ?? "0x",
                              o ? (0, v.NC)(o) : "0x",
                              n ?? "0x",
                              u,
                              ...ea(e, t),
                            ]),
                          ]);
                        })(e, t)
                      : "eip4844" === r
                      ? (function (e, t) {
                          let {
                            chainId: r,
                            gas: i,
                            nonce: n,
                            to: s,
                            value: o,
                            maxFeePerBlobGas: l,
                            maxFeePerGas: c,
                            maxPriorityFeePerGas: u,
                            accessList: h,
                            data: d,
                          } = e;
                          !(function (e) {
                            let { blobVersionedHashes: t } = e;
                            if (t) {
                              if (0 === t.length) throw new W();
                              for (let e of t) {
                                let t = (0, J.d)(e),
                                  r = (0, a.ly)(
                                    (function (e, t, r, { strict: i } = {}) {
                                      return (0, w.v)(e, { strict: !1 })
                                        ? (function (
                                            e,
                                            t,
                                            r,
                                            { strict: i } = {}
                                          ) {
                                            er(e, 0);
                                            let n = `0x${e
                                              .replace("0x", "")
                                              .slice(0 * 2, 2)}`;
                                            return i && ei(n, t, 1), n;
                                          })(e, 0, 1, { strict: i })
                                        : (function (
                                            e,
                                            t,
                                            r,
                                            { strict: i } = {}
                                          ) {
                                            er(e, 0);
                                            let n = e.slice(t, 1);
                                            return i && ei(n, t, r), n;
                                          })(e, 0, 1, { strict: i });
                                    })(e, 0, 0)
                                  );
                                if (32 !== t) throw new K({ hash: e, size: t });
                                if (1 !== r)
                                  throw new Z({ hash: e, version: r });
                              }
                            }
                            en(e);
                          })(e);
                          let p = e.blobVersionedHashes,
                            f = e.sidecars;
                          if (e.blobs && (void 0 === p || void 0 === f)) {
                            let t =
                                "string" == typeof e.blobs[0]
                                  ? e.blobs
                                  : e.blobs.map((e) => (0, v.ci)(e)),
                              r = e.kzg,
                              i = z({ blobs: t, kzg: r });
                            if (
                              (void 0 === p &&
                                (p = (function (e) {
                                  let { commitments: t, version: r } = e,
                                    i =
                                      e.to ??
                                      ("string" == typeof t[0]
                                        ? "hex"
                                        : "bytes"),
                                    n = [];
                                  for (let e of t)
                                    n.push(
                                      (function (e) {
                                        let { commitment: t, version: r = 1 } =
                                            e,
                                          i =
                                            e.to ??
                                            ("string" == typeof t
                                              ? "hex"
                                              : "bytes"),
                                          n = (function (e, t) {
                                            let r = (0, V.JQ)(
                                              (0, w.v)(e, { strict: !1 })
                                                ? A(e)
                                                : e
                                            );
                                            return "bytes" === (t || "hex")
                                              ? r
                                              : (0, v.NC)(r);
                                          })(t, "bytes");
                                        return (
                                          n.set([r], 0),
                                          "bytes" === i ? n : (0, v.ci)(n)
                                        );
                                      })({ commitment: e, to: i, version: r })
                                    );
                                  return n;
                                })({ commitments: i })),
                              void 0 === f)
                            ) {
                              let e = q({ blobs: t, commitments: i, kzg: r });
                              f = (function (e) {
                                let { data: t, kzg: r, to: i } = e,
                                  n =
                                    e.blobs ??
                                    (function (e) {
                                      let t =
                                          e.to ??
                                          ("string" == typeof e.data
                                            ? "hex"
                                            : "bytes"),
                                        r =
                                          "string" == typeof e.data
                                            ? I(e.data)
                                            : e.data,
                                        i = (0, J.d)(r);
                                      if (!i) throw new W();
                                      if (i > 761855)
                                        throw new G({
                                          maxSize: 761855,
                                          size: i,
                                        });
                                      let n = [],
                                        s = !0,
                                        a = 0;
                                      for (; s; ) {
                                        let e = M(new Uint8Array(131072)),
                                          t = 0;
                                        for (; t < 4096; ) {
                                          let i = r.slice(a, a + 31);
                                          if (
                                            (e.pushByte(0),
                                            e.pushBytes(i),
                                            i.length < 31)
                                          ) {
                                            e.pushByte(128), (s = !1);
                                            break;
                                          }
                                          t++, (a += 31);
                                        }
                                        n.push(e);
                                      }
                                      return "bytes" === t
                                        ? n.map((e) => e.bytes)
                                        : n.map((e) => (0, v.ci)(e.bytes));
                                    })({ data: t, to: i }),
                                  s =
                                    e.commitments ??
                                    z({ blobs: n, kzg: r, to: i }),
                                  a =
                                    e.proofs ??
                                    q({
                                      blobs: n,
                                      commitments: s,
                                      kzg: r,
                                      to: i,
                                    }),
                                  o = [];
                                for (let e = 0; e < n.length; e++)
                                  o.push({
                                    blob: n[e],
                                    commitment: s[e],
                                    proof: a[e],
                                  });
                                return o;
                              })({ blobs: t, commitments: i, proofs: e });
                            }
                          }
                          let g = es(h),
                            m = [
                              (0, v.NC)(r),
                              n ? (0, v.NC)(n) : "0x",
                              u ? (0, v.NC)(u) : "0x",
                              c ? (0, v.NC)(c) : "0x",
                              i ? (0, v.NC)(i) : "0x",
                              s ?? "0x",
                              o ? (0, v.NC)(o) : "0x",
                              d ?? "0x",
                              g,
                              l ? (0, v.NC)(l) : "0x",
                              p ?? [],
                              ...ea(e, t),
                            ],
                            y = [],
                            b = [],
                            E = [];
                          if (f)
                            for (let e = 0; e < f.length; e++) {
                              let { blob: t, commitment: r, proof: i } = f[e];
                              y.push(t), b.push(r), E.push(i);
                            }
                          return k(["0x03", f ? B([m, y, b, E]) : B(m)]);
                        })(e, t)
                      : "eip7702" === r
                      ? (function (e, t) {
                          let {
                            authorizationList: r,
                            chainId: i,
                            gas: n,
                            nonce: s,
                            to: a,
                            value: o,
                            maxFeePerGas: l,
                            maxPriorityFeePerGas: c,
                            accessList: u,
                            data: h,
                          } = e;
                          !(function (e) {
                            let { authorizationList: t } = e;
                            if (t)
                              for (let e of t) {
                                let { chainId: t } = e,
                                  r = e.address;
                                if (!x(r)) throw new m({ address: r });
                                if (t < 0) throw new X({ chainId: t });
                              }
                            en(e);
                          })(e);
                          let d = es(u),
                            p = (function (e) {
                              if (!e || 0 === e.length) return [];
                              let t = [];
                              for (let r of e) {
                                let { chainId: e, nonce: i, ...n } = r,
                                  s = r.address;
                                t.push([
                                  e ? (0, v.NC)(e) : "0x",
                                  s,
                                  i ? (0, v.NC)(i) : "0x",
                                  ...ea({}, n),
                                ]);
                              }
                              return t;
                            })(r);
                          return k([
                            "0x04",
                            B([
                              (0, v.NC)(i),
                              s ? (0, v.NC)(s) : "0x",
                              c ? (0, v.NC)(c) : "0x",
                              l ? (0, v.NC)(l) : "0x",
                              n ? (0, v.NC)(n) : "0x",
                              a ?? "0x",
                              o ? (0, v.NC)(o) : "0x",
                              h ?? "0x",
                              d,
                              p,
                              ...ea(e, t),
                            ]),
                          ]);
                        })(e, t)
                      : (function (e, t) {
                          let {
                            chainId: r = 0,
                            gas: i,
                            data: n,
                            nonce: s,
                            to: a,
                            value: o,
                            gasPrice: l,
                          } = e;
                          !(function (e) {
                            let {
                              chainId: t,
                              maxPriorityFeePerGas: r,
                              gasPrice: i,
                              maxFeePerGas: n,
                              to: s,
                            } = e;
                            if (s && !x(s)) throw new m({ address: s });
                            if (void 0 !== t && t <= 0)
                              throw new X({ chainId: t });
                            if (r || n)
                              throw new g.G(
                                "`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute."
                              );
                            if (i && i > Y)
                              throw new ee.Hh({ maxFeePerGas: i });
                          })(e);
                          let c = [
                            s ? (0, v.NC)(s) : "0x",
                            l ? (0, v.NC)(l) : "0x",
                            i ? (0, v.NC)(i) : "0x",
                            a ?? "0x",
                            o ? (0, v.NC)(o) : "0x",
                            n ?? "0x",
                          ];
                          if (t) {
                            let e = (() => {
                                if (t.v >= 35n)
                                  return (t.v - 35n) / 2n > 0
                                    ? t.v
                                    : 27n + (35n === t.v ? 0n : 1n);
                                if (r > 0)
                                  return (
                                    BigInt(2 * r) + BigInt(35n + t.v - 27n)
                                  );
                                let e = 27n + (27n === t.v ? 0n : 1n);
                                if (t.v !== e) throw new F({ v: t.v });
                                return e;
                              })(),
                              i = Q(t.r),
                              n = Q(t.s);
                            c = [
                              ...c,
                              (0, v.NC)(e),
                              "0x00" === i ? "0x" : i,
                              "0x00" === n ? "0x" : n,
                            ];
                          } else
                            r > 0 && (c = [...c, (0, v.NC)(r), "0x", "0x"]);
                          return B(c);
                        })(e, t);
                  })(e, t);
            },
          },
        },
        el = i({
          ...eo,
          id: 8453,
          name: "Base",
          nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
          rpcUrls: { default: { http: ["https://mainnet.base.org"] } },
          blockExplorers: {
            default: {
              name: "Basescan",
              url: "https://basescan.org",
              apiUrl: "https://api.basescan.org/api",
            },
          },
          contracts: {
            ...eo.contracts,
            disputeGameFactory: {
              1: { address: "0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e" },
            },
            l2OutputOracle: {
              1: { address: "0x56315b90c40730925ec5485cf004d835058518A0" },
            },
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 5022,
            },
            portal: {
              1: {
                address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
                blockCreated: 17482143,
              },
            },
            l1StandardBridge: {
              1: {
                address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
                blockCreated: 17482143,
              },
            },
          },
          sourceId: 1,
        }),
        ec = i({
          id: 56,
          name: "BNB Smart Chain",
          nativeCurrency: { decimals: 18, name: "BNB", symbol: "BNB" },
          rpcUrls: { default: { http: ["https://56.rpc.thirdweb.com"] } },
          blockExplorers: {
            default: {
              name: "BscScan",
              url: "https://bscscan.com",
              apiUrl: "https://api.bscscan.com/api",
            },
          },
          contracts: {
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 15921452,
            },
          },
        }),
        eu = i({
          id: 122,
          name: "Fuse",
          nativeCurrency: { name: "Fuse", symbol: "FUSE", decimals: 18 },
          rpcUrls: { default: { http: ["https://rpc.fuse.io"] } },
          blockExplorers: {
            default: {
              name: "Fuse Explorer",
              url: "https://explorer.fuse.io",
              apiUrl: "https://explorer.fuse.io/api",
            },
          },
          contracts: {
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 16146628,
            },
          },
        }),
        eh = i({
          id: 17e3,
          name: "Holesky",
          nativeCurrency: {
            name: "Holesky Ether",
            symbol: "ETH",
            decimals: 18,
          },
          rpcUrls: {
            default: { http: ["https://ethereum-holesky-rpc.publicnode.com"] },
          },
          blockExplorers: {
            default: {
              name: "Etherscan",
              url: "https://holesky.etherscan.io",
              apiUrl: "https://api-holesky.etherscan.io/api",
            },
          },
          contracts: {
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 77,
            },
            ensRegistry: {
              address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
              blockCreated: 801613,
            },
            ensUniversalResolver: {
              address: "0xa6AC935D4971E3CD133b950aE053bECD16fE7f3b",
              blockCreated: 973484,
            },
          },
          testnet: !0,
        }),
        ed = i({
          id: 1,
          name: "Ethereum",
          nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
          rpcUrls: { default: { http: ["https://eth.merkle.io"] } },
          blockExplorers: {
            default: {
              name: "Etherscan",
              url: "https://etherscan.io",
              apiUrl: "https://api.etherscan.io/api",
            },
          },
          contracts: {
            ensRegistry: {
              address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
            },
            ensUniversalResolver: {
              address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
              blockCreated: 19258213,
            },
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 14353601,
            },
          },
        }),
        ep = i({
          id: 11155111,
          name: "Sepolia",
          nativeCurrency: {
            name: "Sepolia Ether",
            symbol: "ETH",
            decimals: 18,
          },
          rpcUrls: { default: { http: ["https://sepolia.drpc.org"] } },
          blockExplorers: {
            default: {
              name: "Etherscan",
              url: "https://sepolia.etherscan.io",
              apiUrl: "https://api-sepolia.etherscan.io/api",
            },
          },
          contracts: {
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 751532,
            },
            ensRegistry: {
              address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
            },
            ensUniversalResolver: {
              address: "0xc8Af999e38273D658BE1b921b88A9Ddf005769cC",
              blockCreated: 5317080,
            },
          },
          testnet: !0,
        });
      function ef(e) {
        return { formatters: void 0, fees: void 0, serializers: void 0, ...e };
      }
      let eg = ef({
          id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
          name: "Solana",
          network: "solana-mainnet",
          nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
          rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
          blockExplorers: {
            default: { name: "Solscan", url: "https://solscan.io" },
          },
          testnet: !1,
          chainNamespace: "solana",
          caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
          deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ",
        }),
        em = ef({
          id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
          name: "Solana Devnet",
          network: "solana-devnet",
          nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
          rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
          blockExplorers: {
            default: { name: "Solscan", url: "https://solscan.io" },
          },
          testnet: !0,
          chainNamespace: "solana",
          caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
          deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K",
        });
      ef({
        id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
        name: "Solana Testnet",
        network: "solana-testnet",
        nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
        rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
        blockExplorers: {
          default: { name: "Solscan", url: "https://solscan.io" },
        },
        testnet: !0,
        chainNamespace: "solana",
        caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      }),
        ef({
          id: "000000000019d6689c085ae165831e93",
          caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
          chainNamespace: "bip122",
          name: "Bitcoin",
          nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 8 },
          rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
        }),
        ef({
          id: "000000000933ea01ad0ee984209779ba",
          caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
          chainNamespace: "bip122",
          name: "Bitcoin Testnet",
          nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 8 },
          rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
          testnet: !0,
        });
    },
    98686: function (e, t, r) {
      "use strict";
      r.d(t, {
        T: function () {
          return i;
        },
      });
      let i = {
        ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
        ERROR_CODE_DEFAULT: 5e3,
        ERROR_INVALID_CHAIN_ID: 32603,
      };
    },
    89977: function (e, t, r) {
      "use strict";
      r.d(t, {
        T: function () {
          return i.T;
        },
        s: function () {
          return a;
        },
      });
      var i = r(98686),
        n = r(12540),
        s = r(54170);
      let a = {
        getMethodsByChainNamespace(e) {
          switch (e) {
            case "solana":
              return [
                "solana_signMessage",
                "solana_signTransaction",
                "solana_requestAccounts",
                "solana_getAccounts",
                "solana_signAllTransactions",
                "solana_signAndSendTransaction",
              ];
            case "eip155":
              return [
                "eth_accounts",
                "eth_requestAccounts",
                "eth_sendRawTransaction",
                "eth_sign",
                "eth_signTransaction",
                "eth_signTypedData",
                "eth_signTypedData_v3",
                "eth_signTypedData_v4",
                "eth_sendTransaction",
                "personal_sign",
                "wallet_switchEthereumChain",
                "wallet_addEthereumChain",
                "wallet_getPermissions",
                "wallet_requestPermissions",
                "wallet_registerOnboarding",
                "wallet_watchAsset",
                "wallet_scanQRCode",
                "wallet_getCallsStatus",
                "wallet_showCallsStatus",
                "wallet_sendCalls",
                "wallet_getCapabilities",
                "wallet_grantPermissions",
                "wallet_revokePermissions",
                "wallet_getAssets",
              ];
            case "bip122":
              return [
                "sendTransfer",
                "signMessage",
                "signPsbt",
                "getAccountAddresses",
              ];
            default:
              return [];
          }
        },
        createNamespaces(e) {
          return e.reduce((e, t) => {
            let { id: r, chainNamespace: i, rpcUrls: n } = t,
              a = n.default.http[0],
              o = this.getMethodsByChainNamespace(i);
            e[i] ||
              (e[i] = {
                methods: o,
                events: ["accountsChanged", "chainChanged"],
                chains: [],
                rpcMap: {},
              });
            let l = `${i}:${r}`,
              c = e[i];
            switch ((c.chains.push(l), l)) {
              case s.Zjg.caipNetworkId:
                c.chains.push(s.Zjg.deprecatedCaipNetworkId);
                break;
              case s.ol5.caipNetworkId:
                c.chains.push(s.ol5.deprecatedCaipNetworkId);
            }
            return c?.rpcMap && a && (c.rpcMap[r] = a), e;
          }, {});
        },
        resolveReownName: async (e) => {
          let t = await n.a.resolveName(e),
            r = Object.values(t?.addresses) || [];
          return r[0]?.address || !1;
        },
        getChainsFromNamespaces: (e = {}) =>
          Object.values(e).flatMap((e) =>
            Array.from(
              new Set([
                ...(e.chains || []),
                ...e.accounts.map((e) => {
                  let [t, r] = e.split(":");
                  return `${t}:${r}`;
                }),
              ])
            )
          ),
        isSessionEventData: (e) =>
          "object" == typeof e &&
          null !== e &&
          "id" in e &&
          "topic" in e &&
          "params" in e &&
          "object" == typeof e.params &&
          null !== e.params &&
          "chainId" in e.params &&
          "event" in e.params &&
          "object" == typeof e.params.event &&
          null !== e.params.event,
      };
    },
    15105: function (e, t, r) {
      "use strict";
      r.d(t, {
        Z: function () {
          return C;
        },
      });
      var i = {};
      r.r(i),
        r.d(i, {
          exclude: function () {
            return A;
          },
          extract: function () {
            return m;
          },
          parse: function () {
            return y;
          },
          parseUrl: function () {
            return b;
          },
          pick: function () {
            return E;
          },
          stringify: function () {
            return w;
          },
          stringifyUrl: function () {
            return v;
          },
        });
      let n = "%[a-f0-9]{2}",
        s = RegExp("(" + n + ")|([^%]+?)", "gi"),
        a = RegExp("(" + n + ")+", "gi");
      function o(e, t) {
        if (!("string" == typeof e && "string" == typeof t))
          throw TypeError("Expected the arguments to be of type `string`");
        if ("" === e || "" === t) return [];
        let r = e.indexOf(t);
        return -1 === r ? [] : [e.slice(0, r), e.slice(r + t.length)];
      }
      let l = (e) => null == e,
        c = (e) =>
          encodeURIComponent(e).replace(
            /[!'()*]/g,
            (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`
          ),
        u = Symbol("encodeFragmentIdentifier");
      function h(e) {
        if ("string" != typeof e || 1 !== e.length)
          throw TypeError(
            "arrayFormatSeparator must be single character string"
          );
      }
      function d(e, t) {
        return t.encode ? (t.strict ? c(e) : encodeURIComponent(e)) : e;
      }
      function p(e, t) {
        return t.decode
          ? (function (e) {
              if ("string" != typeof e)
                throw TypeError(
                  "Expected `encodedURI` to be of type `string`, got `" +
                    typeof e +
                    "`"
                );
              try {
                return decodeURIComponent(e);
              } catch {
                return (function (e) {
                  let t = { "%FE%FF": "", "%FF%FE": "" },
                    r = a.exec(e);
                  for (; r; ) {
                    try {
                      t[r[0]] = decodeURIComponent(r[0]);
                    } catch {
                      let e = (function (e) {
                        try {
                          return decodeURIComponent(e);
                        } catch {
                          let t = e.match(s) || [];
                          for (let r = 1; r < t.length; r++)
                            t =
                              (e = (function e(t, r) {
                                try {
                                  return [decodeURIComponent(t.join(""))];
                                } catch {}
                                if (1 === t.length) return t;
                                r = r || 1;
                                let i = t.slice(0, r),
                                  n = t.slice(r);
                                return Array.prototype.concat.call(
                                  [],
                                  e(i),
                                  e(n)
                                );
                              })(t, r).join("")).match(s) || [];
                          return e;
                        }
                      })(r[0]);
                      e !== r[0] && (t[r[0]] = e);
                    }
                    r = a.exec(e);
                  }
                  for (let r of ((t["%C2"] = ""), Object.keys(t)))
                    e = e.replace(RegExp(r, "g"), t[r]);
                  return e;
                })(e);
              }
            })(e)
          : e;
      }
      function f(e) {
        let t = e.indexOf("#");
        return -1 !== t && (e = e.slice(0, t)), e;
      }
      function g(e, t) {
        return (
          t.parseNumbers &&
          !Number.isNaN(Number(e)) &&
          "string" == typeof e &&
          "" !== e.trim()
            ? (e = Number(e))
            : t.parseBooleans &&
              null !== e &&
              ("true" === e.toLowerCase() || "false" === e.toLowerCase()) &&
              (e = "true" === e.toLowerCase()),
          e
        );
      }
      function m(e) {
        let t = (e = f(e)).indexOf("?");
        return -1 === t ? "" : e.slice(t + 1);
      }
      function y(e, t) {
        h(
          (t = {
            decode: !0,
            sort: !0,
            arrayFormat: "none",
            arrayFormatSeparator: ",",
            parseNumbers: !1,
            parseBooleans: !1,
            ...t,
          }).arrayFormatSeparator
        );
        let r = (function (e) {
            let t;
            switch (e.arrayFormat) {
              case "index":
                return (e, r, i) => {
                  if (
                    ((t = /\[(\d*)]$/.exec(e)),
                    (e = e.replace(/\[\d*]$/, "")),
                    !t)
                  ) {
                    i[e] = r;
                    return;
                  }
                  void 0 === i[e] && (i[e] = {}), (i[e][t[1]] = r);
                };
              case "bracket":
                return (e, r, i) => {
                  if (
                    ((t = /(\[])$/.exec(e)), (e = e.replace(/\[]$/, "")), !t)
                  ) {
                    i[e] = r;
                    return;
                  }
                  if (void 0 === i[e]) {
                    i[e] = [r];
                    return;
                  }
                  i[e] = [...i[e], r];
                };
              case "colon-list-separator":
                return (e, r, i) => {
                  if (
                    ((t = /(:list)$/.exec(e)),
                    (e = e.replace(/:list$/, "")),
                    !t)
                  ) {
                    i[e] = r;
                    return;
                  }
                  if (void 0 === i[e]) {
                    i[e] = [r];
                    return;
                  }
                  i[e] = [...i[e], r];
                };
              case "comma":
              case "separator":
                return (t, r, i) => {
                  let n =
                      "string" == typeof r &&
                      r.includes(e.arrayFormatSeparator),
                    s =
                      "string" == typeof r &&
                      !n &&
                      p(r, e).includes(e.arrayFormatSeparator);
                  r = s ? p(r, e) : r;
                  let a =
                    n || s
                      ? r.split(e.arrayFormatSeparator).map((t) => p(t, e))
                      : null === r
                      ? r
                      : p(r, e);
                  i[t] = a;
                };
              case "bracket-separator":
                return (t, r, i) => {
                  let n = /(\[])$/.test(t);
                  if (((t = t.replace(/\[]$/, "")), !n)) {
                    i[t] = r ? p(r, e) : r;
                    return;
                  }
                  let s =
                    null === r
                      ? []
                      : r.split(e.arrayFormatSeparator).map((t) => p(t, e));
                  if (void 0 === i[t]) {
                    i[t] = s;
                    return;
                  }
                  i[t] = [...i[t], ...s];
                };
              default:
                return (e, t, r) => {
                  if (void 0 === r[e]) {
                    r[e] = t;
                    return;
                  }
                  r[e] = [...[r[e]].flat(), t];
                };
            }
          })(t),
          i = Object.create(null);
        if ("string" != typeof e || !(e = e.trim().replace(/^[?#&]/, "")))
          return i;
        for (let n of e.split("&")) {
          if ("" === n) continue;
          let e = t.decode ? n.replace(/\+/g, " ") : n,
            [s, a] = o(e, "=");
          void 0 === s && (s = e),
            (a =
              void 0 === a
                ? null
                : ["comma", "separator", "bracket-separator"].includes(
                    t.arrayFormat
                  )
                ? a
                : p(a, t)),
            r(p(s, t), a, i);
        }
        for (let [e, r] of Object.entries(i))
          if ("object" == typeof r && null !== r)
            for (let [e, i] of Object.entries(r)) r[e] = g(i, t);
          else i[e] = g(r, t);
        return !1 === t.sort
          ? i
          : (!0 === t.sort
              ? Object.keys(i).sort()
              : Object.keys(i).sort(t.sort)
            ).reduce((e, t) => {
              let r = i[t];
              return (
                r && "object" == typeof r && !Array.isArray(r)
                  ? (e[t] = (function e(t) {
                      return Array.isArray(t)
                        ? t.sort()
                        : "object" == typeof t
                        ? e(Object.keys(t))
                            .sort((e, t) => Number(e) - Number(t))
                            .map((e) => t[e])
                        : t;
                    })(r))
                  : (e[t] = r),
                e
              );
            }, Object.create(null));
      }
      function w(e, t) {
        if (!e) return "";
        h(
          (t = {
            encode: !0,
            strict: !0,
            arrayFormat: "none",
            arrayFormatSeparator: ",",
            ...t,
          }).arrayFormatSeparator
        );
        let r = (r) =>
            (t.skipNull && l(e[r])) || (t.skipEmptyString && "" === e[r]),
          i = (function (e) {
            switch (e.arrayFormat) {
              case "index":
                return (t) => (r, i) => {
                  let n = r.length;
                  return void 0 === i ||
                    (e.skipNull && null === i) ||
                    (e.skipEmptyString && "" === i)
                    ? r
                    : null === i
                    ? [...r, [d(t, e), "[", n, "]"].join("")]
                    : [...r, [d(t, e), "[", d(n, e), "]=", d(i, e)].join("")];
                };
              case "bracket":
                return (t) => (r, i) =>
                  void 0 === i ||
                  (e.skipNull && null === i) ||
                  (e.skipEmptyString && "" === i)
                    ? r
                    : null === i
                    ? [...r, [d(t, e), "[]"].join("")]
                    : [...r, [d(t, e), "[]=", d(i, e)].join("")];
              case "colon-list-separator":
                return (t) => (r, i) =>
                  void 0 === i ||
                  (e.skipNull && null === i) ||
                  (e.skipEmptyString && "" === i)
                    ? r
                    : null === i
                    ? [...r, [d(t, e), ":list="].join("")]
                    : [...r, [d(t, e), ":list=", d(i, e)].join("")];
              case "comma":
              case "separator":
              case "bracket-separator": {
                let t = "bracket-separator" === e.arrayFormat ? "[]=" : "=";
                return (r) => (i, n) =>
                  void 0 === n ||
                  (e.skipNull && null === n) ||
                  (e.skipEmptyString && "" === n)
                    ? i
                    : ((n = null === n ? "" : n), 0 === i.length)
                    ? [[d(r, e), t, d(n, e)].join("")]
                    : [[i, d(n, e)].join(e.arrayFormatSeparator)];
              }
              default:
                return (t) => (r, i) =>
                  void 0 === i ||
                  (e.skipNull && null === i) ||
                  (e.skipEmptyString && "" === i)
                    ? r
                    : null === i
                    ? [...r, d(t, e)]
                    : [...r, [d(t, e), "=", d(i, e)].join("")];
            }
          })(t),
          n = {};
        for (let [t, i] of Object.entries(e)) r(t) || (n[t] = i);
        let s = Object.keys(n);
        return (
          !1 !== t.sort && s.sort(t.sort),
          s
            .map((r) => {
              let n = e[r];
              return void 0 === n
                ? ""
                : null === n
                ? d(r, t)
                : Array.isArray(n)
                ? 0 === n.length && "bracket-separator" === t.arrayFormat
                  ? d(r, t) + "[]"
                  : n.reduce(i(r), []).join("&")
                : d(r, t) + "=" + d(n, t);
            })
            .filter((e) => e.length > 0)
            .join("&")
        );
      }
      function b(e, t) {
        t = { decode: !0, ...t };
        let [r, i] = o(e, "#");
        return (
          void 0 === r && (r = e),
          {
            url: r?.split("?")?.[0] ?? "",
            query: y(m(e), t),
            ...(t && t.parseFragmentIdentifier && i
              ? { fragmentIdentifier: p(i, t) }
              : {}),
          }
        );
      }
      function v(e, t) {
        t = { encode: !0, strict: !0, [u]: !0, ...t };
        let r = f(e.url).split("?")[0] || "",
          i = w({ ...y(m(e.url), { sort: !1 }), ...e.query }, t);
        i && (i = `?${i}`);
        let n = (function (e) {
          let t = "",
            r = e.indexOf("#");
          return -1 !== r && (t = e.slice(r)), t;
        })(e.url);
        if (e.fragmentIdentifier) {
          let i = new URL(r);
          (i.hash = e.fragmentIdentifier),
            (n = t[u] ? i.hash : `#${e.fragmentIdentifier}`);
        }
        return `${r}${i}${n}`;
      }
      function E(e, t, r) {
        let {
          url: i,
          query: n,
          fragmentIdentifier: s,
        } = b(e, (r = { parseFragmentIdentifier: !0, [u]: !1, ...r }));
        return v(
          {
            url: i,
            query: (function (e, t) {
              let r = {};
              if (Array.isArray(t))
                for (let i of t) {
                  let t = Object.getOwnPropertyDescriptor(e, i);
                  t?.enumerable && Object.defineProperty(r, i, t);
                }
              else
                for (let i of Reflect.ownKeys(e)) {
                  let n = Object.getOwnPropertyDescriptor(e, i);
                  if (n.enumerable) {
                    let s = e[i];
                    t(i, s, e) && Object.defineProperty(r, i, n);
                  }
                }
              return r;
            })(n, t),
            fragmentIdentifier: s,
          },
          r
        );
      }
      function A(e, t, r) {
        return E(
          e,
          Array.isArray(t) ? (e) => !t.includes(e) : (e, r) => !t(e, r),
          r
        );
      }
      var C = i;
    },
    13057: function (e, t, r) {
      "use strict";
      r.d(t, {
        Z: function () {
          return i;
        },
      });
      var i = (function (e) {
        if (e.length >= 255) throw TypeError("Alphabet too long");
        let t = new Uint8Array(256);
        for (let e = 0; e < t.length; e++) t[e] = 255;
        for (let r = 0; r < e.length; r++) {
          let i = e.charAt(r),
            n = i.charCodeAt(0);
          if (255 !== t[n]) throw TypeError(i + " is ambiguous");
          t[n] = r;
        }
        let r = e.length,
          i = e.charAt(0),
          n = Math.log(r) / Math.log(256),
          s = Math.log(256) / Math.log(r);
        function a(e) {
          if ("string" != typeof e) throw TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          let s = 0,
            a = 0,
            o = 0;
          for (; e[s] === i; ) a++, s++;
          let l = ((e.length - s) * n + 1) >>> 0,
            c = new Uint8Array(l);
          for (; s < e.length; ) {
            let i = e.charCodeAt(s);
            if (i > 255) return;
            let n = t[i];
            if (255 === n) return;
            let a = 0;
            for (let e = l - 1; (0 !== n || a < o) && -1 !== e; e--, a++)
              (n += (r * c[e]) >>> 0),
                (c[e] = n % 256 >>> 0),
                (n = (n / 256) >>> 0);
            if (0 !== n) throw Error("Non-zero carry");
            (o = a), s++;
          }
          let u = l - o;
          for (; u !== l && 0 === c[u]; ) u++;
          let h = new Uint8Array(a + (l - u)),
            d = a;
          for (; u !== l; ) h[d++] = c[u++];
          return h;
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError("Expected Uint8Array");
            if (0 === t.length) return "";
            let n = 0,
              a = 0,
              o = 0,
              l = t.length;
            for (; o !== l && 0 === t[o]; ) o++, n++;
            let c = ((l - o) * s + 1) >>> 0,
              u = new Uint8Array(c);
            for (; o !== l; ) {
              let e = t[o],
                i = 0;
              for (let t = c - 1; (0 !== e || i < a) && -1 !== t; t--, i++)
                (e += (256 * u[t]) >>> 0),
                  (u[t] = e % r >>> 0),
                  (e = (e / r) >>> 0);
              if (0 !== e) throw Error("Non-zero carry");
              (a = i), o++;
            }
            let h = c - a;
            for (; h !== c && 0 === u[h]; ) h++;
            let d = i.repeat(n);
            for (; h < c; ++h) d += e.charAt(u[h]);
            return d;
          },
          decodeUnsafe: a,
          decode: function (e) {
            let t = a(e);
            if (t) return t;
            throw Error("Non-base" + r + " character");
          },
        };
      })("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    },
    1091: function (e, t, r) {
      "use strict";
      r.d(t, {
        R: function () {
          return D;
        },
      });
      var i = r(35157),
        n = r(41768),
        s = r(70587),
        a = r(45474),
        o = r(9982);
      class l extends n.XI {
        constructor(e) {
          super("address", "address", e, !1);
        }
        defaultValue() {
          return "0x0000000000000000000000000000000000000000";
        }
        encode(e, t) {
          let r = o._.dereference(t, "string");
          try {
            r = (0, s.K)(r);
          } catch (e) {
            return this._throwError(e.message, t);
          }
          return e.writeValue(r);
        }
        decode(e) {
          return (0, s.K)((0, a.m9)(e.readValue(), 20));
        }
      }
      var c = r(69781);
      class u extends n.XI {
        coder;
        constructor(e) {
          super(e.name, e.type, "_", e.dynamic), (this.coder = e);
        }
        defaultValue() {
          return this.coder.defaultValue();
        }
        encode(e, t) {
          return this.coder.encode(e, t);
        }
        decode(e) {
          return this.coder.decode(e);
        }
      }
      function h(e, t, r) {
        let s = [];
        if (Array.isArray(r)) s = r;
        else if (r && "object" == typeof r) {
          let e = {};
          s = t.map((t) => {
            let n = t.localName;
            return (
              (0, i.hu)(
                n,
                "cannot encode object for signature with missing names",
                "INVALID_ARGUMENT",
                { argument: "values", info: { coder: t }, value: r }
              ),
              (0, i.hu)(
                !e[n],
                "cannot encode object for signature with duplicate names",
                "INVALID_ARGUMENT",
                { argument: "values", info: { coder: t }, value: r }
              ),
              (e[n] = !0),
              r[n]
            );
          });
        } else (0, i.en)(!1, "invalid tuple value", "tuple", r);
        (0, i.en)(
          t.length === s.length,
          "types/value length mismatch",
          "tuple",
          r
        );
        let a = new n.QV(),
          o = new n.QV(),
          l = [];
        return (
          t.forEach((e, t) => {
            let r = s[t];
            if (e.dynamic) {
              let t = o.length;
              e.encode(o, r);
              let i = a.writeUpdatableValue();
              l.push((e) => {
                i(e + t);
              });
            } else e.encode(a, r);
          }),
          l.forEach((e) => {
            e(a.length);
          }),
          e.appendWriter(a) + e.appendWriter(o)
        );
      }
      function d(e, t) {
        let r = [],
          s = [],
          a = e.subReader(0);
        return (
          t.forEach((t) => {
            let n = null;
            if (t.dynamic) {
              let r = e.readIndex(),
                s = a.subReader(r);
              try {
                n = t.decode(s);
              } catch (e) {
                if ((0, i.VZ)(e, "BUFFER_OVERRUN")) throw e;
                ((n = e).baseType = t.name),
                  (n.name = t.localName),
                  (n.type = t.type);
              }
            } else
              try {
                n = t.decode(e);
              } catch (e) {
                if ((0, i.VZ)(e, "BUFFER_OVERRUN")) throw e;
                ((n = e).baseType = t.name),
                  (n.name = t.localName),
                  (n.type = t.type);
              }
            if (void 0 == n) throw Error("investigate");
            r.push(n), s.push(t.localName || null);
          }),
          n.x4.fromItems(r, s)
        );
      }
      class p extends n.XI {
        coder;
        length;
        constructor(e, t, r) {
          super(
            "array",
            e.type + "[" + (t >= 0 ? t : "") + "]",
            r,
            -1 === t || e.dynamic
          ),
            (0, c.h)(this, { coder: e, length: t });
        }
        defaultValue() {
          let e = this.coder.defaultValue(),
            t = [];
          for (let r = 0; r < this.length; r++) t.push(e);
          return t;
        }
        encode(e, t) {
          let r = o._.dereference(t, "array");
          Array.isArray(r) || this._throwError("expected array value", r);
          let n = this.length;
          -1 === n && ((n = r.length), e.writeValue(r.length)),
            (0, i.fG)(
              r.length,
              n,
              "coder array" + (this.localName ? " " + this.localName : "")
            );
          let s = [];
          for (let e = 0; e < r.length; e++) s.push(this.coder);
          return h(e, s, r);
        }
        decode(e) {
          let t = this.length;
          -1 === t &&
            ((t = e.readIndex()),
            (0, i.hu)(
              t * n.Bx <= e.dataLength,
              "insufficient data length",
              "BUFFER_OVERRUN",
              { buffer: e.bytes, offset: t * n.Bx, length: e.dataLength }
            ));
          let r = [];
          for (let e = 0; e < t; e++) r.push(new u(this.coder));
          return d(e, r);
        }
      }
      class f extends n.XI {
        constructor(e) {
          super("bool", "bool", e, !1);
        }
        defaultValue() {
          return !1;
        }
        encode(e, t) {
          let r = o._.dereference(t, "bool");
          return e.writeValue(r ? 1 : 0);
        }
        decode(e) {
          return !!e.readValue();
        }
      }
      var g = r(59369);
      class m extends n.XI {
        constructor(e, t) {
          super(e, e, t, !0);
        }
        defaultValue() {
          return "0x";
        }
        encode(e, t) {
          return (t = (0, g.h_)(t)), e.writeValue(t.length) + e.writeBytes(t);
        }
        decode(e) {
          return e.readBytes(e.readIndex(), !0);
        }
      }
      class y extends m {
        constructor(e) {
          super("bytes", e);
        }
        decode(e) {
          return (0, g.Dv)(super.decode(e));
        }
      }
      class w extends n.XI {
        size;
        constructor(e, t) {
          let r = "bytes" + String(e);
          super(r, r, t, !1), (0, c.h)(this, { size: e }, { size: "number" });
        }
        defaultValue() {
          return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(
            0,
            2 + 2 * this.size
          );
        }
        encode(e, t) {
          let r = (0, g.h_)(o._.dereference(t, this.type));
          return (
            r.length !== this.size &&
              this._throwError("incorrect data length", t),
            e.writeBytes(r)
          );
        }
        decode(e) {
          return (0, g.Dv)(e.readBytes(this.size));
        }
      }
      let b = new Uint8Array([]);
      class v extends n.XI {
        constructor(e) {
          super("null", "", e, !1);
        }
        defaultValue() {
          return null;
        }
        encode(e, t) {
          return null != t && this._throwError("not null", t), e.writeBytes(b);
        }
        decode(e) {
          return e.readBytes(0), null;
        }
      }
      let E = BigInt(0),
        A = BigInt(1),
        C = BigInt(
          "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        );
      class _ extends n.XI {
        size;
        signed;
        constructor(e, t, r) {
          let i = (t ? "int" : "uint") + 8 * e;
          super(i, i, r, !1),
            (0, c.h)(
              this,
              { size: e, signed: t },
              { size: "number", signed: "boolean" }
            );
        }
        defaultValue() {
          return 0;
        }
        encode(e, t) {
          let r = (0, a.yT)(o._.dereference(t, this.type)),
            i = (0, a.sS)(C, 8 * n.Bx);
          if (this.signed) {
            let e = (0, a.sS)(i, 8 * this.size - 1);
            (r > e || r < -(e + A)) &&
              this._throwError("value out-of-bounds", t),
              (r = (0, a.$j)(r, 8 * n.Bx));
          } else
            (r < E || r > (0, a.sS)(i, 8 * this.size)) &&
              this._throwError("value out-of-bounds", t);
          return e.writeValue(r);
        }
        decode(e) {
          let t = (0, a.sS)(e.readValue(), 8 * this.size);
          return this.signed && (t = (0, a._Y)(t, 8 * this.size)), t;
        }
      }
      var I = r(9478);
      class N extends m {
        constructor(e) {
          super("string", e);
        }
        defaultValue() {
          return "";
        }
        encode(e, t) {
          return super.encode(e, (0, I.Y0)(o._.dereference(t, "string")));
        }
        decode(e) {
          return (0, I.ZN)(super.decode(e));
        }
      }
      class S extends n.XI {
        coders;
        constructor(e, t) {
          let r = !1,
            i = [];
          e.forEach((e) => {
            e.dynamic && (r = !0), i.push(e.type);
          }),
            super("tuple", "tuple(" + i.join(",") + ")", t, r),
            (0, c.h)(this, { coders: Object.freeze(e.slice()) });
        }
        defaultValue() {
          let e = [];
          this.coders.forEach((t) => {
            e.push(t.defaultValue());
          });
          let t = this.coders.reduce((e, t) => {
            let r = t.localName;
            return r && (e[r] || (e[r] = 0), e[r]++), e;
          }, {});
          return (
            this.coders.forEach((r, i) => {
              let n = r.localName;
              n &&
                1 === t[n] &&
                ("length" === n && (n = "_length"),
                null == e[n] && (e[n] = e[i]));
            }),
            Object.freeze(e)
          );
        }
        encode(e, t) {
          let r = o._.dereference(t, "tuple");
          return h(e, this.coders, r);
        }
        decode(e) {
          return d(e, this.coders);
        }
      }
      var T = r(53642);
      let P = new Map();
      P.set(0, "GENERIC_PANIC"),
        P.set(1, "ASSERT_FALSE"),
        P.set(17, "OVERFLOW"),
        P.set(18, "DIVIDE_BY_ZERO"),
        P.set(33, "ENUM_RANGE_ERROR"),
        P.set(34, "BAD_STORAGE_DATA"),
        P.set(49, "STACK_UNDERFLOW"),
        P.set(50, "ARRAY_RANGE_ERROR"),
        P.set(65, "OUT_OF_MEMORY"),
        P.set(81, "UNINITIALIZED_FUNCTION_CALL");
      let O = new RegExp(/^bytes([0-9]*)$/),
        x = new RegExp(/^(u?int)([0-9]*)$/),
        k = null,
        R = 1024;
      class D {
        #e(e) {
          if (e.isArray())
            return new p(this.#e(e.arrayChildren), e.arrayLength, e.name);
          if (e.isTuple())
            return new S(
              e.components.map((e) => this.#e(e)),
              e.name
            );
          switch (e.baseType) {
            case "address":
              return new l(e.name);
            case "bool":
              return new f(e.name);
            case "string":
              return new N(e.name);
            case "bytes":
              return new y(e.name);
            case "":
              return new v(e.name);
          }
          let t = e.type.match(x);
          if (t) {
            let r = parseInt(t[2] || "256");
            return (
              (0, i.en)(
                0 !== r && r <= 256 && r % 8 == 0,
                "invalid " + t[1] + " bit length",
                "param",
                e
              ),
              new _(r / 8, "int" === t[1], e.name)
            );
          }
          if ((t = e.type.match(O))) {
            let r = parseInt(t[1]);
            return (
              (0, i.en)(0 !== r && r <= 32, "invalid bytes length", "param", e),
              new w(r, e.name)
            );
          }
          (0, i.en)(!1, "invalid type", "type", e.type);
        }
        getDefaultValue(e) {
          return new S(
            e.map((e) => this.#e(T._R.from(e))),
            "_"
          ).defaultValue();
        }
        encode(e, t) {
          (0, i.fG)(t.length, e.length, "types/values length mismatch");
          let r = new S(
              e.map((e) => this.#e(T._R.from(e))),
              "_"
            ),
            s = new n.QV();
          return r.encode(s, t), s.data;
        }
        decode(e, t, r) {
          return new S(
            e.map((e) => this.#e(T._R.from(e))),
            "_"
          ).decode(new n.Ej(t, r, R));
        }
        static _setDefaultMaxInflation(e) {
          (0, i.en)(
            "number" == typeof e && Number.isInteger(e),
            "invalid defaultMaxInflation factor",
            "value",
            e
          ),
            (R = e);
        }
        static defaultAbiCoder() {
          return null == k && (k = new D()), k;
        }
        static getBuiltinCallException(e, t, r) {
          return (function (e, t, r, n) {
            let a = "missing revert data",
              o = null,
              l = null;
            if (r) {
              a = "execution reverted";
              let e = (0, g.Pw)(r);
              if (((r = (0, g.Dv)(r)), 0 === e.length))
                (a += " (no data present; likely require(false) occurred"),
                  (o = "require(false)");
              else if (e.length % 32 != 4)
                a += " (could not decode reason; invalid data length)";
              else if ("0x08c379a0" === (0, g.Dv)(e.slice(0, 4)))
                try {
                  (o = n.decode(["string"], e.slice(4))[0]),
                    (l = {
                      signature: "Error(string)",
                      name: "Error",
                      args: [o],
                    }),
                    (a += `: ${JSON.stringify(o)}`);
                } catch (e) {
                  a += " (could not decode reason; invalid string data)";
                }
              else if ("0x4e487b71" === (0, g.Dv)(e.slice(0, 4)))
                try {
                  let t = Number(n.decode(["uint256"], e.slice(4))[0]);
                  (l = {
                    signature: "Panic(uint256)",
                    name: "Panic",
                    args: [t],
                  }),
                    (o = `Panic due to ${P.get(t) || "UNKNOWN"}(${t})`),
                    (a += `: ${o}`);
                } catch (e) {
                  a += " (could not decode panic code)";
                }
              else a += " (unknown custom error)";
            }
            let c = { to: t.to ? (0, s.K)(t.to) : null, data: t.data || "0x" };
            return (
              t.from && (c.from = (0, s.K)(t.from)),
              (0, i.wf)(a, "CALL_EXCEPTION", {
                action: e,
                data: r,
                reason: o,
                transaction: c,
                invocation: null,
                revert: l,
              })
            );
          })(e, t, r, D.defaultAbiCoder());
        }
      }
    },
    41768: function (e, t, r) {
      "use strict";
      r.d(t, {
        Bx: function () {
          return o;
        },
        Ej: function () {
          return w;
        },
        QV: function () {
          return y;
        },
        XI: function () {
          return m;
        },
        x4: function () {
          return f;
        },
      });
      var i = r(45474),
        n = r(35157),
        s = r(59369),
        a = r(69781);
      let o = 32,
        l = new Uint8Array(32),
        c = ["then"],
        u = {},
        h = new WeakMap();
      function d(e) {
        return h.get(e);
      }
      function p(e, t) {
        let r = Error(
          `deferred error during ABI decoding triggered accessing ${e}`
        );
        throw ((r.error = t), r);
      }
      class f extends Array {
        #t;
        constructor(...e) {
          var t, r;
          let n = e[0],
            s = e[1],
            a = (e[2] || []).slice(),
            o = !0;
          n !== u && ((s = e), (a = []), (o = !1)),
            super(s.length),
            s.forEach((e, t) => {
              this[t] = e;
            });
          let l = a.reduce(
            (e, t) => (
              "string" == typeof t && e.set(t, (e.get(t) || 0) + 1), e
            ),
            new Map()
          );
          if (
            ((t = Object.freeze(
              s.map((e, t) => {
                let r = a[t];
                return null != r && 1 === l.get(r) ? r : null;
              })
            )),
            h.set(this, t),
            (this.#t = []),
            null == this.#t && this.#t,
            !o)
          )
            return;
          Object.freeze(this);
          let f = new Proxy(this, {
            get: (e, t, r) => {
              if ("string" == typeof t) {
                if (t.match(/^[0-9]+$/)) {
                  let r = (0, i.Dx)(t, "%index");
                  if (r < 0 || r >= this.length)
                    throw RangeError("out of result range");
                  let n = e[r];
                  return n instanceof Error && p(`index ${r}`, n), n;
                }
                if (c.indexOf(t) >= 0) return Reflect.get(e, t, r);
                let n = e[t];
                if (n instanceof Function)
                  return function (...t) {
                    return n.apply(this === r ? e : this, t);
                  };
                if (!(t in e))
                  return e.getValue.apply(this === r ? e : this, [t]);
              }
              return Reflect.get(e, t, r);
            },
          });
          return (r = d(this)), h.set(f, r), f;
        }
        toArray(e) {
          let t = [];
          return (
            this.forEach((r, i) => {
              r instanceof Error && p(`index ${i}`, r),
                e && r instanceof f && (r = r.toArray(e)),
                t.push(r);
            }),
            t
          );
        }
        toObject(e) {
          let t = d(this);
          return t.reduce(
            (r, i, s) => (
              (0, n.hu)(
                null != i,
                `value at index ${s} unnamed`,
                "UNSUPPORTED_OPERATION",
                { operation: "toObject()" }
              ),
              (function e(t, r, i) {
                return t.indexOf(null) >= 0
                  ? r.map((t, r) => (t instanceof f ? e(d(t), t, i) : t))
                  : t.reduce((t, n, s) => {
                      let a = r.getValue(n);
                      return (
                        n in t ||
                          (i && a instanceof f && (a = e(d(a), a, i)),
                          (t[n] = a)),
                        t
                      );
                    }, {});
              })(t, this, e)
            ),
            {}
          );
        }
        slice(e, t) {
          null == e && (e = 0),
            e < 0 && (e += this.length) < 0 && (e = 0),
            null == t && (t = this.length),
            t < 0 && (t += this.length) < 0 && (t = 0),
            t > this.length && (t = this.length);
          let r = d(this),
            i = [],
            n = [];
          for (let s = e; s < t; s++) i.push(this[s]), n.push(r[s]);
          return new f(u, i, n);
        }
        filter(e, t) {
          let r = d(this),
            i = [],
            n = [];
          for (let s = 0; s < this.length; s++) {
            let a = this[s];
            a instanceof Error && p(`index ${s}`, a),
              e.call(t, a, s, this) && (i.push(a), n.push(r[s]));
          }
          return new f(u, i, n);
        }
        map(e, t) {
          let r = [];
          for (let i = 0; i < this.length; i++) {
            let n = this[i];
            n instanceof Error && p(`index ${i}`, n),
              r.push(e.call(t, n, i, this));
          }
          return r;
        }
        getValue(e) {
          let t = d(this).indexOf(e);
          if (-1 === t) return;
          let r = this[t];
          return (
            r instanceof Error && p(`property ${JSON.stringify(e)}`, r.error), r
          );
        }
        static fromItems(e, t) {
          return new f(u, e, t);
        }
      }
      function g(e) {
        let t = (0, i.ot)(e);
        return (
          (0, n.hu)(t.length <= o, "value out-of-bounds", "BUFFER_OVERRUN", {
            buffer: t,
            length: o,
            offset: t.length,
          }),
          t.length !== o &&
            (t = (0, s.h_)((0, s.zo)([l.slice(t.length % o), t]))),
          t
        );
      }
      class m {
        name;
        type;
        localName;
        dynamic;
        constructor(e, t, r, i) {
          (0, a.h)(
            this,
            { name: e, type: t, localName: r, dynamic: i },
            {
              name: "string",
              type: "string",
              localName: "string",
              dynamic: "boolean",
            }
          );
        }
        _throwError(e, t) {
          (0, n.en)(!1, e, this.localName, t);
        }
      }
      class y {
        #r;
        #i;
        constructor() {
          (this.#r = []), (this.#i = 0);
        }
        get data() {
          return (0, s.zo)(this.#r);
        }
        get length() {
          return this.#i;
        }
        #n(e) {
          return this.#r.push(e), (this.#i += e.length), e.length;
        }
        appendWriter(e) {
          return this.#n((0, s.h_)(e.data));
        }
        writeBytes(e) {
          let t = (0, s.h_)(e),
            r = t.length % o;
          return r && (t = (0, s.h_)((0, s.zo)([t, l.slice(r)]))), this.#n(t);
        }
        writeValue(e) {
          return this.#n(g(e));
        }
        writeUpdatableValue() {
          let e = this.#r.length;
          return (
            this.#r.push(l),
            (this.#i += o),
            (t) => {
              this.#r[e] = g(t);
            }
          );
        }
      }
      class w {
        allowLoose;
        #r;
        #s;
        #a;
        #o;
        #l;
        constructor(e, t, r) {
          (0, a.h)(this, { allowLoose: !!t }),
            (this.#r = (0, s.h_)(e)),
            (this.#a = 0),
            (this.#o = null),
            (this.#l = null != r ? r : 1024),
            (this.#s = 0);
        }
        get data() {
          return (0, s.Dv)(this.#r);
        }
        get dataLength() {
          return this.#r.length;
        }
        get consumed() {
          return this.#s;
        }
        get bytes() {
          return new Uint8Array(this.#r);
        }
        #c(e) {
          if (this.#o) return this.#o.#c(e);
          (this.#a += e),
            (0, n.hu)(
              this.#l < 1 || this.#a <= this.#l * this.dataLength,
              `compressed ABI data exceeds inflation ratio of ${
                this.#l
              } ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`,
              "BUFFER_OVERRUN",
              {
                buffer: (0, s.h_)(this.#r),
                offset: this.#s,
                length: e,
                info: { bytesRead: this.#a, dataLength: this.dataLength },
              }
            );
        }
        #u(e, t, r) {
          let i = Math.ceil(t / o) * o;
          return (
            this.#s + i > this.#r.length &&
              (this.allowLoose && r && this.#s + t <= this.#r.length
                ? (i = t)
                : (0, n.hu)(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
                    buffer: (0, s.h_)(this.#r),
                    length: this.#r.length,
                    offset: this.#s + i,
                  })),
            this.#r.slice(this.#s, this.#s + i)
          );
        }
        subReader(e) {
          let t = new w(this.#r.slice(this.#s + e), this.allowLoose, this.#l);
          return (t.#o = this), t;
        }
        readBytes(e, t) {
          let r = this.#u(0, e, !!t);
          return this.#c(e), (this.#s += r.length), r.slice(0, e);
        }
        readValue() {
          return (0, i.Gh)(this.readBytes(o));
        }
        readIndex() {
          return (0, i.He)(this.readBytes(o));
        }
      }
    },
    53642: function (e, t, r) {
      "use strict";
      r.d(t, {
        HY: function () {
          return z;
        },
        IC: function () {
          return G;
        },
        QV: function () {
          return W;
        },
        Xg: function () {
          return K;
        },
        YW: function () {
          return J;
        },
        _R: function () {
          return H;
        },
      });
      var i = r(45474),
        n = r(35157),
        s = r(69781),
        a = r(79146);
      function o(e) {
        let t = new Set();
        return e.forEach((e) => t.add(e)), Object.freeze(t);
      }
      let l = o("external public payable override".split(" ")),
        c =
          "constant external internal payable private public pure view override",
        u = o(c.split(" ")),
        h = "constructor error event fallback function receive struct",
        d = o(h.split(" ")),
        p = "calldata memory storage payable indexed",
        f = o(p.split(" ")),
        g = o([h, p, "tuple returns", c].join(" ").split(" ")),
        m = {
          "(": "OPEN_PAREN",
          ")": "CLOSE_PAREN",
          "[": "OPEN_BRACKET",
          "]": "CLOSE_BRACKET",
          ",": "COMMA",
          "@": "AT",
        },
        y = RegExp("^(\\s*)"),
        w = RegExp("^([0-9]+)"),
        b = RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),
        v = RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),
        E = RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
      class A {
        #s;
        #h;
        get offset() {
          return this.#s;
        }
        get length() {
          return this.#h.length - this.#s;
        }
        constructor(e) {
          (this.#s = 0), (this.#h = e.slice());
        }
        clone() {
          return new A(this.#h);
        }
        reset() {
          this.#s = 0;
        }
        #d(e = 0, t = 0) {
          return new A(
            this.#h
              .slice(e, t)
              .map((t) =>
                Object.freeze(
                  Object.assign({}, t, {
                    match: t.match - e,
                    linkBack: t.linkBack - e,
                    linkNext: t.linkNext - e,
                  })
                )
              )
          );
        }
        popKeyword(e) {
          let t = this.peek();
          if ("KEYWORD" !== t.type || !e.has(t.text))
            throw Error(`expected keyword ${t.text}`);
          return this.pop().text;
        }
        popType(e) {
          if (this.peek().type !== e) {
            let t = this.peek();
            throw Error(
              `expected ${e}; got ${t.type} ${JSON.stringify(t.text)}`
            );
          }
          return this.pop().text;
        }
        popParen() {
          let e = this.peek();
          if ("OPEN_PAREN" !== e.type) throw Error("bad start");
          let t = this.#d(this.#s + 1, e.match + 1);
          return (this.#s = e.match + 1), t;
        }
        popParams() {
          let e = this.peek();
          if ("OPEN_PAREN" !== e.type) throw Error("bad start");
          let t = [];
          for (; this.#s < e.match - 1; ) {
            let e = this.peek().linkNext;
            t.push(this.#d(this.#s + 1, e)), (this.#s = e);
          }
          return (this.#s = e.match + 1), t;
        }
        peek() {
          if (this.#s >= this.#h.length) throw Error("out-of-bounds");
          return this.#h[this.#s];
        }
        peekKeyword(e) {
          let t = this.peekType("KEYWORD");
          return null != t && e.has(t) ? t : null;
        }
        peekType(e) {
          if (0 === this.length) return null;
          let t = this.peek();
          return t.type === e ? t.text : null;
        }
        pop() {
          let e = this.peek();
          return this.#s++, e;
        }
        toString() {
          let e = [];
          for (let t = this.#s; t < this.#h.length; t++) {
            let r = this.#h[t];
            e.push(`${r.type}:${r.text}`);
          }
          return `<TokenString ${e.join(" ")}>`;
        }
      }
      function C(e) {
        let t = [],
          r = (t) => {
            let r = a < e.length ? JSON.stringify(e[a]) : "$EOI";
            throw Error(`invalid token ${r} at ${a}: ${t}`);
          },
          n = [],
          s = [],
          a = 0;
        for (; a < e.length; ) {
          let o = e.substring(a),
            l = o.match(y);
          l && ((a += l[1].length), (o = e.substring(a)));
          let c = {
            depth: n.length,
            linkBack: -1,
            linkNext: -1,
            match: -1,
            type: "",
            text: "",
            offset: a,
            value: -1,
          };
          t.push(c);
          let u = m[o[0]] || "";
          if (u) {
            if (((c.type = u), (c.text = o[0]), a++, "OPEN_PAREN" === u))
              n.push(t.length - 1), s.push(t.length - 1);
            else if ("CLOSE_PAREN" == u)
              0 === n.length && r("no matching open bracket"),
                (c.match = n.pop()),
                (t[c.match].match = t.length - 1),
                c.depth--,
                (c.linkBack = s.pop()),
                (t[c.linkBack].linkNext = t.length - 1);
            else if ("COMMA" === u)
              (c.linkBack = s.pop()),
                (t[c.linkBack].linkNext = t.length - 1),
                s.push(t.length - 1);
            else if ("OPEN_BRACKET" === u) c.type = "BRACKET";
            else if ("CLOSE_BRACKET" === u) {
              let e = t.pop().text;
              if (t.length > 0 && "NUMBER" === t[t.length - 1].type) {
                let r = t.pop().text;
                (e = r + e), (t[t.length - 1].value = (0, i.Dx)(r));
              }
              if (0 === t.length || "BRACKET" !== t[t.length - 1].type)
                throw Error("missing opening bracket");
              t[t.length - 1].text += e;
            }
            continue;
          }
          if ((l = o.match(b))) {
            if (((c.text = l[1]), (a += c.text.length), g.has(c.text))) {
              c.type = "KEYWORD";
              continue;
            }
            if (c.text.match(E)) {
              c.type = "TYPE";
              continue;
            }
            c.type = "ID";
            continue;
          }
          if ((l = o.match(w))) {
            (c.text = l[1]), (c.type = "NUMBER"), (a += c.text.length);
            continue;
          }
          throw Error(
            `unexpected token ${JSON.stringify(o[0])} at position ${a}`
          );
        }
        return new A(t.map((e) => Object.freeze(e)));
      }
      function _(e, t) {
        let r = [];
        for (let i in t.keys()) e.has(i) && r.push(i);
        if (r.length > 1) throw Error(`conflicting types: ${r.join(", ")}`);
      }
      function I(e, t) {
        if (t.peekKeyword(d)) {
          let r = t.pop().text;
          if (r !== e) throw Error(`expected ${e}, got ${r}`);
        }
        return t.popType("ID");
      }
      function N(e, t) {
        let r = new Set();
        for (;;) {
          let i = e.peekType("KEYWORD");
          if (null == i || (t && !t.has(i))) break;
          if ((e.pop(), r.has(i)))
            throw Error(`duplicate keywords: ${JSON.stringify(i)}`);
          r.add(i);
        }
        return Object.freeze(r);
      }
      function S(e) {
        let t = N(e, u);
        return (_(t, o("constant payable nonpayable".split(" "))),
        _(t, o("pure view payable nonpayable".split(" "))),
        t.has("view"))
          ? "view"
          : t.has("pure")
          ? "pure"
          : t.has("payable")
          ? "payable"
          : t.has("nonpayable")
          ? "nonpayable"
          : t.has("constant")
          ? "view"
          : "nonpayable";
      }
      function T(e, t) {
        return e.popParams().map((e) => H.from(e, t));
      }
      function P(e) {
        if (e.peekType("AT")) {
          if ((e.pop(), e.peekType("NUMBER"))) return (0, i.yT)(e.pop().text);
          throw Error("invalid gas");
        }
        return null;
      }
      function O(e) {
        if (e.length)
          throw Error(
            `unexpected tokens at offset ${e.offset}: ${e.toString()}`
          );
      }
      let x = new RegExp(/^(.*)\[([0-9]*)\]$/);
      function k(e) {
        let t = e.match(E);
        if (((0, n.en)(t, "invalid type", "type", e), "uint" === e))
          return "uint256";
        if ("int" === e) return "int256";
        if (t[2]) {
          let r = parseInt(t[2]);
          (0, n.en)(0 !== r && r <= 32, "invalid bytes length", "type", e);
        } else if (t[3]) {
          let r = parseInt(t[3]);
          (0, n.en)(
            0 !== r && r <= 256 && r % 8 == 0,
            "invalid numeric width",
            "type",
            e
          );
        }
        return e;
      }
      let R = {},
        D = Symbol.for("_ethers_internal"),
        U = "_ParamTypeInternal",
        L = "_ErrorInternal",
        M = "_EventInternal",
        B = "_ConstructorInternal",
        j = "_FallbackInternal",
        F = "_FunctionInternal",
        $ = "_StructInternal";
      class H {
        name;
        type;
        baseType;
        indexed;
        components;
        arrayLength;
        arrayChildren;
        constructor(e, t, r, i, a, o, l, c) {
          if (
            ((0, n.NK)(e, R, "ParamType"),
            Object.defineProperty(this, D, { value: U }),
            o && (o = Object.freeze(o.slice())),
            "array" === i)
          ) {
            if (null == l || null == c) throw Error("");
          } else if (null != l || null != c) throw Error("");
          if ("tuple" === i) {
            if (null == o) throw Error("");
          } else if (null != o) throw Error("");
          (0, s.h)(this, {
            name: t,
            type: r,
            baseType: i,
            indexed: a,
            components: o,
            arrayLength: l,
            arrayChildren: c,
          });
        }
        format(e) {
          if ((null == e && (e = "sighash"), "json" === e)) {
            let t = this.name || "";
            if (this.isArray()) {
              let e = JSON.parse(this.arrayChildren.format("json"));
              return (
                (e.name = t),
                (e.type += `[${
                  this.arrayLength < 0 ? "" : String(this.arrayLength)
                }]`),
                JSON.stringify(e)
              );
            }
            let r = {
              type: "tuple" === this.baseType ? "tuple" : this.type,
              name: t,
            };
            return (
              "boolean" == typeof this.indexed && (r.indexed = this.indexed),
              this.isTuple() &&
                (r.components = this.components.map((t) =>
                  JSON.parse(t.format(e))
                )),
              JSON.stringify(r)
            );
          }
          let t = "";
          return (
            this.isArray()
              ? (t +=
                  this.arrayChildren.format(e) +
                  `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`)
              : this.isTuple()
              ? (t +=
                  "(" +
                  this.components
                    .map((t) => t.format(e))
                    .join("full" === e ? ", " : ",") +
                  ")")
              : (t += this.type),
            "sighash" !== e &&
              (!0 === this.indexed && (t += " indexed"),
              "full" === e && this.name && (t += " " + this.name)),
            t
          );
        }
        isArray() {
          return "array" === this.baseType;
        }
        isTuple() {
          return "tuple" === this.baseType;
        }
        isIndexable() {
          return null != this.indexed;
        }
        walk(e, t) {
          if (this.isArray()) {
            if (!Array.isArray(e)) throw Error("invalid array value");
            if (-1 !== this.arrayLength && e.length !== this.arrayLength)
              throw Error("array is wrong length");
            let r = this;
            return e.map((e) => r.arrayChildren.walk(e, t));
          }
          if (this.isTuple()) {
            if (!Array.isArray(e)) throw Error("invalid tuple value");
            if (e.length !== this.components.length)
              throw Error("array is wrong length");
            let r = this;
            return e.map((e, i) => r.components[i].walk(e, t));
          }
          return t(this.type, e);
        }
        #p(e, t, r, i) {
          if (this.isArray()) {
            if (!Array.isArray(t)) throw Error("invalid array value");
            if (-1 !== this.arrayLength && t.length !== this.arrayLength)
              throw Error("array is wrong length");
            let n = this.arrayChildren,
              s = t.slice();
            s.forEach((t, i) => {
              n.#p(e, t, r, (e) => {
                s[i] = e;
              });
            }),
              i(s);
            return;
          }
          if (this.isTuple()) {
            let n;
            let s = this.components;
            if (Array.isArray(t)) n = t.slice();
            else {
              if (null == t || "object" != typeof t)
                throw Error("invalid tuple value");
              n = s.map((e) => {
                if (!e.name)
                  throw Error(
                    "cannot use object value with unnamed components"
                  );
                if (!(e.name in t))
                  throw Error(`missing value for component ${e.name}`);
                return t[e.name];
              });
            }
            if (n.length !== this.components.length)
              throw Error("array is wrong length");
            n.forEach((t, i) => {
              s[i].#p(e, t, r, (e) => {
                n[i] = e;
              });
            }),
              i(n);
            return;
          }
          let n = r(this.type, t);
          n.then
            ? e.push(
                (async function () {
                  i(await n);
                })()
              )
            : i(n);
        }
        async walkAsync(e, t) {
          let r = [],
            i = [e];
          return (
            this.#p(r, e, t, (e) => {
              i[0] = e;
            }),
            r.length && (await Promise.all(r)),
            i[0]
          );
        }
        static from(e, t) {
          if (H.isParamType(e)) return e;
          if ("string" == typeof e)
            try {
              return H.from(C(e), t);
            } catch (t) {
              (0, n.en)(!1, "invalid param type", "obj", e);
            }
          else if (e instanceof A) {
            let r = "",
              i = "",
              n = null;
            N(e, o(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN")
              ? ((i = "tuple"),
                (n = e.popParams().map((e) => H.from(e))),
                (r = `tuple(${n.map((e) => e.format()).join(",")})`))
              : (i = r = k(e.popType("TYPE")));
            let s = null,
              a = null;
            for (; e.length && e.peekType("BRACKET"); ) {
              let t = e.pop();
              (s = new H(R, "", r, i, null, n, a, s)),
                (a = t.value),
                (r += t.text),
                (i = "array"),
                (n = null);
            }
            let l = null;
            if (N(e, f).has("indexed")) {
              if (!t) throw Error("");
              l = !0;
            }
            let c = e.peekType("ID") ? e.pop().text : "";
            if (e.length) throw Error("leftover tokens");
            return new H(R, c, r, i, l, n, a, s);
          }
          let r = e.name;
          (0, n.en)(
            !r || ("string" == typeof r && r.match(v)),
            "invalid name",
            "obj.name",
            r
          );
          let i = e.indexed;
          null != i &&
            ((0, n.en)(
              t,
              "parameter cannot be indexed",
              "obj.indexed",
              e.indexed
            ),
            (i = !!i));
          let s = e.type,
            a = s.match(x);
          if (a) {
            let t = parseInt(a[2] || "-1"),
              n = H.from({ type: a[1], components: e.components });
            return new H(R, r || "", s, "array", i, null, t, n);
          }
          if ("tuple" === s || s.startsWith("tuple(") || s.startsWith("(")) {
            let t =
              null != e.components ? e.components.map((e) => H.from(e)) : null;
            return new H(R, r || "", s, "tuple", i, t, null, null);
          }
          return new H(R, r || "", (s = k(e.type)), s, i, null, null, null);
        }
        static isParamType(e) {
          return e && e[D] === U;
        }
      }
      class z {
        type;
        inputs;
        constructor(e, t, r) {
          (0, n.NK)(e, R, "Fragment"),
            (r = Object.freeze(r.slice())),
            (0, s.h)(this, { type: t, inputs: r });
        }
        static from(e) {
          if ("string" == typeof e) {
            try {
              z.from(JSON.parse(e));
            } catch (e) {}
            return z.from(C(e));
          }
          if (e instanceof A)
            switch (e.peekKeyword(d)) {
              case "constructor":
                return K.from(e);
              case "error":
                return G.from(e);
              case "event":
                return W.from(e);
              case "fallback":
              case "receive":
                return Z.from(e);
              case "function":
                return J.from(e);
              case "struct":
                return Q.from(e);
            }
          else if ("object" == typeof e) {
            switch (e.type) {
              case "constructor":
                return K.from(e);
              case "error":
                return G.from(e);
              case "event":
                return W.from(e);
              case "fallback":
              case "receive":
                return Z.from(e);
              case "function":
                return J.from(e);
              case "struct":
                return Q.from(e);
            }
            (0, n.hu)(
              !1,
              `unsupported type: ${e.type}`,
              "UNSUPPORTED_OPERATION",
              { operation: "Fragment.from" }
            );
          }
          (0, n.en)(!1, "unsupported frgament object", "obj", e);
        }
        static isConstructor(e) {
          return K.isFragment(e);
        }
        static isError(e) {
          return G.isFragment(e);
        }
        static isEvent(e) {
          return W.isFragment(e);
        }
        static isFunction(e) {
          return J.isFragment(e);
        }
        static isStruct(e) {
          return Q.isFragment(e);
        }
      }
      class q extends z {
        name;
        constructor(e, t, r, i) {
          super(e, t, i),
            (0, n.en)(
              "string" == typeof r && r.match(v),
              "invalid identifier",
              "name",
              r
            ),
            (i = Object.freeze(i.slice())),
            (0, s.h)(this, { name: r });
        }
      }
      function V(e, t) {
        return (
          "(" + t.map((t) => t.format(e)).join("full" === e ? ", " : ",") + ")"
        );
      }
      class G extends q {
        constructor(e, t, r) {
          super(e, "error", t, r), Object.defineProperty(this, D, { value: L });
        }
        get selector() {
          return (0, a.id)(this.format("sighash")).substring(0, 10);
        }
        format(e) {
          if ((null == e && (e = "sighash"), "json" === e))
            return JSON.stringify({
              type: "error",
              name: this.name,
              inputs: this.inputs.map((t) => JSON.parse(t.format(e))),
            });
          let t = [];
          return (
            "sighash" !== e && t.push("error"),
            t.push(this.name + V(e, this.inputs)),
            t.join(" ")
          );
        }
        static from(e) {
          if (G.isFragment(e)) return e;
          if ("string" == typeof e) return G.from(C(e));
          if (e instanceof A) {
            let t = I("error", e),
              r = T(e);
            return O(e), new G(R, t, r);
          }
          return new G(R, e.name, e.inputs ? e.inputs.map(H.from) : []);
        }
        static isFragment(e) {
          return e && e[D] === L;
        }
      }
      class W extends q {
        anonymous;
        constructor(e, t, r, i) {
          super(e, "event", t, r),
            Object.defineProperty(this, D, { value: M }),
            (0, s.h)(this, { anonymous: i });
        }
        get topicHash() {
          return (0, a.id)(this.format("sighash"));
        }
        format(e) {
          if ((null == e && (e = "sighash"), "json" === e))
            return JSON.stringify({
              type: "event",
              anonymous: this.anonymous,
              name: this.name,
              inputs: this.inputs.map((t) => JSON.parse(t.format(e))),
            });
          let t = [];
          return (
            "sighash" !== e && t.push("event"),
            t.push(this.name + V(e, this.inputs)),
            "sighash" !== e && this.anonymous && t.push("anonymous"),
            t.join(" ")
          );
        }
        static getTopicHash(e, t) {
          return new W(R, e, (t = (t || []).map((e) => H.from(e))), !1)
            .topicHash;
        }
        static from(e) {
          if (W.isFragment(e)) return e;
          if ("string" == typeof e)
            try {
              return W.from(C(e));
            } catch (t) {
              (0, n.en)(!1, "invalid event fragment", "obj", e);
            }
          else if (e instanceof A) {
            let t = I("event", e),
              r = T(e, !0),
              i = !!N(e, o(["anonymous"])).has("anonymous");
            return O(e), new W(R, t, r, i);
          }
          return new W(
            R,
            e.name,
            e.inputs ? e.inputs.map((e) => H.from(e, !0)) : [],
            !!e.anonymous
          );
        }
        static isFragment(e) {
          return e && e[D] === M;
        }
      }
      class K extends z {
        payable;
        gas;
        constructor(e, t, r, i, n) {
          super(e, t, r),
            Object.defineProperty(this, D, { value: B }),
            (0, s.h)(this, { payable: i, gas: n });
        }
        format(e) {
          if (
            ((0, n.hu)(
              null != e && "sighash" !== e,
              "cannot format a constructor for sighash",
              "UNSUPPORTED_OPERATION",
              { operation: "format(sighash)" }
            ),
            "json" === e)
          )
            return JSON.stringify({
              type: "constructor",
              stateMutability: this.payable ? "payable" : "undefined",
              payable: this.payable,
              gas: null != this.gas ? this.gas : void 0,
              inputs: this.inputs.map((t) => JSON.parse(t.format(e))),
            });
          let t = [`constructor${V(e, this.inputs)}`];
          return (
            this.payable && t.push("payable"),
            null != this.gas && t.push(`@${this.gas.toString()}`),
            t.join(" ")
          );
        }
        static from(e) {
          if (K.isFragment(e)) return e;
          if ("string" == typeof e)
            try {
              return K.from(C(e));
            } catch (t) {
              (0, n.en)(!1, "invalid constuctor fragment", "obj", e);
            }
          else if (e instanceof A) {
            N(e, o(["constructor"]));
            let t = T(e),
              r = !!N(e, l).has("payable"),
              i = P(e);
            return O(e), new K(R, "constructor", t, r, i);
          }
          return new K(
            R,
            "constructor",
            e.inputs ? e.inputs.map(H.from) : [],
            !!e.payable,
            null != e.gas ? e.gas : null
          );
        }
        static isFragment(e) {
          return e && e[D] === B;
        }
      }
      class Z extends z {
        payable;
        constructor(e, t, r) {
          super(e, "fallback", t),
            Object.defineProperty(this, D, { value: j }),
            (0, s.h)(this, { payable: r });
        }
        format(e) {
          let t = 0 === this.inputs.length ? "receive" : "fallback";
          return "json" === e
            ? JSON.stringify({
                type: t,
                stateMutability: this.payable ? "payable" : "nonpayable",
              })
            : `${t}()${this.payable ? " payable" : ""}`;
        }
        static from(e) {
          if (Z.isFragment(e)) return e;
          if ("string" == typeof e)
            try {
              return Z.from(C(e));
            } catch (t) {
              (0, n.en)(!1, "invalid fallback fragment", "obj", e);
            }
          else if (e instanceof A) {
            let t = e.toString(),
              r = e.peekKeyword(o(["fallback", "receive"]));
            if (
              ((0, n.en)(r, "type must be fallback or receive", "obj", t),
              "receive" === e.popKeyword(o(["fallback", "receive"])))
            ) {
              let t = T(e);
              return (
                (0, n.en)(
                  0 === t.length,
                  "receive cannot have arguments",
                  "obj.inputs",
                  t
                ),
                N(e, o(["payable"])),
                O(e),
                new Z(R, [], !0)
              );
            }
            let i = T(e);
            i.length
              ? (0, n.en)(
                  1 === i.length && "bytes" === i[0].type,
                  "invalid fallback inputs",
                  "obj.inputs",
                  i.map((e) => e.format("minimal")).join(", ")
                )
              : (i = [H.from("bytes")]);
            let s = S(e);
            if (
              ((0, n.en)(
                "nonpayable" === s || "payable" === s,
                "fallback cannot be constants",
                "obj.stateMutability",
                s
              ),
              N(e, o(["returns"])).has("returns"))
            ) {
              let t = T(e);
              (0, n.en)(
                1 === t.length && "bytes" === t[0].type,
                "invalid fallback outputs",
                "obj.outputs",
                t.map((e) => e.format("minimal")).join(", ")
              );
            }
            return O(e), new Z(R, i, "payable" === s);
          }
          return "receive" === e.type
            ? new Z(R, [], !0)
            : "fallback" === e.type
            ? new Z(R, [H.from("bytes")], "payable" === e.stateMutability)
            : void (0, n.en)(!1, "invalid fallback description", "obj", e);
        }
        static isFragment(e) {
          return e && e[D] === j;
        }
      }
      class J extends q {
        constant;
        outputs;
        stateMutability;
        payable;
        gas;
        constructor(e, t, r, i, n, a) {
          super(e, "function", t, i),
            Object.defineProperty(this, D, { value: F }),
            (n = Object.freeze(n.slice())),
            (0, s.h)(this, {
              constant: "view" === r || "pure" === r,
              gas: a,
              outputs: n,
              payable: "payable" === r,
              stateMutability: r,
            });
        }
        get selector() {
          return (0, a.id)(this.format("sighash")).substring(0, 10);
        }
        format(e) {
          if ((null == e && (e = "sighash"), "json" === e))
            return JSON.stringify({
              type: "function",
              name: this.name,
              constant: this.constant,
              stateMutability:
                "nonpayable" !== this.stateMutability
                  ? this.stateMutability
                  : void 0,
              payable: this.payable,
              gas: null != this.gas ? this.gas : void 0,
              inputs: this.inputs.map((t) => JSON.parse(t.format(e))),
              outputs: this.outputs.map((t) => JSON.parse(t.format(e))),
            });
          let t = [];
          return (
            "sighash" !== e && t.push("function"),
            t.push(this.name + V(e, this.inputs)),
            "sighash" !== e &&
              ("nonpayable" !== this.stateMutability &&
                t.push(this.stateMutability),
              this.outputs &&
                this.outputs.length &&
                (t.push("returns"), t.push(V(e, this.outputs))),
              null != this.gas && t.push(`@${this.gas.toString()}`)),
            t.join(" ")
          );
        }
        static getSelector(e, t) {
          return new J(
            R,
            e,
            "view",
            (t = (t || []).map((e) => H.from(e))),
            [],
            null
          ).selector;
        }
        static from(e) {
          if (J.isFragment(e)) return e;
          if ("string" == typeof e)
            try {
              return J.from(C(e));
            } catch (t) {
              (0, n.en)(!1, "invalid function fragment", "obj", e);
            }
          else if (e instanceof A) {
            let t = I("function", e),
              r = T(e),
              i = S(e),
              n = [];
            N(e, o(["returns"])).has("returns") && (n = T(e));
            let s = P(e);
            return O(e), new J(R, t, i, r, n, s);
          }
          let t = e.stateMutability;
          return (
            null != t ||
              ((t = "payable"),
              "boolean" == typeof e.constant
                ? ((t = "view"),
                  e.constant ||
                    ((t = "payable"),
                    "boolean" != typeof e.payable ||
                      e.payable ||
                      (t = "nonpayable")))
                : "boolean" != typeof e.payable ||
                  e.payable ||
                  (t = "nonpayable")),
            new J(
              R,
              e.name,
              t,
              e.inputs ? e.inputs.map(H.from) : [],
              e.outputs ? e.outputs.map(H.from) : [],
              null != e.gas ? e.gas : null
            )
          );
        }
        static isFragment(e) {
          return e && e[D] === F;
        }
      }
      class Q extends q {
        constructor(e, t, r) {
          super(e, "struct", t, r),
            Object.defineProperty(this, D, { value: $ });
        }
        format() {
          throw Error("@TODO");
        }
        static from(e) {
          if ("string" == typeof e)
            try {
              return Q.from(C(e));
            } catch (t) {
              (0, n.en)(!1, "invalid struct fragment", "obj", e);
            }
          else if (e instanceof A) {
            let t = I("struct", e),
              r = T(e);
            return O(e), new Q(R, t, r);
          }
          return new Q(R, e.name, e.inputs ? e.inputs.map(H.from) : []);
        }
        static isFragment(e) {
          return e && e[D] === $;
        }
      }
    },
    31758: function (e, t, r) {
      "use strict";
      r.d(t, {
        vU: function () {
          return b;
        },
      });
      var i = r(19066),
        n = r(79146),
        s = r(69781),
        a = r(35157),
        o = r(59369),
        l = r(45474),
        c = r(1091),
        u = r(41768),
        h = r(53642),
        d = r(9982);
      class p {
        fragment;
        name;
        signature;
        topic;
        args;
        constructor(e, t, r) {
          let i = e.name,
            n = e.format();
          (0, s.h)(this, {
            fragment: e,
            name: i,
            signature: n,
            topic: t,
            args: r,
          });
        }
      }
      class f {
        fragment;
        name;
        args;
        signature;
        selector;
        value;
        constructor(e, t, r, i) {
          let n = e.name,
            a = e.format();
          (0, s.h)(this, {
            fragment: e,
            name: n,
            args: r,
            signature: a,
            selector: t,
            value: i,
          });
        }
      }
      class g {
        fragment;
        name;
        args;
        signature;
        selector;
        constructor(e, t, r) {
          let i = e.name,
            n = e.format();
          (0, s.h)(this, {
            fragment: e,
            name: i,
            args: r,
            signature: n,
            selector: t,
          });
        }
      }
      class m {
        hash;
        _isIndexed;
        static isIndexed(e) {
          return !!(e && e._isIndexed);
        }
        constructor(e) {
          (0, s.h)(this, { hash: e, _isIndexed: !0 });
        }
      }
      let y = {
          0: "generic panic",
          1: "assert(false)",
          17: "arithmetic overflow",
          18: "division or modulo by zero",
          33: "enum overflow",
          34: "invalid encoded storage byte array accessed",
          49: "out-of-bounds array access; popping on an empty array",
          50: "out-of-bounds access of an array or bytesN",
          65: "out of memory",
          81: "uninitialized function",
        },
        w = {
          "0x08c379a0": {
            signature: "Error(string)",
            name: "Error",
            inputs: ["string"],
            reason: (e) => `reverted with reason string ${JSON.stringify(e)}`,
          },
          "0x4e487b71": {
            signature: "Panic(uint256)",
            name: "Panic",
            inputs: ["uint256"],
            reason: (e) => {
              let t = "unknown panic code";
              return (
                e >= 0 && e <= 255 && y[e.toString()] && (t = y[e.toString()]),
                `reverted with panic code 0x${e.toString(16)} (${t})`
              );
            },
          },
        };
      class b {
        fragments;
        deploy;
        fallback;
        receive;
        #f;
        #g;
        #m;
        #y;
        constructor(e) {
          let t = [];
          (t = "string" == typeof e ? JSON.parse(e) : e),
            (this.#m = new Map()),
            (this.#f = new Map()),
            (this.#g = new Map());
          let r = [];
          for (let e of t)
            try {
              r.push(h.HY.from(e));
            } catch (t) {
              console.log(
                `[Warning] Invalid Fragment ${JSON.stringify(e)}:`,
                t.message
              );
            }
          (0, s.h)(this, { fragments: Object.freeze(r) });
          let i = null,
            n = !1;
          (this.#y = this.getAbiCoder()),
            this.fragments.forEach((e, t) => {
              let r;
              switch (e.type) {
                case "constructor":
                  if (this.deploy) {
                    console.log("duplicate definition - constructor");
                    return;
                  }
                  (0, s.h)(this, { deploy: e });
                  return;
                case "fallback":
                  0 === e.inputs.length
                    ? (n = !0)
                    : ((0, a.en)(
                        !i || e.payable !== i.payable,
                        "conflicting fallback fragments",
                        `fragments[${t}]`,
                        e
                      ),
                      (n = (i = e).payable));
                  return;
                case "function":
                  r = this.#m;
                  break;
                case "event":
                  r = this.#g;
                  break;
                case "error":
                  r = this.#f;
                  break;
                default:
                  return;
              }
              let o = e.format();
              r.has(o) || r.set(o, e);
            }),
            this.deploy ||
              (0, s.h)(this, { deploy: h.Xg.from("constructor()") }),
            (0, s.h)(this, { fallback: i, receive: n });
        }
        format(e) {
          let t = e ? "minimal" : "full";
          return this.fragments.map((e) => e.format(t));
        }
        formatJson() {
          return JSON.stringify(
            this.fragments
              .map((e) => e.format("json"))
              .map((e) => JSON.parse(e))
          );
        }
        getAbiCoder() {
          return c.R.defaultAbiCoder();
        }
        #w(e, t, r) {
          if ((0, o.A7)(e)) {
            let t = e.toLowerCase();
            for (let e of this.#m.values()) if (t === e.selector) return e;
            return null;
          }
          if (-1 === e.indexOf("(")) {
            let i = [];
            for (let [t, r] of this.#m) t.split("(")[0] === e && i.push(r);
            if (t) {
              let e = t.length > 0 ? t[t.length - 1] : null,
                r = t.length,
                n = !0;
              d._.isTyped(e) && "overrides" === e.type && ((n = !1), r--);
              for (let e = i.length - 1; e >= 0; e--) {
                let t = i[e].inputs.length;
                t === r || (n && t === r - 1) || i.splice(e, 1);
              }
              for (let e = i.length - 1; e >= 0; e--) {
                let r = i[e].inputs;
                for (let n = 0; n < t.length; n++)
                  if (d._.isTyped(t[n])) {
                    if (n >= r.length) {
                      if ("overrides" === t[n].type) continue;
                      i.splice(e, 1);
                      break;
                    }
                    if (t[n].type !== r[n].baseType) {
                      i.splice(e, 1);
                      break;
                    }
                  }
              }
            }
            if (1 === i.length && t && t.length !== i[0].inputs.length) {
              let e = t[t.length - 1];
              (null == e || Array.isArray(e) || "object" != typeof e) &&
                i.splice(0, 1);
            }
            if (0 === i.length) return null;
            if (i.length > 1 && r) {
              let t = i.map((e) => JSON.stringify(e.format())).join(", ");
              (0, a.en)(
                !1,
                `ambiguous function description (i.e. matches ${t})`,
                "key",
                e
              );
            }
            return i[0];
          }
          return this.#m.get(h.YW.from(e).format()) || null;
        }
        getFunctionName(e) {
          let t = this.#w(e, null, !1);
          return (0, a.en)(t, "no matching function", "key", e), t.name;
        }
        hasFunction(e) {
          return !!this.#w(e, null, !1);
        }
        getFunction(e, t) {
          return this.#w(e, t || null, !0);
        }
        forEachFunction(e) {
          let t = Array.from(this.#m.keys());
          t.sort((e, t) => e.localeCompare(t));
          for (let r = 0; r < t.length; r++) {
            let i = t[r];
            e(this.#m.get(i), r);
          }
        }
        #b(e, t, r) {
          if ((0, o.A7)(e)) {
            let t = e.toLowerCase();
            for (let e of this.#g.values()) if (t === e.topicHash) return e;
            return null;
          }
          if (-1 === e.indexOf("(")) {
            let i = [];
            for (let [t, r] of this.#g) t.split("(")[0] === e && i.push(r);
            if (t) {
              for (let e = i.length - 1; e >= 0; e--)
                i[e].inputs.length < t.length && i.splice(e, 1);
              for (let e = i.length - 1; e >= 0; e--) {
                let r = i[e].inputs;
                for (let n = 0; n < t.length; n++)
                  if (d._.isTyped(t[n]) && t[n].type !== r[n].baseType) {
                    i.splice(e, 1);
                    break;
                  }
              }
            }
            if (0 === i.length) return null;
            if (i.length > 1 && r) {
              let t = i.map((e) => JSON.stringify(e.format())).join(", ");
              (0, a.en)(
                !1,
                `ambiguous event description (i.e. matches ${t})`,
                "key",
                e
              );
            }
            return i[0];
          }
          return this.#g.get(h.QV.from(e).format()) || null;
        }
        getEventName(e) {
          let t = this.#b(e, null, !1);
          return (0, a.en)(t, "no matching event", "key", e), t.name;
        }
        hasEvent(e) {
          return !!this.#b(e, null, !1);
        }
        getEvent(e, t) {
          return this.#b(e, t || null, !0);
        }
        forEachEvent(e) {
          let t = Array.from(this.#g.keys());
          t.sort((e, t) => e.localeCompare(t));
          for (let r = 0; r < t.length; r++) {
            let i = t[r];
            e(this.#g.get(i), r);
          }
        }
        getError(e, t) {
          if ((0, o.A7)(e)) {
            let t = e.toLowerCase();
            if (w[t]) return h.IC.from(w[t].signature);
            for (let e of this.#f.values()) if (t === e.selector) return e;
            return null;
          }
          if (-1 === e.indexOf("(")) {
            let t = [];
            for (let [r, i] of this.#f) r.split("(")[0] === e && t.push(i);
            if (0 === t.length)
              return "Error" === e
                ? h.IC.from("error Error(string)")
                : "Panic" === e
                ? h.IC.from("error Panic(uint256)")
                : null;
            if (t.length > 1) {
              let r = t.map((e) => JSON.stringify(e.format())).join(", ");
              (0, a.en)(
                !1,
                `ambiguous error description (i.e. ${r})`,
                "name",
                e
              );
            }
            return t[0];
          }
          return "Error(string)" === (e = h.IC.from(e).format())
            ? h.IC.from("error Error(string)")
            : "Panic(uint256)" === e
            ? h.IC.from("error Panic(uint256)")
            : this.#f.get(e) || null;
        }
        forEachError(e) {
          let t = Array.from(this.#f.keys());
          t.sort((e, t) => e.localeCompare(t));
          for (let r = 0; r < t.length; r++) {
            let i = t[r];
            e(this.#f.get(i), r);
          }
        }
        _decodeParams(e, t) {
          return this.#y.decode(e, t);
        }
        _encodeParams(e, t) {
          return this.#y.encode(e, t);
        }
        encodeDeploy(e) {
          return this._encodeParams(this.deploy.inputs, e || []);
        }
        decodeErrorResult(e, t) {
          if ("string" == typeof e) {
            let t = this.getError(e);
            (0, a.en)(t, "unknown error", "fragment", e), (e = t);
          }
          return (
            (0, a.en)(
              (0, o.QB)(t, 0, 4) === e.selector,
              `data signature does not match error ${e.name}.`,
              "data",
              t
            ),
            this._decodeParams(e.inputs, (0, o.QB)(t, 4))
          );
        }
        encodeErrorResult(e, t) {
          if ("string" == typeof e) {
            let t = this.getError(e);
            (0, a.en)(t, "unknown error", "fragment", e), (e = t);
          }
          return (0, o.zo)([e.selector, this._encodeParams(e.inputs, t || [])]);
        }
        decodeFunctionData(e, t) {
          if ("string" == typeof e) {
            let t = this.getFunction(e);
            (0, a.en)(t, "unknown function", "fragment", e), (e = t);
          }
          return (
            (0, a.en)(
              (0, o.QB)(t, 0, 4) === e.selector,
              `data signature does not match function ${e.name}.`,
              "data",
              t
            ),
            this._decodeParams(e.inputs, (0, o.QB)(t, 4))
          );
        }
        encodeFunctionData(e, t) {
          if ("string" == typeof e) {
            let t = this.getFunction(e);
            (0, a.en)(t, "unknown function", "fragment", e), (e = t);
          }
          return (0, o.zo)([e.selector, this._encodeParams(e.inputs, t || [])]);
        }
        decodeFunctionResult(e, t) {
          if ("string" == typeof e) {
            let t = this.getFunction(e);
            (0, a.en)(t, "unknown function", "fragment", e), (e = t);
          }
          let r = "invalid length for result data",
            i = (0, o.h_)(t);
          if (i.length % 32 == 0)
            try {
              return this.#y.decode(e.outputs, i);
            } catch (e) {
              r = "could not decode result data";
            }
          (0, a.hu)(!1, r, "BAD_DATA", {
            value: (0, o.Dv)(i),
            info: { method: e.name, signature: e.format() },
          });
        }
        makeError(e, t) {
          let r = (0, o.Pw)(e, "data"),
            i = c.R.getBuiltinCallException("call", t, r);
          if (
            i.message.startsWith("execution reverted (unknown custom error)")
          ) {
            let e = (0, o.Dv)(r.slice(0, 4)),
              t = this.getError(e);
            if (t)
              try {
                let e = this.#y.decode(t.inputs, r.slice(4));
                (i.revert = { name: t.name, signature: t.format(), args: e }),
                  (i.reason = i.revert.signature),
                  (i.message = `execution reverted: ${i.reason}`);
              } catch (e) {
                i.message =
                  "execution reverted (coult not decode custom error)";
              }
          }
          let n = this.parseTransaction(t);
          return (
            n &&
              (i.invocation = {
                method: n.name,
                signature: n.signature,
                args: n.args,
              }),
            i
          );
        }
        encodeFunctionResult(e, t) {
          if ("string" == typeof e) {
            let t = this.getFunction(e);
            (0, a.en)(t, "unknown function", "fragment", e), (e = t);
          }
          return (0, o.Dv)(this.#y.encode(e.outputs, t || []));
        }
        encodeFilterTopics(e, t) {
          if ("string" == typeof e) {
            let t = this.getEvent(e);
            (0, a.en)(t, "unknown event", "eventFragment", e), (e = t);
          }
          (0, a.hu)(
            t.length <= e.inputs.length,
            `too many arguments for ${e.format()}`,
            "UNEXPECTED_ARGUMENT",
            { count: t.length, expectedCount: e.inputs.length }
          );
          let r = [];
          e.anonymous || r.push(e.topicHash);
          let s = (e, t) =>
            "string" === e.type
              ? (0, n.id)(t)
              : "bytes" === e.type
              ? (0, i.w)((0, o.Dv)(t))
              : ("bool" === e.type && "boolean" == typeof t
                  ? (t = t ? "0x01" : "0x00")
                  : e.type.match(/^u?int/)
                  ? (t = (0, l.m9)(t))
                  : e.type.match(/^bytes/)
                  ? (t = (0, o.SK)(t, 32))
                  : "address" === e.type && this.#y.encode(["address"], [t]),
                (0, o.U3)((0, o.Dv)(t), 32));
          for (
            t.forEach((t, i) => {
              let n = e.inputs[i];
              if (!n.indexed) {
                (0, a.en)(
                  null == t,
                  "cannot filter non-indexed parameters; must be null",
                  "contract." + n.name,
                  t
                );
                return;
              }
              null == t
                ? r.push(null)
                : "array" === n.baseType || "tuple" === n.baseType
                ? (0, a.en)(
                    !1,
                    "filtering with tuples or arrays not supported",
                    "contract." + n.name,
                    t
                  )
                : Array.isArray(t)
                ? r.push(t.map((e) => s(n, e)))
                : r.push(s(n, t));
            });
            r.length && null === r[r.length - 1];

          )
            r.pop();
          return r;
        }
        encodeEventLog(e, t) {
          if ("string" == typeof e) {
            let t = this.getEvent(e);
            (0, a.en)(t, "unknown event", "eventFragment", e), (e = t);
          }
          let r = [],
            s = [],
            o = [];
          return (
            e.anonymous || r.push(e.topicHash),
            (0, a.en)(
              t.length === e.inputs.length,
              "event arguments/values mismatch",
              "values",
              t
            ),
            e.inputs.forEach((e, a) => {
              let l = t[a];
              if (e.indexed) {
                if ("string" === e.type) r.push((0, n.id)(l));
                else if ("bytes" === e.type) r.push((0, i.w)(l));
                else if ("tuple" === e.baseType || "array" === e.baseType)
                  throw Error("not implemented");
                else r.push(this.#y.encode([e.type], [l]));
              } else s.push(e), o.push(l);
            }),
            { data: this.#y.encode(s, o), topics: r }
          );
        }
        decodeEventLog(e, t, r) {
          if ("string" == typeof e) {
            let t = this.getEvent(e);
            (0, a.en)(t, "unknown event", "eventFragment", e), (e = t);
          }
          if (null != r && !e.anonymous) {
            let t = e.topicHash;
            (0, a.en)(
              (0, o.A7)(r[0], 32) && r[0].toLowerCase() === t,
              "fragment/topic mismatch",
              "topics[0]",
              r[0]
            ),
              (r = r.slice(1));
          }
          let i = [],
            n = [],
            s = [];
          e.inputs.forEach((e, t) => {
            e.indexed
              ? "string" === e.type ||
                "bytes" === e.type ||
                "tuple" === e.baseType ||
                "array" === e.baseType
                ? (i.push(h._R.from({ type: "bytes32", name: e.name })),
                  s.push(!0))
                : (i.push(e), s.push(!1))
              : (n.push(e), s.push(!1));
          });
          let l = null != r ? this.#y.decode(i, (0, o.zo)(r)) : null,
            c = this.#y.decode(n, t, !0),
            d = [],
            p = [],
            f = 0,
            g = 0;
          return (
            e.inputs.forEach((e, t) => {
              let r = null;
              if (e.indexed) {
                if (null == l) r = new m(null);
                else if (s[t]) r = new m(l[g++]);
                else
                  try {
                    r = l[g++];
                  } catch (e) {
                    r = e;
                  }
              } else
                try {
                  r = c[f++];
                } catch (e) {
                  r = e;
                }
              d.push(r), p.push(e.name || null);
            }),
            u.x4.fromItems(d, p)
          );
        }
        parseTransaction(e) {
          let t = (0, o.Pw)(e.data, "tx.data"),
            r = (0, l.yT)(null != e.value ? e.value : 0, "tx.value"),
            i = this.getFunction((0, o.Dv)(t.slice(0, 4)));
          if (!i) return null;
          let n = this.#y.decode(i.inputs, t.slice(4));
          return new f(i, i.selector, n, r);
        }
        parseCallResult(e) {
          throw Error("@TODO");
        }
        parseLog(e) {
          let t = this.getEvent(e.topics[0]);
          return !t || t.anonymous
            ? null
            : new p(t, t.topicHash, this.decodeEventLog(t, e.data, e.topics));
        }
        parseError(e) {
          let t = (0, o.Dv)(e),
            r = this.getError((0, o.QB)(t, 0, 4));
          if (!r) return null;
          let i = this.#y.decode(r.inputs, (0, o.QB)(t, 4));
          return new g(r, r.selector, i);
        }
        static from(e) {
          return e instanceof b
            ? e
            : new b(
                "string" == typeof e
                  ? JSON.parse(e)
                  : "function" == typeof e.formatJson
                  ? e.formatJson()
                  : "function" == typeof e.format
                  ? e.format("json")
                  : e
              );
        }
      }
    },
    9982: function (e, t, r) {
      "use strict";
      r.d(t, {
        _: function () {
          return c;
        },
      });
      var i = r(35157),
        n = r(69781);
      let s = {};
      function a(e, t) {
        let r = !1;
        return (
          t < 0 && ((r = !0), (t *= -1)),
          new c(s, `${r ? "" : "u"}int${t}`, e, { signed: r, width: t })
        );
      }
      function o(e, t) {
        return new c(s, `bytes${t || ""}`, e, { size: t });
      }
      let l = Symbol.for("_ethers_typed");
      class c {
        type;
        value;
        #v;
        _typedSymbol;
        constructor(e, t, r, a) {
          null == a && (a = null),
            (0, i.NK)(s, e, "Typed"),
            (0, n.h)(this, { _typedSymbol: l, type: t, value: r }),
            (this.#v = a),
            this.format();
        }
        format() {
          if ("array" === this.type || "dynamicArray" === this.type)
            throw Error("");
          return "tuple" === this.type
            ? `tuple(${this.value.map((e) => e.format()).join(",")})`
            : this.type;
        }
        defaultValue() {
          return 0;
        }
        minValue() {
          return 0;
        }
        maxValue() {
          return 0;
        }
        isBigInt() {
          return !!this.type.match(/^u?int[0-9]+$/);
        }
        isData() {
          return this.type.startsWith("bytes");
        }
        isString() {
          return "string" === this.type;
        }
        get tupleName() {
          if ("tuple" !== this.type) throw TypeError("not a tuple");
          return this.#v;
        }
        get arrayLength() {
          if ("array" !== this.type) throw TypeError("not an array");
          return !0 === this.#v
            ? -1
            : !1 === this.#v
            ? this.value.length
            : null;
        }
        static from(e, t) {
          return new c(s, e, t);
        }
        static uint8(e) {
          return a(e, 8);
        }
        static uint16(e) {
          return a(e, 16);
        }
        static uint24(e) {
          return a(e, 24);
        }
        static uint32(e) {
          return a(e, 32);
        }
        static uint40(e) {
          return a(e, 40);
        }
        static uint48(e) {
          return a(e, 48);
        }
        static uint56(e) {
          return a(e, 56);
        }
        static uint64(e) {
          return a(e, 64);
        }
        static uint72(e) {
          return a(e, 72);
        }
        static uint80(e) {
          return a(e, 80);
        }
        static uint88(e) {
          return a(e, 88);
        }
        static uint96(e) {
          return a(e, 96);
        }
        static uint104(e) {
          return a(e, 104);
        }
        static uint112(e) {
          return a(e, 112);
        }
        static uint120(e) {
          return a(e, 120);
        }
        static uint128(e) {
          return a(e, 128);
        }
        static uint136(e) {
          return a(e, 136);
        }
        static uint144(e) {
          return a(e, 144);
        }
        static uint152(e) {
          return a(e, 152);
        }
        static uint160(e) {
          return a(e, 160);
        }
        static uint168(e) {
          return a(e, 168);
        }
        static uint176(e) {
          return a(e, 176);
        }
        static uint184(e) {
          return a(e, 184);
        }
        static uint192(e) {
          return a(e, 192);
        }
        static uint200(e) {
          return a(e, 200);
        }
        static uint208(e) {
          return a(e, 208);
        }
        static uint216(e) {
          return a(e, 216);
        }
        static uint224(e) {
          return a(e, 224);
        }
        static uint232(e) {
          return a(e, 232);
        }
        static uint240(e) {
          return a(e, 240);
        }
        static uint248(e) {
          return a(e, 248);
        }
        static uint256(e) {
          return a(e, 256);
        }
        static uint(e) {
          return a(e, 256);
        }
        static int8(e) {
          return a(e, -8);
        }
        static int16(e) {
          return a(e, -16);
        }
        static int24(e) {
          return a(e, -24);
        }
        static int32(e) {
          return a(e, -32);
        }
        static int40(e) {
          return a(e, -40);
        }
        static int48(e) {
          return a(e, -48);
        }
        static int56(e) {
          return a(e, -56);
        }
        static int64(e) {
          return a(e, -64);
        }
        static int72(e) {
          return a(e, -72);
        }
        static int80(e) {
          return a(e, -80);
        }
        static int88(e) {
          return a(e, -88);
        }
        static int96(e) {
          return a(e, -96);
        }
        static int104(e) {
          return a(e, -104);
        }
        static int112(e) {
          return a(e, -112);
        }
        static int120(e) {
          return a(e, -120);
        }
        static int128(e) {
          return a(e, -128);
        }
        static int136(e) {
          return a(e, -136);
        }
        static int144(e) {
          return a(e, -144);
        }
        static int152(e) {
          return a(e, -152);
        }
        static int160(e) {
          return a(e, -160);
        }
        static int168(e) {
          return a(e, -168);
        }
        static int176(e) {
          return a(e, -176);
        }
        static int184(e) {
          return a(e, -184);
        }
        static int192(e) {
          return a(e, -192);
        }
        static int200(e) {
          return a(e, -200);
        }
        static int208(e) {
          return a(e, -208);
        }
        static int216(e) {
          return a(e, -216);
        }
        static int224(e) {
          return a(e, -224);
        }
        static int232(e) {
          return a(e, -232);
        }
        static int240(e) {
          return a(e, -240);
        }
        static int248(e) {
          return a(e, -248);
        }
        static int256(e) {
          return a(e, -256);
        }
        static int(e) {
          return a(e, -256);
        }
        static bytes1(e) {
          return o(e, 1);
        }
        static bytes2(e) {
          return o(e, 2);
        }
        static bytes3(e) {
          return o(e, 3);
        }
        static bytes4(e) {
          return o(e, 4);
        }
        static bytes5(e) {
          return o(e, 5);
        }
        static bytes6(e) {
          return o(e, 6);
        }
        static bytes7(e) {
          return o(e, 7);
        }
        static bytes8(e) {
          return o(e, 8);
        }
        static bytes9(e) {
          return o(e, 9);
        }
        static bytes10(e) {
          return o(e, 10);
        }
        static bytes11(e) {
          return o(e, 11);
        }
        static bytes12(e) {
          return o(e, 12);
        }
        static bytes13(e) {
          return o(e, 13);
        }
        static bytes14(e) {
          return o(e, 14);
        }
        static bytes15(e) {
          return o(e, 15);
        }
        static bytes16(e) {
          return o(e, 16);
        }
        static bytes17(e) {
          return o(e, 17);
        }
        static bytes18(e) {
          return o(e, 18);
        }
        static bytes19(e) {
          return o(e, 19);
        }
        static bytes20(e) {
          return o(e, 20);
        }
        static bytes21(e) {
          return o(e, 21);
        }
        static bytes22(e) {
          return o(e, 22);
        }
        static bytes23(e) {
          return o(e, 23);
        }
        static bytes24(e) {
          return o(e, 24);
        }
        static bytes25(e) {
          return o(e, 25);
        }
        static bytes26(e) {
          return o(e, 26);
        }
        static bytes27(e) {
          return o(e, 27);
        }
        static bytes28(e) {
          return o(e, 28);
        }
        static bytes29(e) {
          return o(e, 29);
        }
        static bytes30(e) {
          return o(e, 30);
        }
        static bytes31(e) {
          return o(e, 31);
        }
        static bytes32(e) {
          return o(e, 32);
        }
        static address(e) {
          return new c(s, "address", e);
        }
        static bool(e) {
          return new c(s, "bool", !!e);
        }
        static bytes(e) {
          return new c(s, "bytes", e);
        }
        static string(e) {
          return new c(s, "string", e);
        }
        static array(e, t) {
          throw Error("not implemented yet");
        }
        static tuple(e, t) {
          throw Error("not implemented yet");
        }
        static overrides(e) {
          return new c(s, "overrides", Object.assign({}, e));
        }
        static isTyped(e) {
          return (
            e &&
            "object" == typeof e &&
            "_typedSymbol" in e &&
            e._typedSymbol === l
          );
        }
        static dereference(e, t) {
          if (c.isTyped(e)) {
            if (e.type !== t)
              throw Error(`invalid type: expecetd ${t}, got ${e.type}`);
            return e.value;
          }
          return e;
        }
      }
    },
    70587: function (e, t, r) {
      "use strict";
      r.d(t, {
        K: function () {
          return h;
        },
      });
      var i = r(19066),
        n = r(59369),
        s = r(35157);
      let a = BigInt(0),
        o = BigInt(36);
      function l(e) {
        let t = (e = e.toLowerCase()).substring(2).split(""),
          r = new Uint8Array(40);
        for (let e = 0; e < 40; e++) r[e] = t[e].charCodeAt(0);
        let s = (0, n.Pw)((0, i.w)(r));
        for (let e = 0; e < 40; e += 2)
          s[e >> 1] >> 4 >= 8 && (t[e] = t[e].toUpperCase()),
            (15 & s[e >> 1]) >= 8 && (t[e + 1] = t[e + 1].toUpperCase());
        return "0x" + t.join("");
      }
      let c = {};
      for (let e = 0; e < 10; e++) c[String(e)] = String(e);
      for (let e = 0; e < 26; e++)
        c[String.fromCharCode(65 + e)] = String(10 + e);
      let u = (function () {
        let e = {};
        for (let t = 0; t < 36; t++)
          e["0123456789abcdefghijklmnopqrstuvwxyz"[t]] = BigInt(t);
        return e;
      })();
      function h(e) {
        if (
          ((0, s.en)("string" == typeof e, "invalid address", "address", e),
          e.match(/^(0x)?[0-9a-fA-F]{40}$/))
        ) {
          e.startsWith("0x") || (e = "0x" + e);
          let t = l(e);
          return (
            (0, s.en)(
              !e.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || t === e,
              "bad address checksum",
              "address",
              e
            ),
            t
          );
        }
        if (e.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
          (0, s.en)(
            e.substring(2, 4) ===
              (function (e) {
                let t = (e =
                  (e = e.toUpperCase()).substring(4) + e.substring(0, 2) + "00")
                  .split("")
                  .map((e) => c[e])
                  .join("");
                for (; t.length >= 15; ) {
                  let e = t.substring(0, 15);
                  t = (parseInt(e, 10) % 97) + t.substring(e.length);
                }
                let r = String(98 - (parseInt(t, 10) % 97));
                for (; r.length < 2; ) r = "0" + r;
                return r;
              })(e),
            "bad icap checksum",
            "address",
            e
          );
          let t = (function (e) {
            e = e.toLowerCase();
            let t = a;
            for (let r = 0; r < e.length; r++) t = t * o + u[e[r]];
            return t;
          })(e.substring(4)).toString(16);
          for (; t.length < 40; ) t = "0" + t;
          return l("0x" + t);
        }
        (0, s.en)(!1, "invalid address", "address", e);
      }
    },
    3876: function (e, t, r) {
      "use strict";
      r.d(t, {
        RC: function () {
          return s;
        },
        ru: function () {
          return o;
        },
      });
      var i = r(35157),
        n = r(70587);
      function s(e) {
        return e && "function" == typeof e.getAddress;
      }
      async function a(e, t) {
        let r = await t;
        return (
          (null == r || "0x0000000000000000000000000000000000000000" === r) &&
            ((0, i.hu)(
              "string" != typeof e,
              "unconfigured name",
              "UNCONFIGURED_NAME",
              { value: e }
            ),
            (0, i.en)(
              !1,
              "invalid AddressLike value; did not resolve to a value address",
              "target",
              e
            )),
          (0, n.K)(r)
        );
      }
      function o(e, t) {
        return "string" == typeof e
          ? e.match(/^0x[0-9a-f]{40}$/i)
            ? (0, n.K)(e)
            : ((0, i.hu)(
                null != t,
                "ENS resolution requires a provider",
                "UNSUPPORTED_OPERATION",
                { operation: "resolveName" }
              ),
              a(e, t.resolveName(e)))
          : s(e)
          ? a(e, e.getAddress())
          : e && "function" == typeof e.then
          ? a(e, e)
          : void (0, i.en)(!1, "unsupported addressable value", "target", e);
      }
    },
    94552: function (e, t, r) {
      "use strict";
      r.d(t, {
        N: function () {
          return i;
        },
      });
      let i = "0x0000000000000000000000000000000000000000";
    },
    59868: function (e, t, r) {
      "use strict";
      r.d(t, {
        CH: function () {
          return $;
        },
      });
      var i = r(9982),
        n = r(31758),
        s = r(3876),
        a = r(62418),
        o = r(69781),
        l = r(35157),
        c = r(45474),
        u = r(59369),
        h = r(15968);
      class d extends a.Zb {
        interface;
        fragment;
        args;
        constructor(e, t, r) {
          super(e, e.provider);
          let i = t.decodeEventLog(r, e.data, e.topics);
          (0, o.h)(this, { args: i, fragment: r, interface: t });
        }
        get eventName() {
          return this.fragment.name;
        }
        get eventSignature() {
          return this.fragment.format();
        }
      }
      class p extends a.Zb {
        error;
        constructor(e, t) {
          super(e, e.provider), (0, o.h)(this, { error: t });
        }
      }
      class f extends a.IX {
        #E;
        constructor(e, t, r) {
          super(r, t), (this.#E = e);
        }
        get logs() {
          return super.logs.map((e) => {
            let t = e.topics.length ? this.#E.getEvent(e.topics[0]) : null;
            if (t)
              try {
                return new d(e, this.#E, t);
              } catch (t) {
                return new p(e, t);
              }
            return e;
          });
        }
      }
      class g extends a.Mw {
        #E;
        constructor(e, t, r) {
          super(r, t), (this.#E = e);
        }
        async wait(e, t) {
          let r = await super.wait(e, t);
          return null == r ? null : new f(this.#E, this.provider, r);
        }
      }
      class m extends h.Z {
        log;
        constructor(e, t, r, i) {
          super(e, t, r), (0, o.h)(this, { log: i });
        }
        async getBlock() {
          return await this.log.getBlock();
        }
        async getTransaction() {
          return await this.log.getTransaction();
        }
        async getTransactionReceipt() {
          return await this.log.getTransactionReceipt();
        }
      }
      class y extends m {
        constructor(e, t, r, i, n) {
          super(e, t, r, new d(n, e.interface, i));
          let s = e.interface.decodeEventLog(i, this.log.data, this.log.topics);
          (0, o.h)(this, { args: s, fragment: i });
        }
        get eventName() {
          return this.fragment.name;
        }
        get eventSignature() {
          return this.fragment.format();
        }
      }
      let w = BigInt(0);
      function b(e) {
        return e && "function" == typeof e.call;
      }
      function v(e) {
        return e && "function" == typeof e.estimateGas;
      }
      function E(e) {
        return e && "function" == typeof e.resolveName;
      }
      function A(e) {
        return e && "function" == typeof e.sendTransaction;
      }
      function C(e) {
        if (null != e) {
          if (E(e)) return e;
          if (e.provider) return e.provider;
        }
      }
      class _ {
        #A;
        fragment;
        constructor(e, t, r) {
          if (((0, o.h)(this, { fragment: t }), t.inputs.length < r.length))
            throw Error("too many arguments");
          let i = I(e.runner, "resolveName"),
            n = E(i) ? i : null;
          this.#A = (async function () {
            let i = await Promise.all(
              t.inputs.map((e, t) =>
                null == r[t]
                  ? null
                  : e.walkAsync(r[t], (e, t) =>
                      "address" === e
                        ? Array.isArray(t)
                          ? Promise.all(t.map((e) => (0, s.ru)(e, n)))
                          : (0, s.ru)(t, n)
                        : t
                    )
              )
            );
            return e.interface.encodeFilterTopics(t, i);
          })();
        }
        getTopicFilter() {
          return this.#A;
        }
      }
      function I(e, t) {
        return null == e
          ? null
          : "function" == typeof e[t]
          ? e
          : e.provider && "function" == typeof e.provider[t]
          ? e.provider
          : null;
      }
      function N(e) {
        return null == e ? null : e.provider || null;
      }
      async function S(e, t) {
        let r = i._.dereference(e, "overrides");
        (0, l.en)(
          "object" == typeof r,
          "invalid overrides parameter",
          "overrides",
          e
        );
        let n = (0, a.kK)(r);
        return (
          (0, l.en)(
            null == n.to || (t || []).indexOf("to") >= 0,
            "cannot override to",
            "overrides.to",
            n.to
          ),
          (0, l.en)(
            null == n.data || (t || []).indexOf("data") >= 0,
            "cannot override data",
            "overrides.data",
            n.data
          ),
          n.from && (n.from = n.from),
          n
        );
      }
      async function T(e, t, r) {
        let n = I(e, "resolveName"),
          a = E(n) ? n : null;
        return await Promise.all(
          t.map((e, t) =>
            e.walkAsync(r[t], (e, t) =>
              ((t = i._.dereference(t, e)), "address" === e)
                ? (0, s.ru)(t, a)
                : t
            )
          )
        );
      }
      let P = Symbol.for("_ethersInternal_contract"),
        O = new WeakMap();
      function x(e) {
        return O.get(e[P]);
      }
      async function k(e, t) {
        let r;
        let i = null;
        if (Array.isArray(t)) {
          let i = function (t) {
            if ((0, u.A7)(t, 32)) return t;
            let r = e.interface.getEvent(t);
            return (0, l.en)(r, "unknown fragment", "name", t), r.topicHash;
          };
          r = t.map((e) =>
            null == e ? null : Array.isArray(e) ? e.map(i) : i(e)
          );
        } else
          "*" === t
            ? (r = [null])
            : "string" == typeof t
            ? (0, u.A7)(t, 32)
              ? (r = [t])
              : ((i = e.interface.getEvent(t)),
                (0, l.en)(i, "unknown fragment", "event", t),
                (r = [i.topicHash]))
            : t &&
              "object" == typeof t &&
              "getTopicFilter" in t &&
              "function" == typeof t.getTopicFilter &&
              t.fragment
            ? (r = await t.getTopicFilter())
            : "fragment" in t
            ? (r = [(i = t.fragment).topicHash])
            : (0, l.en)(!1, "unknown event name", "event", t);
        return {
          fragment: i,
          tag: (r = r.map((e) => {
            if (null == e) return null;
            if (Array.isArray(e)) {
              let t = Array.from(
                new Set(e.map((e) => e.toLowerCase())).values()
              );
              return 1 === t.length ? t[0] : (t.sort(), t);
            }
            return e.toLowerCase();
          }))
            .map((e) =>
              null == e ? "null" : Array.isArray(e) ? e.join("|") : e
            )
            .join("&"),
          topics: r,
        };
      }
      async function R(e, t) {
        let { subs: r } = x(e);
        return r.get((await k(e, t)).tag) || null;
      }
      async function D(e, t, r) {
        let i = N(e.runner);
        (0, l.hu)(
          i,
          "contract runner does not support subscribing",
          "UNSUPPORTED_OPERATION",
          { operation: t }
        );
        let { fragment: n, tag: s, topics: a } = await k(e, r),
          { addr: o, subs: c } = x(e),
          u = c.get(s);
        if (!u) {
          let t = { address: o || e, topics: a },
            l = (t) => {
              let i = n;
              if (null == i)
                try {
                  i = e.interface.getEvent(t.topics[0]);
                } catch (e) {}
              if (i) {
                let s = i,
                  a = n ? e.interface.decodeEventLog(n, t.data, t.topics) : [];
                M(e, r, a, (i) => new y(e, i, r, s, t));
              } else M(e, r, [], (i) => new m(e, i, r, t));
            },
            h = [];
          (u = {
            tag: s,
            listeners: [],
            start: () => {
              h.length || h.push(i.on(t, l));
            },
            stop: async () => {
              if (0 == h.length) return;
              let e = h;
              (h = []), await Promise.all(e), i.off(t, l);
            },
          }),
            c.set(s, u);
        }
        return u;
      }
      let U = Promise.resolve();
      async function L(e, t, r, i) {
        await U;
        let n = await R(e, t);
        if (!n) return !1;
        let s = n.listeners.length;
        return (
          (n.listeners = n.listeners.filter(({ listener: t, once: n }) => {
            let s = Array.from(r);
            i && s.push(i(n ? null : t));
            try {
              t.call(e, ...s);
            } catch (e) {}
            return !n;
          })),
          0 === n.listeners.length && (n.stop(), x(e).subs.delete(n.tag)),
          s > 0
        );
      }
      async function M(e, t, r, i) {
        try {
          await U;
        } catch (e) {}
        let n = L(e, t, r, i);
        return (U = n), await n;
      }
      let B = ["then"];
      class j {
        target;
        interface;
        runner;
        filters;
        [P];
        fallback;
        constructor(e, t, r, i) {
          var a;
          let h;
          (0, l.en)(
            "string" == typeof e || (0, s.RC)(e),
            "invalid value for Contract target",
            "target",
            e
          ),
            null == r && (r = null);
          let d = n.vU.from(t);
          (0, o.h)(this, { target: e, runner: r, interface: d }),
            Object.defineProperty(this, P, { value: {} });
          let p = null,
            f = null;
          if (i) {
            let e = N(r);
            f = new g(this.interface, e, i);
          }
          let m = new Map();
          if ("string" == typeof e) {
            if ((0, u.A7)(e)) (p = e), (h = Promise.resolve(e));
            else {
              let t = I(r, "resolveName");
              if (!E(t))
                throw (0, l.wf)(
                  "contract runner does not support name resolution",
                  "UNSUPPORTED_OPERATION",
                  { operation: "resolveName" }
                );
              h = t.resolveName(e).then((t) => {
                if (null == t)
                  throw (0, l.wf)(
                    "an ENS name used for a contract target must be correctly configured",
                    "UNCONFIGURED_NAME",
                    { value: e }
                  );
                return (x(this).addr = t), t;
              });
            }
          } else
            h = e.getAddress().then((e) => {
              if (null == e) throw Error("TODO");
              return (x(this).addr = e), e;
            });
          (a = { addrPromise: h, addr: p, deployTx: f, subs: m }),
            O.set(this[P], a);
          let y = new Proxy(
            {},
            {
              get: (e, t, r) => {
                if ("symbol" == typeof t || B.indexOf(t) >= 0)
                  return Reflect.get(e, t, r);
                try {
                  return this.getEvent(t);
                } catch (e) {
                  if (!(0, l.VZ)(e, "INVALID_ARGUMENT") || "key" !== e.argument)
                    throw e;
                }
              },
              has: (e, t) =>
                B.indexOf(t) >= 0
                  ? Reflect.has(e, t)
                  : Reflect.has(e, t) || this.interface.hasEvent(String(t)),
            }
          );
          return (
            (0, o.h)(this, { filters: y }),
            (0, o.h)(this, {
              fallback:
                d.receive || d.fallback
                  ? (function (e) {
                      let t = async function (t) {
                          let r = await S(t, ["data"]);
                          (r.to = await e.getAddress()),
                            r.from &&
                              (r.from = await (0, s.ru)(r.from, C(e.runner)));
                          let i = e.interface,
                            n =
                              (0, c.yT)(r.value || w, "overrides.value") === w,
                            a = "0x" === (r.data || "0x");
                          !i.fallback ||
                            i.fallback.payable ||
                            !i.receive ||
                            a ||
                            n ||
                            (0, l.en)(
                              !1,
                              "cannot send data to receive or send value to non-payable fallback",
                              "overrides",
                              t
                            ),
                            (0, l.en)(
                              i.fallback || a,
                              "cannot send data to receive-only contract",
                              "overrides.data",
                              r.data
                            );
                          let o =
                            i.receive || (i.fallback && i.fallback.payable);
                          return (
                            (0, l.en)(
                              o || n,
                              "cannot send value to non-payable fallback",
                              "overrides.value",
                              r.value
                            ),
                            (0, l.en)(
                              i.fallback || a,
                              "cannot send data to receive-only contract",
                              "overrides.data",
                              r.data
                            ),
                            r
                          );
                        },
                        r = async function (r) {
                          let i = I(e.runner, "call");
                          (0, l.hu)(
                            b(i),
                            "contract runner does not support calling",
                            "UNSUPPORTED_OPERATION",
                            { operation: "call" }
                          );
                          let n = await t(r);
                          try {
                            return await i.call(n);
                          } catch (t) {
                            if ((0, l.Hl)(t) && t.data)
                              throw e.interface.makeError(t.data, n);
                            throw t;
                          }
                        },
                        i = async function (r) {
                          let i = e.runner;
                          (0, l.hu)(
                            A(i),
                            "contract runner does not support sending transactions",
                            "UNSUPPORTED_OPERATION",
                            { operation: "sendTransaction" }
                          );
                          let n = await i.sendTransaction(await t(r)),
                            s = N(e.runner);
                          return new g(e.interface, s, n);
                        },
                        n = async function (r) {
                          let i = I(e.runner, "estimateGas");
                          return (
                            (0, l.hu)(
                              v(i),
                              "contract runner does not support gas estimation",
                              "UNSUPPORTED_OPERATION",
                              { operation: "estimateGas" }
                            ),
                            await i.estimateGas(await t(r))
                          );
                        },
                        a = async (e) => await i(e);
                      return (
                        (0, o.h)(a, {
                          _contract: e,
                          estimateGas: n,
                          populateTransaction: t,
                          send: i,
                          staticCall: r,
                        }),
                        a
                      );
                    })(this)
                  : null,
            }),
            new Proxy(this, {
              get: (e, t, r) => {
                if ("symbol" == typeof t || t in e || B.indexOf(t) >= 0)
                  return Reflect.get(e, t, r);
                try {
                  return e.getFunction(t);
                } catch (e) {
                  if (!(0, l.VZ)(e, "INVALID_ARGUMENT") || "key" !== e.argument)
                    throw e;
                }
              },
              has: (e, t) =>
                "symbol" == typeof t || t in e || B.indexOf(t) >= 0
                  ? Reflect.has(e, t)
                  : e.interface.hasFunction(t),
            })
          );
        }
        connect(e) {
          return new j(this.target, this.interface, e);
        }
        attach(e) {
          return new j(e, this.interface, this.runner);
        }
        async getAddress() {
          return await x(this).addrPromise;
        }
        async getDeployedCode() {
          let e = N(this.runner);
          (0, l.hu)(
            e,
            "runner does not support .provider",
            "UNSUPPORTED_OPERATION",
            { operation: "getDeployedCode" }
          );
          let t = await e.getCode(await this.getAddress());
          return "0x" === t ? null : t;
        }
        async waitForDeployment() {
          let e = this.deploymentTransaction();
          if (e) return await e.wait(), this;
          if (null != (await this.getDeployedCode())) return this;
          let t = N(this.runner);
          return (
            (0, l.hu)(
              null != t,
              "contract runner does not support .provider",
              "UNSUPPORTED_OPERATION",
              { operation: "waitForDeployment" }
            ),
            new Promise((e, r) => {
              let i = async () => {
                try {
                  let r = await this.getDeployedCode();
                  if (null != r) return e(this);
                  t.once("block", i);
                } catch (e) {
                  r(e);
                }
              };
              i();
            })
          );
        }
        deploymentTransaction() {
          return x(this).deployTx;
        }
        getFunction(e) {
          return (
            "string" != typeof e && (e = e.format()),
            (function (e, t) {
              let r = function (...r) {
                  let i = e.interface.getFunction(t, r);
                  return (
                    (0, l.hu)(
                      i,
                      "no matching fragment",
                      "UNSUPPORTED_OPERATION",
                      { operation: "fragment", info: { key: t, args: r } }
                    ),
                    i
                  );
                },
                i = async function (...t) {
                  let i = r(...t),
                    n = {};
                  if (
                    (i.inputs.length + 1 === t.length &&
                      (n = await S(t.pop())).from &&
                      (n.from = await (0, s.ru)(n.from, C(e.runner))),
                    i.inputs.length !== t.length)
                  )
                    throw Error(
                      "internal error: fragment inputs doesn't match arguments; should not happen"
                    );
                  let a = await T(e.runner, i.inputs, t);
                  return Object.assign(
                    {},
                    n,
                    await (0, o.m)({
                      to: e.getAddress(),
                      data: e.interface.encodeFunctionData(i, a),
                    })
                  );
                },
                n = async function (...e) {
                  let t = await u(...e);
                  return 1 === t.length ? t[0] : t;
                },
                a = async function (...t) {
                  let r = e.runner;
                  (0, l.hu)(
                    A(r),
                    "contract runner does not support sending transactions",
                    "UNSUPPORTED_OPERATION",
                    { operation: "sendTransaction" }
                  );
                  let n = await r.sendTransaction(await i(...t)),
                    s = N(e.runner);
                  return new g(e.interface, s, n);
                },
                c = async function (...t) {
                  let r = I(e.runner, "estimateGas");
                  return (
                    (0, l.hu)(
                      v(r),
                      "contract runner does not support gas estimation",
                      "UNSUPPORTED_OPERATION",
                      { operation: "estimateGas" }
                    ),
                    await r.estimateGas(await i(...t))
                  );
                },
                u = async function (...t) {
                  let n = I(e.runner, "call");
                  (0, l.hu)(
                    b(n),
                    "contract runner does not support calling",
                    "UNSUPPORTED_OPERATION",
                    { operation: "call" }
                  );
                  let s = await i(...t),
                    a = "0x";
                  try {
                    a = await n.call(s);
                  } catch (t) {
                    if ((0, l.Hl)(t) && t.data)
                      throw e.interface.makeError(t.data, s);
                    throw t;
                  }
                  let o = r(...t);
                  return e.interface.decodeFunctionResult(o, a);
                },
                h = async (...e) =>
                  r(...e).constant ? await n(...e) : await a(...e);
              return (
                (0, o.h)(h, {
                  name: e.interface.getFunctionName(t),
                  _contract: e,
                  _key: t,
                  getFragment: r,
                  estimateGas: c,
                  populateTransaction: i,
                  send: a,
                  staticCall: n,
                  staticCallResult: u,
                }),
                Object.defineProperty(h, "fragment", {
                  configurable: !1,
                  enumerable: !0,
                  get: () => {
                    let r = e.interface.getFunction(t);
                    return (
                      (0, l.hu)(
                        r,
                        "no matching fragment",
                        "UNSUPPORTED_OPERATION",
                        { operation: "fragment", info: { key: t } }
                      ),
                      r
                    );
                  },
                }),
                h
              );
            })(this, e)
          );
        }
        getEvent(e) {
          return (
            "string" != typeof e && (e = e.format()),
            (function (e, t) {
              let r = function (...r) {
                  let i = e.interface.getEvent(t, r);
                  return (
                    (0, l.hu)(
                      i,
                      "no matching fragment",
                      "UNSUPPORTED_OPERATION",
                      { operation: "fragment", info: { key: t, args: r } }
                    ),
                    i
                  );
                },
                i = function (...t) {
                  return new _(e, r(...t), t);
                };
              return (
                (0, o.h)(i, {
                  name: e.interface.getEventName(t),
                  _contract: e,
                  _key: t,
                  getFragment: r,
                }),
                Object.defineProperty(i, "fragment", {
                  configurable: !1,
                  enumerable: !0,
                  get: () => {
                    let r = e.interface.getEvent(t);
                    return (
                      (0, l.hu)(
                        r,
                        "no matching fragment",
                        "UNSUPPORTED_OPERATION",
                        { operation: "fragment", info: { key: t } }
                      ),
                      r
                    );
                  },
                }),
                i
              );
            })(this, e)
          );
        }
        async queryTransaction(e) {
          throw Error("@TODO");
        }
        async queryFilter(e, t, r) {
          null == t && (t = 0), null == r && (r = "latest");
          let { addr: i, addrPromise: n } = x(this),
            s = i || (await n),
            { fragment: o, topics: c } = await k(this, e),
            u = { address: s, topics: c, fromBlock: t, toBlock: r },
            h = N(this.runner);
          return (
            (0, l.hu)(
              h,
              "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION",
              { operation: "queryFilter" }
            ),
            (await h.getLogs(u)).map((e) => {
              let t = o;
              if (null == t)
                try {
                  t = this.interface.getEvent(e.topics[0]);
                } catch (e) {}
              if (t)
                try {
                  return new d(e, this.interface, t);
                } catch (t) {
                  return new p(e, t);
                }
              return new a.Zb(e, h);
            })
          );
        }
        async on(e, t) {
          let r = await D(this, "on", e);
          return r.listeners.push({ listener: t, once: !1 }), r.start(), this;
        }
        async once(e, t) {
          let r = await D(this, "once", e);
          return r.listeners.push({ listener: t, once: !0 }), r.start(), this;
        }
        async emit(e, ...t) {
          return await M(this, e, t, null);
        }
        async listenerCount(e) {
          if (e) {
            let t = await R(this, e);
            return t ? t.listeners.length : 0;
          }
          let { subs: t } = x(this),
            r = 0;
          for (let { listeners: e } of t.values()) r += e.length;
          return r;
        }
        async listeners(e) {
          if (e) {
            let t = await R(this, e);
            return t ? t.listeners.map(({ listener: e }) => e) : [];
          }
          let { subs: t } = x(this),
            r = [];
          for (let { listeners: e } of t.values())
            r = r.concat(e.map(({ listener: e }) => e));
          return r;
        }
        async off(e, t) {
          let r = await R(this, e);
          if (!r) return this;
          if (t) {
            let e = r.listeners.map(({ listener: e }) => e).indexOf(t);
            e >= 0 && r.listeners.splice(e, 1);
          }
          return (
            (null == t || 0 === r.listeners.length) &&
              (r.stop(), x(this).subs.delete(r.tag)),
            this
          );
        }
        async removeAllListeners(e) {
          if (e) {
            let t = await R(this, e);
            if (!t) return this;
            t.stop(), x(this).subs.delete(t.tag);
          } else {
            let { subs: e } = x(this);
            for (let { tag: t, stop: r } of e.values()) r(), e.delete(t);
          }
          return this;
        }
        async addListener(e, t) {
          return await this.on(e, t);
        }
        async removeListener(e, t) {
          return await this.off(e, t);
        }
        static buildClass(e) {
          class t extends j {
            constructor(t, r = null) {
              super(t, e, r);
            }
          }
          return t;
        }
        static from(e, t, r) {
          return null == r && (r = null), new this(e, t, r);
        }
      }
      function F() {
        return j;
      }
      class $ extends F() {}
    },
    19066: function (e, t, r) {
      "use strict";
      r.d(t, {
        w: function () {
          return I;
        },
      });
      var i = r(25655),
        n = r(64450),
        s = r(35891);
      let [a, o, l] = [[], [], []],
        c = BigInt(0),
        u = BigInt(1),
        h = BigInt(2),
        d = BigInt(7),
        p = BigInt(256),
        f = BigInt(113);
      for (let e = 0, t = u, r = 1, i = 0; e < 24; e++) {
        ([r, i] = [i, (2 * r + 3 * i) % 5]),
          a.push(2 * (5 * i + r)),
          o.push((((e + 1) * (e + 2)) / 2) % 64);
        let n = c;
        for (let e = 0; e < 7; e++)
          (t = ((t << u) ^ ((t >> d) * f)) % p) & h &&
            (n ^= u << ((u << BigInt(e)) - u));
        l.push(n);
      }
      let [g, m] = (0, n.Vl)(l, !0),
        y = (e, t, r) => (r > 32 ? (0, n.SD)(e, t, r) : (0, n.EP)(e, t, r)),
        w = (e, t, r) => (r > 32 ? (0, n.mk)(e, t, r) : (0, n.gm)(e, t, r));
      class b extends s.kb {
        constructor(e, t, r, n = !1, a = 24) {
          if (
            (super(),
            (this.blockLen = e),
            (this.suffix = t),
            (this.outputLen = r),
            (this.enableXOF = n),
            (this.rounds = a),
            (this.pos = 0),
            (this.posOut = 0),
            (this.finished = !1),
            (this.destroyed = !1),
            (0, i.Rx)(r),
            0 >= this.blockLen || this.blockLen >= 200)
          )
            throw Error("Sha3 supports only keccak-f1600 function");
          (this.state = new Uint8Array(200)),
            (this.state32 = (0, s.Jq)(this.state));
        }
        keccak() {
          !(function (e, t = 24) {
            let r = new Uint32Array(10);
            for (let i = 24 - t; i < 24; i++) {
              for (let t = 0; t < 10; t++)
                r[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];
              for (let t = 0; t < 10; t += 2) {
                let i = (t + 8) % 10,
                  n = (t + 2) % 10,
                  s = r[n],
                  a = r[n + 1],
                  o = y(s, a, 1) ^ r[i],
                  l = w(s, a, 1) ^ r[i + 1];
                for (let r = 0; r < 50; r += 10)
                  (e[t + r] ^= o), (e[t + r + 1] ^= l);
              }
              let t = e[2],
                n = e[3];
              for (let r = 0; r < 24; r++) {
                let i = o[r],
                  s = y(t, n, i),
                  l = w(t, n, i),
                  c = a[r];
                (t = e[c]), (n = e[c + 1]), (e[c] = s), (e[c + 1] = l);
              }
              for (let t = 0; t < 50; t += 10) {
                for (let i = 0; i < 10; i++) r[i] = e[t + i];
                for (let i = 0; i < 10; i++)
                  e[t + i] ^= ~r[(i + 2) % 10] & r[(i + 4) % 10];
              }
              (e[0] ^= g[i]), (e[1] ^= m[i]);
            }
            r.fill(0);
          })(this.state32, this.rounds),
            (this.posOut = 0),
            (this.pos = 0);
        }
        update(e) {
          (0, i.Gg)(this);
          let { blockLen: t, state: r } = this,
            n = (e = (0, s.O0)(e)).length;
          for (let i = 0; i < n; ) {
            let s = Math.min(t - this.pos, n - i);
            for (let t = 0; t < s; t++) r[this.pos++] ^= e[i++];
            this.pos === t && this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished) return;
          this.finished = !0;
          let { state: e, suffix: t, pos: r, blockLen: i } = this;
          (e[r] ^= t),
            (128 & t) != 0 && r === i - 1 && this.keccak(),
            (e[i - 1] ^= 128),
            this.keccak();
        }
        writeInto(e) {
          (0, i.Gg)(this, !1), (0, i.aI)(e), this.finish();
          let t = this.state,
            { blockLen: r } = this;
          for (let i = 0, n = e.length; i < n; ) {
            this.posOut >= r && this.keccak();
            let s = Math.min(r - this.posOut, n - i);
            e.set(t.subarray(this.posOut, this.posOut + s), i),
              (this.posOut += s),
              (i += s);
          }
          return e;
        }
        xofInto(e) {
          if (!this.enableXOF)
            throw Error("XOF is not possible for this instance");
          return this.writeInto(e);
        }
        xof(e) {
          return (0, i.Rx)(e), this.xofInto(new Uint8Array(e));
        }
        digestInto(e) {
          if (((0, i.J8)(e, this), this.finished))
            throw Error("digest() was already called");
          return this.writeInto(e), this.destroy(), e;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          (this.destroyed = !0), this.state.fill(0);
        }
        _cloneInto(e) {
          let {
            blockLen: t,
            suffix: r,
            outputLen: i,
            rounds: n,
            enableXOF: s,
          } = this;
          return (
            e || (e = new b(t, r, i, s, n)),
            e.state32.set(this.state32),
            (e.pos = this.pos),
            (e.posOut = this.posOut),
            (e.finished = this.finished),
            (e.rounds = n),
            (e.suffix = r),
            (e.outputLen = i),
            (e.enableXOF = s),
            (e.destroyed = this.destroyed),
            e
          );
        }
      }
      let v = (0, s.hE)(() => new b(136, 1, 32));
      var E = r(59369);
      let A = !1,
        C = function (e) {
          return v(e);
        },
        _ = C;
      function I(e) {
        let t = (0, E.Pw)(e, "data");
        return (0, E.Dv)(_(t));
      }
      (I._ = C),
        (I.lock = function () {
          A = !0;
        }),
        (I.register = function (e) {
          if (A) throw TypeError("keccak256 is locked");
          _ = e;
        }),
        Object.freeze(I);
    },
    61188: function (e, t, r) {
      "use strict";
      r.d(t, {
        P: function () {
          return g;
        },
      });
      let i =
        "0x0000000000000000000000000000000000000000000000000000000000000000";
      var n = r(59369),
        s = r(45474),
        a = r(35157);
      let o = BigInt(0),
        l = BigInt(1),
        c = BigInt(2),
        u = BigInt(27),
        h = BigInt(28),
        d = BigInt(35),
        p = {};
      function f(e) {
        return (0, n.U3)((0, s.ot)(e), 32);
      }
      class g {
        #C;
        #_;
        #I;
        #N;
        get r() {
          return this.#C;
        }
        set r(e) {
          (0, a.en)(32 === (0, n.M5)(e), "invalid r", "value", e),
            (this.#C = (0, n.Dv)(e));
        }
        get s() {
          return this.#_;
        }
        set s(e) {
          (0, a.en)(32 === (0, n.M5)(e), "invalid s", "value", e);
          let t = (0, n.Dv)(e);
          (0, a.en)(
            8 > parseInt(t.substring(0, 3)),
            "non-canonical s",
            "value",
            t
          ),
            (this.#_ = t);
        }
        get v() {
          return this.#I;
        }
        set v(e) {
          let t = (0, s.Dx)(e, "value");
          (0, a.en)(27 === t || 28 === t, "invalid v", "v", e), (this.#I = t);
        }
        get networkV() {
          return this.#N;
        }
        get legacyChainId() {
          let e = this.networkV;
          return null == e ? null : g.getChainId(e);
        }
        get yParity() {
          return 27 === this.v ? 0 : 1;
        }
        get yParityAndS() {
          let e = (0, n.Pw)(this.s);
          return this.yParity && (e[0] |= 128), (0, n.Dv)(e);
        }
        get compactSerialized() {
          return (0, n.zo)([this.r, this.yParityAndS]);
        }
        get serialized() {
          return (0, n.zo)([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
        }
        constructor(e, t, r, i) {
          (0, a.NK)(e, p, "Signature"),
            (this.#C = t),
            (this.#_ = r),
            (this.#I = i),
            (this.#N = null);
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
        }
        clone() {
          let e = new g(p, this.r, this.s, this.v);
          return this.networkV && (e.#N = this.networkV), e;
        }
        toJSON() {
          let e = this.networkV;
          return {
            _type: "signature",
            networkV: null != e ? e.toString() : null,
            r: this.r,
            s: this.s,
            v: this.v,
          };
        }
        static getChainId(e) {
          let t = (0, s.yT)(e, "v");
          return t == u || t == h
            ? o
            : ((0, a.en)(t >= d, "invalid EIP-155 v", "v", e), (t - d) / c);
        }
        static getChainIdV(e, t) {
          return (0, s.yT)(e) * c + BigInt(35 + t - 27);
        }
        static getNormalizedV(e) {
          let t = (0, s.yT)(e);
          return t === o || t === u
            ? 27
            : t === l || t === h
            ? 28
            : ((0, a.en)(t >= d, "invalid v", "v", e), t & l ? 27 : 28);
        }
        static from(e) {
          function t(t, r) {
            (0, a.en)(t, r, "signature", e);
          }
          if (null == e) return new g(p, i, i, 27);
          if ("string" == typeof e) {
            let r = (0, n.Pw)(e, "signature");
            if (64 === r.length) {
              let e = (0, n.Dv)(r.slice(0, 32)),
                t = r.slice(32, 64),
                i = 128 & t[0] ? 28 : 27;
              return (t[0] &= 127), new g(p, e, (0, n.Dv)(t), i);
            }
            if (65 === r.length) {
              let e = (0, n.Dv)(r.slice(0, 32)),
                i = r.slice(32, 64);
              t((128 & i[0]) == 0, "non-canonical s");
              let s = g.getNormalizedV(r[64]);
              return new g(p, e, (0, n.Dv)(i), s);
            }
            t(!1, "invalid raw signature length");
          }
          if (e instanceof g) return e.clone();
          let r = e.r;
          t(null != r, "missing r");
          let o = f(r),
            l = (function (e, r) {
              if (null != e) return f(e);
              if (null != r) {
                t((0, n.A7)(r, 32), "invalid yParityAndS");
                let e = (0, n.Pw)(r);
                return (e[0] &= 127), (0, n.Dv)(e);
              }
              t(!1, "missing s");
            })(e.s, e.yParityAndS);
          t((128 & (0, n.Pw)(l)[0]) == 0, "non-canonical s");
          let { networkV: c, v: u } = (function (e, r, i) {
              if (null != e) {
                let t = (0, s.yT)(e);
                return {
                  networkV: t >= d ? t : void 0,
                  v: g.getNormalizedV(t),
                };
              }
              if (null != r)
                return (
                  t((0, n.A7)(r, 32), "invalid yParityAndS"),
                  { v: 128 & (0, n.Pw)(r)[0] ? 28 : 27 }
                );
              if (null != i) {
                switch ((0, s.Dx)(i, "sig.yParity")) {
                  case 0:
                    return { v: 27 };
                  case 1:
                    return { v: 28 };
                }
                t(!1, "invalid yParity");
              }
              t(!1, "missing v");
            })(e.v, e.yParityAndS, e.yParity),
            h = new g(p, o, l, u);
          return (
            c && (h.#N = c),
            t(
              null == e.yParity ||
                (0, s.Dx)(e.yParity, "sig.yParity") === h.yParity,
              "yParity mismatch"
            ),
            t(
              null == e.yParityAndS || e.yParityAndS === h.yParityAndS,
              "yParityAndS mismatch"
            ),
            h
          );
        }
      }
    },
    79146: function (e, t, r) {
      "use strict";
      r.d(t, {
        id: function () {
          return s;
        },
      });
      var i = r(19066),
        n = r(9478);
      function s(e) {
        return (0, i.w)((0, n.Y0)(e));
      }
    },
    16038: function (e, t, r) {
      "use strict";
      let i, n, s, a, o, l, c, u, h, d, p, f, g, m, y;
      r.d(t, {
        u: function () {
          return eF;
        },
        P: function () {
          return eU;
        },
      });
      var w = r(3876),
        b = r(70587),
        v = r(94552),
        E = r(59868),
        A = r(19066),
        C = r(35157),
        _ = r(9478),
        I = r(59369);
      let N = new Map([
        [8217, "apostrophe"],
        [8260, "fraction slash"],
        [12539, "middle dot"],
      ]);
      function S(e) {
        var t;
        let r;
        return (
          (t = (function (e) {
            let t = 0;
            function r() {
              return (e[t++] << 8) | e[t++];
            }
            let i = r(),
              n = 1,
              s = [0, 1];
            for (let e = 1; e < i; e++) s.push((n += r()));
            let a = r(),
              o = t;
            t += a;
            let l = 0,
              c = 0;
            function u() {
              return (
                0 == l && ((c = (c << 8) | e[t++]), (l = 8)), (c >> --l) & 1
              );
            }
            let h = 2147483648 - 1,
              d = 0;
            for (let e = 0; e < 31; e++) d = (d << 1) | u();
            let p = [],
              f = 0,
              g = 2147483648;
            for (;;) {
              let e = Math.floor(((d - f + 1) * n - 1) / g),
                t = 0,
                r = i;
              for (; r - t > 1; ) {
                let i = (t + r) >>> 1;
                e < s[i] ? (r = i) : (t = i);
              }
              if (0 == t) break;
              p.push(t);
              let a = f + Math.floor((g * s[t]) / n),
                o = f + Math.floor((g * s[t + 1]) / n) - 1;
              for (; ((a ^ o) & 1073741824) == 0; )
                (d = ((d << 1) & h) | u()),
                  (a = (a << 1) & h),
                  (o = ((o << 1) & h) | 1);
              for (; a & ~o & 536870912; )
                (d = (1073741824 & d) | ((d << 1) & (h >>> 1)) | u()),
                  (a = (a << 1) ^ 1073741824),
                  (o = ((1073741824 ^ o) << 1) | 1073741825);
              (f = a), (g = 1 + o - a);
            }
            let m = i - 4;
            return p.map((t) => {
              switch (t - m) {
                case 3:
                  return m + 65792 + ((e[o++] << 16) | (e[o++] << 8) | e[o++]);
                case 2:
                  return m + 256 + ((e[o++] << 8) | e[o++]);
                case 1:
                  return m + e[o++];
                default:
                  return t - 1;
              }
            });
          })(
            (function (e) {
              let t = [];
              [
                ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
              ].forEach((e, r) => (t[e.charCodeAt(0)] = r));
              let r = e.length,
                i = new Uint8Array((6 * r) >> 3);
              for (let n = 0, s = 0, a = 0, o = 0; n < r; n++)
                (o = (o << 6) | t[e.charCodeAt(n)]),
                  (a += 6) >= 8 && (i[s++] = o >> (a -= 8));
              return i;
            })(e)
          )),
          (r = 0),
          () => t[r++]
        );
      }
      function T(e, t = 0) {
        let r = [];
        for (;;) {
          let i = e(),
            n = e();
          if (!n) break;
          t += i;
          for (let e = 0; e < n; e++) r.push(t + e);
          t += n + 1;
        }
        return r;
      }
      function P(e) {
        return x(() => {
          let t = T(e);
          if (t.length) return t;
        });
      }
      function O(e) {
        let t = [];
        for (;;) {
          let r = e();
          if (0 == r) break;
          t.push(
            (function (e, t) {
              let r = 1 + t(),
                i = t(),
                n = x(t);
              return k(n.length, 1 + e, t).flatMap((e, t) => {
                let [s, ...a] = e;
                return Array(n[t])
                  .fill()
                  .map((e, t) => {
                    let n = t * i;
                    return [s + t * r, a.map((e) => e + n)];
                  });
              });
            })(r, e)
          );
        }
        for (;;) {
          let r = e() - 1;
          if (r < 0) break;
          t.push(k(1 + e(), 1 + r, e).map((e) => [e[0], e.slice(1)]));
        }
        return t.flat();
      }
      function x(e) {
        let t = [];
        for (;;) {
          let r = e(t.length);
          if (!r) break;
          t.push(r);
        }
        return t;
      }
      function k(e, t, r) {
        let i = Array(e)
          .fill()
          .map(() => []);
        for (let n = 0; n < t; n++)
          (function (e, t) {
            let r = Array(e);
            for (let n = 0, s = 0; n < e; n++) {
              var i;
              r[n] = s += 1 & (i = t()) ? ~i >> 1 : i >> 1;
            }
            return r;
          })(e, r).forEach((e, t) => i[t].push(e));
        return i;
      }
      function R(e) {
        return `{${e.toString(16).toUpperCase().padStart(2, "0")}}`;
      }
      function D(e) {
        let t = e.length;
        if (t < 4096) return String.fromCodePoint(...e);
        let r = [];
        for (let i = 0; i < t; )
          r.push(String.fromCodePoint(...e.slice(i, (i += 4096))));
        return r.join("");
      }
      function U(e, t) {
        let r = e.length,
          i = r - t.length;
        for (let n = 0; 0 == i && n < r; n++) i = e[n] - t[n];
        return i;
      }
      function L(e) {
        return (e >> 24) & 255;
      }
      function M(e) {
        return 16777215 & e;
      }
      function B(e) {
        return e >= 44032 && e < 55204;
      }
      function j(e) {
        i ||
          (function () {
            let e = S(
              "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g"
            );
            for (let [t, r] of ((i = new Map(
              P(e).flatMap((e, t) => e.map((e) => [e, (t + 1) << 24]))
            )),
            (n = new Set(T(e))),
            (s = new Map()),
            (a = new Map()),
            O(e))) {
              if (!n.has(t) && 2 == r.length) {
                let [e, i] = r,
                  n = a.get(e);
                n || ((n = new Map()), a.set(e, n)), n.set(i, t);
              }
              s.set(t, r.reverse());
            }
          })();
        let t = [],
          r = [],
          o = !1;
        function l(e) {
          let r = i.get(e);
          r && ((o = !0), (e |= r)), t.push(e);
        }
        for (let i of e)
          for (;;) {
            if (i < 128) t.push(i);
            else if (B(i)) {
              let e = i - 44032,
                t = (e / 588) | 0,
                r = ((e % 588) / 28) | 0,
                n = e % 28;
              l(4352 + t), l(4449 + r), n > 0 && l(4519 + n);
            } else {
              let e = s.get(i);
              e ? r.push(...e) : l(i);
            }
            if (!r.length) break;
            i = r.pop();
          }
        if (o && t.length > 1) {
          let e = L(t[0]);
          for (let r = 1; r < t.length; r++) {
            let i = L(t[r]);
            if (0 == i || e <= i) {
              e = i;
              continue;
            }
            let n = r - 1;
            for (;;) {
              let r = t[n + 1];
              if (((t[n + 1] = t[n]), (t[n] = r), !n || (e = L(t[--n])) <= i))
                break;
            }
            e = L(t[r]);
          }
        }
        return t;
      }
      function F(e) {
        return (function (e) {
          let t = [],
            r = [],
            i = -1,
            n = 0;
          for (let s of e) {
            let e = L(s),
              o = M(s);
            if (-1 == i) 0 == e ? (i = o) : t.push(o);
            else if (n > 0 && n >= e)
              0 == e ? (t.push(i, ...r), (r.length = 0), (i = o)) : r.push(o),
                (n = e);
            else {
              let s = (function (e, t) {
                if (e >= 4352 && e < 4371 && t >= 4449 && t < 4470)
                  return 44032 + (e - 4352) * 588 + (t - 4449) * 28;
                if (B(e) && t > 4519 && t < 4547 && (e - 44032) % 28 == 0)
                  return e + (t - 4519);
                {
                  let r = a.get(e);
                  return r && (r = r.get(t)) ? r : -1;
                }
              })(i, o);
              s >= 0
                ? (i = s)
                : 0 == n && 0 == e
                ? (t.push(i), (i = o))
                : (r.push(o), (n = e));
            }
          }
          return i >= 0 && t.push(i, ...r), t;
        })(j(e));
      }
      let $ = (e) => Array.from(e);
      function H(e, t) {
        return e.P.has(t) || e.Q.has(t);
      }
      class z extends Array {
        get is_emoji() {
          return !0;
        }
      }
      function q() {
        let e, t;
        if (o) return;
        let r = S(
            "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI"
          ),
          i = () => T(r),
          n = () => new Set(i()),
          s = (e, t) => t.forEach((t) => e.add(t));
        (o = new Map(O(r))),
          (l = n()),
          (c = i()),
          (u = new Set(i().map((e) => c[e]))),
          (c = new Set(c)),
          (h = n()),
          n();
        let a = P(r),
          w = r(),
          b = () => {
            let e = new Set();
            return i().forEach((t) => s(e, a[t])), s(e, i()), e;
          };
        (d = x((e) => {
          let t = x(r).map((e) => e + 96);
          if (t.length) {
            let i = e >= w;
            return (
              (t[0] -= 32),
              (t = D(t)),
              i && (t = `Restricted[${t}]`),
              { N: t, P: b(), Q: b(), M: !r(), R: i }
            );
          }
        })),
          (p = n()),
          (f = new Map());
        let v = i()
          .concat($(p))
          .sort((e, t) => e - t);
        for (let { V: e, M: t } of (v.forEach((e, t) => {
          let i = r(),
            n = (v[t] = i ? v[t - i] : { V: [], M: new Map() });
          n.V.push(e), p.has(e) || f.set(e, n);
        }),
        new Set(f.values()))) {
          let r = [];
          for (let t of e) {
            let e = d.filter((e) => H(e, t)),
              i = r.find(({ G: t }) => e.some((e) => t.has(e)));
            i || ((i = { G: new Set(), V: [] }), r.push(i)),
              i.V.push(t),
              s(i.G, e);
          }
          let i = r.flatMap((e) => $(e.G));
          for (let { G: e, V: n } of r) {
            let r = new Set(i.filter((t) => !e.has(t)));
            for (let e of n) t.set(e, r);
          }
        }
        g = new Set();
        let E = new Set(),
          A = (e) => (g.has(e) ? E.add(e) : g.add(e));
        for (let e of d) {
          for (let t of e.P) A(t);
          for (let t of e.Q) A(t);
        }
        for (let e of g) f.has(e) || E.has(e) || f.set(e, 1);
        for (let i of (s(g, j(g).map(M)),
        (m = ((e = []),
        (t = T(r)),
        (function t({ S: r, B: i }, n, s) {
          if (!(4 & r) || s !== n[n.length - 1])
            for (let a of (2 & r && (s = n[n.length - 1]),
            1 & r && e.push(n),
            i))
              for (let e of a.Q) t(a, [...n, e], s);
        })(
          (function e(i) {
            return {
              S: r(),
              B: x(() => {
                let i = T(r).map((e) => t[e]);
                if (i.length) return e(i);
              }),
              Q: i,
            };
          })([]),
          []
        ),
        e)
          .map((e) => z.from(e))
          .sort(U)),
        (y = new Map()),
        m)) {
          let e = [y];
          for (let t of i) {
            let r = e.map((e) => {
              let r = e.get(t);
              return r || ((r = new Map()), e.set(t, r)), r;
            });
            65039 === t ? e.push(...r) : (e = r);
          }
          for (let t of e) t.V = i;
        }
      }
      function V(e) {
        return (K(e) ? "" : `${G(W([e]))} `) + R(e);
      }
      function G(e) {
        return `"${e}"\u200E`;
      }
      function W(e, t = 1 / 0, r = R) {
        var i;
        let n = [];
        (i = e[0]),
          q(),
          c.has(i) && n.push(""),
          e.length > t &&
            ((t >>= 1), (e = [...e.slice(0, t), 8230, ...e.slice(-t)]));
        let s = 0,
          a = e.length;
        for (let t = 0; t < a; t++) {
          let i = e[t];
          K(i) && (n.push(D(e.slice(s, t))), n.push(r(i)), (s = t + 1));
        }
        return n.push(D(e.slice(s, a))), n.join("");
      }
      function K(e) {
        return q(), h.has(e);
      }
      function Z(e) {
        return Error(`disallowed character: ${V(e)}`);
      }
      function J(e, t) {
        let r = V(t),
          i = d.find((e) => e.P.has(t));
        return (
          i && (r = `${i.N} ${r}`), Error(`illegal mixture: ${e.N} + ${r}`)
        );
      }
      function Q(e) {
        return Error(`illegal placement: ${e}`);
      }
      function Y(e) {
        return e.filter((e) => 65039 != e);
      }
      let X = new Uint8Array(32);
      function ee(e) {
        return (
          (0, C.en)(
            0 !== e.length,
            "invalid ENS name; empty component",
            "comp",
            e
          ),
          e
        );
      }
      function et(e) {
        let t = (0, _.Y0)(
            (function (e) {
              try {
                var t;
                if (0 === e.length) throw Error("empty label");
                return (t = (function (e, t, r) {
                  if (!e) return [];
                  q();
                  let i = 0;
                  return e.split(".").map((e) => {
                    let n = (function (e) {
                        let t = [];
                        for (let r = 0, i = e.length; r < i; ) {
                          let i = e.codePointAt(r);
                          (r += i < 65536 ? 1 : 2), t.push(i);
                        }
                        return t;
                      })(e),
                      s = { input: n, offset: i };
                    i += n.length + 1;
                    try {
                      let e,
                        i = (s.tokens = (function (e, t, r) {
                          let i = [],
                            n = [];
                          for (e = e.slice().reverse(); e.length; ) {
                            let s = (function (e, t) {
                              let r,
                                i = y,
                                n = e.length;
                              for (; n && (i = i.get(e[--n])); ) {
                                let { V: t } = i;
                                t && ((r = t), (e.length = n));
                              }
                              return r;
                            })(e);
                            if (s)
                              n.length && (i.push(t(n)), (n = [])),
                                i.push(r(s));
                            else {
                              let t = e.pop();
                              if (g.has(t)) n.push(t);
                              else {
                                let e = o.get(t);
                                if (e) n.push(...e);
                                else if (!l.has(t)) throw Z(t);
                              }
                            }
                          }
                          return n.length && i.push(t(n)), i;
                        })(n, t, r)),
                        a = i.length;
                      if (!a) throw Error("empty label");
                      let h = (s.output = i.flat());
                      if (
                        ((function (e) {
                          for (let t = e.lastIndexOf(95); t > 0; )
                            if (95 !== e[--t])
                              throw Error("underscore allowed only at start");
                        })(h),
                        !(s.emoji = a > 1 || i[0].is_emoji) &&
                          h.every((e) => e < 128))
                      )
                        (function (e) {
                          if (e.length >= 4 && 45 == e[2] && 45 == e[3])
                            throw Error(
                              `invalid label extension: "${D(e.slice(0, 4))}"`
                            );
                        })(h),
                          (e = "ASCII");
                      else {
                        let t = i.flatMap((e) => (e.is_emoji ? [] : e));
                        if (t.length) {
                          if (c.has(h[0])) throw Q("leading combining mark");
                          for (let e = 1; e < a; e++) {
                            let t = i[e];
                            if (!t.is_emoji && c.has(t[0]))
                              throw Q(
                                `emoji + combining mark: "${D(i[e - 1])} + ${W([
                                  t[0],
                                ])}"`
                              );
                          }
                          !(function (e) {
                            let t = e[0],
                              r = N.get(t);
                            if (r) throw Q(`leading ${r}`);
                            let i = e.length,
                              n = -1;
                            for (let s = 1; s < i; s++) {
                              t = e[s];
                              let i = N.get(t);
                              if (i) {
                                if (n == s) throw Q(`${r} + ${i}`);
                                (n = s + 1), (r = i);
                              }
                            }
                            if (n == i) throw Q(`trailing ${r}`);
                          })(h);
                          let r = $(new Set(t)),
                            [n] = (function (e) {
                              let t = d;
                              for (let r of e) {
                                let e = t.filter((e) => H(e, r));
                                if (!e.length) {
                                  if (d.some((e) => H(e, r))) throw J(t[0], r);
                                  throw Z(r);
                                }
                                if (((t = e), 1 == e.length)) break;
                              }
                              return t;
                            })(r);
                          (function (e, t) {
                            for (let r of t) if (!H(e, r)) throw J(e, r);
                            if (e.M) {
                              let e = j(t).map(M);
                              for (let t = 1, r = e.length; t < r; t++)
                                if (u.has(e[t])) {
                                  let i = t + 1;
                                  for (let n; i < r && u.has((n = e[i])); i++)
                                    for (let r = t; r < i; r++)
                                      if (e[r] == n)
                                        throw Error(
                                          `duplicate non-spacing marks: ${V(n)}`
                                        );
                                  if (i - t > 4)
                                    throw Error(
                                      `excessive non-spacing marks: ${G(
                                        W(e.slice(t - 1, i))
                                      )} (${i - t}/4)`
                                    );
                                  t = i;
                                }
                            }
                          })(n, t),
                            (function (e, t) {
                              let r;
                              let i = [];
                              for (let e of t) {
                                let t = f.get(e);
                                if (1 === t) return;
                                if (t) {
                                  let i = t.M.get(e);
                                  if (
                                    !(r = r ? r.filter((e) => i.has(e)) : $(i))
                                      .length
                                  )
                                    return;
                                } else i.push(e);
                              }
                              if (r) {
                                for (let t of r)
                                  if (i.every((e) => H(t, e)))
                                    throw Error(
                                      `whole-script confusable: ${e.N}/${t.N}`
                                    );
                              }
                            })(n, r),
                            (e = n.N);
                        } else e = "Emoji";
                      }
                      s.type = e;
                    } catch (e) {
                      s.error = e;
                    }
                    return s;
                  });
                })(e, F, Y))
                  .map(({ input: e, error: r, output: i }) => {
                    if (r) {
                      let i = r.message;
                      throw Error(
                        1 == t.length ? i : `Invalid label ${G(W(e, 63))}: ${i}`
                      );
                    }
                    return D(i);
                  })
                  .join(".");
              } catch (t) {
                (0, C.en)(!1, `invalid ENS name (${t.message})`, "name", e);
              }
            })(e)
          ),
          r = [];
        if (0 === e.length) return r;
        let i = 0;
        for (let e = 0; e < t.length; e++)
          46 === t[e] && (r.push(ee(t.slice(i, e))), (i = e + 1));
        return (
          (0, C.en)(
            i < t.length,
            "invalid ENS name; empty component",
            "name",
            e
          ),
          r.push(ee(t.slice(i))),
          r
        );
      }
      function er(e) {
        (0, C.en)(
          "string" == typeof e,
          "invalid ENS name; not a string",
          "name",
          e
        ),
          (0, C.en)(e.length, "invalid ENS name (empty label)", "name", e);
        let t = X,
          r = et(e);
        for (; r.length; ) t = (0, A.w)((0, I.zo)([t, (0, A.w)(r.pop())]));
        return (0, I.Dv)(t);
      }
      X.fill(0);
      var ei = r(44250),
        en = r(69781),
        es = r(81741),
        ea = r(45474),
        eo = r(15968);
      let el = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      BigInt(0);
      let ec = BigInt(58);
      function eu(e) {
        return (
          e.match(/^ipfs:\/\/ipfs\//i)
            ? (e = e.substring(12))
            : e.match(/^ipfs:\/\//i)
            ? (e = e.substring(7))
            : (0, C.en)(!1, "unsupported IPFS format", "link", e),
          `https://gateway.ipfs.io/ipfs/${e}`
        );
      }
      class eh {
        name;
        constructor(e) {
          (0, en.h)(this, { name: e });
        }
        connect(e) {
          return this;
        }
        supportsCoinType(e) {
          return !1;
        }
        async encodeAddress(e, t) {
          throw Error("unsupported coin");
        }
        async decodeAddress(e, t) {
          throw Error("unsupported coin");
        }
      }
      let ed = RegExp("^(ipfs)://(.*)$", "i"),
        ep = [
          RegExp("^(https)://(.*)$", "i"),
          RegExp("^(data):(.*)$", "i"),
          ed,
          RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
        ];
      class ef {
        provider;
        address;
        name;
        #S;
        #T;
        constructor(e, t, r) {
          (0, en.h)(this, { provider: e, address: t, name: r }),
            (this.#S = null),
            (this.#T = new E.CH(
              t,
              [
                "function supportsInterface(bytes4) view returns (bool)",
                "function resolve(bytes, bytes) view returns (bytes)",
                "function addr(bytes32) view returns (address)",
                "function addr(bytes32, uint) view returns (bytes)",
                "function text(bytes32, string) view returns (string)",
                "function contenthash(bytes32) view returns (bytes)",
              ],
              e
            ));
        }
        async supportsWildcard() {
          return (
            null == this.#S &&
              (this.#S = (async () => {
                try {
                  return await this.#T.supportsInterface("0x9061b923");
                } catch (e) {
                  if ((0, C.VZ)(e, "CALL_EXCEPTION")) return !1;
                  throw ((this.#S = null), e);
                }
              })()),
            await this.#S
          );
        }
        async #P(e, t) {
          var r;
          t = (t || []).slice();
          let i = this.#T.interface;
          t.unshift(er(this.name));
          let n = null;
          (await this.supportsWildcard()) &&
            ((n = i.getFunction(e)),
            (0, C.hu)(n, "missing fragment", "UNKNOWN_ERROR", {
              info: { funcName: e },
            }),
            (t = [
              ((r = this.name),
              (0, C.en)(
                !0,
                "DNS encoded label cannot exceed 255",
                "length",
                255
              ),
              (0, I.Dv)(
                (0, I.zo)(
                  et(r).map((e) => {
                    (0, C.en)(
                      e.length <= 255,
                      `label ${JSON.stringify(r)} exceeds 255 bytes`,
                      "name",
                      r
                    );
                    let t = new Uint8Array(e.length + 1);
                    return t.set(e, 1), (t[0] = t.length - 1), t;
                  })
                )
              ) + "00"),
              i.encodeFunctionData(n, t),
            ]),
            (e = "resolve(bytes,bytes)")),
            t.push({ enableCcipRead: !0 });
          try {
            let r = await this.#T[e](...t);
            if (n) return i.decodeFunctionResult(n, r)[0];
            return r;
          } catch (e) {
            if (!(0, C.VZ)(e, "CALL_EXCEPTION")) throw e;
          }
          return null;
        }
        async getAddress(e) {
          if ((null == e && (e = 60), 60 === e))
            try {
              let e = await this.#P("addr(bytes32)");
              if (null == e || e === v.N) return null;
              return e;
            } catch (e) {
              if ((0, C.VZ)(e, "CALL_EXCEPTION")) return null;
              throw e;
            }
          if (e >= 0 && e < 2147483648) {
            let t = e + 2147483648,
              r = await this.#P("addr(bytes32,uint)", [t]);
            if ((0, I.A7)(r, 20)) return (0, b.K)(r);
          }
          let t = null;
          for (let r of this.provider.plugins)
            if (r instanceof eh && r.supportsCoinType(e)) {
              t = r;
              break;
            }
          if (null == t) return null;
          let r = await this.#P("addr(bytes32,uint)", [e]);
          if (null == r || "0x" === r) return null;
          let i = await t.decodeAddress(e, r);
          if (null != i) return i;
          (0, C.hu)(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
            operation: `getAddress(${e})`,
            info: { coinType: e, data: r },
          });
        }
        async getText(e) {
          let t = await this.#P("text(bytes32,string)", [e]);
          return null == t || "0x" === t ? null : t;
        }
        async getContentHash() {
          let e = await this.#P("contenthash(bytes32)");
          if (null == e || "0x" === e) return null;
          let t = e.match(
            /^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/
          );
          if (t) {
            let e = "e3010170" === t[1] ? "ipfs" : "ipns",
              r = parseInt(t[4], 16);
            if (t[5].length === 2 * r)
              return `${e}://${(function (e) {
                let t = (0, I.Pw)(e),
                  r = (0, ea.Gh)(t),
                  i = "";
                for (; r; ) (i = el[Number(r % ec)] + i), (r /= ec);
                for (let e = 0; e < t.length && !t[e]; e++) i = el[0] + i;
                return i;
              })("0x" + t[2])}`;
          }
          let r = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
          if (r && 64 === r[1].length) return `bzz://${r[1]}`;
          (0, C.hu)(
            !1,
            "invalid or unsupported content hash data",
            "UNSUPPORTED_OPERATION",
            { operation: "getContentHash()", info: { data: e } }
          );
        }
        async getAvatar() {
          return (await this._getAvatar()).url;
        }
        async _getAvatar() {
          let e = [{ type: "name", value: this.name }];
          try {
            let t = await this.getText("avatar");
            if (null == t)
              return (
                e.push({ type: "!avatar", value: "" }),
                { url: null, linkage: e }
              );
            e.push({ type: "avatar", value: t });
            for (let r = 0; r < ep.length; r++) {
              let i = t.match(ep[r]);
              if (null == i) continue;
              let n = i[1].toLowerCase();
              switch (n) {
                case "https":
                case "data":
                  return (
                    e.push({ type: "url", value: t }), { linkage: e, url: t }
                  );
                case "ipfs": {
                  let r = eu(t);
                  return (
                    e.push({ type: "ipfs", value: t }),
                    e.push({ type: "url", value: r }),
                    { linkage: e, url: r }
                  );
                }
                case "erc721":
                case "erc1155": {
                  let r = "erc721" === n ? "tokenURI(uint256)" : "uri(uint256)";
                  e.push({ type: n, value: t });
                  let s = await this.getAddress();
                  if (null == s)
                    return (
                      e.push({ type: "!owner", value: "" }),
                      { url: null, linkage: e }
                    );
                  let a = (i[2] || "").split("/");
                  if (2 !== a.length)
                    return (
                      e.push({ type: `!${n}caip`, value: i[2] || "" }),
                      { url: null, linkage: e }
                    );
                  let o = a[1],
                    l = new E.CH(
                      a[0],
                      [
                        "function tokenURI(uint) view returns (string)",
                        "function ownerOf(uint) view returns (address)",
                        "function uri(uint) view returns (string)",
                        "function balanceOf(address, uint256) view returns (uint)",
                      ],
                      this.provider
                    );
                  if ("erc721" === n) {
                    let t = await l.ownerOf(o);
                    if (s !== t)
                      return (
                        e.push({ type: "!owner", value: t }),
                        { url: null, linkage: e }
                      );
                    e.push({ type: "owner", value: t });
                  } else if ("erc1155" === n) {
                    let t = await l.balanceOf(s, o);
                    if (!t)
                      return (
                        e.push({ type: "!balance", value: "0" }),
                        { url: null, linkage: e }
                      );
                    e.push({ type: "balance", value: t.toString() });
                  }
                  let c = await l[r](o);
                  if (null == c || "0x" === c)
                    return (
                      e.push({ type: "!metadata-url", value: "" }),
                      { url: null, linkage: e }
                    );
                  e.push({ type: "metadata-url-base", value: c }),
                    "erc1155" === n &&
                      ((c = c.replace("{id}", (0, ea.m9)(o, 32).substring(2))),
                      e.push({ type: "metadata-url-expanded", value: c })),
                    c.match(/^ipfs:/i) && (c = eu(c)),
                    e.push({ type: "metadata-url", value: c });
                  let u = {},
                    h = await new es.gd(c).send();
                  h.assertOk();
                  try {
                    u = h.bodyJson;
                  } catch (t) {
                    try {
                      e.push({ type: "!metadata", value: h.bodyText });
                    } catch (r) {
                      let t = h.body;
                      t && e.push({ type: "!metadata", value: (0, I.Dv)(t) });
                    }
                    return { url: null, linkage: e };
                  }
                  if (!u)
                    return (
                      e.push({ type: "!metadata", value: "" }),
                      { url: null, linkage: e }
                    );
                  e.push({ type: "metadata", value: JSON.stringify(u) });
                  let d = u.image;
                  if ("string" != typeof d)
                    return (
                      e.push({ type: "!imageUrl", value: "" }),
                      { url: null, linkage: e }
                    );
                  if (d.match(/^(https:\/\/|data:)/i));
                  else {
                    let t = d.match(ed);
                    if (null == t)
                      return (
                        e.push({ type: "!imageUrl-ipfs", value: d }),
                        { url: null, linkage: e }
                      );
                    e.push({ type: "imageUrl-ipfs", value: d }), (d = eu(d));
                  }
                  return (
                    e.push({ type: "url", value: d }), { linkage: e, url: d }
                  );
                }
              }
            }
          } catch (e) {}
          return { linkage: e, url: null };
        }
        static async getEnsAddress(e) {
          let t = await e.getNetwork(),
            r = t.getPlugin("org.ethers.plugins.network.Ens");
          return (
            (0, C.hu)(
              r,
              "network does not support ENS",
              "UNSUPPORTED_OPERATION",
              { operation: "getEnsAddress", info: { network: t } }
            ),
            r.address
          );
        }
        static async #O(e, t) {
          let r = await ef.getEnsAddress(e);
          try {
            let i = new E.CH(
                r,
                ["function resolver(bytes32) view returns (address)"],
                e
              ),
              n = await i.resolver(er(t), { enableCcipRead: !0 });
            if (n === v.N) return null;
            return n;
          } catch (e) {
            throw e;
          }
          return null;
        }
        static async fromName(e, t) {
          let r = t;
          for (;;) {
            if ("" === r || "." === r || ("eth" !== t && "eth" === r))
              return null;
            let i = await ef.#O(e, r);
            if (null != i) {
              let n = new ef(e, i, t);
              if (r !== t && !(await n.supportsWildcard())) return null;
              return n;
            }
            r = r.split(".").slice(1).join(".");
          }
        }
      }
      var eg = r(48996),
        em = r(61188),
        ey = r(22086);
      let ew = BigInt(0);
      function eb(e, t) {
        return function (r) {
          return null == r ? t : e(r);
        };
      }
      function ev(e, t) {
        return (r) => {
          if (t && null == r) return null;
          if (!Array.isArray(r)) throw Error("not an array");
          return r.map((t) => e(t));
        };
      }
      function eE(e, t) {
        return (r) => {
          let i = {};
          for (let n in e) {
            let s = n;
            if (t && n in t && !(s in r)) {
              for (let e of t[n])
                if (e in r) {
                  s = e;
                  break;
                }
            }
            try {
              let t = e[n](r[s]);
              void 0 !== t && (i[n] = t);
            } catch (t) {
              let e = t instanceof Error ? t.message : "not-an-error";
              (0, C.hu)(!1, `invalid value for value.${n} (${e})`, "BAD_DATA", {
                value: r,
              });
            }
          }
          return i;
        };
      }
      function eA(e) {
        return (0, C.en)((0, I.A7)(e, !0), "invalid data", "value", e), e;
      }
      function eC(e) {
        return (0, C.en)((0, I.A7)(e, 32), "invalid hash", "value", e), e;
      }
      let e_ = eE(
          {
            address: b.K,
            blockHash: eC,
            blockNumber: ea.Dx,
            data: eA,
            index: ea.Dx,
            removed: eb(function (e) {
              switch (e) {
                case !0:
                case "true":
                  return !0;
                case !1:
                case "false":
                  return !1;
              }
              (0,
              C.en)(!1, `invalid boolean; ${JSON.stringify(e)}`, "value", e);
            }, !1),
            topics: ev(eC),
            transactionHash: eC,
            transactionIndex: ea.Dx,
          },
          { index: ["logIndex"] }
        ),
        eI = eE(
          {
            hash: eb(eC),
            parentHash: eC,
            parentBeaconBlockRoot: eb(eC, null),
            number: ea.Dx,
            timestamp: ea.Dx,
            nonce: eb(eA),
            difficulty: ea.yT,
            gasLimit: ea.yT,
            gasUsed: ea.yT,
            stateRoot: eb(eC, null),
            receiptsRoot: eb(eC, null),
            blobGasUsed: eb(ea.yT, null),
            excessBlobGas: eb(ea.yT, null),
            miner: eb(b.K),
            prevRandao: eb(eC, null),
            extraData: eA,
            baseFeePerGas: eb(ea.yT),
          },
          { prevRandao: ["mixHash"] }
        ),
        eN = eE(
          {
            transactionIndex: ea.Dx,
            blockNumber: ea.Dx,
            transactionHash: eC,
            address: b.K,
            topics: ev(eC),
            data: eA,
            index: ea.Dx,
            blockHash: eC,
          },
          { index: ["logIndex"] }
        ),
        eS = eE(
          {
            to: eb(b.K, null),
            from: eb(b.K, null),
            contractAddress: eb(b.K, null),
            index: ea.Dx,
            root: eb(I.Dv),
            gasUsed: ea.yT,
            blobGasUsed: eb(ea.yT, null),
            logsBloom: eb(eA),
            blockHash: eC,
            hash: eC,
            logs: ev(function (e) {
              return eN(e);
            }),
            blockNumber: ea.Dx,
            cumulativeGasUsed: ea.yT,
            effectiveGasPrice: eb(ea.yT),
            blobGasPrice: eb(ea.yT, null),
            status: eb(ea.Dx),
            type: eb(ea.Dx, 0),
          },
          {
            effectiveGasPrice: ["gasPrice"],
            hash: ["transactionHash"],
            index: ["transactionIndex"],
          }
        );
      function eT(e) {
        e.to &&
          (0, ea.yT)(e.to) === ew &&
          (e.to = "0x0000000000000000000000000000000000000000");
        let t = eE(
          {
            hash: eC,
            index: eb(ea.Dx, void 0),
            type: (e) => ("0x" === e || null == e ? 0 : (0, ea.Dx)(e)),
            accessList: eb(ey.z, null),
            blobVersionedHashes: eb(ev(eC, !0), null),
            blockHash: eb(eC, null),
            blockNumber: eb(ea.Dx, null),
            transactionIndex: eb(ea.Dx, null),
            from: b.K,
            gasPrice: eb(ea.yT),
            maxPriorityFeePerGas: eb(ea.yT),
            maxFeePerGas: eb(ea.yT),
            maxFeePerBlobGas: eb(ea.yT, null),
            gasLimit: ea.yT,
            to: eb(b.K, null),
            value: ea.yT,
            nonce: ea.Dx,
            data: eA,
            creates: eb(b.K, null),
            chainId: eb(ea.yT, null),
          },
          { data: ["input"], gasLimit: ["gas"], index: ["transactionIndex"] }
        )(e);
        if (
          (null == t.to &&
            null == t.creates &&
            (t.creates = (function (e) {
              let t = (0, b.K)(e.from),
                r = (0, ea.yT)(e.nonce, "tx.nonce").toString(16);
              return (
                (r = "0" === r ? "0x" : r.length % 2 ? "0x0" + r : "0x" + r),
                (0, b.K)((0, I.QB)((0, A.w)((0, eg.e)([t, r])), 12))
              );
            })(t)),
          (1 === e.type || 2 === e.type) &&
            null == e.accessList &&
            (t.accessList = []),
          e.signature
            ? (t.signature = em.P.from(e.signature))
            : (t.signature = em.P.from(e)),
          null == t.chainId)
        ) {
          let e = t.signature.legacyChainId;
          null != e && (t.chainId = e);
        }
        return (
          t.blockHash && (0, ea.yT)(t.blockHash) === ew && (t.blockHash = null),
          t
        );
      }
      var eP = r(86804),
        eO = r(62418),
        ex = r(87258);
      let ek = BigInt(2);
      function eR(e) {
        return e && "function" == typeof e.then;
      }
      function eD(e, t) {
        return (
          e +
          ":" +
          JSON.stringify(t, (e, t) => {
            if (null == t) return "null";
            if ("bigint" == typeof t) return `bigint:${t.toString()}`;
            if ("string" == typeof t) return t.toLowerCase();
            if ("object" == typeof t && !Array.isArray(t)) {
              let e = Object.keys(t);
              return e.sort(), e.reduce((e, r) => ((e[r] = t[r]), e), {});
            }
            return t;
          })
        );
      }
      class eU {
        name;
        constructor(e) {
          (0, en.h)(this, { name: e });
        }
        start() {}
        stop() {}
        pause(e) {}
        resume() {}
      }
      function eL(e) {
        return (e = Array.from(new Set(e).values())).sort(), e;
      }
      async function eM(e, t) {
        if (null == e) throw Error("invalid event");
        if ((Array.isArray(e) && (e = { topics: e }), "string" == typeof e))
          switch (e) {
            case "block":
            case "debug":
            case "error":
            case "finalized":
            case "network":
            case "pending":
            case "safe":
              return { type: e, tag: e };
          }
        if ((0, I.A7)(e, 32)) {
          let t = e.toLowerCase();
          return { type: "transaction", tag: eD("tx", { hash: t }), hash: t };
        }
        if (e.orphan) {
          let t = e;
          return {
            type: "orphan",
            tag: eD("orphan", t),
            filter: JSON.parse(JSON.stringify(t)),
          };
        }
        if (e.address || e.topics) {
          let r = e,
            i = {
              topics: (r.topics || []).map((e) =>
                null == e
                  ? null
                  : Array.isArray(e)
                  ? eL(e.map((e) => e.toLowerCase()))
                  : e.toLowerCase()
              ),
            };
          if (r.address) {
            let e = [],
              n = [],
              s = (r) => {
                (0, I.A7)(r)
                  ? e.push(r)
                  : n.push(
                      (async () => {
                        e.push(await (0, w.ru)(r, t));
                      })()
                    );
              };
            Array.isArray(r.address) ? r.address.forEach(s) : s(r.address),
              n.length && (await Promise.all(n)),
              (i.address = eL(e.map((e) => e.toLowerCase())));
          }
          return { filter: i, tag: eD("event", i), type: "event" };
        }
        (0, C.en)(!1, "unknown ProviderEvent", "event", e);
      }
      function eB() {
        return new Date().getTime();
      }
      let ej = { cacheTimeout: 250, pollingInterval: 4e3 };
      class eF {
        #x;
        #k;
        #R;
        #D;
        #U;
        #L;
        #M;
        #B;
        #j;
        #F;
        #$;
        #v;
        constructor(e, t) {
          if (((this.#v = Object.assign({}, ej, t || {})), "any" === e))
            (this.#L = !0), (this.#U = null);
          else if (e) {
            let t = eP.Z.from(e);
            (this.#L = !1),
              (this.#U = Promise.resolve(t)),
              setTimeout(() => {
                this.emit("network", t, null);
              }, 0);
          } else (this.#L = !1), (this.#U = null);
          (this.#B = -1),
            (this.#M = new Map()),
            (this.#x = new Map()),
            (this.#k = new Map()),
            (this.#R = null),
            (this.#D = !1),
            (this.#j = 1),
            (this.#F = new Map()),
            (this.#$ = !1);
        }
        get pollingInterval() {
          return this.#v.pollingInterval;
        }
        get provider() {
          return this;
        }
        get plugins() {
          return Array.from(this.#k.values());
        }
        attachPlugin(e) {
          if (this.#k.get(e.name))
            throw Error(`cannot replace existing plugin: ${e.name} `);
          return this.#k.set(e.name, e.connect(this)), this;
        }
        getPlugin(e) {
          return this.#k.get(e) || null;
        }
        get disableCcipRead() {
          return this.#$;
        }
        set disableCcipRead(e) {
          this.#$ = !!e;
        }
        async #H(e) {
          let t = this.#v.cacheTimeout;
          if (t < 0) return await this._perform(e);
          let r = eD(e.method, e),
            i = this.#M.get(r);
          return (
            i ||
              ((i = this._perform(e)),
              this.#M.set(r, i),
              setTimeout(() => {
                this.#M.get(r) === i && this.#M.delete(r);
              }, t)),
            await i
          );
        }
        async ccipReadFetch(e, t, r) {
          if (this.disableCcipRead || 0 === r.length || null == e.to)
            return null;
          let i = e.to.toLowerCase(),
            n = t.toLowerCase(),
            s = [];
          for (let t = 0; t < r.length; t++) {
            let a;
            let o = r[t],
              l = o.replace("{sender}", i).replace("{data}", n),
              c = new es.gd(l);
            -1 === o.indexOf("{data}") && (c.body = { data: n, sender: i }),
              this.emit("debug", {
                action: "sendCcipReadFetchRequest",
                request: c,
                index: t,
                urls: r,
              });
            let u = "unknown error";
            try {
              a = await c.send();
            } catch (e) {
              s.push(e.message),
                this.emit("debug", {
                  action: "receiveCcipReadFetchError",
                  request: c,
                  result: { error: e },
                });
              continue;
            }
            try {
              let e = a.bodyJson;
              if (e.data)
                return (
                  this.emit("debug", {
                    action: "receiveCcipReadFetchResult",
                    request: c,
                    result: e,
                  }),
                  e.data
                );
              e.message && (u = e.message),
                this.emit("debug", {
                  action: "receiveCcipReadFetchError",
                  request: c,
                  result: e,
                });
            } catch (e) {}
            (0, C.hu)(
              a.statusCode < 400 || a.statusCode >= 500,
              `response not found during CCIP fetch: ${u}`,
              "OFFCHAIN_FAULT",
              {
                reason: "404_MISSING_RESOURCE",
                transaction: e,
                info: { url: o, errorMessage: u },
              }
            ),
              s.push(u);
          }
          (0, C.hu)(
            !1,
            `error encountered during CCIP fetch: ${s
              .map((e) => JSON.stringify(e))
              .join(", ")}`,
            "OFFCHAIN_FAULT",
            {
              reason: "500_SERVER_ERROR",
              transaction: e,
              info: { urls: r, errorMessages: s },
            }
          );
        }
        _wrapBlock(e, t) {
          return new eO.gO(
            (function (e) {
              let t = eI(e);
              return (
                (t.transactions = e.transactions.map((e) =>
                  "string" == typeof e ? e : eT(e)
                )),
                t
              );
            })(e),
            this
          );
        }
        _wrapLog(e, t) {
          return new eO.Zb(e_(e), this);
        }
        _wrapTransactionReceipt(e, t) {
          return new eO.IX(eS(e), this);
        }
        _wrapTransactionResponse(e, t) {
          return new eO.Mw(eT(e), this);
        }
        _detectNetwork() {
          (0, C.hu)(
            !1,
            "sub-classes must implement this",
            "UNSUPPORTED_OPERATION",
            { operation: "_detectNetwork" }
          );
        }
        async _perform(e) {
          (0, C.hu)(
            !1,
            `unsupported method: ${e.method}`,
            "UNSUPPORTED_OPERATION",
            { operation: e.method, info: e }
          );
        }
        async getBlockNumber() {
          let e = (0, ea.Dx)(
            await this.#H({ method: "getBlockNumber" }),
            "%response"
          );
          return this.#B >= 0 && (this.#B = e), e;
        }
        _getAddress(e) {
          return (0, w.ru)(e, this);
        }
        _getBlockTag(e) {
          if (null == e) return "latest";
          switch (e) {
            case "earliest":
              return "0x0";
            case "finalized":
            case "latest":
            case "pending":
            case "safe":
              return e;
          }
          return (0, I.A7)(e)
            ? (0, I.A7)(e, 32)
              ? e
              : (0, ea.B4)(e)
            : ("bigint" == typeof e && (e = (0, ea.Dx)(e, "blockTag")),
              "number" == typeof e)
            ? e >= 0
              ? (0, ea.B4)(e)
              : this.#B >= 0
              ? (0, ea.B4)(this.#B + e)
              : this.getBlockNumber().then((t) => (0, ea.B4)(t + e))
            : void (0, C.en)(!1, "invalid blockTag", "blockTag", e);
        }
        _getFilter(e) {
          let t, r;
          let i = (e.topics || []).map((e) =>
              null == e
                ? null
                : Array.isArray(e)
                ? eL(e.map((e) => e.toLowerCase()))
                : e.toLowerCase()
            ),
            n = "blockHash" in e ? e.blockHash : void 0,
            s = (e, t, r) => {
              let s;
              switch (e.length) {
                case 0:
                  break;
                case 1:
                  s = e[0];
                  break;
                default:
                  e.sort(), (s = e);
              }
              if (n && (null != t || null != r)) throw Error("invalid filter");
              let a = {};
              return (
                s && (a.address = s),
                i.length && (a.topics = i),
                t && (a.fromBlock = t),
                r && (a.toBlock = r),
                n && (a.blockHash = n),
                a
              );
            },
            a = [];
          if (e.address) {
            if (Array.isArray(e.address))
              for (let t of e.address) a.push(this._getAddress(t));
            else a.push(this._getAddress(e.address));
          }
          return (
            "fromBlock" in e && (t = this._getBlockTag(e.fromBlock)),
            ("toBlock" in e && (r = this._getBlockTag(e.toBlock)),
            a.filter((e) => "string" != typeof e).length ||
              (null != t && "string" != typeof t) ||
              (null != r && "string" != typeof r))
              ? Promise.all([Promise.all(a), t, r]).then((e) =>
                  s(e[0], e[1], e[2])
                )
              : s(a, t, r)
          );
        }
        _getTransactionRequest(e) {
          let t = (0, eO.kK)(e),
            r = [];
          if (
            (["to", "from"].forEach((e) => {
              if (null == t[e]) return;
              let i = (0, w.ru)(t[e], this);
              eR(i)
                ? r.push(
                    (async function () {
                      t[e] = await i;
                    })()
                  )
                : (t[e] = i);
            }),
            null != t.blockTag)
          ) {
            let e = this._getBlockTag(t.blockTag);
            eR(e)
              ? r.push(
                  (async function () {
                    t.blockTag = await e;
                  })()
                )
              : (t.blockTag = e);
          }
          return r.length
            ? (async function () {
                return await Promise.all(r), t;
              })()
            : t;
        }
        async getNetwork() {
          if (null == this.#U) {
            let e = (async () => {
              try {
                let e = await this._detectNetwork();
                return this.emit("network", e, null), e;
              } catch (t) {
                throw (this.#U === e && (this.#U = null), t);
              }
            })();
            return (this.#U = e), (await e).clone();
          }
          let e = this.#U,
            [t, r] = await Promise.all([e, this._detectNetwork()]);
          return (
            t.chainId !== r.chainId &&
              (this.#L
                ? (this.emit("network", r, t),
                  this.#U === e && (this.#U = Promise.resolve(r)))
                : (0, C.hu)(
                    !1,
                    `network changed: ${t.chainId} => ${r.chainId} `,
                    "NETWORK_ERROR",
                    { event: "changed" }
                  )),
            t.clone()
          );
        }
        async getFeeData() {
          let e = await this.getNetwork(),
            t = async () => {
              let {
                  _block: t,
                  gasPrice: r,
                  priorityFee: i,
                } = await (0, en.m)({
                  _block: this.#z("latest", !1),
                  gasPrice: (async () => {
                    try {
                      let e = await this.#H({ method: "getGasPrice" });
                      return (0, ea.yT)(e, "%response");
                    } catch (e) {}
                    return null;
                  })(),
                  priorityFee: (async () => {
                    try {
                      let e = await this.#H({ method: "getPriorityFee" });
                      return (0, ea.yT)(e, "%response");
                    } catch (e) {}
                    return null;
                  })(),
                }),
                n = null,
                s = null,
                a = this._wrapBlock(t, e);
              return (
                a &&
                  a.baseFeePerGas &&
                  ((s = null != i ? i : BigInt("1000000000")),
                  (n = a.baseFeePerGas * ek + s)),
                new eO.jW(r, n, s)
              );
            },
            r = e.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
          if (r) {
            let e = new es.gd(r.url),
              i = await r.processFunc(t, this, e);
            return new eO.jW(
              i.gasPrice,
              i.maxFeePerGas,
              i.maxPriorityFeePerGas
            );
          }
          return await t();
        }
        async estimateGas(e) {
          let t = this._getTransactionRequest(e);
          return (
            eR(t) && (t = await t),
            (0, ea.yT)(
              await this.#H({ method: "estimateGas", transaction: t }),
              "%response"
            )
          );
        }
        async #q(e, t, r) {
          (0, C.hu)(
            r < 10,
            "CCIP read exceeded maximum redirections",
            "OFFCHAIN_FAULT",
            {
              reason: "TOO_MANY_REDIRECTS",
              transaction: Object.assign({}, e, {
                blockTag: t,
                enableCcipRead: !0,
              }),
            }
          );
          let i = (0, eO.kK)(e);
          try {
            return (0, I.Dv)(
              await this._perform({
                method: "call",
                transaction: i,
                blockTag: t,
              })
            );
          } catch (e) {
            if (
              !this.disableCcipRead &&
              (0, C.Hl)(e) &&
              e.data &&
              r >= 0 &&
              "latest" === t &&
              null != i.to &&
              "0x556f1830" === (0, I.QB)(e.data, 0, 4)
            ) {
              let n;
              let s = e.data,
                a = await (0, w.ru)(i.to, this);
              try {
                n = (function (e) {
                  let t = {
                    sender: "",
                    urls: [],
                    calldata: "",
                    selector: "",
                    extraData: "",
                    errorArgs: [],
                  };
                  (0, C.hu)(
                    (0, I.M5)(e) >= 160,
                    "insufficient OffchainLookup data",
                    "OFFCHAIN_FAULT",
                    { reason: "insufficient OffchainLookup data" }
                  );
                  let r = (0, I.QB)(e, 0, 32);
                  (0, C.hu)(
                    (0, I.QB)(r, 0, 12) === (0, I.QB)(eq, 0, 12),
                    "corrupt OffchainLookup sender",
                    "OFFCHAIN_FAULT",
                    { reason: "corrupt OffchainLookup sender" }
                  ),
                    (t.sender = (0, I.QB)(r, 12));
                  try {
                    let r = [],
                      i = (0, ea.Dx)((0, I.QB)(e, 32, 64)),
                      n = (0, ea.Dx)((0, I.QB)(e, i, i + 32)),
                      s = (0, I.QB)(e, i + 32);
                    for (let e = 0; e < n; e++) {
                      let t = (function (e, t) {
                        try {
                          let r = e$(e, t);
                          if (r) return (0, _.ZN)(r);
                        } catch (e) {}
                        return null;
                      })(s, 32 * e);
                      if (null == t) throw Error("abort");
                      r.push(t);
                    }
                    t.urls = r;
                  } catch (e) {
                    (0, C.hu)(
                      !1,
                      "corrupt OffchainLookup urls",
                      "OFFCHAIN_FAULT",
                      { reason: "corrupt OffchainLookup urls" }
                    );
                  }
                  try {
                    let r = e$(e, 64);
                    if (null == r) throw Error("abort");
                    t.calldata = r;
                  } catch (e) {
                    (0, C.hu)(
                      !1,
                      "corrupt OffchainLookup calldata",
                      "OFFCHAIN_FAULT",
                      { reason: "corrupt OffchainLookup calldata" }
                    );
                  }
                  (0, C.hu)(
                    (0, I.QB)(e, 100, 128) === (0, I.QB)(eq, 0, 28),
                    "corrupt OffchainLookup callbaackSelector",
                    "OFFCHAIN_FAULT",
                    { reason: "corrupt OffchainLookup callbaackSelector" }
                  ),
                    (t.selector = (0, I.QB)(e, 96, 100));
                  try {
                    let r = e$(e, 128);
                    if (null == r) throw Error("abort");
                    t.extraData = r;
                  } catch (e) {
                    (0, C.hu)(
                      !1,
                      "corrupt OffchainLookup extraData",
                      "OFFCHAIN_FAULT",
                      { reason: "corrupt OffchainLookup extraData" }
                    );
                  }
                  return (
                    (t.errorArgs = "sender,urls,calldata,selector,extraData"
                      .split(/,/)
                      .map((e) => t[e])),
                    t
                  );
                })((0, I.QB)(e.data, 4));
              } catch (e) {
                (0, C.hu)(!1, e.message, "OFFCHAIN_FAULT", {
                  reason: "BAD_DATA",
                  transaction: i,
                  info: { data: s },
                });
              }
              (0, C.hu)(
                n.sender.toLowerCase() === a.toLowerCase(),
                "CCIP Read sender mismatch",
                "CALL_EXCEPTION",
                {
                  action: "call",
                  data: s,
                  reason: "OffchainLookup",
                  transaction: i,
                  invocation: null,
                  revert: {
                    signature:
                      "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    name: "OffchainLookup",
                    args: n.errorArgs,
                  },
                }
              );
              let o = await this.ccipReadFetch(i, n.calldata, n.urls);
              (0, C.hu)(
                null != o,
                "CCIP Read failed to fetch data",
                "OFFCHAIN_FAULT",
                {
                  reason: "FETCH_FAILED",
                  transaction: i,
                  info: { data: e.data, errorArgs: n.errorArgs },
                }
              );
              let l = {
                to: a,
                data: (0, I.zo)([
                  n.selector,
                  (function (e) {
                    let t = [],
                      r = 0;
                    for (let i = 0; i < e.length; i++) t.push(ez), (r += 32);
                    for (let i = 0; i < e.length; i++) {
                      let n = (0, I.Pw)(e[i]);
                      (t[i] = eH(r)),
                        t.push(eH(n.length)),
                        t.push(
                          (function (e) {
                            if (e.length % 32 == 0) return e;
                            let t = new Uint8Array(
                              32 * Math.ceil(e.length / 32)
                            );
                            return t.set(e), t;
                          })(n)
                        ),
                        (r += 32 + 32 * Math.ceil(n.length / 32));
                    }
                    return (0, I.zo)(t);
                  })([o, n.extraData]),
                ]),
              };
              this.emit("debug", {
                action: "sendCcipReadCall",
                transaction: l,
              });
              try {
                let e = await this.#q(l, t, r + 1);
                return (
                  this.emit("debug", {
                    action: "receiveCcipReadCallResult",
                    transaction: Object.assign({}, l),
                    result: e,
                  }),
                  e
                );
              } catch (e) {
                throw (
                  (this.emit("debug", {
                    action: "receiveCcipReadCallError",
                    transaction: Object.assign({}, l),
                    error: e,
                  }),
                  e)
                );
              }
            }
            throw e;
          }
        }
        async #V(e) {
          let { value: t } = await (0, en.m)({
            network: this.getNetwork(),
            value: e,
          });
          return t;
        }
        async call(e) {
          let { tx: t, blockTag: r } = await (0, en.m)({
            tx: this._getTransactionRequest(e),
            blockTag: this._getBlockTag(e.blockTag),
          });
          return await this.#V(this.#q(t, r, e.enableCcipRead ? 0 : -1));
        }
        async #G(e, t, r) {
          let i = this._getAddress(t),
            n = this._getBlockTag(r);
          return (
            ("string" != typeof i || "string" != typeof n) &&
              ([i, n] = await Promise.all([i, n])),
            await this.#V(
              this.#H(Object.assign(e, { address: i, blockTag: n }))
            )
          );
        }
        async getBalance(e, t) {
          return (0, ea.yT)(
            await this.#G({ method: "getBalance" }, e, t),
            "%response"
          );
        }
        async getTransactionCount(e, t) {
          return (0, ea.Dx)(
            await this.#G({ method: "getTransactionCount" }, e, t),
            "%response"
          );
        }
        async getCode(e, t) {
          return (0, I.Dv)(await this.#G({ method: "getCode" }, e, t));
        }
        async getStorage(e, t, r) {
          let i = (0, ea.yT)(t, "position");
          return (0, I.Dv)(
            await this.#G({ method: "getStorage", position: i }, e, r)
          );
        }
        async broadcastTransaction(e) {
          let {
              blockNumber: t,
              hash: r,
              network: i,
            } = await (0, en.m)({
              blockNumber: this.getBlockNumber(),
              hash: this._perform({
                method: "broadcastTransaction",
                signedTransaction: e,
              }),
              network: this.getNetwork(),
            }),
            n = ei.Y.from(e);
          if (n.hash !== r)
            throw Error("@TODO: the returned hash did not match");
          return this._wrapTransactionResponse(n, i).replaceableTransaction(t);
        }
        async #z(e, t) {
          if ((0, I.A7)(e, 32))
            return await this.#H({
              method: "getBlock",
              blockHash: e,
              includeTransactions: t,
            });
          let r = this._getBlockTag(e);
          return (
            "string" != typeof r && (r = await r),
            await this.#H({
              method: "getBlock",
              blockTag: r,
              includeTransactions: t,
            })
          );
        }
        async getBlock(e, t) {
          let { network: r, params: i } = await (0, en.m)({
            network: this.getNetwork(),
            params: this.#z(e, !!t),
          });
          return null == i ? null : this._wrapBlock(i, r);
        }
        async getTransaction(e) {
          let { network: t, params: r } = await (0, en.m)({
            network: this.getNetwork(),
            params: this.#H({ method: "getTransaction", hash: e }),
          });
          return null == r ? null : this._wrapTransactionResponse(r, t);
        }
        async getTransactionReceipt(e) {
          let { network: t, params: r } = await (0, en.m)({
            network: this.getNetwork(),
            params: this.#H({ method: "getTransactionReceipt", hash: e }),
          });
          if (null == r) return null;
          if (null == r.gasPrice && null == r.effectiveGasPrice) {
            let t = await this.#H({ method: "getTransaction", hash: e });
            if (null == t)
              throw Error(
                "report this; could not find tx or effectiveGasPrice"
              );
            r.effectiveGasPrice = t.gasPrice;
          }
          return this._wrapTransactionReceipt(r, t);
        }
        async getTransactionResult(e) {
          let { result: t } = await (0, en.m)({
            network: this.getNetwork(),
            result: this.#H({ method: "getTransactionResult", hash: e }),
          });
          return null == t ? null : (0, I.Dv)(t);
        }
        async getLogs(e) {
          let t = this._getFilter(e);
          eR(t) && (t = await t);
          let { network: r, params: i } = await (0, en.m)({
            network: this.getNetwork(),
            params: this.#H({ method: "getLogs", filter: t }),
          });
          return i.map((e) => this._wrapLog(e, r));
        }
        _getProvider(e) {
          (0, C.hu)(
            !1,
            "provider cannot connect to target network",
            "UNSUPPORTED_OPERATION",
            { operation: "_getProvider()" }
          );
        }
        async getResolver(e) {
          return await ef.fromName(this, e);
        }
        async getAvatar(e) {
          let t = await this.getResolver(e);
          return t ? await t.getAvatar() : null;
        }
        async resolveName(e) {
          let t = await this.getResolver(e);
          return t ? await t.getAddress() : null;
        }
        async lookupAddress(e) {
          let t = er(
            (e = (0, b.K)(e)).substring(2).toLowerCase() + ".addr.reverse"
          );
          try {
            let r = await ef.getEnsAddress(this),
              i = new E.CH(
                r,
                ["function resolver(bytes32) view returns (address)"],
                this
              ),
              n = await i.resolver(t);
            if (null == n || n === v.N) return null;
            let s = new E.CH(
                n,
                ["function name(bytes32) view returns (string)"],
                this
              ),
              a = await s.name(t);
            if ((await this.resolveName(a)) !== e) return null;
            return a;
          } catch (e) {
            if (
              ((0, C.VZ)(e, "BAD_DATA") && "0x" === e.value) ||
              (0, C.VZ)(e, "CALL_EXCEPTION")
            )
              return null;
            throw e;
          }
          return null;
        }
        async waitForTransaction(e, t, r) {
          let i = null != t ? t : 1;
          return 0 === i
            ? this.getTransactionReceipt(e)
            : new Promise(async (t, n) => {
                let s = null,
                  a = async (r) => {
                    try {
                      let n = await this.getTransactionReceipt(e);
                      if (null != n && r - n.blockNumber + 1 >= i) {
                        t(n), s && (clearTimeout(s), (s = null));
                        return;
                      }
                    } catch (e) {
                      console.log("EEE", e);
                    }
                    this.once("block", a);
                  };
                null != r &&
                  (s = setTimeout(() => {
                    null != s &&
                      ((s = null),
                      this.off("block", a),
                      n(
                        (0, C.wf)("timeout", "TIMEOUT", { reason: "timeout" })
                      ));
                  }, r)),
                  a(await this.getBlockNumber());
              });
        }
        async waitForBlock(e) {
          (0, C.hu)(!1, "not implemented yet", "NOT_IMPLEMENTED", {
            operation: "waitForBlock",
          });
        }
        _clearTimeout(e) {
          let t = this.#F.get(e);
          t && (t.timer && clearTimeout(t.timer), this.#F.delete(e));
        }
        _setTimeout(e, t) {
          null == t && (t = 0);
          let r = this.#j++,
            i = () => {
              this.#F.delete(r), e();
            };
          if (this.paused) this.#F.set(r, { timer: null, func: i, time: t });
          else {
            let e = setTimeout(i, t);
            this.#F.set(r, { timer: e, func: i, time: eB() });
          }
          return r;
        }
        _forEachSubscriber(e) {
          for (let t of this.#x.values()) e(t.subscriber);
        }
        _getSubscriber(e) {
          switch (e.type) {
            case "debug":
            case "error":
            case "network":
              return new eU(e.type);
            case "block": {
              let e = new ex.tR(this);
              return (e.pollingInterval = this.pollingInterval), e;
            }
            case "safe":
            case "finalized":
              return new ex.ub(this, e.type);
            case "event":
              return new ex.H9(this, e.filter);
            case "transaction":
              return new ex.yq(this, e.hash);
            case "orphan":
              return new ex.wF(this, e.filter);
          }
          throw Error(`unsupported event: ${e.type}`);
        }
        _recoverSubscriber(e, t) {
          for (let r of this.#x.values())
            if (r.subscriber === e) {
              r.started && r.subscriber.stop(),
                (r.subscriber = t),
                r.started && t.start(),
                null != this.#R && t.pause(this.#R);
              break;
            }
        }
        async #W(e, t) {
          let r = await eM(e, this);
          return (
            "event" === r.type &&
              t &&
              t.length > 0 &&
              !0 === t[0].removed &&
              (r = await eM({ orphan: "drop-log", log: t[0] }, this)),
            this.#x.get(r.tag) || null
          );
        }
        async #K(e) {
          let t = await eM(e, this),
            r = t.tag,
            i = this.#x.get(r);
          return (
            !i &&
              ((i = {
                subscriber: this._getSubscriber(t),
                tag: r,
                addressableMap: new WeakMap(),
                nameMap: new Map(),
                started: !1,
                listeners: [],
              }),
              this.#x.set(r, i)),
            i
          );
        }
        async on(e, t) {
          let r = await this.#K(e);
          return (
            r.listeners.push({ listener: t, once: !1 }),
            r.started ||
              (r.subscriber.start(),
              (r.started = !0),
              null != this.#R && r.subscriber.pause(this.#R)),
            this
          );
        }
        async once(e, t) {
          let r = await this.#K(e);
          return (
            r.listeners.push({ listener: t, once: !0 }),
            r.started ||
              (r.subscriber.start(),
              (r.started = !0),
              null != this.#R && r.subscriber.pause(this.#R)),
            this
          );
        }
        async emit(e, ...t) {
          let r = await this.#W(e, t);
          if (!r || 0 === r.listeners.length) return !1;
          let i = r.listeners.length;
          return (
            (r.listeners = r.listeners.filter(({ listener: r, once: i }) => {
              let n = new eo.Z(this, i ? null : r, e);
              try {
                r.call(this, ...t, n);
              } catch (e) {}
              return !i;
            })),
            0 === r.listeners.length &&
              (r.started && r.subscriber.stop(), this.#x.delete(r.tag)),
            i > 0
          );
        }
        async listenerCount(e) {
          if (e) {
            let t = await this.#W(e);
            return t ? t.listeners.length : 0;
          }
          let t = 0;
          for (let { listeners: e } of this.#x.values()) t += e.length;
          return t;
        }
        async listeners(e) {
          if (e) {
            let t = await this.#W(e);
            return t ? t.listeners.map(({ listener: e }) => e) : [];
          }
          let t = [];
          for (let { listeners: e } of this.#x.values())
            t = t.concat(e.map(({ listener: e }) => e));
          return t;
        }
        async off(e, t) {
          let r = await this.#W(e);
          if (!r) return this;
          if (t) {
            let e = r.listeners.map(({ listener: e }) => e).indexOf(t);
            e >= 0 && r.listeners.splice(e, 1);
          }
          return (
            (t && 0 !== r.listeners.length) ||
              (r.started && r.subscriber.stop(), this.#x.delete(r.tag)),
            this
          );
        }
        async removeAllListeners(e) {
          if (e) {
            let { tag: t, started: r, subscriber: i } = await this.#K(e);
            r && i.stop(), this.#x.delete(t);
          } else
            for (let [e, { started: t, subscriber: r }] of this.#x)
              t && r.stop(), this.#x.delete(e);
          return this;
        }
        async addListener(e, t) {
          return await this.on(e, t);
        }
        async removeListener(e, t) {
          return this.off(e, t);
        }
        get destroyed() {
          return this.#D;
        }
        destroy() {
          for (let e of (this.removeAllListeners(), this.#F.keys()))
            this._clearTimeout(e);
          this.#D = !0;
        }
        get paused() {
          return null != this.#R;
        }
        set paused(e) {
          !!e !== this.paused && (this.paused ? this.resume() : this.pause(!1));
        }
        pause(e) {
          if (((this.#B = -1), null != this.#R)) {
            if (!!e == this.#R) return;
            (0, C.hu)(
              !1,
              "cannot change pause type; resume first",
              "UNSUPPORTED_OPERATION",
              { operation: "pause" }
            );
          }
          for (let t of (this._forEachSubscriber((t) => t.pause(e)),
          (this.#R = !!e),
          this.#F.values()))
            t.timer && clearTimeout(t.timer), (t.time = eB() - t.time);
        }
        resume() {
          if (null != this.#R)
            for (let e of (this._forEachSubscriber((e) => e.resume()),
            (this.#R = null),
            this.#F.values())) {
              let t = e.time;
              t < 0 && (t = 0), (e.time = eB()), setTimeout(e.func, t);
            }
        }
      }
      function e$(e, t) {
        if ("0x" === e) return null;
        try {
          let r = (0, ea.Dx)((0, I.QB)(e, t, t + 32)),
            i = (0, ea.Dx)((0, I.QB)(e, r, r + 32));
          return (0, I.QB)(e, r + 32, r + 32 + i);
        } catch (e) {}
        return null;
      }
      function eH(e) {
        let t = (0, ea.ot)(e);
        if (t.length > 32) throw Error("internal; should not happen");
        let r = new Uint8Array(32);
        return r.set(t, 32 - t.length), r;
      }
      let ez = new Uint8Array([]),
        eq =
          "0x0000000000000000000000000000000000000000000000000000000000000000";
    },
    86804: function (e, t, r) {
      "use strict";
      r.d(t, {
        Z: function () {
          return d;
        },
      });
      var i = r(22086),
        n = r(45474),
        s = r(35157),
        a = r(69781);
      class o {
        name;
        constructor(e) {
          (0, a.h)(this, { name: e });
        }
        clone() {
          return new o(this.name);
        }
      }
      class l extends o {
        effectiveBlock;
        txBase;
        txCreate;
        txDataZero;
        txDataNonzero;
        txAccessListStorageKey;
        txAccessListAddress;
        constructor(e, t) {
          null == e && (e = 0),
            super(`org.ethers.network.plugins.GasCost#${e || 0}`);
          let r = { effectiveBlock: e };
          function i(e, i) {
            let n = (t || {})[e];
            null == n && (n = i),
              (0, s.en)(
                "number" == typeof n,
                `invalud value for ${e}`,
                "costs",
                t
              ),
              (r[e] = n);
          }
          i("txBase", 21e3),
            i("txCreate", 32e3),
            i("txDataZero", 4),
            i("txDataNonzero", 16),
            i("txAccessListStorageKey", 1900),
            i("txAccessListAddress", 2400),
            (0, a.h)(this, r);
        }
        clone() {
          return new l(this.effectiveBlock, this);
        }
      }
      class c extends o {
        address;
        targetNetwork;
        constructor(e, t) {
          super("org.ethers.plugins.network.Ens"),
            (0, a.h)(this, {
              address: e || "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
              targetNetwork: null == t ? 1 : t,
            });
        }
        clone() {
          return new c(this.address, this.targetNetwork);
        }
      }
      class u extends o {
        #Z;
        #J;
        get url() {
          return this.#Z;
        }
        get processFunc() {
          return this.#J;
        }
        constructor(e, t) {
          super("org.ethers.plugins.network.FetchUrlFeeDataPlugin"),
            (this.#Z = e),
            (this.#J = t);
        }
        clone() {
          return this;
        }
      }
      let h = new Map();
      class d {
        #Q;
        #Y;
        #k;
        constructor(e, t) {
          (this.#Q = e), (this.#Y = (0, n.yT)(t)), (this.#k = new Map());
        }
        toJSON() {
          return { name: this.name, chainId: String(this.chainId) };
        }
        get name() {
          return this.#Q;
        }
        set name(e) {
          this.#Q = e;
        }
        get chainId() {
          return this.#Y;
        }
        set chainId(e) {
          this.#Y = (0, n.yT)(e, "chainId");
        }
        matches(e) {
          if (null == e) return !1;
          if ("string" == typeof e) {
            try {
              return this.chainId === (0, n.yT)(e);
            } catch (e) {}
            return this.name === e;
          }
          if ("number" == typeof e || "bigint" == typeof e) {
            try {
              return this.chainId === (0, n.yT)(e);
            } catch (e) {}
            return !1;
          }
          if ("object" == typeof e) {
            if (null != e.chainId) {
              try {
                return this.chainId === (0, n.yT)(e.chainId);
              } catch (e) {}
              return !1;
            }
            if (null != e.name) return this.name === e.name;
          }
          return !1;
        }
        get plugins() {
          return Array.from(this.#k.values());
        }
        attachPlugin(e) {
          if (this.#k.get(e.name))
            throw Error(`cannot replace existing plugin: ${e.name} `);
          return this.#k.set(e.name, e.clone()), this;
        }
        getPlugin(e) {
          return this.#k.get(e) || null;
        }
        getPlugins(e) {
          return this.plugins.filter((t) => t.name.split("#")[0] === e);
        }
        clone() {
          let e = new d(this.name, this.chainId);
          return (
            this.plugins.forEach((t) => {
              e.attachPlugin(t.clone());
            }),
            e
          );
        }
        computeIntrinsicGas(e) {
          let t =
              this.getPlugin("org.ethers.plugins.network.GasCost") || new l(),
            r = t.txBase;
          if ((null == e.to && (r += t.txCreate), e.data))
            for (let i = 2; i < e.data.length; i += 2)
              "00" === e.data.substring(i, i + 2)
                ? (r += t.txDataZero)
                : (r += t.txDataNonzero);
          if (e.accessList) {
            let n = (0, i.z)(e.accessList);
            for (let e in n)
              r +=
                t.txAccessListAddress +
                t.txAccessListStorageKey * n[e].storageKeys.length;
          }
          return r;
        }
        static from(e) {
          if (
            ((function () {
              g ||
                ((g = !0),
                e("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }),
                e("ropsten", 3, { ensNetwork: 3 }),
                e("rinkeby", 4, { ensNetwork: 4 }),
                e("goerli", 5, { ensNetwork: 5 }),
                e("kovan", 42, { ensNetwork: 42 }),
                e("sepolia", 11155111, { ensNetwork: 11155111 }),
                e("holesky", 17e3, { ensNetwork: 17e3 }),
                e("classic", 61, {}),
                e("classicKotti", 6, {}),
                e("arbitrum", 42161, { ensNetwork: 1 }),
                e("arbitrum-goerli", 421613, {}),
                e("arbitrum-sepolia", 421614, {}),
                e("base", 8453, { ensNetwork: 1 }),
                e("base-goerli", 84531, {}),
                e("base-sepolia", 84532, {}),
                e("bnb", 56, { ensNetwork: 1 }),
                e("bnbt", 97, {}),
                e("linea", 59144, { ensNetwork: 1 }),
                e("linea-goerli", 59140, {}),
                e("linea-sepolia", 59141, {}),
                e("matic", 137, {
                  ensNetwork: 1,
                  plugins: [f("https://gasstation.polygon.technology/v2")],
                }),
                e("matic-amoy", 80002, {}),
                e("matic-mumbai", 80001, {
                  altNames: ["maticMumbai", "maticmum"],
                  plugins: [
                    f("https://gasstation-testnet.polygon.technology/v2"),
                  ],
                }),
                e("optimism", 10, { ensNetwork: 1, plugins: [] }),
                e("optimism-goerli", 420, {}),
                e("optimism-sepolia", 11155420, {}),
                e("xdai", 100, { ensNetwork: 1 }));
              function e(e, t, r) {
                let i = function () {
                  let i = new d(e, t);
                  return (
                    null != r.ensNetwork &&
                      i.attachPlugin(new c(null, r.ensNetwork)),
                    i.attachPlugin(new l()),
                    (r.plugins || []).forEach((e) => {
                      i.attachPlugin(e);
                    }),
                    i
                  );
                };
                d.register(e, i),
                  d.register(t, i),
                  r.altNames &&
                    r.altNames.forEach((e) => {
                      d.register(e, i);
                    });
              }
            })(),
            null == e)
          )
            return d.from("mainnet");
          if (
            ("number" == typeof e && (e = BigInt(e)),
            "string" == typeof e || "bigint" == typeof e)
          ) {
            let t = h.get(e);
            if (t) return t();
            if ("bigint" == typeof e) return new d("unknown", e);
            (0, s.en)(!1, "unknown network", "network", e);
          }
          if ("function" == typeof e.clone) return e.clone();
          if ("object" == typeof e) {
            (0, s.en)(
              "string" == typeof e.name && "number" == typeof e.chainId,
              "invalid network object name or chainId",
              "network",
              e
            );
            let t = new d(e.name, e.chainId);
            return (
              (e.ensAddress || null != e.ensNetwork) &&
                t.attachPlugin(new c(e.ensAddress, e.ensNetwork)),
              t
            );
          }
          (0, s.en)(!1, "invalid network", "network", e);
        }
        static register(e, t) {
          "number" == typeof e && (e = BigInt(e));
          let r = h.get(e);
          r &&
            (0, s.en)(
              !1,
              `conflicting network for ${JSON.stringify(r.name)}`,
              "nameOrChainId",
              e
            ),
            h.set(e, t);
        }
      }
      function p(e, t) {
        let r = String(e);
        if (!r.match(/^[0-9.]+$/)) throw Error(`invalid gwei value: ${e}`);
        let i = r.split(".");
        if ((1 === i.length && i.push(""), 2 !== i.length))
          throw Error(`invalid gwei value: ${e}`);
        for (; i[1].length < t; ) i[1] += "0";
        if (i[1].length > 9) {
          let e = BigInt(i[1].substring(0, 9));
          !i[1].substring(9).match(/^0+$/) && e++, (i[1] = e.toString());
        }
        return BigInt(i[0] + i[1]);
      }
      function f(e) {
        return new u(e, async (e, t, r) => {
          let i;
          r.setHeader("User-Agent", "ethers");
          try {
            let [t, n] = await Promise.all([r.send(), e()]),
              s = (i = t).bodyJson.standard;
            return {
              gasPrice: n.gasPrice,
              maxFeePerGas: p(s.maxFee, 9),
              maxPriorityFeePerGas: p(s.maxPriorityFee, 9),
            };
          } catch (e) {
            (0, s.hu)(
              !1,
              `error encountered with polygon gas station (${JSON.stringify(
                r.url
              )})`,
              "SERVER_ERROR",
              { request: r, response: i, error: e }
            );
          }
        });
      }
      let g = !1;
    },
    69146: function (e, t, r) {
      "use strict";
      r.d(t, {
        Q: function () {
          return s;
        },
      });
      var i = r(35157),
        n = r(73507);
      class s extends n.JU {
        #X;
        constructor(e, t, r) {
          let n = Object.assign({}, null != r ? r : {}, { batchMaxCount: 1 });
          (0, i.en)(e && e.request, "invalid EIP-1193 provider", "ethereum", e),
            super(t, n),
            (this.#X = async (t, r) => {
              let i = { method: t, params: r };
              this.emit("debug", { action: "sendEip1193Request", payload: i });
              try {
                let t = await e.request(i);
                return (
                  this.emit("debug", {
                    action: "receiveEip1193Result",
                    result: t,
                  }),
                  t
                );
              } catch (t) {
                let e = Error(t.message);
                throw (
                  ((e.code = t.code),
                  (e.data = t.data),
                  (e.payload = i),
                  this.emit("debug", {
                    action: "receiveEip1193Error",
                    error: e,
                  }),
                  e)
                );
              }
            });
        }
        async send(e, t) {
          return await this._start(), await super.send(e, t);
        }
        async _send(e) {
          (0, i.en)(
            !Array.isArray(e),
            "EIP-1193 does not support batch request",
            "payload",
            e
          );
          try {
            let t = await this.#X(e.method, e.params || []);
            return [{ id: e.id, result: t }];
          } catch (t) {
            return [
              {
                id: e.id,
                error: { code: t.code, data: t.data, message: t.message },
              },
            ];
          }
        }
        getRpcError(e, t) {
          switch ((t = JSON.parse(JSON.stringify(t))).error.code || -1) {
            case 4001:
              t.error.message = `ethers-user-denied: ${t.error.message}`;
              break;
            case 4200:
              t.error.message = `ethers-unsupported: ${t.error.message}`;
          }
          return super.getRpcError(e, t);
        }
        async hasSigner(e) {
          null == e && (e = 0);
          let t = await this.send("eth_accounts", []);
          return "number" == typeof e
            ? t.length > e
            : ((e = e.toLowerCase()),
              0 !== t.filter((t) => t.toLowerCase() === e).length);
        }
        async getSigner(e) {
          if ((null == e && (e = 0), !(await this.hasSigner(e))))
            try {
              await this.#X("eth_requestAccounts", []);
            } catch (t) {
              let e = t.payload;
              throw this.getRpcError(e, { id: e.id, error: t });
            }
          return await super.getSigner(e);
        }
      }
    },
    73507: function (e, t, r) {
      "use strict";
      r.d(t, {
        JU: function () {
          return K;
        },
        vH: function () {
          return W;
        },
        r6: function () {
          return Z;
        },
        C1: function () {
          return G;
        },
      });
      var i = r(1091),
        n = r(70587),
        s = r(3876),
        a = r(19066),
        o = r(59369),
        l = r(45474),
        c = r(35157),
        u = r(69781),
        h = r(79146);
      let d = new Uint8Array(32);
      d.fill(0);
      let p = BigInt(-1),
        f = BigInt(0),
        g = BigInt(1),
        m = BigInt(
          "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        ),
        y = (0, l.m9)(g, 32),
        w = (0, l.m9)(f, 32),
        b = {
          name: "string",
          version: "string",
          chainId: "uint256",
          verifyingContract: "address",
          salt: "bytes32",
        },
        v = ["name", "version", "chainId", "verifyingContract", "salt"];
      function E(e) {
        return function (t) {
          return (
            (0, c.en)(
              "string" == typeof t,
              `invalid domain value for ${JSON.stringify(e)}`,
              `domain.${e}`,
              t
            ),
            t
          );
        };
      }
      let A = {
        name: E("name"),
        version: E("version"),
        chainId: function (e) {
          let t = (0, l.yT)(e, "domain.chainId");
          return ((0, c.en)(t >= 0, "invalid chain ID", "domain.chainId", e),
          Number.isSafeInteger(t))
            ? Number(t)
            : (0, l.B4)(t);
        },
        verifyingContract: function (e) {
          try {
            return (0, n.K)(e).toLowerCase();
          } catch (e) {}
          (0, c.en)(
            !1,
            'invalid domain value "verifyingContract"',
            "domain.verifyingContract",
            e
          );
        },
        salt: function (e) {
          let t = (0, o.Pw)(e, "domain.salt");
          return (
            (0, c.en)(
              32 === t.length,
              'invalid domain value "salt"',
              "domain.salt",
              e
            ),
            (0, o.Dv)(t)
          );
        },
      };
      function C(e) {
        {
          let t = e.match(/^(u?)int(\d+)$/);
          if (t) {
            let r = "" === t[1],
              i = parseInt(t[2]);
            (0, c.en)(
              i % 8 == 0 && 0 !== i && i <= 256 && t[2] === String(i),
              "invalid numeric width",
              "type",
              e
            );
            let n = (0, l.sS)(m, r ? i - 1 : i),
              s = r ? (n + g) * p : f;
            return function (t) {
              let i = (0, l.yT)(t, "value");
              return (
                (0, c.en)(
                  i >= s && i <= n,
                  `value out-of-bounds for ${e}`,
                  "value",
                  i
                ),
                (0, l.m9)(r ? (0, l.$j)(i, 256) : i, 32)
              );
            };
          }
        }
        {
          let t = e.match(/^bytes(\d+)$/);
          if (t) {
            let r = parseInt(t[1]);
            return (
              (0, c.en)(
                0 !== r && r <= 32 && t[1] === String(r),
                "invalid bytes width",
                "type",
                e
              ),
              function (t) {
                let i = (0, o.Pw)(t);
                return (
                  (0, c.en)(
                    i.length === r,
                    `invalid length for ${e}`,
                    "value",
                    t
                  ),
                  (function (e) {
                    let t = (0, o.Pw)(e),
                      r = t.length % 32;
                    return r ? (0, o.zo)([t, d.slice(r)]) : (0, o.Dv)(t);
                  })(t)
                );
              }
            );
          }
        }
        switch (e) {
          case "address":
            return function (e) {
              return (0, o.U3)((0, n.K)(e), 32);
            };
          case "bool":
            return function (e) {
              return e ? y : w;
            };
          case "bytes":
            return function (e) {
              return (0, a.w)(e);
            };
          case "string":
            return function (e) {
              return (0, h.id)(e);
            };
        }
        return null;
      }
      function _(e, t) {
        return `${e}(${t
          .map(({ name: e, type: t }) => t + " " + e)
          .join(",")})`;
      }
      function I(e) {
        let t = e.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
        return t
          ? {
              base: t[1],
              index: t[2] + t[4],
              array: {
                base: t[1],
                prefix: t[1] + t[2],
                count: t[5] ? parseInt(t[5]) : -1,
              },
            }
          : { base: e };
      }
      class N {
        primaryType;
        #ee;
        get types() {
          return JSON.parse(this.#ee);
        }
        #et;
        #er;
        constructor(e) {
          (this.#et = new Map()), (this.#er = new Map());
          let t = new Map(),
            r = new Map(),
            i = new Map(),
            n = {};
          for (let s in (Object.keys(e).forEach((s) => {
            (n[s] = e[s].map(({ name: t, type: r }) => {
              let { base: i, index: n } = I(r);
              return (
                "int" !== i || e.int || (i = "int256"),
                "uint" !== i || e.uint || (i = "uint256"),
                { name: t, type: i + (n || "") }
              );
            })),
              t.set(s, new Set()),
              r.set(s, []),
              i.set(s, new Set());
          }),
          (this.#ee = JSON.stringify(n)),
          n)) {
            let i = new Set();
            for (let a of n[s]) {
              (0, c.en)(
                !i.has(a.name),
                `duplicate variable name ${JSON.stringify(
                  a.name
                )} in ${JSON.stringify(s)}`,
                "types",
                e
              ),
                i.add(a.name);
              let n = I(a.type).base;
              (0, c.en)(
                n !== s,
                `circular type reference to ${JSON.stringify(n)}`,
                "types",
                e
              ),
                C(n) ||
                  ((0, c.en)(
                    r.has(n),
                    `unknown type ${JSON.stringify(n)}`,
                    "types",
                    e
                  ),
                  r.get(n).push(s),
                  t.get(s).add(n));
            }
          }
          let s = Array.from(r.keys()).filter((e) => 0 === r.get(e).length);
          for (let [a, o] of ((0, c.en)(
            0 !== s.length,
            "missing primary type",
            "types",
            e
          ),
          (0, c.en)(
            1 === s.length,
            `ambiguous primary types or unused types: ${s
              .map((e) => JSON.stringify(e))
              .join(", ")}`,
            "types",
            e
          ),
          (0, u.h)(this, { primaryType: s[0] }),
          !(function n(s, a) {
            for (let o of ((0, c.en)(
              !a.has(s),
              `circular type reference to ${JSON.stringify(s)}`,
              "types",
              e
            ),
            a.add(s),
            t.get(s)))
              if (r.has(o)) for (let e of (n(o, a), a)) i.get(e).add(o);
            a.delete(s);
          })(this.primaryType, new Set()),
          i)) {
            let e = Array.from(o);
            e.sort(),
              this.#et.set(a, _(a, n[a]) + e.map((e) => _(e, n[e])).join(""));
          }
        }
        getEncoder(e) {
          let t = this.#er.get(e);
          return t || ((t = this.#ei(e)), this.#er.set(e, t)), t;
        }
        #ei(e) {
          {
            let t = C(e);
            if (t) return t;
          }
          let t = I(e).array;
          if (t) {
            let e = t.prefix,
              r = this.getEncoder(e);
            return (i) => {
              (0, c.en)(
                -1 === t.count || t.count === i.length,
                `array length mismatch; expected length ${t.count}`,
                "value",
                i
              );
              let n = i.map(r);
              return (
                this.#et.has(e) && (n = n.map(a.w)), (0, a.w)((0, o.zo)(n))
              );
            };
          }
          let r = this.types[e];
          if (r) {
            let t = (0, h.id)(this.#et.get(e));
            return (e) => {
              let i = r.map(({ name: t, type: r }) => {
                let i = this.getEncoder(r)(e[t]);
                return this.#et.has(r) ? (0, a.w)(i) : i;
              });
              return i.unshift(t), (0, o.zo)(i);
            };
          }
          (0, c.en)(!1, `unknown type: ${e}`, "type", e);
        }
        encodeType(e) {
          let t = this.#et.get(e);
          return (
            (0, c.en)(t, `unknown type: ${JSON.stringify(e)}`, "name", e), t
          );
        }
        encodeData(e, t) {
          return this.getEncoder(e)(t);
        }
        hashStruct(e, t) {
          return (0, a.w)(this.encodeData(e, t));
        }
        encode(e) {
          return this.encodeData(this.primaryType, e);
        }
        hash(e) {
          return this.hashStruct(this.primaryType, e);
        }
        _visit(e, t, r) {
          if (C(e)) return r(e, t);
          let i = I(e).array;
          if (i)
            return (
              (0, c.en)(
                -1 === i.count || i.count === t.length,
                `array length mismatch; expected length ${i.count}`,
                "value",
                t
              ),
              t.map((e) => this._visit(i.prefix, e, r))
            );
          let n = this.types[e];
          if (n)
            return n.reduce(
              (e, { name: i, type: n }) => (
                (e[i] = this._visit(n, t[i], r)), e
              ),
              {}
            );
          (0, c.en)(!1, `unknown type: ${e}`, "type", e);
        }
        visit(e, t) {
          return this._visit(this.primaryType, e, t);
        }
        static from(e) {
          return new N(e);
        }
        static getPrimaryType(e) {
          return N.from(e).primaryType;
        }
        static hashStruct(e, t, r) {
          return N.from(t).hashStruct(e, r);
        }
        static hashDomain(e) {
          let t = [];
          for (let r in e) {
            if (null == e[r]) continue;
            let i = b[r];
            (0, c.en)(
              i,
              `invalid typed-data domain key: ${JSON.stringify(r)}`,
              "domain",
              e
            ),
              t.push({ name: r, type: i });
          }
          return (
            t.sort((e, t) => v.indexOf(e.name) - v.indexOf(t.name)),
            N.hashStruct("EIP712Domain", { EIP712Domain: t }, e)
          );
        }
        static encode(e, t, r) {
          return (0, o.zo)(["0x1901", N.hashDomain(e), N.from(t).hash(r)]);
        }
        static hash(e, t, r) {
          return (0, a.w)(N.encode(e, t, r));
        }
        static async resolveNames(e, t, r, i) {
          for (let t in (e = Object.assign({}, e))) null == e[t] && delete e[t];
          let n = {};
          e.verifyingContract &&
            !(0, o.A7)(e.verifyingContract, 20) &&
            (n[e.verifyingContract] = "0x");
          let s = N.from(t);
          for (let e in (s.visit(
            r,
            (e, t) => ("address" !== e || (0, o.A7)(t, 20) || (n[t] = "0x"), t)
          ),
          n))
            n[e] = await i(e);
          return (
            e.verifyingContract &&
              n[e.verifyingContract] &&
              (e.verifyingContract = n[e.verifyingContract]),
            (r = s.visit(r, (e, t) => ("address" === e && n[t] ? n[t] : t))),
            { domain: e, value: r }
          );
        }
        static getPayload(e, t, r) {
          N.hashDomain(e);
          let i = {},
            n = [];
          v.forEach((t) => {
            let r = e[t];
            null != r && ((i[t] = A[t](r)), n.push({ name: t, type: b[t] }));
          });
          let s = N.from(t),
            a = Object.assign({}, (t = s.types));
          return (
            (0, c.en)(
              null == a.EIP712Domain,
              "types must not contain EIP712Domain type",
              "types.EIP712Domain",
              t
            ),
            (a.EIP712Domain = n),
            s.encode(r),
            {
              types: a,
              domain: i,
              primaryType: s.primaryType,
              message: s.visit(r, (e, t) => {
                if (e.match(/^bytes(\d*)/)) return (0, o.Dv)((0, o.Pw)(t));
                if (e.match(/^u?int/)) return (0, l.yT)(t).toString();
                switch (e) {
                  case "address":
                    return t.toLowerCase();
                  case "bool":
                    return !!t;
                  case "string":
                    return (
                      (0, c.en)(
                        "string" == typeof t,
                        "invalid string",
                        "value",
                        t
                      ),
                      t
                    );
                }
                (0, c.en)(!1, "unsupported type", "type", e);
              }),
            }
          );
        }
      }
      var S = r(22086),
        T = r(9478),
        P = r(81741),
        O = r(16038),
        x = r(44250),
        k = r(62418);
      function R(e, t) {
        if (e.provider) return e.provider;
        (0, c.hu)(!1, "missing provider", "UNSUPPORTED_OPERATION", {
          operation: t,
        });
      }
      async function D(e, t) {
        let r = (0, k.kK)(t);
        if ((null != r.to && (r.to = (0, s.ru)(r.to, e)), null != r.from)) {
          let t = r.from;
          r.from = Promise.all([e.getAddress(), (0, s.ru)(t, e)]).then(
            ([e, t]) => (
              (0, c.en)(
                e.toLowerCase() === t.toLowerCase(),
                "transaction from mismatch",
                "tx.from",
                t
              ),
              e
            )
          );
        } else r.from = e.getAddress();
        return await (0, u.m)(r);
      }
      class U {
        provider;
        constructor(e) {
          (0, u.h)(this, { provider: e || null });
        }
        async getNonce(e) {
          return R(this, "getTransactionCount").getTransactionCount(
            await this.getAddress(),
            e
          );
        }
        async populateCall(e) {
          return await D(this, e);
        }
        async populateTransaction(e) {
          let t = R(this, "populateTransaction"),
            r = await D(this, e);
          null == r.nonce && (r.nonce = await this.getNonce("pending")),
            null == r.gasLimit && (r.gasLimit = await this.estimateGas(r));
          let i = await this.provider.getNetwork();
          if (null != r.chainId) {
            let t = (0, l.yT)(r.chainId);
            (0, c.en)(
              t === i.chainId,
              "transaction chainId mismatch",
              "tx.chainId",
              e.chainId
            );
          } else r.chainId = i.chainId;
          let n = null != r.maxFeePerGas || null != r.maxPriorityFeePerGas;
          if (
            (null != r.gasPrice && (2 === r.type || n)
              ? (0, c.en)(
                  !1,
                  "eip-1559 transaction do not support gasPrice",
                  "tx",
                  e
                )
              : (0 === r.type || 1 === r.type) &&
                n &&
                (0, c.en)(
                  !1,
                  "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas",
                  "tx",
                  e
                ),
            (2 === r.type || null == r.type) &&
              null != r.maxFeePerGas &&
              null != r.maxPriorityFeePerGas)
          )
            r.type = 2;
          else if (0 === r.type || 1 === r.type) {
            let e = await t.getFeeData();
            (0, c.hu)(
              null != e.gasPrice,
              "network does not support gasPrice",
              "UNSUPPORTED_OPERATION",
              { operation: "getGasPrice" }
            ),
              null == r.gasPrice && (r.gasPrice = e.gasPrice);
          } else {
            let e = await t.getFeeData();
            if (null == r.type) {
              if (null != e.maxFeePerGas && null != e.maxPriorityFeePerGas) {
                if (((r.type = 2), null != r.gasPrice)) {
                  let e = r.gasPrice;
                  delete r.gasPrice,
                    (r.maxFeePerGas = e),
                    (r.maxPriorityFeePerGas = e);
                } else
                  null == r.maxFeePerGas && (r.maxFeePerGas = e.maxFeePerGas),
                    null == r.maxPriorityFeePerGas &&
                      (r.maxPriorityFeePerGas = e.maxPriorityFeePerGas);
              } else
                null != e.gasPrice
                  ? ((0, c.hu)(
                      !n,
                      "network does not support EIP-1559",
                      "UNSUPPORTED_OPERATION",
                      { operation: "populateTransaction" }
                    ),
                    null == r.gasPrice && (r.gasPrice = e.gasPrice),
                    (r.type = 0))
                  : (0, c.hu)(
                      !1,
                      "failed to get consistent fee data",
                      "UNSUPPORTED_OPERATION",
                      { operation: "signer.getFeeData" }
                    );
            } else
              (2 === r.type || 3 === r.type) &&
                (null == r.maxFeePerGas && (r.maxFeePerGas = e.maxFeePerGas),
                null == r.maxPriorityFeePerGas &&
                  (r.maxPriorityFeePerGas = e.maxPriorityFeePerGas));
          }
          return await (0, u.m)(r);
        }
        async estimateGas(e) {
          return R(this, "estimateGas").estimateGas(await this.populateCall(e));
        }
        async call(e) {
          return R(this, "call").call(await this.populateCall(e));
        }
        async resolveName(e) {
          let t = R(this, "resolveName");
          return await t.resolveName(e);
        }
        async sendTransaction(e) {
          let t = R(this, "sendTransaction"),
            r = await this.populateTransaction(e);
          delete r.from;
          let i = x.Y.from(r);
          return await t.broadcastTransaction(await this.signTransaction(i));
        }
      }
      var L = r(86804),
        M = r(87258);
      class B {
        #en;
        #es;
        #ea;
        #eo;
        #el;
        #ec;
        constructor(e) {
          (this.#en = e),
            (this.#es = null),
            (this.#ea = this.#eu.bind(this)),
            (this.#eo = !1),
            (this.#el = null),
            (this.#ec = !1);
        }
        _subscribe(e) {
          throw Error("subclasses must override this");
        }
        _emitResults(e, t) {
          throw Error("subclasses must override this");
        }
        _recover(e) {
          throw Error("subclasses must override this");
        }
        async #eu(e) {
          try {
            null == this.#es && (this.#es = this._subscribe(this.#en));
            let e = null;
            try {
              e = await this.#es;
            } catch (e) {
              if (
                !(0, c.VZ)(e, "UNSUPPORTED_OPERATION") ||
                "eth_newFilter" !== e.operation
              )
                throw e;
            }
            if (null == e) {
              (this.#es = null),
                this.#en._recoverSubscriber(this, this._recover(this.#en));
              return;
            }
            let t = await this.#en.getNetwork();
            if ((this.#el || (this.#el = t), this.#el.chainId !== t.chainId))
              throw Error("chaid changed");
            if (this.#ec) return;
            let r = await this.#en.send("eth_getFilterChanges", [e]);
            await this._emitResults(this.#en, r);
          } catch (e) {
            console.log("@TODO", e);
          }
          this.#en.once("block", this.#ea);
        }
        #eh() {
          let e = this.#es;
          e &&
            ((this.#es = null),
            e.then((e) => {
              this.#en.destroyed || this.#en.send("eth_uninstallFilter", [e]);
            }));
        }
        start() {
          this.#eo || ((this.#eo = !0), this.#eu(-2));
        }
        stop() {
          this.#eo &&
            ((this.#eo = !1),
            (this.#ec = !0),
            this.#eh(),
            this.#en.off("block", this.#ea));
        }
        pause(e) {
          e && this.#eh(), this.#en.off("block", this.#ea);
        }
        resume() {
          this.start();
        }
      }
      class j extends B {
        #ed;
        constructor(e, t) {
          super(e), (this.#ed = JSON.parse(JSON.stringify(t)));
        }
        _recover(e) {
          return new M.H9(e, this.#ed);
        }
        async _subscribe(e) {
          return await e.send("eth_newFilter", [this.#ed]);
        }
        async _emitResults(e, t) {
          for (let r of t) e.emit(this.#ed, e._wrapLog(r, e._network));
        }
      }
      class F extends B {
        async _subscribe(e) {
          return await e.send("eth_newPendingTransactionFilter", []);
        }
        async _emitResults(e, t) {
          for (let r of t) e.emit("pending", r);
        }
      }
      let $ = "bigint,boolean,function,number,string,symbol".split(/,/g);
      function H(e) {
        if (
          null == e ||
          $.indexOf(typeof e) >= 0 ||
          "function" == typeof e.getAddress
        )
          return e;
        if (Array.isArray(e)) return e.map(H);
        if ("object" == typeof e)
          return Object.keys(e).reduce((t, r) => ((t[r] = e[r]), t), {});
        throw Error(`should not happen: ${e} (${typeof e})`);
      }
      function z(e) {
        return e ? e.toLowerCase() : e;
      }
      function q(e) {
        return e && "number" == typeof e.pollingInterval;
      }
      let V = {
        polling: !1,
        staticNetwork: null,
        batchStallTime: 10,
        batchMaxSize: 1048576,
        batchMaxCount: 100,
        cacheTimeout: 250,
        pollingInterval: 4e3,
      };
      class G extends U {
        address;
        constructor(e, t) {
          super(e), (t = (0, n.K)(t)), (0, u.h)(this, { address: t });
        }
        connect(e) {
          (0, c.hu)(
            !1,
            "cannot reconnect JsonRpcSigner",
            "UNSUPPORTED_OPERATION",
            { operation: "signer.connect" }
          );
        }
        async getAddress() {
          return this.address;
        }
        async populateTransaction(e) {
          return await this.populateCall(e);
        }
        async sendUncheckedTransaction(e) {
          let t = H(e),
            r = [];
          if (t.from) {
            let i = t.from;
            r.push(
              (async () => {
                let r = await (0, s.ru)(i, this.provider);
                (0, c.en)(
                  null != r && r.toLowerCase() === this.address.toLowerCase(),
                  "from address mismatch",
                  "transaction",
                  e
                ),
                  (t.from = r);
              })()
            );
          } else t.from = this.address;
          if (
            (null == t.gasLimit &&
              r.push(
                (async () => {
                  t.gasLimit = await this.provider.estimateGas({
                    ...t,
                    from: this.address,
                  });
                })()
              ),
            null != t.to)
          ) {
            let e = t.to;
            r.push(
              (async () => {
                t.to = await (0, s.ru)(e, this.provider);
              })()
            );
          }
          r.length && (await Promise.all(r));
          let i = this.provider.getRpcTransaction(t);
          return this.provider.send("eth_sendTransaction", [i]);
        }
        async sendTransaction(e) {
          let t = await this.provider.getBlockNumber(),
            r = await this.sendUncheckedTransaction(e);
          return await new Promise((e, i) => {
            let n = [1e3, 100],
              s = 0,
              a = async () => {
                try {
                  let i = await this.provider.getTransaction(r);
                  if (null != i) {
                    e(i.replaceableTransaction(t));
                    return;
                  }
                } catch (e) {
                  if (
                    (0, c.VZ)(e, "CANCELLED") ||
                    (0, c.VZ)(e, "BAD_DATA") ||
                    (0, c.VZ)(e, "NETWORK_ERROR") ||
                    (0, c.VZ)(e, "UNSUPPORTED_OPERATION")
                  ) {
                    null == e.info && (e.info = {}),
                      (e.info.sendTransactionHash = r),
                      i(e);
                    return;
                  }
                  if (
                    (0, c.VZ)(e, "INVALID_ARGUMENT") &&
                    (s++,
                    null == e.info && (e.info = {}),
                    (e.info.sendTransactionHash = r),
                    s > 10)
                  ) {
                    i(e);
                    return;
                  }
                  this.provider.emit(
                    "error",
                    (0, c.wf)(
                      "failed to fetch transation after sending (will try again)",
                      "UNKNOWN_ERROR",
                      { error: e }
                    )
                  );
                }
                this.provider._setTimeout(() => {
                  a();
                }, n.pop() || 4e3);
              };
            a();
          });
        }
        async signTransaction(e) {
          let t = H(e);
          if (t.from) {
            let r = await (0, s.ru)(t.from, this.provider);
            (0, c.en)(
              null != r && r.toLowerCase() === this.address.toLowerCase(),
              "from address mismatch",
              "transaction",
              e
            ),
              (t.from = r);
          } else t.from = this.address;
          let r = this.provider.getRpcTransaction(t);
          return await this.provider.send("eth_signTransaction", [r]);
        }
        async signMessage(e) {
          let t = "string" == typeof e ? (0, T.Y0)(e) : e;
          return await this.provider.send("personal_sign", [
            (0, o.Dv)(t),
            this.address.toLowerCase(),
          ]);
        }
        async signTypedData(e, t, r) {
          let i = H(r),
            n = await N.resolveNames(e, t, i, async (e) => {
              let t = await (0, s.ru)(e);
              return (
                (0, c.en)(
                  null != t,
                  "TypedData does not support null address",
                  "value",
                  e
                ),
                t
              );
            });
          return await this.provider.send("eth_signTypedData_v4", [
            this.address.toLowerCase(),
            JSON.stringify(N.getPayload(n.domain, t, n.value)),
          ]);
        }
        async unlock(e) {
          return this.provider.send("personal_unlockAccount", [
            this.address.toLowerCase(),
            e,
            null,
          ]);
        }
        async _legacySignMessage(e) {
          let t = "string" == typeof e ? (0, T.Y0)(e) : e;
          return await this.provider.send("eth_sign", [
            this.address.toLowerCase(),
            (0, o.Dv)(t),
          ]);
        }
      }
      class W extends O.u {
        #v;
        #ep;
        #ef;
        #eg;
        #em;
        #el;
        #ey;
        #ew() {
          if (this.#eg) return;
          let e =
            1 === this._getOption("batchMaxCount")
              ? 0
              : this._getOption("batchStallTime");
          this.#eg = setTimeout(() => {
            this.#eg = null;
            let e = this.#ef;
            for (this.#ef = []; e.length; ) {
              let t = [e.shift()];
              for (; e.length && t.length !== this.#v.batchMaxCount; )
                if (
                  (t.push(e.shift()),
                  JSON.stringify(t.map((e) => e.payload)).length >
                    this.#v.batchMaxSize)
                ) {
                  e.unshift(t.pop());
                  break;
                }
              (async () => {
                let e = 1 === t.length ? t[0].payload : t.map((e) => e.payload);
                this.emit("debug", { action: "sendRpcPayload", payload: e });
                try {
                  let r = await this._send(e);
                  for (let { resolve: e, reject: i, payload: n } of (this.emit(
                    "debug",
                    { action: "receiveRpcResult", result: r }
                  ),
                  t)) {
                    if (this.destroyed) {
                      i(
                        (0, c.wf)(
                          "provider destroyed; cancelled request",
                          "UNSUPPORTED_OPERATION",
                          { operation: n.method }
                        )
                      );
                      continue;
                    }
                    let t = r.filter((e) => e.id === n.id)[0];
                    if (null == t) {
                      let e = (0, c.wf)(
                        "missing response for request",
                        "BAD_DATA",
                        { value: r, info: { payload: n } }
                      );
                      this.emit("error", e), i(e);
                      continue;
                    }
                    if ("error" in t) {
                      i(this.getRpcError(n, t));
                      continue;
                    }
                    e(t.result);
                  }
                } catch (e) {
                  for (let { reject: r } of (this.emit("debug", {
                    action: "receiveRpcError",
                    error: e,
                  }),
                  t))
                    r(e);
                }
              })();
            }
          }, e);
        }
        constructor(e, t) {
          super(e, t),
            (this.#ep = 1),
            (this.#v = Object.assign({}, V, t || {})),
            (this.#ef = []),
            (this.#eg = null),
            (this.#el = null),
            (this.#ey = null);
          {
            let e = null,
              t = new Promise((t) => {
                e = t;
              });
            this.#em = { promise: t, resolve: e };
          }
          let r = this._getOption("staticNetwork");
          "boolean" == typeof r
            ? ((0, c.en)(
                !r || "any" !== e,
                "staticNetwork cannot be used on special network 'any'",
                "options",
                t
              ),
              r && null != e && (this.#el = L.Z.from(e)))
            : r &&
              ((0, c.en)(
                null == e || r.matches(e),
                "staticNetwork MUST match network object",
                "options",
                t
              ),
              (this.#el = r));
        }
        _getOption(e) {
          return this.#v[e];
        }
        get _network() {
          return (
            (0, c.hu)(
              this.#el,
              "network is not available yet",
              "NETWORK_ERROR"
            ),
            this.#el
          );
        }
        async _perform(e) {
          if ("call" === e.method || "estimateGas" === e.method) {
            let t = e.transaction;
            if (
              t &&
              null != t.type &&
              (0, l.yT)(t.type) &&
              null == t.maxFeePerGas &&
              null == t.maxPriorityFeePerGas
            ) {
              let r = await this.getFeeData();
              null == r.maxFeePerGas &&
                null == r.maxPriorityFeePerGas &&
                (e = Object.assign({}, e, {
                  transaction: Object.assign({}, t, { type: void 0 }),
                }));
            }
          }
          let t = this.getRpcRequest(e);
          return null != t
            ? await this.send(t.method, t.args)
            : super._perform(e);
        }
        async _detectNetwork() {
          let e = this._getOption("staticNetwork");
          if (e) {
            if (!0 !== e) return e;
            if (this.#el) return this.#el;
          }
          return (
            this.#ey ||
              (this.ready
                ? (this.#ey = (async () => {
                    try {
                      let e = L.Z.from(
                        (0, l.yT)(await this.send("eth_chainId", []))
                      );
                      return (this.#ey = null), e;
                    } catch (e) {
                      throw ((this.#ey = null), e);
                    }
                  })())
                : (this.#ey = (async () => {
                    let e;
                    let t = {
                      id: this.#ep++,
                      method: "eth_chainId",
                      params: [],
                      jsonrpc: "2.0",
                    };
                    this.emit("debug", {
                      action: "sendRpcPayload",
                      payload: t,
                    });
                    try {
                      (e = (await this._send(t))[0]), (this.#ey = null);
                    } catch (e) {
                      throw (
                        ((this.#ey = null),
                        this.emit("debug", {
                          action: "receiveRpcError",
                          error: e,
                        }),
                        e)
                      );
                    }
                    if (
                      (this.emit("debug", {
                        action: "receiveRpcResult",
                        result: e,
                      }),
                      "result" in e)
                    )
                      return L.Z.from((0, l.yT)(e.result));
                    throw this.getRpcError(t, e);
                  })())),
            await this.#ey
          );
        }
        _start() {
          null != this.#em &&
            null != this.#em.resolve &&
            (this.#em.resolve(),
            (this.#em = null),
            (async () => {
              for (; null == this.#el && !this.destroyed; )
                try {
                  this.#el = await this._detectNetwork();
                } catch (e) {
                  if (this.destroyed) break;
                  console.log(
                    "JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"
                  ),
                    this.emit(
                      "error",
                      (0, c.wf)(
                        "failed to bootstrap network detection",
                        "NETWORK_ERROR",
                        {
                          event: "initial-network-discovery",
                          info: { error: e },
                        }
                      )
                    ),
                    await new Promise((e) => {
                      setTimeout(e, 1e3);
                    });
                }
              this.#ew();
            })());
        }
        async _waitUntilReady() {
          if (null != this.#em) return await this.#em.promise;
        }
        _getSubscriber(e) {
          return "pending" === e.type
            ? new F(this)
            : "event" === e.type
            ? this._getOption("polling")
              ? new M.H9(this, e.filter)
              : new j(this, e.filter)
            : "orphan" === e.type && "drop-log" === e.filter.orphan
            ? new O.P("orphan")
            : super._getSubscriber(e);
        }
        get ready() {
          return null == this.#em;
        }
        getRpcTransaction(e) {
          let t = {};
          return (
            [
              "chainId",
              "gasLimit",
              "gasPrice",
              "type",
              "maxFeePerGas",
              "maxPriorityFeePerGas",
              "nonce",
              "value",
            ].forEach((r) => {
              if (null == e[r]) return;
              let i = r;
              "gasLimit" === r && (i = "gas"),
                (t[i] = (0, l.B4)((0, l.yT)(e[r], `tx.${r}`)));
            }),
            ["from", "to", "data"].forEach((r) => {
              null != e[r] && (t[r] = (0, o.Dv)(e[r]));
            }),
            e.accessList && (t.accessList = (0, S.z)(e.accessList)),
            e.blobVersionedHashes &&
              (t.blobVersionedHashes = e.blobVersionedHashes.map((e) =>
                e.toLowerCase()
              )),
            t
          );
        }
        getRpcRequest(e) {
          switch (e.method) {
            case "chainId":
              return { method: "eth_chainId", args: [] };
            case "getBlockNumber":
              return { method: "eth_blockNumber", args: [] };
            case "getGasPrice":
              return { method: "eth_gasPrice", args: [] };
            case "getPriorityFee":
              return { method: "eth_maxPriorityFeePerGas", args: [] };
            case "getBalance":
              return {
                method: "eth_getBalance",
                args: [z(e.address), e.blockTag],
              };
            case "getTransactionCount":
              return {
                method: "eth_getTransactionCount",
                args: [z(e.address), e.blockTag],
              };
            case "getCode":
              return {
                method: "eth_getCode",
                args: [z(e.address), e.blockTag],
              };
            case "getStorage":
              return {
                method: "eth_getStorageAt",
                args: [
                  z(e.address),
                  "0x" + e.position.toString(16),
                  e.blockTag,
                ],
              };
            case "broadcastTransaction":
              return {
                method: "eth_sendRawTransaction",
                args: [e.signedTransaction],
              };
            case "getBlock":
              if ("blockTag" in e)
                return {
                  method: "eth_getBlockByNumber",
                  args: [e.blockTag, !!e.includeTransactions],
                };
              if ("blockHash" in e)
                return {
                  method: "eth_getBlockByHash",
                  args: [e.blockHash, !!e.includeTransactions],
                };
              break;
            case "getTransaction":
              return { method: "eth_getTransactionByHash", args: [e.hash] };
            case "getTransactionReceipt":
              return { method: "eth_getTransactionReceipt", args: [e.hash] };
            case "call":
              return {
                method: "eth_call",
                args: [this.getRpcTransaction(e.transaction), e.blockTag],
              };
            case "estimateGas":
              return {
                method: "eth_estimateGas",
                args: [this.getRpcTransaction(e.transaction)],
              };
            case "getLogs":
              return (
                e.filter &&
                  null != e.filter.address &&
                  (Array.isArray(e.filter.address)
                    ? (e.filter.address = e.filter.address.map(z))
                    : (e.filter.address = z(e.filter.address))),
                { method: "eth_getLogs", args: [e.filter] }
              );
          }
          return null;
        }
        getRpcError(e, t) {
          let { method: r } = e,
            { error: n } = t;
          if ("eth_estimateGas" === r && n.message) {
            let t = n.message;
            if (!t.match(/revert/i) && t.match(/insufficient funds/i))
              return (0, c.wf)("insufficient funds", "INSUFFICIENT_FUNDS", {
                transaction: e.params[0],
                info: { payload: e, error: n },
              });
          }
          if ("eth_call" === r || "eth_estimateGas" === r) {
            let t = (function e(t) {
                if (null == t) return null;
                if (
                  "string" == typeof t.message &&
                  t.message.match(/revert/i) &&
                  (0, o.A7)(t.data)
                )
                  return { message: t.message, data: t.data };
                if ("object" == typeof t) {
                  for (let r in t) {
                    let i = e(t[r]);
                    if (i) return i;
                  }
                  return null;
                }
                if ("string" == typeof t)
                  try {
                    return e(JSON.parse(t));
                  } catch (e) {}
                return null;
              })(n),
              s = i.R.getBuiltinCallException(
                "eth_call" === r ? "call" : "estimateGas",
                e.params[0],
                t ? t.data : null
              );
            return (s.info = { error: n, payload: e }), s;
          }
          let s = JSON.stringify(
            (function (e) {
              let t = [];
              return (
                !(function e(t, r) {
                  if (null != t) {
                    if (
                      ("string" == typeof t.message && r.push(t.message),
                      "object" == typeof t)
                    )
                      for (let i in t) e(t[i], r);
                    if ("string" == typeof t)
                      try {
                        return e(JSON.parse(t), r);
                      } catch (e) {}
                  }
                })(e, t),
                t
              );
            })(n)
          );
          if (
            "string" == typeof n.message &&
            n.message.match(/user denied|ethers-user-denied/i)
          )
            return (0, c.wf)("user rejected action", "ACTION_REJECTED", {
              action:
                {
                  eth_sign: "signMessage",
                  personal_sign: "signMessage",
                  eth_signTypedData_v4: "signTypedData",
                  eth_signTransaction: "signTransaction",
                  eth_sendTransaction: "sendTransaction",
                  eth_requestAccounts: "requestAccess",
                  wallet_requestAccounts: "requestAccess",
                }[r] || "unknown",
              reason: "rejected",
              info: { payload: e, error: n },
            });
          if ("eth_sendRawTransaction" === r || "eth_sendTransaction" === r) {
            let t = e.params[0];
            if (s.match(/insufficient funds|base fee exceeds gas limit/i))
              return (0, c.wf)(
                "insufficient funds for intrinsic transaction cost",
                "INSUFFICIENT_FUNDS",
                { transaction: t, info: { error: n } }
              );
            if (s.match(/nonce/i) && s.match(/too low/i))
              return (0, c.wf)("nonce has already been used", "NONCE_EXPIRED", {
                transaction: t,
                info: { error: n },
              });
            if (s.match(/replacement transaction/i) && s.match(/underpriced/i))
              return (0, c.wf)(
                "replacement fee too low",
                "REPLACEMENT_UNDERPRICED",
                { transaction: t, info: { error: n } }
              );
            if (s.match(/only replay-protected/i))
              return (0, c.wf)(
                "legacy pre-eip-155 transactions not supported",
                "UNSUPPORTED_OPERATION",
                { operation: r, info: { transaction: t, info: { error: n } } }
              );
          }
          let a = !!s.match(/the method .* does not exist/i);
          return (!a &&
            n &&
            n.details &&
            n.details.startsWith("Unauthorized method:") &&
            (a = !0),
          a)
            ? (0, c.wf)("unsupported operation", "UNSUPPORTED_OPERATION", {
                operation: e.method,
                info: { error: n, payload: e },
              })
            : (0, c.wf)("could not coalesce error", "UNKNOWN_ERROR", {
                error: n,
                payload: e,
              });
        }
        send(e, t) {
          if (this.destroyed)
            return Promise.reject(
              (0, c.wf)(
                "provider destroyed; cancelled request",
                "UNSUPPORTED_OPERATION",
                { operation: e }
              )
            );
          let r = this.#ep++,
            i = new Promise((i, n) => {
              this.#ef.push({
                resolve: i,
                reject: n,
                payload: { method: e, params: t, id: r, jsonrpc: "2.0" },
              });
            });
          return this.#ew(), i;
        }
        async getSigner(e) {
          null == e && (e = 0);
          let t = this.send("eth_accounts", []);
          if ("number" == typeof e) {
            let r = await t;
            if (e >= r.length) throw Error("no such account");
            return new G(this, r[e]);
          }
          let { accounts: r } = await (0, u.m)({
            network: this.getNetwork(),
            accounts: t,
          });
          for (let t of ((e = (0, n.K)(e)), r))
            if ((0, n.K)(t) === e) return new G(this, e);
          throw Error("invalid account");
        }
        async listAccounts() {
          return (await this.send("eth_accounts", [])).map(
            (e) => new G(this, e)
          );
        }
        destroy() {
          for (let { payload: e, reject: t } of (this.#eg &&
            (clearTimeout(this.#eg), (this.#eg = null)),
          this.#ef))
            t(
              (0, c.wf)(
                "provider destroyed; cancelled request",
                "UNSUPPORTED_OPERATION",
                { operation: e.method }
              )
            );
          (this.#ef = []), super.destroy();
        }
      }
      class K extends W {
        #eb;
        constructor(e, t) {
          super(e, t);
          let r = this._getOption("pollingInterval");
          null == r && (r = V.pollingInterval), (this.#eb = r);
        }
        _getSubscriber(e) {
          let t = super._getSubscriber(e);
          return q(t) && (t.pollingInterval = this.#eb), t;
        }
        get pollingInterval() {
          return this.#eb;
        }
        set pollingInterval(e) {
          if (!Number.isInteger(e) || e < 0) throw Error("invalid interval");
          (this.#eb = e),
            this._forEachSubscriber((e) => {
              q(e) && (e.pollingInterval = this.#eb);
            });
        }
      }
      class Z extends K {
        #ev;
        constructor(e, t, r) {
          null == e && (e = "http://localhost:8545"),
            super(t, r),
            "string" == typeof e
              ? (this.#ev = new P.gd(e))
              : (this.#ev = e.clone());
        }
        _getConnection() {
          return this.#ev.clone();
        }
        async send(e, t) {
          return await this._start(), await super.send(e, t);
        }
        async _send(e) {
          let t = this._getConnection();
          (t.body = JSON.stringify(e)),
            t.setHeader("content-type", "application/json");
          let r = await t.send();
          r.assertOk();
          let i = r.bodyJson;
          return Array.isArray(i) || (i = [i]), i;
        }
      }
    },
    62418: function (e, t, r) {
      "use strict";
      r.d(t, {
        IX: function () {
          return g;
        },
        Mw: function () {
          return m;
        },
        Zb: function () {
          return f;
        },
        gO: function () {
          return p;
        },
        jW: function () {
          return h;
        },
        kK: function () {
          return d;
        },
      });
      var i = r(69781),
        n = r(59369),
        s = r(45474),
        a = r(35157),
        o = r(22086);
      let l = BigInt(0);
      function c(e) {
        return null == e ? null : e;
      }
      function u(e) {
        return null == e ? null : e.toString();
      }
      class h {
        gasPrice;
        maxFeePerGas;
        maxPriorityFeePerGas;
        constructor(e, t, r) {
          (0, i.h)(this, {
            gasPrice: c(e),
            maxFeePerGas: c(t),
            maxPriorityFeePerGas: c(r),
          });
        }
        toJSON() {
          let { gasPrice: e, maxFeePerGas: t, maxPriorityFeePerGas: r } = this;
          return {
            _type: "FeeData",
            gasPrice: u(e),
            maxFeePerGas: u(t),
            maxPriorityFeePerGas: u(r),
          };
        }
      }
      function d(e) {
        let t = {};
        for (let r of (e.to && (t.to = e.to),
        e.from && (t.from = e.from),
        e.data && (t.data = (0, n.Dv)(e.data)),
        "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(
          /,/
        )))
          r in e && null != e[r] && (t[r] = (0, s.yT)(e[r], `request.${r}`));
        for (let r of "type,nonce".split(/,/))
          r in e && null != e[r] && (t[r] = (0, s.Dx)(e[r], `request.${r}`));
        return (
          e.accessList && (t.accessList = (0, o.z)(e.accessList)),
          "blockTag" in e && (t.blockTag = e.blockTag),
          "enableCcipRead" in e && (t.enableCcipRead = !!e.enableCcipRead),
          "customData" in e && (t.customData = e.customData),
          "blobVersionedHashes" in e &&
            e.blobVersionedHashes &&
            (t.blobVersionedHashes = e.blobVersionedHashes.slice()),
          "kzg" in e && (t.kzg = e.kzg),
          "blobs" in e &&
            e.blobs &&
            (t.blobs = e.blobs.map((e) =>
              (0, n.Zq)(e) ? (0, n.Dv)(e) : Object.assign({}, e)
            )),
          t
        );
      }
      class p {
        provider;
        number;
        hash;
        timestamp;
        parentHash;
        parentBeaconBlockRoot;
        nonce;
        difficulty;
        gasLimit;
        gasUsed;
        stateRoot;
        receiptsRoot;
        blobGasUsed;
        excessBlobGas;
        miner;
        prevRandao;
        extraData;
        baseFeePerGas;
        #eE;
        constructor(e, t) {
          (this.#eE = e.transactions.map((e) =>
            "string" != typeof e ? new m(e, t) : e
          )),
            (0, i.h)(this, {
              provider: t,
              hash: c(e.hash),
              number: e.number,
              timestamp: e.timestamp,
              parentHash: e.parentHash,
              parentBeaconBlockRoot: e.parentBeaconBlockRoot,
              nonce: e.nonce,
              difficulty: e.difficulty,
              gasLimit: e.gasLimit,
              gasUsed: e.gasUsed,
              blobGasUsed: e.blobGasUsed,
              excessBlobGas: e.excessBlobGas,
              miner: e.miner,
              prevRandao: c(e.prevRandao),
              extraData: e.extraData,
              baseFeePerGas: c(e.baseFeePerGas),
              stateRoot: e.stateRoot,
              receiptsRoot: e.receiptsRoot,
            });
        }
        get transactions() {
          return this.#eE.map((e) => ("string" == typeof e ? e : e.hash));
        }
        get prefetchedTransactions() {
          let e = this.#eE.slice();
          return 0 === e.length
            ? []
            : ((0, a.hu)(
                "object" == typeof e[0],
                "transactions were not prefetched with block request",
                "UNSUPPORTED_OPERATION",
                { operation: "transactionResponses()" }
              ),
              e);
        }
        toJSON() {
          let {
            baseFeePerGas: e,
            difficulty: t,
            extraData: r,
            gasLimit: i,
            gasUsed: n,
            hash: s,
            miner: a,
            prevRandao: o,
            nonce: l,
            number: c,
            parentHash: h,
            parentBeaconBlockRoot: d,
            stateRoot: p,
            receiptsRoot: f,
            timestamp: g,
            transactions: m,
          } = this;
          return {
            _type: "Block",
            baseFeePerGas: u(e),
            difficulty: u(t),
            extraData: r,
            gasLimit: u(i),
            gasUsed: u(n),
            blobGasUsed: u(this.blobGasUsed),
            excessBlobGas: u(this.excessBlobGas),
            hash: s,
            miner: a,
            prevRandao: o,
            nonce: l,
            number: c,
            parentHash: h,
            timestamp: g,
            parentBeaconBlockRoot: d,
            stateRoot: p,
            receiptsRoot: f,
            transactions: m,
          };
        }
        [Symbol.iterator]() {
          let e = 0,
            t = this.transactions;
          return {
            next: () =>
              e < this.length
                ? { value: t[e++], done: !1 }
                : { value: void 0, done: !0 },
          };
        }
        get length() {
          return this.#eE.length;
        }
        get date() {
          return null == this.timestamp ? null : new Date(1e3 * this.timestamp);
        }
        async getTransaction(e) {
          let t;
          if ("number" == typeof e) t = this.#eE[e];
          else {
            let r = e.toLowerCase();
            for (let e of this.#eE) {
              if ("string" == typeof e) {
                if (e !== r) continue;
                t = e;
                break;
              }
              if (e.hash === r) {
                t = e;
                break;
              }
            }
          }
          if (null == t) throw Error("no such tx");
          return "string" == typeof t
            ? await this.provider.getTransaction(t)
            : t;
        }
        getPrefetchedTransaction(e) {
          let t = this.prefetchedTransactions;
          if ("number" == typeof e) return t[e];
          for (let r of ((e = e.toLowerCase()), t)) if (r.hash === e) return r;
          (0, a.en)(!1, "no matching transaction", "indexOrHash", e);
        }
        isMined() {
          return !!this.hash;
        }
        isLondon() {
          return !!this.baseFeePerGas;
        }
        orphanedEvent() {
          if (!this.isMined()) throw Error("");
          return { orphan: "drop-block", hash: this.hash, number: this.number };
        }
      }
      class f {
        provider;
        transactionHash;
        blockHash;
        blockNumber;
        removed;
        address;
        data;
        topics;
        index;
        transactionIndex;
        constructor(e, t) {
          this.provider = t;
          let r = Object.freeze(e.topics.slice());
          (0, i.h)(this, {
            transactionHash: e.transactionHash,
            blockHash: e.blockHash,
            blockNumber: e.blockNumber,
            removed: e.removed,
            address: e.address,
            data: e.data,
            topics: r,
            index: e.index,
            transactionIndex: e.transactionIndex,
          });
        }
        toJSON() {
          let {
            address: e,
            blockHash: t,
            blockNumber: r,
            data: i,
            index: n,
            removed: s,
            topics: a,
            transactionHash: o,
            transactionIndex: l,
          } = this;
          return {
            _type: "log",
            address: e,
            blockHash: t,
            blockNumber: r,
            data: i,
            index: n,
            removed: s,
            topics: a,
            transactionHash: o,
            transactionIndex: l,
          };
        }
        async getBlock() {
          let e = await this.provider.getBlock(this.blockHash);
          return (
            (0, a.hu)(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e
          );
        }
        async getTransaction() {
          let e = await this.provider.getTransaction(this.transactionHash);
          return (
            (0, a.hu)(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e
          );
        }
        async getTransactionReceipt() {
          let e = await this.provider.getTransactionReceipt(
            this.transactionHash
          );
          return (
            (0, a.hu)(
              !!e,
              "failed to find transaction receipt",
              "UNKNOWN_ERROR",
              {}
            ),
            e
          );
        }
        removedEvent() {
          return {
            orphan: "drop-log",
            log: {
              transactionHash: this.transactionHash,
              blockHash: this.blockHash,
              blockNumber: this.blockNumber,
              address: this.address,
              data: this.data,
              topics: Object.freeze(this.topics.slice()),
              index: this.index,
            },
          };
        }
      }
      class g {
        provider;
        to;
        from;
        contractAddress;
        hash;
        index;
        blockHash;
        blockNumber;
        logsBloom;
        gasUsed;
        blobGasUsed;
        cumulativeGasUsed;
        gasPrice;
        blobGasPrice;
        type;
        status;
        root;
        #eA;
        constructor(e, t) {
          this.#eA = Object.freeze(e.logs.map((e) => new f(e, t)));
          let r = l;
          null != e.effectiveGasPrice
            ? (r = e.effectiveGasPrice)
            : null != e.gasPrice && (r = e.gasPrice),
            (0, i.h)(this, {
              provider: t,
              to: e.to,
              from: e.from,
              contractAddress: e.contractAddress,
              hash: e.hash,
              index: e.index,
              blockHash: e.blockHash,
              blockNumber: e.blockNumber,
              logsBloom: e.logsBloom,
              gasUsed: e.gasUsed,
              cumulativeGasUsed: e.cumulativeGasUsed,
              blobGasUsed: e.blobGasUsed,
              gasPrice: r,
              blobGasPrice: e.blobGasPrice,
              type: e.type,
              status: e.status,
              root: e.root,
            });
        }
        get logs() {
          return this.#eA;
        }
        toJSON() {
          let {
            to: e,
            from: t,
            contractAddress: r,
            hash: i,
            index: n,
            blockHash: s,
            blockNumber: a,
            logsBloom: o,
            logs: l,
            status: c,
            root: h,
          } = this;
          return {
            _type: "TransactionReceipt",
            blockHash: s,
            blockNumber: a,
            contractAddress: r,
            cumulativeGasUsed: u(this.cumulativeGasUsed),
            from: t,
            gasPrice: u(this.gasPrice),
            blobGasUsed: u(this.blobGasUsed),
            blobGasPrice: u(this.blobGasPrice),
            gasUsed: u(this.gasUsed),
            hash: i,
            index: n,
            logs: l,
            logsBloom: o,
            root: h,
            status: c,
            to: e,
          };
        }
        get length() {
          return this.logs.length;
        }
        [Symbol.iterator]() {
          let e = 0;
          return {
            next: () =>
              e < this.length
                ? { value: this.logs[e++], done: !1 }
                : { value: void 0, done: !0 },
          };
        }
        get fee() {
          return this.gasUsed * this.gasPrice;
        }
        async getBlock() {
          let e = await this.provider.getBlock(this.blockHash);
          if (null == e) throw Error("TODO");
          return e;
        }
        async getTransaction() {
          let e = await this.provider.getTransaction(this.hash);
          if (null == e) throw Error("TODO");
          return e;
        }
        async getResult() {
          return await this.provider.getTransactionResult(this.hash);
        }
        async confirmations() {
          return (await this.provider.getBlockNumber()) - this.blockNumber + 1;
        }
        removedEvent() {
          return w(this);
        }
        reorderedEvent(e) {
          return (
            (0, a.hu)(
              !e || e.isMined(),
              "unmined 'other' transction cannot be orphaned",
              "UNSUPPORTED_OPERATION",
              { operation: "reorderedEvent(other)" }
            ),
            y(this, e)
          );
        }
      }
      class m {
        provider;
        blockNumber;
        blockHash;
        index;
        hash;
        type;
        to;
        from;
        nonce;
        gasLimit;
        gasPrice;
        maxPriorityFeePerGas;
        maxFeePerGas;
        maxFeePerBlobGas;
        data;
        value;
        chainId;
        signature;
        accessList;
        blobVersionedHashes;
        #eC;
        constructor(e, t) {
          (this.provider = t),
            (this.blockNumber = null != e.blockNumber ? e.blockNumber : null),
            (this.blockHash = null != e.blockHash ? e.blockHash : null),
            (this.hash = e.hash),
            (this.index = e.index),
            (this.type = e.type),
            (this.from = e.from),
            (this.to = e.to || null),
            (this.gasLimit = e.gasLimit),
            (this.nonce = e.nonce),
            (this.data = e.data),
            (this.value = e.value),
            (this.gasPrice = e.gasPrice),
            (this.maxPriorityFeePerGas =
              null != e.maxPriorityFeePerGas ? e.maxPriorityFeePerGas : null),
            (this.maxFeePerGas =
              null != e.maxFeePerGas ? e.maxFeePerGas : null),
            (this.maxFeePerBlobGas =
              null != e.maxFeePerBlobGas ? e.maxFeePerBlobGas : null),
            (this.chainId = e.chainId),
            (this.signature = e.signature),
            (this.accessList = null != e.accessList ? e.accessList : null),
            (this.blobVersionedHashes =
              null != e.blobVersionedHashes ? e.blobVersionedHashes : null),
            (this.#eC = -1);
        }
        toJSON() {
          let {
            blockNumber: e,
            blockHash: t,
            index: r,
            hash: i,
            type: n,
            to: s,
            from: a,
            nonce: o,
            data: l,
            signature: c,
            accessList: h,
            blobVersionedHashes: d,
          } = this;
          return {
            _type: "TransactionResponse",
            accessList: h,
            blockNumber: e,
            blockHash: t,
            blobVersionedHashes: d,
            chainId: u(this.chainId),
            data: l,
            from: a,
            gasLimit: u(this.gasLimit),
            gasPrice: u(this.gasPrice),
            hash: i,
            maxFeePerGas: u(this.maxFeePerGas),
            maxPriorityFeePerGas: u(this.maxPriorityFeePerGas),
            maxFeePerBlobGas: u(this.maxFeePerBlobGas),
            nonce: o,
            signature: c,
            to: s,
            index: r,
            type: n,
            value: u(this.value),
          };
        }
        async getBlock() {
          let e = this.blockNumber;
          if (null == e) {
            let t = await this.getTransaction();
            t && (e = t.blockNumber);
          }
          if (null == e) return null;
          let t = this.provider.getBlock(e);
          if (null == t) throw Error("TODO");
          return t;
        }
        async getTransaction() {
          return this.provider.getTransaction(this.hash);
        }
        async confirmations() {
          if (null == this.blockNumber) {
            let { tx: e, blockNumber: t } = await (0, i.m)({
              tx: this.getTransaction(),
              blockNumber: this.provider.getBlockNumber(),
            });
            return null == e || null == e.blockNumber
              ? 0
              : t - e.blockNumber + 1;
          }
          return (await this.provider.getBlockNumber()) - this.blockNumber + 1;
        }
        async wait(e, t) {
          let r = null == e ? 1 : e,
            n = null == t ? 0 : t,
            s = this.#eC,
            o = -1,
            c = -1 === s,
            u = async () => {
              if (c) return null;
              let { blockNumber: e, nonce: t } = await (0, i.m)({
                blockNumber: this.provider.getBlockNumber(),
                nonce: this.provider.getTransactionCount(this.from),
              });
              if (t < this.nonce) {
                s = e;
                return;
              }
              if (c) return null;
              let n = await this.getTransaction();
              if (!n || null == n.blockNumber)
                for (
                  -1 === o && (o = s - 3) < this.#eC && (o = this.#eC);
                  o <= e;

                ) {
                  if (c) return null;
                  let t = await this.provider.getBlock(o, !0);
                  if (null == t) break;
                  for (let e of t) if (e === this.hash) return;
                  for (let i = 0; i < t.length; i++) {
                    let n = await t.getTransaction(i);
                    if (n.from === this.from && n.nonce === this.nonce) {
                      if (c) return null;
                      let t = await this.provider.getTransactionReceipt(n.hash);
                      if (null == t || e - t.blockNumber + 1 < r) return;
                      let i = "replaced";
                      n.data === this.data &&
                      n.to === this.to &&
                      n.value === this.value
                        ? (i = "repriced")
                        : "0x" === n.data &&
                          n.from === n.to &&
                          n.value === l &&
                          (i = "cancelled"),
                        (0, a.hu)(
                          !1,
                          "transaction was replaced",
                          "TRANSACTION_REPLACED",
                          {
                            cancelled: "replaced" === i || "cancelled" === i,
                            reason: i,
                            replacement: n.replaceableTransaction(s),
                            hash: n.hash,
                            receipt: t,
                          }
                        );
                    }
                  }
                  o++;
                }
            },
            h = (e) => {
              if (null == e || 0 !== e.status) return e;
              (0, a.hu)(
                !1,
                "transaction execution reverted",
                "CALL_EXCEPTION",
                {
                  action: "sendTransaction",
                  data: null,
                  reason: null,
                  invocation: null,
                  revert: null,
                  transaction: { to: e.to, from: e.from, data: "" },
                  receipt: e,
                }
              );
            },
            d = await this.provider.getTransactionReceipt(this.hash);
          if (0 === r) return h(d);
          if (d) {
            if ((await d.confirmations()) >= r) return h(d);
          } else if ((await u(), 0 === r)) return null;
          let p = new Promise((e, t) => {
            let i = [],
              o = () => {
                i.forEach((e) => e());
              };
            if (
              (i.push(() => {
                c = !0;
              }),
              n > 0)
            ) {
              let e = setTimeout(() => {
                o(), t((0, a.wf)("wait for transaction timeout", "TIMEOUT"));
              }, n);
              i.push(() => {
                clearTimeout(e);
              });
            }
            let l = async (i) => {
              if ((await i.confirmations()) >= r) {
                o();
                try {
                  e(h(i));
                } catch (e) {
                  t(e);
                }
              }
            };
            if (
              (i.push(() => {
                this.provider.off(this.hash, l);
              }),
              this.provider.on(this.hash, l),
              s >= 0)
            ) {
              let e = async () => {
                try {
                  await u();
                } catch (e) {
                  if ((0, a.VZ)(e, "TRANSACTION_REPLACED")) {
                    o(), t(e);
                    return;
                  }
                }
                c || this.provider.once("block", e);
              };
              i.push(() => {
                this.provider.off("block", e);
              }),
                this.provider.once("block", e);
            }
          });
          return await p;
        }
        isMined() {
          return null != this.blockHash;
        }
        isLegacy() {
          return 0 === this.type;
        }
        isBerlin() {
          return 1 === this.type;
        }
        isLondon() {
          return 2 === this.type;
        }
        isCancun() {
          return 3 === this.type;
        }
        removedEvent() {
          return (
            (0, a.hu)(
              this.isMined(),
              "unmined transaction canot be orphaned",
              "UNSUPPORTED_OPERATION",
              { operation: "removeEvent()" }
            ),
            w(this)
          );
        }
        reorderedEvent(e) {
          return (
            (0, a.hu)(
              this.isMined(),
              "unmined transaction canot be orphaned",
              "UNSUPPORTED_OPERATION",
              { operation: "removeEvent()" }
            ),
            (0, a.hu)(
              !e || e.isMined(),
              "unmined 'other' transaction canot be orphaned",
              "UNSUPPORTED_OPERATION",
              { operation: "removeEvent()" }
            ),
            y(this, e)
          );
        }
        replaceableTransaction(e) {
          (0, a.en)(
            Number.isInteger(e) && e >= 0,
            "invalid startBlock",
            "startBlock",
            e
          );
          let t = new m(this, this.provider);
          return (t.#eC = e), t;
        }
      }
      function y(e, t) {
        return { orphan: "reorder-transaction", tx: e, other: t };
      }
      function w(e) {
        return { orphan: "drop-transaction", tx: e };
      }
    },
    87258: function (e, t, r) {
      "use strict";
      function i(e) {
        return JSON.parse(JSON.stringify(e));
      }
      r.d(t, {
        H9: function () {
          return c;
        },
        tR: function () {
          return n;
        },
        ub: function () {
          return a;
        },
        wF: function () {
          return o;
        },
        yq: function () {
          return l;
        },
      });
      class n {
        #en;
        #ea;
        #e_;
        #eI;
        constructor(e) {
          (this.#en = e), (this.#ea = null), (this.#e_ = 4e3), (this.#eI = -2);
        }
        get pollingInterval() {
          return this.#e_;
        }
        set pollingInterval(e) {
          this.#e_ = e;
        }
        async #eu() {
          try {
            let e = await this.#en.getBlockNumber();
            if (-2 === this.#eI) {
              this.#eI = e;
              return;
            }
            if (e !== this.#eI) {
              for (let t = this.#eI + 1; t <= e; t++) {
                if (null == this.#ea) return;
                await this.#en.emit("block", t);
              }
              this.#eI = e;
            }
          } catch (e) {}
          null != this.#ea &&
            (this.#ea = this.#en._setTimeout(this.#eu.bind(this), this.#e_));
        }
        start() {
          this.#ea ||
            ((this.#ea = this.#en._setTimeout(this.#eu.bind(this), this.#e_)),
            this.#eu());
        }
        stop() {
          this.#ea && (this.#en._clearTimeout(this.#ea), (this.#ea = null));
        }
        pause(e) {
          this.stop(), e && (this.#eI = -2);
        }
        resume() {
          this.start();
        }
      }
      class s {
        #en;
        #eu;
        #eo;
        constructor(e) {
          (this.#en = e),
            (this.#eo = !1),
            (this.#eu = (e) => {
              this._poll(e, this.#en);
            });
        }
        async _poll(e, t) {
          throw Error("sub-classes must override this");
        }
        start() {
          this.#eo ||
            ((this.#eo = !0), this.#eu(-2), this.#en.on("block", this.#eu));
        }
        stop() {
          this.#eo && ((this.#eo = !1), this.#en.off("block", this.#eu));
        }
        pause(e) {
          this.stop();
        }
        resume() {
          this.start();
        }
      }
      class a extends s {
        #eN;
        #eS;
        constructor(e, t) {
          super(e), (this.#eN = t), (this.#eS = -2);
        }
        pause(e) {
          e && (this.#eS = -2), super.pause(e);
        }
        async _poll(e, t) {
          let r = await t.getBlock(this.#eN);
          null != r &&
            (-2 === this.#eS
              ? (this.#eS = r.number)
              : r.number > this.#eS &&
                (t.emit(this.#eN, r.number), (this.#eS = r.number)));
        }
      }
      class o extends s {
        #A;
        constructor(e, t) {
          super(e), (this.#A = i(t));
        }
        async _poll(e, t) {
          throw Error("@TODO");
        }
      }
      class l extends s {
        #eT;
        constructor(e, t) {
          super(e), (this.#eT = t);
        }
        async _poll(e, t) {
          let r = await t.getTransactionReceipt(this.#eT);
          r && t.emit(this.#eT, r);
        }
      }
      class c {
        #en;
        #A;
        #ea;
        #eo;
        #eI;
        constructor(e, t) {
          (this.#en = e),
            (this.#A = i(t)),
            (this.#ea = this.#eu.bind(this)),
            (this.#eo = !1),
            (this.#eI = -2);
        }
        async #eu(e) {
          if (-2 === this.#eI) return;
          let t = i(this.#A);
          (t.fromBlock = this.#eI + 1), (t.toBlock = e);
          let r = await this.#en.getLogs(t);
          if (0 === r.length) {
            this.#eI < e - 60 && (this.#eI = e - 60);
            return;
          }
          for (let e of r)
            this.#en.emit(this.#A, e), (this.#eI = e.blockNumber);
        }
        start() {
          this.#eo ||
            ((this.#eo = !0),
            -2 === this.#eI &&
              this.#en.getBlockNumber().then((e) => {
                this.#eI = e;
              }),
            this.#en.on("block", this.#ea));
        }
        stop() {
          this.#eo && ((this.#eo = !1), this.#en.off("block", this.#ea));
        }
        pause(e) {
          this.stop(), e && (this.#eI = -2);
        }
        resume() {
          this.start();
        }
      }
    },
    22086: function (e, t, r) {
      "use strict";
      r.d(t, {
        z: function () {
          return o;
        },
      });
      var i = r(70587),
        n = r(35157),
        s = r(59369);
      function a(e, t) {
        return {
          address: (0, i.K)(e),
          storageKeys: t.map(
            (e, t) => (
              (0, n.en)(
                (0, s.A7)(e, 32),
                "invalid slot",
                `storageKeys[${t}]`,
                e
              ),
              e.toLowerCase()
            )
          ),
        };
      }
      function o(e) {
        if (Array.isArray(e))
          return e.map((t, r) =>
            Array.isArray(t)
              ? ((0, n.en)(
                  2 === t.length,
                  "invalid slot set",
                  `value[${r}]`,
                  t
                ),
                a(t[0], t[1]))
              : ((0, n.en)(
                  null != t && "object" == typeof t,
                  "invalid address-slot set",
                  "value",
                  e
                ),
                a(t.address, t.storageKeys))
          );
        (0, n.en)(
          null != e && "object" == typeof e,
          "invalid access list",
          "value",
          e
        );
        let t = Object.keys(e).map((t) => {
          let r = e[t].reduce((e, t) => ((e[t] = !0), e), {});
          return a(t, Object.keys(r).sort());
        });
        return t.sort((e, t) => e.address.localeCompare(t.address)), t;
      }
    },
    44250: function (e, t, r) {
      "use strict";
      r.d(t, {
        Y: function () {
          return e2;
        },
      });
      var i = {};
      r.r(i),
        r.d(i, {
          dQ: function () {
            return J;
          },
          ci: function () {
            return $;
          },
          bytesToNumberBE: function () {
            return q;
          },
          ty: function () {
            return V;
          },
          eV: function () {
            return Z;
          },
          n$: function () {
            return X;
          },
          ql: function () {
            return K;
          },
          hexToBytes: function () {
            return z;
          },
          tL: function () {
            return G;
          },
          S5: function () {
            return W;
          },
          FF: function () {
            return et;
          },
        });
      var n = r(70587),
        s = r(94552),
        a = r(25655),
        o = r(35891);
      class l extends o.kb {
        constructor(e, t, r, i) {
          super(),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.padOffset = r),
            (this.isLE = i),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.buffer = new Uint8Array(e)),
            (this.view = (0, o.GL)(this.buffer));
        }
        update(e) {
          (0, a.Gg)(this);
          let { view: t, buffer: r, blockLen: i } = this,
            n = (e = (0, o.O0)(e)).length;
          for (let s = 0; s < n; ) {
            let a = Math.min(i - this.pos, n - s);
            if (a === i) {
              let t = (0, o.GL)(e);
              for (; i <= n - s; s += i) this.process(t, s);
              continue;
            }
            r.set(e.subarray(s, s + a), this.pos),
              (this.pos += a),
              (s += a),
              this.pos === i && (this.process(t, 0), (this.pos = 0));
          }
          return (this.length += e.length), this.roundClean(), this;
        }
        digestInto(e) {
          (0, a.Gg)(this), (0, a.J8)(e, this), (this.finished = !0);
          let { buffer: t, view: r, blockLen: i, isLE: n } = this,
            { pos: s } = this;
          (t[s++] = 128),
            this.buffer.subarray(s).fill(0),
            this.padOffset > i - s && (this.process(r, 0), (s = 0));
          for (let e = s; e < i; e++) t[e] = 0;
          !(function (e, t, r, i) {
            if ("function" == typeof e.setBigUint64)
              return e.setBigUint64(t, r, i);
            let n = BigInt(32),
              s = BigInt(4294967295),
              a = Number((r >> n) & s),
              o = Number(r & s),
              l = i ? 4 : 0,
              c = i ? 0 : 4;
            e.setUint32(t + l, a, i), e.setUint32(t + c, o, i);
          })(r, i - 8, BigInt(8 * this.length), n),
            this.process(r, 0);
          let l = (0, o.GL)(e),
            c = this.outputLen;
          if (c % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
          let u = c / 4,
            h = this.get();
          if (u > h.length) throw Error("_sha2: outputLen bigger than state");
          for (let e = 0; e < u; e++) l.setUint32(4 * e, h[e], n);
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          let {
            blockLen: t,
            buffer: r,
            length: i,
            finished: n,
            destroyed: s,
            pos: a,
          } = this;
          return (
            (e.length = i),
            (e.pos = a),
            (e.finished = n),
            (e.destroyed = s),
            i % t && e.buffer.set(r),
            e
          );
        }
      }
      let c = (e, t, r) => (e & t) ^ (~e & r),
        u = (e, t, r) => (e & t) ^ (e & r) ^ (t & r),
        h = new Uint32Array([
          1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
          2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
          1925078388, 2162078206, 2614888103, 3248222580, 3835390401,
          4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692,
          1996064986, 2554220882, 2821834349, 2952996808, 3210313671,
          3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912,
          1294757372, 1396182291, 1695183700, 1986661051, 2177026350,
          2456956037, 2730485921, 2820302411, 3259730800, 3345764771,
          3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616,
          659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
          1955562222, 2024104815, 2227730452, 2361852424, 2428436474,
          2756734187, 3204031479, 3329325298,
        ]),
        d = new Uint32Array([
          1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
          2600822924, 528734635, 1541459225,
        ]),
        p = new Uint32Array(64);
      class f extends l {
        constructor() {
          super(64, 32, 8, !1),
            (this.A = 0 | d[0]),
            (this.B = 0 | d[1]),
            (this.C = 0 | d[2]),
            (this.D = 0 | d[3]),
            (this.E = 0 | d[4]),
            (this.F = 0 | d[5]),
            (this.G = 0 | d[6]),
            (this.H = 0 | d[7]);
        }
        get() {
          let { A: e, B: t, C: r, D: i, E: n, F: s, G: a, H: o } = this;
          return [e, t, r, i, n, s, a, o];
        }
        set(e, t, r, i, n, s, a, o) {
          (this.A = 0 | e),
            (this.B = 0 | t),
            (this.C = 0 | r),
            (this.D = 0 | i),
            (this.E = 0 | n),
            (this.F = 0 | s),
            (this.G = 0 | a),
            (this.H = 0 | o);
        }
        process(e, t) {
          for (let r = 0; r < 16; r++, t += 4) p[r] = e.getUint32(t, !1);
          for (let e = 16; e < 64; e++) {
            let t = p[e - 15],
              r = p[e - 2],
              i = (0, o.np)(t, 7) ^ (0, o.np)(t, 18) ^ (t >>> 3),
              n = (0, o.np)(r, 17) ^ (0, o.np)(r, 19) ^ (r >>> 10);
            p[e] = (n + p[e - 7] + i + p[e - 16]) | 0;
          }
          let { A: r, B: i, C: n, D: s, E: a, F: l, G: d, H: f } = this;
          for (let e = 0; e < 64; e++) {
            let t =
                (f +
                  ((0, o.np)(a, 6) ^ (0, o.np)(a, 11) ^ (0, o.np)(a, 25)) +
                  c(a, l, d) +
                  h[e] +
                  p[e]) |
                0,
              g =
                (((0, o.np)(r, 2) ^ (0, o.np)(r, 13) ^ (0, o.np)(r, 22)) +
                  u(r, i, n)) |
                0;
            (f = d),
              (d = l),
              (l = a),
              (a = (s + t) | 0),
              (s = n),
              (n = i),
              (i = r),
              (r = (t + g) | 0);
          }
          (r = (r + this.A) | 0),
            (i = (i + this.B) | 0),
            (n = (n + this.C) | 0),
            (s = (s + this.D) | 0),
            (a = (a + this.E) | 0),
            (l = (l + this.F) | 0),
            (d = (d + this.G) | 0),
            (f = (f + this.H) | 0),
            this.set(r, i, n, s, a, l, d, f);
        }
        roundClean() {
          p.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
        }
      }
      let g = (0, o.hE)(() => new f());
      var m = r(64450);
      let [y, w] = m.ZP.split(
          [
            "0x428a2f98d728ae22",
            "0x7137449123ef65cd",
            "0xb5c0fbcfec4d3b2f",
            "0xe9b5dba58189dbbc",
            "0x3956c25bf348b538",
            "0x59f111f1b605d019",
            "0x923f82a4af194f9b",
            "0xab1c5ed5da6d8118",
            "0xd807aa98a3030242",
            "0x12835b0145706fbe",
            "0x243185be4ee4b28c",
            "0x550c7dc3d5ffb4e2",
            "0x72be5d74f27b896f",
            "0x80deb1fe3b1696b1",
            "0x9bdc06a725c71235",
            "0xc19bf174cf692694",
            "0xe49b69c19ef14ad2",
            "0xefbe4786384f25e3",
            "0x0fc19dc68b8cd5b5",
            "0x240ca1cc77ac9c65",
            "0x2de92c6f592b0275",
            "0x4a7484aa6ea6e483",
            "0x5cb0a9dcbd41fbd4",
            "0x76f988da831153b5",
            "0x983e5152ee66dfab",
            "0xa831c66d2db43210",
            "0xb00327c898fb213f",
            "0xbf597fc7beef0ee4",
            "0xc6e00bf33da88fc2",
            "0xd5a79147930aa725",
            "0x06ca6351e003826f",
            "0x142929670a0e6e70",
            "0x27b70a8546d22ffc",
            "0x2e1b21385c26c926",
            "0x4d2c6dfc5ac42aed",
            "0x53380d139d95b3df",
            "0x650a73548baf63de",
            "0x766a0abb3c77b2a8",
            "0x81c2c92e47edaee6",
            "0x92722c851482353b",
            "0xa2bfe8a14cf10364",
            "0xa81a664bbc423001",
            "0xc24b8b70d0f89791",
            "0xc76c51a30654be30",
            "0xd192e819d6ef5218",
            "0xd69906245565a910",
            "0xf40e35855771202a",
            "0x106aa07032bbd1b8",
            "0x19a4c116b8d2d0c8",
            "0x1e376c085141ab53",
            "0x2748774cdf8eeb99",
            "0x34b0bcb5e19b48a8",
            "0x391c0cb3c5c95a63",
            "0x4ed8aa4ae3418acb",
            "0x5b9cca4f7763e373",
            "0x682e6ff3d6b2b8a3",
            "0x748f82ee5defb2fc",
            "0x78a5636f43172f60",
            "0x84c87814a1f0ab72",
            "0x8cc702081a6439ec",
            "0x90befffa23631e28",
            "0xa4506cebde82bde9",
            "0xbef9a3f7b2c67915",
            "0xc67178f2e372532b",
            "0xca273eceea26619c",
            "0xd186b8c721c0c207",
            "0xeada7dd6cde0eb1e",
            "0xf57d4f7fee6ed178",
            "0x06f067aa72176fba",
            "0x0a637dc5a2c898a6",
            "0x113f9804bef90dae",
            "0x1b710b35131c471b",
            "0x28db77f523047d84",
            "0x32caab7b40c72493",
            "0x3c9ebe0a15c9bebc",
            "0x431d67c49c100d4c",
            "0x4cc5d4becb3e42b6",
            "0x597f299cfc657e2a",
            "0x5fcb6fab3ad6faec",
            "0x6c44198c4a475817",
          ].map((e) => BigInt(e))
        ),
        b = new Uint32Array(80),
        v = new Uint32Array(80);
      class E extends l {
        constructor() {
          super(128, 64, 16, !1),
            (this.Ah = 1779033703),
            (this.Al = -205731576),
            (this.Bh = -1150833019),
            (this.Bl = -2067093701),
            (this.Ch = 1013904242),
            (this.Cl = -23791573),
            (this.Dh = -1521486534),
            (this.Dl = 1595750129),
            (this.Eh = 1359893119),
            (this.El = -1377402159),
            (this.Fh = -1694144372),
            (this.Fl = 725511199),
            (this.Gh = 528734635),
            (this.Gl = -79577749),
            (this.Hh = 1541459225),
            (this.Hl = 327033209);
        }
        get() {
          let {
            Ah: e,
            Al: t,
            Bh: r,
            Bl: i,
            Ch: n,
            Cl: s,
            Dh: a,
            Dl: o,
            Eh: l,
            El: c,
            Fh: u,
            Fl: h,
            Gh: d,
            Gl: p,
            Hh: f,
            Hl: g,
          } = this;
          return [e, t, r, i, n, s, a, o, l, c, u, h, d, p, f, g];
        }
        set(e, t, r, i, n, s, a, o, l, c, u, h, d, p, f, g) {
          (this.Ah = 0 | e),
            (this.Al = 0 | t),
            (this.Bh = 0 | r),
            (this.Bl = 0 | i),
            (this.Ch = 0 | n),
            (this.Cl = 0 | s),
            (this.Dh = 0 | a),
            (this.Dl = 0 | o),
            (this.Eh = 0 | l),
            (this.El = 0 | c),
            (this.Fh = 0 | u),
            (this.Fl = 0 | h),
            (this.Gh = 0 | d),
            (this.Gl = 0 | p),
            (this.Hh = 0 | f),
            (this.Hl = 0 | g);
        }
        process(e, t) {
          for (let r = 0; r < 16; r++, t += 4)
            (b[r] = e.getUint32(t)), (v[r] = e.getUint32((t += 4)));
          for (let e = 16; e < 80; e++) {
            let t = 0 | b[e - 15],
              r = 0 | v[e - 15],
              i =
                m.ZP.rotrSH(t, r, 1) ^
                m.ZP.rotrSH(t, r, 8) ^
                m.ZP.shrSH(t, r, 7),
              n =
                m.ZP.rotrSL(t, r, 1) ^
                m.ZP.rotrSL(t, r, 8) ^
                m.ZP.shrSL(t, r, 7),
              s = 0 | b[e - 2],
              a = 0 | v[e - 2],
              o =
                m.ZP.rotrSH(s, a, 19) ^
                m.ZP.rotrBH(s, a, 61) ^
                m.ZP.shrSH(s, a, 6),
              l =
                m.ZP.rotrSL(s, a, 19) ^
                m.ZP.rotrBL(s, a, 61) ^
                m.ZP.shrSL(s, a, 6),
              c = m.ZP.add4L(n, l, v[e - 7], v[e - 16]),
              u = m.ZP.add4H(c, i, o, b[e - 7], b[e - 16]);
            (b[e] = 0 | u), (v[e] = 0 | c);
          }
          let {
            Ah: r,
            Al: i,
            Bh: n,
            Bl: s,
            Ch: a,
            Cl: o,
            Dh: l,
            Dl: c,
            Eh: u,
            El: h,
            Fh: d,
            Fl: p,
            Gh: f,
            Gl: g,
            Hh: E,
            Hl: A,
          } = this;
          for (let e = 0; e < 80; e++) {
            let t =
                m.ZP.rotrSH(u, h, 14) ^
                m.ZP.rotrSH(u, h, 18) ^
                m.ZP.rotrBH(u, h, 41),
              C =
                m.ZP.rotrSL(u, h, 14) ^
                m.ZP.rotrSL(u, h, 18) ^
                m.ZP.rotrBL(u, h, 41),
              _ = (u & d) ^ (~u & f),
              I = (h & p) ^ (~h & g),
              N = m.ZP.add5L(A, C, I, w[e], v[e]),
              S = m.ZP.add5H(N, E, t, _, y[e], b[e]),
              T = 0 | N,
              P =
                m.ZP.rotrSH(r, i, 28) ^
                m.ZP.rotrBH(r, i, 34) ^
                m.ZP.rotrBH(r, i, 39),
              O =
                m.ZP.rotrSL(r, i, 28) ^
                m.ZP.rotrBL(r, i, 34) ^
                m.ZP.rotrBL(r, i, 39),
              x = (r & n) ^ (r & a) ^ (n & a),
              k = (i & s) ^ (i & o) ^ (s & o);
            (E = 0 | f),
              (A = 0 | g),
              (f = 0 | d),
              (g = 0 | p),
              (d = 0 | u),
              (p = 0 | h),
              ({ h: u, l: h } = m.ZP.add(0 | l, 0 | c, 0 | S, 0 | T)),
              (l = 0 | a),
              (c = 0 | o),
              (a = 0 | n),
              (o = 0 | s),
              (n = 0 | r),
              (s = 0 | i);
            let R = m.ZP.add3L(T, O, k);
            (r = m.ZP.add3H(R, S, P, x)), (i = 0 | R);
          }
          ({ h: r, l: i } = m.ZP.add(0 | this.Ah, 0 | this.Al, 0 | r, 0 | i)),
            ({ h: n, l: s } = m.ZP.add(0 | this.Bh, 0 | this.Bl, 0 | n, 0 | s)),
            ({ h: a, l: o } = m.ZP.add(0 | this.Ch, 0 | this.Cl, 0 | a, 0 | o)),
            ({ h: l, l: c } = m.ZP.add(0 | this.Dh, 0 | this.Dl, 0 | l, 0 | c)),
            ({ h: u, l: h } = m.ZP.add(0 | this.Eh, 0 | this.El, 0 | u, 0 | h)),
            ({ h: d, l: p } = m.ZP.add(0 | this.Fh, 0 | this.Fl, 0 | d, 0 | p)),
            ({ h: f, l: g } = m.ZP.add(0 | this.Gh, 0 | this.Gl, 0 | f, 0 | g)),
            ({ h: E, l: A } = m.ZP.add(0 | this.Hh, 0 | this.Hl, 0 | E, 0 | A)),
            this.set(r, i, n, s, a, o, l, c, u, h, d, p, f, g, E, A);
        }
        roundClean() {
          b.fill(0), v.fill(0);
        }
        destroy() {
          this.buffer.fill(0),
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      }
      let A = (0, o.hE)(() => new E());
      var C = r(35157);
      let _ = (function () {
        if ("undefined" != typeof self) return self;
        if ("undefined" != typeof window) return window;
        if ("undefined" != typeof global) return global;
        throw Error("unable to locate global object");
      })();
      function I(e) {
        switch (e) {
          case "sha256":
            return g.create();
          case "sha512":
            return A.create();
        }
        (0, C.en)(!1, "invalid hashing algorithm name", "algorithm", e);
      }
      _.crypto || _.msCrypto;
      var N = r(59369);
      let S = function (e) {
          return I("sha256").update(e).digest();
        },
        T = function (e) {
          return I("sha512").update(e).digest();
        },
        P = S,
        O = T,
        x = !1,
        k = !1;
      function R(e) {
        let t = (0, N.Pw)(e, "data");
        return (0, N.Dv)(P(t));
      }
      function D(e) {
        let t = (0, N.Pw)(e, "data");
        return (0, N.Dv)(O(t));
      }
      (R._ = S),
        (R.lock = function () {
          x = !0;
        }),
        (R.register = function (e) {
          if (x) throw Error("sha256 is locked");
          P = e;
        }),
        Object.freeze(R),
        (D._ = T),
        (D.lock = function () {
          k = !0;
        }),
        (D.register = function (e) {
          if (k) throw Error("sha512 is locked");
          O = e;
        }),
        Object.freeze(R);
      var U = r(61188),
        L = r(19066);
      BigInt(0);
      let M = BigInt(1),
        B = BigInt(2),
        j = (e) => e instanceof Uint8Array,
        F = Array.from({ length: 256 }, (e, t) =>
          t.toString(16).padStart(2, "0")
        );
      function $(e) {
        if (!j(e)) throw Error("Uint8Array expected");
        let t = "";
        for (let r = 0; r < e.length; r++) t += F[e[r]];
        return t;
      }
      function H(e) {
        if ("string" != typeof e)
          throw Error("hex string expected, got " + typeof e);
        return BigInt("" === e ? "0" : `0x${e}`);
      }
      function z(e) {
        if ("string" != typeof e)
          throw Error("hex string expected, got " + typeof e);
        let t = e.length;
        if (t % 2)
          throw Error(
            "padded hex string expected, got unpadded hex of length " + t
          );
        let r = new Uint8Array(t / 2);
        for (let t = 0; t < r.length; t++) {
          let i = 2 * t,
            n = Number.parseInt(e.slice(i, i + 2), 16);
          if (Number.isNaN(n) || n < 0) throw Error("Invalid byte sequence");
          r[t] = n;
        }
        return r;
      }
      function q(e) {
        return H($(e));
      }
      function V(e) {
        if (!j(e)) throw Error("Uint8Array expected");
        return H($(Uint8Array.from(e).reverse()));
      }
      function G(e, t) {
        return z(e.toString(16).padStart(2 * t, "0"));
      }
      function W(e, t) {
        return G(e, t).reverse();
      }
      function K(e, t, r) {
        let i;
        if ("string" == typeof t)
          try {
            i = z(t);
          } catch (r) {
            throw Error(
              `${e} must be valid hex string, got "${t}". Cause: ${r}`
            );
          }
        else if (j(t)) i = Uint8Array.from(t);
        else throw Error(`${e} must be hex string or Uint8Array`);
        let n = i.length;
        if ("number" == typeof r && n !== r)
          throw Error(`${e} expected ${r} bytes, got ${n}`);
        return i;
      }
      function Z(...e) {
        let t = new Uint8Array(e.reduce((e, t) => e + t.length, 0)),
          r = 0;
        return (
          e.forEach((e) => {
            if (!j(e)) throw Error("Uint8Array expected");
            t.set(e, r), (r += e.length);
          }),
          t
        );
      }
      let J = (e) => (B << BigInt(e - 1)) - M,
        Q = (e) => new Uint8Array(e),
        Y = (e) => Uint8Array.from(e);
      function X(e, t, r) {
        if ("number" != typeof e || e < 2)
          throw Error("hashLen must be a number");
        if ("number" != typeof t || t < 2)
          throw Error("qByteLen must be a number");
        if ("function" != typeof r) throw Error("hmacFn must be a function");
        let i = Q(e),
          n = Q(e),
          s = 0,
          a = () => {
            i.fill(1), n.fill(0), (s = 0);
          },
          o = (...e) => r(n, i, ...e),
          l = (e = Q()) => {
            (n = o(Y([0]), e)),
              (i = o()),
              0 !== e.length && ((n = o(Y([1]), e)), (i = o()));
          },
          c = () => {
            if (s++ >= 1e3) throw Error("drbg: tried 1000 values");
            let e = 0,
              r = [];
            for (; e < t; ) {
              let t = (i = o()).slice();
              r.push(t), (e += i.length);
            }
            return Z(...r);
          };
        return (e, t) => {
          let r;
          for (a(), l(e); !(r = t(c())); ) l();
          return a(), r;
        };
      }
      let ee = {
        bigint: (e) => "bigint" == typeof e,
        function: (e) => "function" == typeof e,
        boolean: (e) => "boolean" == typeof e,
        string: (e) => "string" == typeof e,
        stringOrUint8Array: (e) =>
          "string" == typeof e || e instanceof Uint8Array,
        isSafeInteger: (e) => Number.isSafeInteger(e),
        array: (e) => Array.isArray(e),
        field: (e, t) => t.Fp.isValid(e),
        hash: (e) =>
          "function" == typeof e && Number.isSafeInteger(e.outputLen),
      };
      function et(e, t, r = {}) {
        let i = (t, r, i) => {
          let n = ee[r];
          if ("function" != typeof n)
            throw Error(`Invalid validator "${r}", expected function`);
          let s = e[t];
          if ((!i || void 0 !== s) && !n(s, e))
            throw Error(
              `Invalid param ${String(t)}=${s} (${typeof s}), expected ${r}`
            );
        };
        for (let [e, r] of Object.entries(t)) i(e, r, !1);
        for (let [e, t] of Object.entries(r)) i(e, t, !0);
        return e;
      }
      let er = BigInt(0),
        ei = BigInt(1),
        en = BigInt(2),
        es = BigInt(3),
        ea = BigInt(4),
        eo = BigInt(5),
        el = BigInt(8);
      function ec(e, t) {
        let r = e % t;
        return r >= er ? r : t + r;
      }
      function eu(e, t, r) {
        let i = e;
        for (; t-- > er; ) (i *= i), (i %= r);
        return i;
      }
      function eh(e, t) {
        if (e === er || t <= er)
          throw Error(
            `invert: expected positive integers, got n=${e} mod=${t}`
          );
        let r = ec(e, t),
          i = t,
          n = er,
          s = ei,
          a = ei,
          o = er;
        for (; r !== er; ) {
          let e = i / r,
            t = i % r,
            l = n - a * e,
            c = s - o * e;
          (i = r), (r = t), (n = a), (s = o), (a = l), (o = c);
        }
        if (i !== ei) throw Error("invert: does not exist");
        return ec(n, t);
      }
      BigInt(9), BigInt(16);
      let ed = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN",
      ];
      function ep(e, t) {
        let r = void 0 !== t ? t : e.toString(2).length;
        return { nBitLength: r, nByteLength: Math.ceil(r / 8) };
      }
      function ef(e) {
        if ("bigint" != typeof e) throw Error("field order must be bigint");
        return Math.ceil(e.toString(2).length / 8);
      }
      function eg(e) {
        let t = ef(e);
        return t + Math.ceil(t / 2);
      }
      class em extends o.kb {
        constructor(e, t) {
          super(), (this.finished = !1), (this.destroyed = !1), (0, a.vp)(e);
          let r = (0, o.O0)(t);
          if (
            ((this.iHash = e.create()), "function" != typeof this.iHash.update)
          )
            throw Error("Expected instance of class which extends utils.Hash");
          (this.blockLen = this.iHash.blockLen),
            (this.outputLen = this.iHash.outputLen);
          let i = this.blockLen,
            n = new Uint8Array(i);
          n.set(r.length > i ? e.create().update(r).digest() : r);
          for (let e = 0; e < n.length; e++) n[e] ^= 54;
          this.iHash.update(n), (this.oHash = e.create());
          for (let e = 0; e < n.length; e++) n[e] ^= 106;
          this.oHash.update(n), n.fill(0);
        }
        update(e) {
          return (0, a.Gg)(this), this.iHash.update(e), this;
        }
        digestInto(e) {
          (0, a.Gg)(this),
            (0, a.aI)(e, this.outputLen),
            (this.finished = !0),
            this.iHash.digestInto(e),
            this.oHash.update(e),
            this.oHash.digestInto(e),
            this.destroy();
        }
        digest() {
          let e = new Uint8Array(this.oHash.outputLen);
          return this.digestInto(e), e;
        }
        _cloneInto(e) {
          e || (e = Object.create(Object.getPrototypeOf(this), {}));
          let {
            oHash: t,
            iHash: r,
            finished: i,
            destroyed: n,
            blockLen: s,
            outputLen: a,
          } = this;
          return (
            (e.finished = i),
            (e.destroyed = n),
            (e.blockLen = s),
            (e.outputLen = a),
            (e.oHash = t._cloneInto(e.oHash)),
            (e.iHash = r._cloneInto(e.iHash)),
            e
          );
        }
        destroy() {
          (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
        }
      }
      let ey = (e, t, r) => new em(e, t).update(r).digest();
      ey.create = (e, t) => new em(e, t);
      let ew = BigInt(0),
        eb = BigInt(1);
      function ev(e) {
        return (
          et(
            e.Fp,
            ed.reduce((e, t) => ((e[t] = "function"), e), {
              ORDER: "bigint",
              MASK: "bigint",
              BYTES: "isSafeInteger",
              BITS: "isSafeInteger",
            })
          ),
          et(
            e,
            { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
            { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
          ),
          Object.freeze({ ...ep(e.n, e.nBitLength), ...e, p: e.Fp.ORDER })
        );
      }
      let { bytesToNumberBE: eE, hexToBytes: eA } = i,
        eC = {
          Err: class extends Error {
            constructor(e = "") {
              super(e);
            }
          },
          _parseInt(e) {
            let { Err: t } = eC;
            if (e.length < 2 || 2 !== e[0])
              throw new t("Invalid signature integer tag");
            let r = e[1],
              i = e.subarray(2, r + 2);
            if (!r || i.length !== r)
              throw new t("Invalid signature integer: wrong length");
            if (128 & i[0]) throw new t("Invalid signature integer: negative");
            if (0 === i[0] && !(128 & i[1]))
              throw new t(
                "Invalid signature integer: unnecessary leading zero"
              );
            return { d: eE(i), l: e.subarray(r + 2) };
          },
          toSig(e) {
            let { Err: t } = eC,
              r = "string" == typeof e ? eA(e) : e;
            if (!(r instanceof Uint8Array)) throw Error("ui8a expected");
            let i = r.length;
            if (i < 2 || 48 != r[0]) throw new t("Invalid signature tag");
            if (r[1] !== i - 2)
              throw new t("Invalid signature: incorrect length");
            let { d: n, l: s } = eC._parseInt(r.subarray(2)),
              { d: a, l: o } = eC._parseInt(s);
            if (o.length)
              throw new t("Invalid signature: left bytes after parsing");
            return { r: n, s: a };
          },
          hexFromSig(e) {
            let t = (e) => (8 & Number.parseInt(e[0], 16) ? "00" + e : e),
              r = (e) => {
                let t = e.toString(16);
                return 1 & t.length ? `0${t}` : t;
              },
              i = t(r(e.s)),
              n = t(r(e.r)),
              s = i.length / 2,
              a = n.length / 2,
              o = r(s),
              l = r(a);
            return `30${r(a + s + 4)}02${l}${n}02${o}${i}`;
          },
        },
        e_ = BigInt(0),
        eI = BigInt(1),
        eN = (BigInt(2), BigInt(3));
      BigInt(4);
      let eS = BigInt(
          "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
        ),
        eT = BigInt(
          "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
        ),
        eP = BigInt(1),
        eO = BigInt(2),
        ex = (e, t) => (e + t / eO) / t,
        ek = (function (e, t, r = !1, i = {}) {
          if (e <= er) throw Error(`Expected Field ORDER > 0, got ${e}`);
          let { nBitLength: n, nByteLength: s } = ep(e, t);
          if (s > 2048)
            throw Error("Field lengths over 2048 bytes are not supported");
          let a = (function (e) {
              if (e % ea === es) {
                let t = (e + ei) / ea;
                return function (e, r) {
                  let i = e.pow(r, t);
                  if (!e.eql(e.sqr(i), r))
                    throw Error("Cannot find square root");
                  return i;
                };
              }
              if (e % el === eo) {
                let t = (e - eo) / el;
                return function (e, r) {
                  let i = e.mul(r, en),
                    n = e.pow(i, t),
                    s = e.mul(r, n),
                    a = e.mul(e.mul(s, en), n),
                    o = e.mul(s, e.sub(a, e.ONE));
                  if (!e.eql(e.sqr(o), r))
                    throw Error("Cannot find square root");
                  return o;
                };
              }
              return (function (e) {
                let t, r, i;
                let n = (e - ei) / en;
                for (t = e - ei, r = 0; t % en === er; t /= en, r++);
                for (
                  i = en;
                  i < e &&
                  (function (e, t, r) {
                    if (r <= er || t < er)
                      throw Error("Expected power/modulo > 0");
                    if (r === ei) return er;
                    let i = ei;
                    for (; t > er; )
                      t & ei && (i = (i * e) % r),
                        (e = (e * e) % r),
                        (t >>= ei);
                    return i;
                  })(i, n, e) !==
                    e - ei;
                  i++
                );
                if (1 === r) {
                  let t = (e + ei) / ea;
                  return function (e, r) {
                    let i = e.pow(r, t);
                    if (!e.eql(e.sqr(i), r))
                      throw Error("Cannot find square root");
                    return i;
                  };
                }
                let s = (t + ei) / en;
                return function (e, a) {
                  if (e.pow(a, n) === e.neg(e.ONE))
                    throw Error("Cannot find square root");
                  let o = r,
                    l = e.pow(e.mul(e.ONE, i), t),
                    c = e.pow(a, s),
                    u = e.pow(a, t);
                  for (; !e.eql(u, e.ONE); ) {
                    if (e.eql(u, e.ZERO)) return e.ZERO;
                    let t = 1;
                    for (let r = e.sqr(u); t < o && !e.eql(r, e.ONE); t++)
                      r = e.sqr(r);
                    let r = e.pow(l, ei << BigInt(o - t - 1));
                    (l = e.sqr(r)),
                      (c = e.mul(c, r)),
                      (u = e.mul(u, l)),
                      (o = t);
                  }
                  return c;
                };
              })(e);
            })(e),
            o = Object.freeze({
              ORDER: e,
              BITS: n,
              BYTES: s,
              MASK: J(n),
              ZERO: er,
              ONE: ei,
              create: (t) => ec(t, e),
              isValid: (t) => {
                if ("bigint" != typeof t)
                  throw Error(
                    `Invalid field element: expected bigint, got ${typeof t}`
                  );
                return er <= t && t < e;
              },
              is0: (e) => e === er,
              isOdd: (e) => (e & ei) === ei,
              neg: (t) => ec(-t, e),
              eql: (e, t) => e === t,
              sqr: (t) => ec(t * t, e),
              add: (t, r) => ec(t + r, e),
              sub: (t, r) => ec(t - r, e),
              mul: (t, r) => ec(t * r, e),
              pow: (e, t) =>
                (function (e, t, r) {
                  if (r < er) throw Error("Expected power > 0");
                  if (r === er) return e.ONE;
                  if (r === ei) return t;
                  let i = e.ONE,
                    n = t;
                  for (; r > er; )
                    r & ei && (i = e.mul(i, n)), (n = e.sqr(n)), (r >>= ei);
                  return i;
                })(o, e, t),
              div: (t, r) => ec(t * eh(r, e), e),
              sqrN: (e) => e * e,
              addN: (e, t) => e + t,
              subN: (e, t) => e - t,
              mulN: (e, t) => e * t,
              inv: (t) => eh(t, e),
              sqrt: i.sqrt || ((e) => a(o, e)),
              invertBatch: (e) =>
                (function (e, t) {
                  let r = Array(t.length),
                    i = t.reduce(
                      (t, i, n) => (e.is0(i) ? t : ((r[n] = t), e.mul(t, i))),
                      e.ONE
                    ),
                    n = e.inv(i);
                  return (
                    t.reduceRight(
                      (t, i, n) =>
                        e.is0(i) ? t : ((r[n] = e.mul(t, r[n])), e.mul(t, i)),
                      n
                    ),
                    r
                  );
                })(o, e),
              cmov: (e, t, r) => (r ? t : e),
              toBytes: (e) => (r ? W(e, s) : G(e, s)),
              fromBytes: (e) => {
                if (e.length !== s)
                  throw Error(`Fp.fromBytes: expected ${s}, got ${e.length}`);
                return r ? V(e) : q(e);
              },
            });
          return Object.freeze(o);
        })(eS, void 0, void 0, {
          sqrt: function (e) {
            let t = BigInt(3),
              r = BigInt(6),
              i = BigInt(11),
              n = BigInt(22),
              s = BigInt(23),
              a = BigInt(44),
              o = BigInt(88),
              l = (e * e * e) % eS,
              c = (l * l * e) % eS,
              u = (eu(c, t, eS) * c) % eS,
              h = (eu(u, t, eS) * c) % eS,
              d = (eu(h, eO, eS) * l) % eS,
              p = (eu(d, i, eS) * d) % eS,
              f = (eu(p, n, eS) * p) % eS,
              g = (eu(f, a, eS) * f) % eS,
              m = (eu(g, o, eS) * g) % eS,
              y = (eu(m, a, eS) * f) % eS,
              w = (eu(y, t, eS) * c) % eS,
              b = (eu(w, s, eS) * p) % eS,
              v = (eu(b, r, eS) * l) % eS,
              E = eu(v, eO, eS);
            if (!ek.eql(ek.sqr(E), e)) throw Error("Cannot find square root");
            return E;
          },
        }),
        eR = (function (e, t) {
          let r = (t) =>
            (function (e) {
              let t = (function (e) {
                  let t = ev(e);
                  return (
                    et(
                      t,
                      {
                        hash: "hash",
                        hmac: "function",
                        randomBytes: "function",
                      },
                      {
                        bits2int: "function",
                        bits2int_modN: "function",
                        lowS: "boolean",
                      }
                    ),
                    Object.freeze({ lowS: !0, ...t })
                  );
                })(e),
                { Fp: r, n: i } = t,
                n = r.BYTES + 1,
                s = 2 * r.BYTES + 1;
              function a(e) {
                return ec(e, i);
              }
              let {
                  ProjectivePoint: o,
                  normPrivateKeyToScalar: l,
                  weierstrassEquation: c,
                  isWithinCurveOrder: u,
                } = (function (e) {
                  let t = (function (e) {
                      let t = ev(e);
                      et(
                        t,
                        { a: "field", b: "field" },
                        {
                          allowedPrivateKeyLengths: "array",
                          wrapPrivateKey: "boolean",
                          isTorsionFree: "function",
                          clearCofactor: "function",
                          allowInfinityPoint: "boolean",
                          fromBytes: "function",
                          toBytes: "function",
                        }
                      );
                      let { endo: r, Fp: i, a: n } = t;
                      if (r) {
                        if (!i.eql(n, i.ZERO))
                          throw Error(
                            "Endomorphism can only be defined for Koblitz curves that have a=0"
                          );
                        if (
                          "object" != typeof r ||
                          "bigint" != typeof r.beta ||
                          "function" != typeof r.splitScalar
                        )
                          throw Error(
                            "Expected endomorphism with beta: bigint and splitScalar: function"
                          );
                      }
                      return Object.freeze({ ...t });
                    })(e),
                    { Fp: r } = t,
                    i =
                      t.toBytes ||
                      ((e, t, i) => {
                        let n = t.toAffine();
                        return Z(
                          Uint8Array.from([4]),
                          r.toBytes(n.x),
                          r.toBytes(n.y)
                        );
                      }),
                    n =
                      t.fromBytes ||
                      ((e) => {
                        let t = e.subarray(1);
                        return {
                          x: r.fromBytes(t.subarray(0, r.BYTES)),
                          y: r.fromBytes(t.subarray(r.BYTES, 2 * r.BYTES)),
                        };
                      });
                  function s(e) {
                    let { a: i, b: n } = t,
                      s = r.sqr(e),
                      a = r.mul(s, e);
                    return r.add(r.add(a, r.mul(e, i)), n);
                  }
                  if (!r.eql(r.sqr(t.Gy), s(t.Gx)))
                    throw Error("bad generator point: equation left != right");
                  function a(e) {
                    return "bigint" == typeof e && e_ < e && e < t.n;
                  }
                  function o(e) {
                    if (!a(e))
                      throw Error(
                        "Expected valid bigint: 0 < bigint < curve.n"
                      );
                  }
                  function l(e) {
                    let r;
                    let {
                      allowedPrivateKeyLengths: i,
                      nByteLength: n,
                      wrapPrivateKey: s,
                      n: a,
                    } = t;
                    if (i && "bigint" != typeof e) {
                      if (
                        (e instanceof Uint8Array && (e = $(e)),
                        "string" != typeof e || !i.includes(e.length))
                      )
                        throw Error("Invalid key");
                      e = e.padStart(2 * n, "0");
                    }
                    try {
                      r = "bigint" == typeof e ? e : q(K("private key", e, n));
                    } catch (t) {
                      throw Error(
                        `private key must be ${n} bytes, hex or bigint, not ${typeof e}`
                      );
                    }
                    return s && (r = ec(r, a)), o(r), r;
                  }
                  let c = new Map();
                  function u(e) {
                    if (!(e instanceof h))
                      throw Error("ProjectivePoint expected");
                  }
                  class h {
                    constructor(e, t, i) {
                      if (
                        ((this.px = e),
                        (this.py = t),
                        (this.pz = i),
                        null == e || !r.isValid(e))
                      )
                        throw Error("x required");
                      if (null == t || !r.isValid(t)) throw Error("y required");
                      if (null == i || !r.isValid(i)) throw Error("z required");
                    }
                    static fromAffine(e) {
                      let { x: t, y: i } = e || {};
                      if (!e || !r.isValid(t) || !r.isValid(i))
                        throw Error("invalid affine point");
                      if (e instanceof h)
                        throw Error("projective point not allowed");
                      let n = (e) => r.eql(e, r.ZERO);
                      return n(t) && n(i) ? h.ZERO : new h(t, i, r.ONE);
                    }
                    get x() {
                      return this.toAffine().x;
                    }
                    get y() {
                      return this.toAffine().y;
                    }
                    static normalizeZ(e) {
                      let t = r.invertBatch(e.map((e) => e.pz));
                      return e
                        .map((e, r) => e.toAffine(t[r]))
                        .map(h.fromAffine);
                    }
                    static fromHex(e) {
                      let t = h.fromAffine(n(K("pointHex", e)));
                      return t.assertValidity(), t;
                    }
                    static fromPrivateKey(e) {
                      return h.BASE.multiply(l(e));
                    }
                    _setWindowSize(e) {
                      (this._WINDOW_SIZE = e), c.delete(this);
                    }
                    assertValidity() {
                      if (this.is0()) {
                        if (t.allowInfinityPoint && !r.is0(this.py)) return;
                        throw Error("bad point: ZERO");
                      }
                      let { x: e, y: i } = this.toAffine();
                      if (!r.isValid(e) || !r.isValid(i))
                        throw Error("bad point: x or y not FE");
                      let n = r.sqr(i),
                        a = s(e);
                      if (!r.eql(n, a))
                        throw Error("bad point: equation left != right");
                      if (!this.isTorsionFree())
                        throw Error("bad point: not in prime-order subgroup");
                    }
                    hasEvenY() {
                      let { y: e } = this.toAffine();
                      if (r.isOdd) return !r.isOdd(e);
                      throw Error("Field doesn't support isOdd");
                    }
                    equals(e) {
                      u(e);
                      let { px: t, py: i, pz: n } = this,
                        { px: s, py: a, pz: o } = e,
                        l = r.eql(r.mul(t, o), r.mul(s, n)),
                        c = r.eql(r.mul(i, o), r.mul(a, n));
                      return l && c;
                    }
                    negate() {
                      return new h(this.px, r.neg(this.py), this.pz);
                    }
                    double() {
                      let { a: e, b: i } = t,
                        n = r.mul(i, eN),
                        { px: s, py: a, pz: o } = this,
                        l = r.ZERO,
                        c = r.ZERO,
                        u = r.ZERO,
                        d = r.mul(s, s),
                        p = r.mul(a, a),
                        f = r.mul(o, o),
                        g = r.mul(s, a);
                      return (
                        (g = r.add(g, g)),
                        (u = r.mul(s, o)),
                        (u = r.add(u, u)),
                        (l = r.mul(e, u)),
                        (c = r.mul(n, f)),
                        (c = r.add(l, c)),
                        (l = r.sub(p, c)),
                        (c = r.add(p, c)),
                        (c = r.mul(l, c)),
                        (l = r.mul(g, l)),
                        (u = r.mul(n, u)),
                        (f = r.mul(e, f)),
                        (g = r.sub(d, f)),
                        (g = r.mul(e, g)),
                        (g = r.add(g, u)),
                        (u = r.add(d, d)),
                        (d = r.add(u, d)),
                        (d = r.add(d, f)),
                        (d = r.mul(d, g)),
                        (c = r.add(c, d)),
                        (f = r.mul(a, o)),
                        (f = r.add(f, f)),
                        (d = r.mul(f, g)),
                        (l = r.sub(l, d)),
                        (u = r.mul(f, p)),
                        (u = r.add(u, u)),
                        new h(l, c, (u = r.add(u, u)))
                      );
                    }
                    add(e) {
                      u(e);
                      let { px: i, py: n, pz: s } = this,
                        { px: a, py: o, pz: l } = e,
                        c = r.ZERO,
                        d = r.ZERO,
                        p = r.ZERO,
                        f = t.a,
                        g = r.mul(t.b, eN),
                        m = r.mul(i, a),
                        y = r.mul(n, o),
                        w = r.mul(s, l),
                        b = r.add(i, n),
                        v = r.add(a, o);
                      (b = r.mul(b, v)),
                        (v = r.add(m, y)),
                        (b = r.sub(b, v)),
                        (v = r.add(i, s));
                      let E = r.add(a, l);
                      return (
                        (v = r.mul(v, E)),
                        (E = r.add(m, w)),
                        (v = r.sub(v, E)),
                        (E = r.add(n, s)),
                        (c = r.add(o, l)),
                        (E = r.mul(E, c)),
                        (c = r.add(y, w)),
                        (E = r.sub(E, c)),
                        (p = r.mul(f, v)),
                        (c = r.mul(g, w)),
                        (p = r.add(c, p)),
                        (c = r.sub(y, p)),
                        (p = r.add(y, p)),
                        (d = r.mul(c, p)),
                        (y = r.add(m, m)),
                        (y = r.add(y, m)),
                        (w = r.mul(f, w)),
                        (v = r.mul(g, v)),
                        (y = r.add(y, w)),
                        (w = r.sub(m, w)),
                        (w = r.mul(f, w)),
                        (v = r.add(v, w)),
                        (m = r.mul(y, v)),
                        (d = r.add(d, m)),
                        (m = r.mul(E, v)),
                        (c = r.mul(b, c)),
                        (c = r.sub(c, m)),
                        (m = r.mul(b, y)),
                        (p = r.mul(E, p)),
                        new h(c, d, (p = r.add(p, m)))
                      );
                    }
                    subtract(e) {
                      return this.add(e.negate());
                    }
                    is0() {
                      return this.equals(h.ZERO);
                    }
                    wNAF(e) {
                      return p.wNAFCached(this, c, e, (e) => {
                        let t = r.invertBatch(e.map((e) => e.pz));
                        return e
                          .map((e, r) => e.toAffine(t[r]))
                          .map(h.fromAffine);
                      });
                    }
                    multiplyUnsafe(e) {
                      let i = h.ZERO;
                      if (e === e_) return i;
                      if ((o(e), e === eI)) return this;
                      let { endo: n } = t;
                      if (!n) return p.unsafeLadder(this, e);
                      let {
                          k1neg: s,
                          k1: a,
                          k2neg: l,
                          k2: c,
                        } = n.splitScalar(e),
                        u = i,
                        d = i,
                        f = this;
                      for (; a > e_ || c > e_; )
                        a & eI && (u = u.add(f)),
                          c & eI && (d = d.add(f)),
                          (f = f.double()),
                          (a >>= eI),
                          (c >>= eI);
                      return (
                        s && (u = u.negate()),
                        l && (d = d.negate()),
                        (d = new h(r.mul(d.px, n.beta), d.py, d.pz)),
                        u.add(d)
                      );
                    }
                    multiply(e) {
                      let i, n;
                      o(e);
                      let { endo: s } = t;
                      if (s) {
                        let {
                            k1neg: t,
                            k1: a,
                            k2neg: o,
                            k2: l,
                          } = s.splitScalar(e),
                          { p: c, f: u } = this.wNAF(a),
                          { p: d, f: f } = this.wNAF(l);
                        (c = p.constTimeNegate(t, c)),
                          (d = p.constTimeNegate(o, d)),
                          (d = new h(r.mul(d.px, s.beta), d.py, d.pz)),
                          (i = c.add(d)),
                          (n = u.add(f));
                      } else {
                        let { p: t, f: r } = this.wNAF(e);
                        (i = t), (n = r);
                      }
                      return h.normalizeZ([i, n])[0];
                    }
                    multiplyAndAddUnsafe(e, t, r) {
                      let i = h.BASE,
                        n = (e, t) =>
                          t !== e_ && t !== eI && e.equals(i)
                            ? e.multiply(t)
                            : e.multiplyUnsafe(t),
                        s = n(this, t).add(n(e, r));
                      return s.is0() ? void 0 : s;
                    }
                    toAffine(e) {
                      let { px: t, py: i, pz: n } = this,
                        s = this.is0();
                      null == e && (e = s ? r.ONE : r.inv(n));
                      let a = r.mul(t, e),
                        o = r.mul(i, e),
                        l = r.mul(n, e);
                      if (s) return { x: r.ZERO, y: r.ZERO };
                      if (!r.eql(l, r.ONE)) throw Error("invZ was invalid");
                      return { x: a, y: o };
                    }
                    isTorsionFree() {
                      let { h: e, isTorsionFree: r } = t;
                      if (e === eI) return !0;
                      if (r) return r(h, this);
                      throw Error(
                        "isTorsionFree() has not been declared for the elliptic curve"
                      );
                    }
                    clearCofactor() {
                      let { h: e, clearCofactor: r } = t;
                      return e === eI
                        ? this
                        : r
                        ? r(h, this)
                        : this.multiplyUnsafe(t.h);
                    }
                    toRawBytes(e = !0) {
                      return this.assertValidity(), i(h, this, e);
                    }
                    toHex(e = !0) {
                      return $(this.toRawBytes(e));
                    }
                  }
                  (h.BASE = new h(t.Gx, t.Gy, r.ONE)),
                    (h.ZERO = new h(r.ZERO, r.ONE, r.ZERO));
                  let d = t.nBitLength,
                    p = (function (e, t) {
                      let r = (e, t) => {
                          let r = t.negate();
                          return e ? r : t;
                        },
                        i = (e) => ({
                          windows: Math.ceil(t / e) + 1,
                          windowSize: 2 ** (e - 1),
                        });
                      return {
                        constTimeNegate: r,
                        unsafeLadder(t, r) {
                          let i = e.ZERO,
                            n = t;
                          for (; r > ew; )
                            r & eb && (i = i.add(n)),
                              (n = n.double()),
                              (r >>= eb);
                          return i;
                        },
                        precomputeWindow(e, t) {
                          let { windows: r, windowSize: n } = i(t),
                            s = [],
                            a = e,
                            o = a;
                          for (let e = 0; e < r; e++) {
                            (o = a), s.push(o);
                            for (let e = 1; e < n; e++)
                              (o = o.add(a)), s.push(o);
                            a = o.double();
                          }
                          return s;
                        },
                        wNAF(t, n, s) {
                          let { windows: a, windowSize: o } = i(t),
                            l = e.ZERO,
                            c = e.BASE,
                            u = BigInt(2 ** t - 1),
                            h = 2 ** t,
                            d = BigInt(t);
                          for (let e = 0; e < a; e++) {
                            let t = e * o,
                              i = Number(s & u);
                            (s >>= d), i > o && ((i -= h), (s += eb));
                            let a = t + Math.abs(i) - 1,
                              p = e % 2 != 0,
                              f = i < 0;
                            0 === i
                              ? (c = c.add(r(p, n[t])))
                              : (l = l.add(r(f, n[a])));
                          }
                          return { p: l, f: c };
                        },
                        wNAFCached(e, t, r, i) {
                          let n = e._WINDOW_SIZE || 1,
                            s = t.get(e);
                          return (
                            s ||
                              ((s = this.precomputeWindow(e, n)),
                              1 !== n && t.set(e, i(s))),
                            this.wNAF(n, s, r)
                          );
                        },
                      };
                    })(h, t.endo ? Math.ceil(d / 2) : d);
                  return {
                    CURVE: t,
                    ProjectivePoint: h,
                    normPrivateKeyToScalar: l,
                    weierstrassEquation: s,
                    isWithinCurveOrder: a,
                  };
                })({
                  ...t,
                  toBytes(e, t, i) {
                    let n = t.toAffine(),
                      s = r.toBytes(n.x),
                      a = Z;
                    return i
                      ? a(Uint8Array.from([t.hasEvenY() ? 2 : 3]), s)
                      : a(Uint8Array.from([4]), s, r.toBytes(n.y));
                  },
                  fromBytes(e) {
                    let t = e.length,
                      i = e[0],
                      a = e.subarray(1);
                    if (t === n && (2 === i || 3 === i)) {
                      let e = q(a);
                      if (!(e_ < e && e < r.ORDER))
                        throw Error("Point is not on curve");
                      let t = c(e),
                        n = r.sqrt(t);
                      return (
                        ((1 & i) == 1) != ((n & eI) === eI) && (n = r.neg(n)),
                        { x: e, y: n }
                      );
                    }
                    if (t === s && 4 === i)
                      return {
                        x: r.fromBytes(a.subarray(0, r.BYTES)),
                        y: r.fromBytes(a.subarray(r.BYTES, 2 * r.BYTES)),
                      };
                    throw Error(
                      `Point of length ${t} was invalid. Expected ${n} compressed bytes or ${s} uncompressed bytes`
                    );
                  },
                }),
                h = (e) => $(G(e, t.nByteLength)),
                d = (e, t, r) => q(e.slice(t, r));
              class p {
                constructor(e, t, r) {
                  (this.r = e),
                    (this.s = t),
                    (this.recovery = r),
                    this.assertValidity();
                }
                static fromCompact(e) {
                  let r = t.nByteLength;
                  return new p(
                    d((e = K("compactSignature", e, 2 * r)), 0, r),
                    d(e, r, 2 * r)
                  );
                }
                static fromDER(e) {
                  let { r: t, s: r } = eC.toSig(K("DER", e));
                  return new p(t, r);
                }
                assertValidity() {
                  if (!u(this.r)) throw Error("r must be 0 < r < CURVE.n");
                  if (!u(this.s)) throw Error("s must be 0 < s < CURVE.n");
                }
                addRecoveryBit(e) {
                  return new p(this.r, this.s, e);
                }
                recoverPublicKey(e) {
                  let { r: n, s, recovery: l } = this,
                    c = m(K("msgHash", e));
                  if (null == l || ![0, 1, 2, 3].includes(l))
                    throw Error("recovery id invalid");
                  let u = 2 === l || 3 === l ? n + t.n : n;
                  if (u >= r.ORDER) throw Error("recovery id 2 or 3 invalid");
                  let d = (1 & l) == 0 ? "02" : "03",
                    p = o.fromHex(d + h(u)),
                    f = eh(u, i),
                    g = a(-c * f),
                    y = a(s * f),
                    w = o.BASE.multiplyAndAddUnsafe(p, g, y);
                  if (!w) throw Error("point at infinify");
                  return w.assertValidity(), w;
                }
                hasHighS() {
                  return this.s > i >> eI;
                }
                normalizeS() {
                  return this.hasHighS()
                    ? new p(this.r, a(-this.s), this.recovery)
                    : this;
                }
                toDERRawBytes() {
                  return z(this.toDERHex());
                }
                toDERHex() {
                  return eC.hexFromSig({ r: this.r, s: this.s });
                }
                toCompactRawBytes() {
                  return z(this.toCompactHex());
                }
                toCompactHex() {
                  return h(this.r) + h(this.s);
                }
              }
              function f(e) {
                let t = e instanceof Uint8Array,
                  r = "string" == typeof e,
                  i = (t || r) && e.length;
                return t
                  ? i === n || i === s
                  : r
                  ? i === 2 * n || i === 2 * s
                  : e instanceof o;
              }
              let g =
                  t.bits2int ||
                  function (e) {
                    let r = q(e),
                      i = 8 * e.length - t.nBitLength;
                    return i > 0 ? r >> BigInt(i) : r;
                  },
                m =
                  t.bits2int_modN ||
                  function (e) {
                    return a(g(e));
                  },
                y = J(t.nBitLength);
              function w(e) {
                if ("bigint" != typeof e) throw Error("bigint expected");
                if (!(e_ <= e && e < y))
                  throw Error(`bigint expected < 2^${t.nBitLength}`);
                return G(e, t.nByteLength);
              }
              let b = { lowS: t.lowS, prehash: !1 },
                v = { lowS: t.lowS, prehash: !1 };
              return (
                o.BASE._setWindowSize(8),
                {
                  CURVE: t,
                  getPublicKey: function (e, t = !0) {
                    return o.fromPrivateKey(e).toRawBytes(t);
                  },
                  getSharedSecret: function (e, t, r = !0) {
                    if (f(e)) throw Error("first arg must be private key");
                    if (!f(t)) throw Error("second arg must be public key");
                    return o.fromHex(t).multiply(l(e)).toRawBytes(r);
                  },
                  sign: function (e, n, s = b) {
                    let { seed: c, k2sig: h } = (function (e, n, s = b) {
                      if (["recovered", "canonical"].some((e) => e in s))
                        throw Error("sign() legacy options not supported");
                      let { hash: c, randomBytes: h } = t,
                        { lowS: d, prehash: f, extraEntropy: y } = s;
                      null == d && (d = !0),
                        (e = K("msgHash", e)),
                        f && (e = K("prehashed msgHash", c(e)));
                      let v = m(e),
                        E = l(n),
                        A = [w(E), w(v)];
                      if (null != y) {
                        let e = !0 === y ? h(r.BYTES) : y;
                        A.push(K("extraEntropy", e));
                      }
                      return {
                        seed: Z(...A),
                        k2sig: function (e) {
                          let t = g(e);
                          if (!u(t)) return;
                          let r = eh(t, i),
                            n = o.BASE.multiply(t).toAffine(),
                            s = a(n.x);
                          if (s === e_) return;
                          let l = a(r * a(v + s * E));
                          if (l === e_) return;
                          let c = (n.x === s ? 0 : 2) | Number(n.y & eI),
                            h = l;
                          if (d && l > i >> eI)
                            (h = l > i >> eI ? a(-l) : l), (c ^= 1);
                          return new p(s, h, c);
                        },
                      };
                    })(e, n, s);
                    return X(t.hash.outputLen, t.nByteLength, t.hmac)(c, h);
                  },
                  verify: function (e, r, n, s = v) {
                    let l, c;
                    if (
                      ((r = K("msgHash", r)),
                      (n = K("publicKey", n)),
                      "strict" in s)
                    )
                      throw Error("options.strict was renamed to lowS");
                    let { lowS: u, prehash: h } = s;
                    try {
                      if ("string" == typeof e || e instanceof Uint8Array)
                        try {
                          c = p.fromDER(e);
                        } catch (t) {
                          if (!(t instanceof eC.Err)) throw t;
                          c = p.fromCompact(e);
                        }
                      else if (
                        "object" == typeof e &&
                        "bigint" == typeof e.r &&
                        "bigint" == typeof e.s
                      ) {
                        let { r: t, s: r } = e;
                        c = new p(t, r);
                      } else throw Error("PARSE");
                      l = o.fromHex(n);
                    } catch (e) {
                      if ("PARSE" === e.message)
                        throw Error(
                          "signature must be Signature instance, Uint8Array or hex string"
                        );
                      return !1;
                    }
                    if (u && c.hasHighS()) return !1;
                    h && (r = t.hash(r));
                    let { r: d, s: f } = c,
                      g = m(r),
                      y = eh(f, i),
                      w = a(g * y),
                      b = a(d * y),
                      E = o.BASE.multiplyAndAddUnsafe(l, w, b)?.toAffine();
                    return !!E && a(E.x) === d;
                  },
                  ProjectivePoint: o,
                  Signature: p,
                  utils: {
                    isValidPrivateKey(e) {
                      try {
                        return l(e), !0;
                      } catch (e) {
                        return !1;
                      }
                    },
                    normPrivateKeyToScalar: l,
                    randomPrivateKey: () => {
                      let e = eg(t.n);
                      return (function (e, t, r = !1) {
                        let i = e.length,
                          n = ef(t),
                          s = eg(t);
                        if (i < 16 || i < s || i > 1024)
                          throw Error(
                            `expected ${s}-1024 bytes of input, got ${i}`
                          );
                        let a = ec(r ? q(e) : V(e), t - ei) + ei;
                        return r ? W(a, n) : G(a, n);
                      })(t.randomBytes(e), t.n);
                    },
                    precompute: (e = 8, t = o.BASE) => (
                      t._setWindowSize(e), t.multiply(BigInt(3)), t
                    ),
                  },
                }
              );
            })({
              ...e,
              hash: t,
              hmac: (e, ...r) => ey(t, e, (0, o.eV)(...r)),
              randomBytes: o.O6,
            });
          return Object.freeze({ ...r(t), create: r });
        })(
          {
            a: BigInt(0),
            b: BigInt(7),
            Fp: ek,
            n: eT,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240"
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424"
            ),
            h: BigInt(1),
            lowS: !0,
            endo: {
              beta: BigInt(
                "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
              ),
              splitScalar: (e) => {
                let t = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                  r = -eP * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                  i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                  n = BigInt("0x100000000000000000000000000000000"),
                  s = ex(t * e, eT),
                  a = ex(-r * e, eT),
                  o = ec(e - s * t - a * i, eT),
                  l = ec(-s * r - a * t, eT),
                  c = o > n,
                  u = l > n;
                if ((c && (o = eT - o), u && (l = eT - l), o > n || l > n))
                  throw Error("splitScalar: Endomorphism failed, k=" + e);
                return { k1neg: c, k1: o, k2neg: u, k2: l };
              },
            },
          },
          g
        );
      BigInt(0), eR.ProjectivePoint;
      var eD = r(45474);
      class eU {
        #eP;
        constructor(e) {
          (0, C.en)(
            32 === (0, N.M5)(e),
            "invalid private key",
            "privateKey",
            "[REDACTED]"
          ),
            (this.#eP = (0, N.Dv)(e));
        }
        get privateKey() {
          return this.#eP;
        }
        get publicKey() {
          return eU.computePublicKey(this.#eP);
        }
        get compressedPublicKey() {
          return eU.computePublicKey(this.#eP, !0);
        }
        sign(e) {
          (0, C.en)(32 === (0, N.M5)(e), "invalid digest length", "digest", e);
          let t = eR.sign((0, N.h_)(e), (0, N.h_)(this.#eP), { lowS: !0 });
          return U.P.from({
            r: (0, eD.m9)(t.r, 32),
            s: (0, eD.m9)(t.s, 32),
            v: t.recovery ? 28 : 27,
          });
        }
        computeSharedSecret(e) {
          let t = eU.computePublicKey(e);
          return (0, N.Dv)(
            eR.getSharedSecret((0, N.h_)(this.#eP), (0, N.Pw)(t), !1)
          );
        }
        static computePublicKey(e, t) {
          let r = (0, N.Pw)(e, "key");
          if (32 === r.length) {
            let e = eR.getPublicKey(r, !!t);
            return (0, N.Dv)(e);
          }
          if (64 === r.length) {
            let e = new Uint8Array(65);
            (e[0] = 4), e.set(r, 1), (r = e);
          }
          let i = eR.ProjectivePoint.fromHex(r);
          return (0, N.Dv)(i.toRawBytes(t));
        }
        static recoverPublicKey(e, t) {
          (0, C.en)(32 === (0, N.M5)(e), "invalid digest length", "digest", e);
          let r = U.P.from(t),
            i = eR.Signature.fromCompact((0, N.h_)((0, N.zo)([r.r, r.s]))),
            n = (i = i.addRecoveryBit(r.yParity)).recoverPublicKey(
              (0, N.h_)(e)
            );
          return (
            (0, C.en)(
              null != n,
              "invalid signautre for digest",
              "signature",
              t
            ),
            "0x" + n.toHex(!1)
          );
        }
        static addPoints(e, t, r) {
          let i = eR.ProjectivePoint.fromHex(
              eU.computePublicKey(e).substring(2)
            ),
            n = eR.ProjectivePoint.fromHex(eU.computePublicKey(t).substring(2));
          return "0x" + i.add(n).toHex(!!r);
        }
      }
      function eL(e, t, r) {
        let i = 0;
        for (let n = 0; n < r; n++) i = 256 * i + e[t + n];
        return i;
      }
      function eM(e, t, r, i) {
        let n = [];
        for (; r < t + 1 + i; ) {
          let s = eB(e, r);
          n.push(s.result),
            (r += s.consumed),
            (0, C.hu)(
              r <= t + 1 + i,
              "child data too short",
              "BUFFER_OVERRUN",
              { buffer: e, length: i, offset: t }
            );
        }
        return { consumed: 1 + i, result: n };
      }
      function eB(e, t) {
        (0, C.hu)(0 !== e.length, "data too short", "BUFFER_OVERRUN", {
          buffer: e,
          length: 0,
          offset: 1,
        });
        let r = (t) => {
          (0, C.hu)(
            t <= e.length,
            "data short segment too short",
            "BUFFER_OVERRUN",
            { buffer: e, length: e.length, offset: t }
          );
        };
        if (e[t] >= 248) {
          let i = e[t] - 247;
          r(t + 1 + i);
          let n = eL(e, t + 1, i);
          return r(t + 1 + i + n), eM(e, t, t + 1 + i, i + n);
        }
        if (e[t] >= 192) {
          let i = e[t] - 192;
          return r(t + 1 + i), eM(e, t, t + 1, i);
        }
        if (e[t] >= 184) {
          let i = e[t] - 183;
          r(t + 1 + i);
          let n = eL(e, t + 1, i);
          r(t + 1 + i + n);
          let s = (0, N.Dv)(e.slice(t + 1 + i, t + 1 + i + n));
          return { consumed: 1 + i + n, result: s };
        }
        if (e[t] >= 128) {
          let i = e[t] - 128;
          r(t + 1 + i);
          let n = (0, N.Dv)(e.slice(t + 1, t + 1 + i));
          return { consumed: 1 + i, result: n };
        }
        return {
          consumed: 1,
          result: (function (e) {
            let t = e.toString(16);
            for (; t.length < 2; ) t = "0" + t;
            return "0x" + t;
          })(e[t]),
        };
      }
      function ej(e) {
        let t = (0, N.Pw)(e, "data"),
          r = eB(t, 0);
        return (
          (0, C.en)(
            r.consumed === t.length,
            "unexpected junk after rlp payload",
            "data",
            e
          ),
          r.result
        );
      }
      var eF = r(48996),
        e$ = r(22086);
      let eH = BigInt(0),
        ez = BigInt(2),
        eq = BigInt(27),
        eV = BigInt(28),
        eG = BigInt(35),
        eW = BigInt(
          "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        );
      function eK(e, t) {
        let r = e.toString(16);
        for (; r.length < 2; ) r = "0" + r;
        return "0x" + (r += R(t).substring(4));
      }
      function eZ(e) {
        return "0x" === e ? null : (0, n.K)(e);
      }
      function eJ(e, t) {
        try {
          return (0, e$.z)(e);
        } catch (r) {
          (0, C.en)(!1, r.message, t, e);
        }
      }
      function eQ(e, t) {
        return "0x" === e ? 0 : (0, eD.Dx)(e, t);
      }
      function eY(e, t) {
        if ("0x" === e) return eH;
        let r = (0, eD.yT)(e, t);
        return (0, C.en)(r <= eW, "value exceeds uint size", t, r), r;
      }
      function eX(e, t) {
        let r = (0, eD.yT)(e, "value"),
          i = (0, eD.ot)(r);
        return (0, C.en)(i.length <= 32, "value too large", `tx.${t}`, r), i;
      }
      function e0(e) {
        return (0, e$.z)(e).map((e) => [e.address, e.storageKeys]);
      }
      function e1(e, t) {
        let r;
        try {
          if (((r = eQ(t[0], "yParity")), 0 !== r && 1 !== r))
            throw Error("bad yParity");
        } catch (e) {
          (0, C.en)(!1, "invalid yParity", "yParity", t[0]);
        }
        let i = (0, N.U3)(t[1], 32),
          n = (0, N.U3)(t[2], 32),
          s = U.P.from({ r: i, s: n, yParity: r });
        e.signature = s;
      }
      class e2 {
        #eO;
        #ex;
        #r;
        #ek;
        #eR;
        #eD;
        #eU;
        #eL;
        #eM;
        #Y;
        #eB;
        #ej;
        #eF;
        #e$;
        #eH;
        #ez;
        get type() {
          return this.#eO;
        }
        set type(e) {
          switch (e) {
            case null:
              this.#eO = null;
              break;
            case 0:
            case "legacy":
              this.#eO = 0;
              break;
            case 1:
            case "berlin":
            case "eip-2930":
              this.#eO = 1;
              break;
            case 2:
            case "london":
            case "eip-1559":
              this.#eO = 2;
              break;
            case 3:
            case "cancun":
            case "eip-4844":
              this.#eO = 3;
              break;
            default:
              (0, C.en)(!1, "unsupported transaction type", "type", e);
          }
        }
        get typeName() {
          switch (this.type) {
            case 0:
              return "legacy";
            case 1:
              return "eip-2930";
            case 2:
              return "eip-1559";
            case 3:
              return "eip-4844";
          }
          return null;
        }
        get to() {
          let e = this.#ex;
          return null == e && 3 === this.type ? s.N : e;
        }
        set to(e) {
          this.#ex = null == e ? null : (0, n.K)(e);
        }
        get nonce() {
          return this.#ek;
        }
        set nonce(e) {
          this.#ek = (0, eD.Dx)(e, "value");
        }
        get gasLimit() {
          return this.#eR;
        }
        set gasLimit(e) {
          this.#eR = (0, eD.yT)(e);
        }
        get gasPrice() {
          let e = this.#eD;
          return null == e && (0 === this.type || 1 === this.type) ? eH : e;
        }
        set gasPrice(e) {
          this.#eD = null == e ? null : (0, eD.yT)(e, "gasPrice");
        }
        get maxPriorityFeePerGas() {
          let e = this.#eU;
          return null == e
            ? 2 === this.type || 3 === this.type
              ? eH
              : null
            : e;
        }
        set maxPriorityFeePerGas(e) {
          this.#eU = null == e ? null : (0, eD.yT)(e, "maxPriorityFeePerGas");
        }
        get maxFeePerGas() {
          let e = this.#eL;
          return null == e
            ? 2 === this.type || 3 === this.type
              ? eH
              : null
            : e;
        }
        set maxFeePerGas(e) {
          this.#eL = null == e ? null : (0, eD.yT)(e, "maxFeePerGas");
        }
        get data() {
          return this.#r;
        }
        set data(e) {
          this.#r = (0, N.Dv)(e);
        }
        get value() {
          return this.#eM;
        }
        set value(e) {
          this.#eM = (0, eD.yT)(e, "value");
        }
        get chainId() {
          return this.#Y;
        }
        set chainId(e) {
          this.#Y = (0, eD.yT)(e);
        }
        get signature() {
          return this.#eB || null;
        }
        set signature(e) {
          this.#eB = null == e ? null : U.P.from(e);
        }
        get accessList() {
          let e = this.#ej || null;
          return null == e
            ? 1 === this.type || 2 === this.type || 3 === this.type
              ? []
              : null
            : e;
        }
        set accessList(e) {
          this.#ej = null == e ? null : (0, e$.z)(e);
        }
        get maxFeePerBlobGas() {
          let e = this.#eF;
          return null == e && 3 === this.type ? eH : e;
        }
        set maxFeePerBlobGas(e) {
          this.#eF = null == e ? null : (0, eD.yT)(e, "maxFeePerBlobGas");
        }
        get blobVersionedHashes() {
          let e = this.#e$;
          return null == e && 3 === this.type ? [] : e;
        }
        set blobVersionedHashes(e) {
          if (null != e) {
            (0, C.en)(
              Array.isArray(e),
              "blobVersionedHashes must be an Array",
              "value",
              e
            ),
              (e = e.slice());
            for (let t = 0; t < e.length; t++)
              (0, C.en)(
                (0, N.A7)(e[t], 32),
                "invalid blobVersionedHash",
                `value[${t}]`,
                e[t]
              );
          }
          this.#e$ = e;
        }
        get blobs() {
          return null == this.#ez
            ? null
            : this.#ez.map((e) => Object.assign({}, e));
        }
        set blobs(e) {
          if (null == e) {
            this.#ez = null;
            return;
          }
          let t = [],
            r = [];
          for (let i = 0; i < e.length; i++) {
            let n = e[i];
            if ((0, N.Zq)(n)) {
              (0, C.hu)(
                this.#eH,
                "adding a raw blob requires a KZG library",
                "UNSUPPORTED_OPERATION",
                { operation: "set blobs()" }
              );
              let e = (0, N.Pw)(n);
              if (
                ((0, C.en)(
                  e.length <= 131072,
                  "blob is too large",
                  `blobs[${i}]`,
                  n
                ),
                131072 !== e.length)
              ) {
                let t = new Uint8Array(131072);
                t.set(e), (e = t);
              }
              let s = this.#eH.blobToKzgCommitment(e),
                a = (0, N.Dv)(this.#eH.computeBlobKzgProof(e, s));
              t.push({
                data: (0, N.Dv)(e),
                commitment: (0, N.Dv)(s),
                proof: a,
              }),
                r.push(eK(1, s));
            } else {
              let e = (0, N.Dv)(n.commitment);
              t.push({
                data: (0, N.Dv)(n.data),
                commitment: e,
                proof: (0, N.Dv)(n.proof),
              }),
                r.push(eK(1, e));
            }
          }
          (this.#ez = t), (this.#e$ = r);
        }
        get kzg() {
          return this.#eH;
        }
        set kzg(e) {
          this.#eH = e;
        }
        constructor() {
          (this.#eO = null),
            (this.#ex = null),
            (this.#ek = 0),
            (this.#eR = eH),
            (this.#eD = null),
            (this.#eU = null),
            (this.#eL = null),
            (this.#r = "0x"),
            (this.#eM = eH),
            (this.#Y = eH),
            (this.#eB = null),
            (this.#ej = null),
            (this.#eF = null),
            (this.#e$ = null),
            (this.#ez = null),
            (this.#eH = null);
        }
        get hash() {
          return null == this.signature ? null : (0, L.w)(this.#eq(!0, !1));
        }
        get unsignedHash() {
          return (0, L.w)(this.unsignedSerialized);
        }
        get from() {
          var e, t, r;
          let i;
          return null == this.signature
            ? null
            : ((e = this.unsignedHash),
              (t = this.signature),
              (i =
                "string" == typeof (r = eU.recoverPublicKey(e, t))
                  ? eU.computePublicKey(r, !1)
                  : r.publicKey),
              (0, n.K)((0, L.w)("0x" + i.substring(4)).substring(26)));
        }
        get fromPublicKey() {
          return null == this.signature
            ? null
            : eU.recoverPublicKey(this.unsignedHash, this.signature);
        }
        isSigned() {
          return null != this.signature;
        }
        #eq(e, t) {
          (0, C.hu)(
            !e || null != this.signature,
            "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized",
            "UNSUPPORTED_OPERATION",
            { operation: ".serialized" }
          );
          let r = e ? this.signature : null;
          switch (this.inferType()) {
            case 0:
              return (function (e, t) {
                let r = [
                    eX(e.nonce, "nonce"),
                    eX(e.gasPrice || 0, "gasPrice"),
                    eX(e.gasLimit, "gasLimit"),
                    e.to || "0x",
                    eX(e.value, "value"),
                    e.data,
                  ],
                  i = eH;
                if (e.chainId != eH)
                  (i = (0, eD.yT)(e.chainId, "tx.chainId")),
                    (0, C.en)(
                      !t || null == t.networkV || t.legacyChainId === i,
                      "tx.chainId/sig.v mismatch",
                      "sig",
                      t
                    );
                else if (e.signature) {
                  let t = e.signature.legacyChainId;
                  null != t && (i = t);
                }
                if (!t)
                  return (
                    i !== eH &&
                      (r.push((0, eD.ot)(i)), r.push("0x"), r.push("0x")),
                    (0, eF.e)(r)
                  );
                let n = BigInt(27 + t.yParity);
                return (
                  i !== eH
                    ? (n = U.P.getChainIdV(i, t.v))
                    : BigInt(t.v) !== n &&
                      (0, C.en)(!1, "tx.chainId/sig.v mismatch", "sig", t),
                  r.push((0, eD.ot)(n)),
                  r.push((0, eD.ot)(t.r)),
                  r.push((0, eD.ot)(t.s)),
                  (0, eF.e)(r)
                );
              })(this, r);
            case 1:
              return (function (e, t) {
                let r = [
                  eX(e.chainId, "chainId"),
                  eX(e.nonce, "nonce"),
                  eX(e.gasPrice || 0, "gasPrice"),
                  eX(e.gasLimit, "gasLimit"),
                  e.to || "0x",
                  eX(e.value, "value"),
                  e.data,
                  e0(e.accessList || []),
                ];
                return (
                  t &&
                    (r.push(eX(t.yParity, "recoveryParam")),
                    r.push((0, eD.ot)(t.r)),
                    r.push((0, eD.ot)(t.s))),
                  (0, N.zo)(["0x01", (0, eF.e)(r)])
                );
              })(this, r);
            case 2:
              return (function (e, t) {
                let r = [
                  eX(e.chainId, "chainId"),
                  eX(e.nonce, "nonce"),
                  eX(e.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
                  eX(e.maxFeePerGas || 0, "maxFeePerGas"),
                  eX(e.gasLimit, "gasLimit"),
                  e.to || "0x",
                  eX(e.value, "value"),
                  e.data,
                  e0(e.accessList || []),
                ];
                return (
                  t &&
                    (r.push(eX(t.yParity, "yParity")),
                    r.push((0, eD.ot)(t.r)),
                    r.push((0, eD.ot)(t.s))),
                  (0, N.zo)(["0x02", (0, eF.e)(r)])
                );
              })(this, r);
            case 3:
              return (function (e, t, r) {
                let i = [
                  eX(e.chainId, "chainId"),
                  eX(e.nonce, "nonce"),
                  eX(e.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
                  eX(e.maxFeePerGas || 0, "maxFeePerGas"),
                  eX(e.gasLimit, "gasLimit"),
                  e.to || s.N,
                  eX(e.value, "value"),
                  e.data,
                  e0(e.accessList || []),
                  eX(e.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
                  (function (e, t) {
                    (0, C.en)(Array.isArray(e), `invalid ${t}`, "value", e);
                    for (let t = 0; t < e.length; t++)
                      (0, C.en)(
                        (0, N.A7)(e[t], 32),
                        "invalid ${ param } hash",
                        `value[${t}]`,
                        e[t]
                      );
                    return e;
                  })(e.blobVersionedHashes || [], "blobVersionedHashes"),
                ];
                return t &&
                  (i.push(eX(t.yParity, "yParity")),
                  i.push((0, eD.ot)(t.r)),
                  i.push((0, eD.ot)(t.s)),
                  r)
                  ? (0, N.zo)([
                      "0x03",
                      (0, eF.e)([
                        i,
                        r.map((e) => e.data),
                        r.map((e) => e.commitment),
                        r.map((e) => e.proof),
                      ]),
                    ])
                  : (0, N.zo)(["0x03", (0, eF.e)(i)]);
              })(this, r, t ? this.blobs : null);
          }
          (0, C.hu)(
            !1,
            "unsupported transaction type",
            "UNSUPPORTED_OPERATION",
            { operation: ".serialized" }
          );
        }
        get serialized() {
          return this.#eq(!0, !0);
        }
        get unsignedSerialized() {
          return this.#eq(!1, !1);
        }
        inferType() {
          let e = this.inferTypes();
          return e.indexOf(2) >= 0 ? 2 : e.pop();
        }
        inferTypes() {
          let e = null != this.gasPrice,
            t = null != this.maxFeePerGas || null != this.maxPriorityFeePerGas,
            r = null != this.accessList,
            i = null != this.#eF || this.#e$;
          null != this.maxFeePerGas &&
            null != this.maxPriorityFeePerGas &&
            (0, C.hu)(
              this.maxFeePerGas >= this.maxPriorityFeePerGas,
              "priorityFee cannot be more than maxFee",
              "BAD_DATA",
              { value: this }
            ),
            (0, C.hu)(
              !t || (0 !== this.type && 1 !== this.type),
              "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas",
              "BAD_DATA",
              { value: this }
            ),
            (0, C.hu)(
              0 !== this.type || !r,
              "legacy transaction cannot have accessList",
              "BAD_DATA",
              { value: this }
            );
          let n = [];
          return (
            null != this.type
              ? n.push(this.type)
              : t
              ? n.push(2)
              : e
              ? (n.push(1), r || n.push(0))
              : r
              ? (n.push(1), n.push(2))
              : ((i && this.to) || (n.push(0), n.push(1), n.push(2)),
                n.push(3)),
            n.sort(),
            n
          );
        }
        isLegacy() {
          return 0 === this.type;
        }
        isBerlin() {
          return 1 === this.type;
        }
        isLondon() {
          return 2 === this.type;
        }
        isCancun() {
          return 3 === this.type;
        }
        clone() {
          return e2.from(this);
        }
        toJSON() {
          let e = (e) => (null == e ? null : e.toString());
          return {
            type: this.type,
            to: this.to,
            data: this.data,
            nonce: this.nonce,
            gasLimit: e(this.gasLimit),
            gasPrice: e(this.gasPrice),
            maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
            maxFeePerGas: e(this.maxFeePerGas),
            value: e(this.value),
            chainId: e(this.chainId),
            sig: this.signature ? this.signature.toJSON() : null,
            accessList: this.accessList,
          };
        }
        static from(e) {
          if (null == e) return new e2();
          if ("string" == typeof e) {
            let t = (0, N.Pw)(e);
            if (t[0] >= 127)
              return e2.from(
                (function (e) {
                  let t = ej(e);
                  (0, C.en)(
                    Array.isArray(t) && (9 === t.length || 6 === t.length),
                    "invalid field count for legacy transaction",
                    "data",
                    e
                  );
                  let r = {
                    type: 0,
                    nonce: eQ(t[0], "nonce"),
                    gasPrice: eY(t[1], "gasPrice"),
                    gasLimit: eY(t[2], "gasLimit"),
                    to: eZ(t[3]),
                    value: eY(t[4], "value"),
                    data: (0, N.Dv)(t[5]),
                    chainId: eH,
                  };
                  if (6 === t.length) return r;
                  let i = eY(t[6], "v"),
                    n = eY(t[7], "r"),
                    s = eY(t[8], "s");
                  if (n === eH && s === eH) r.chainId = i;
                  else {
                    let e = (i - eG) / ez;
                    e < eH && (e = eH),
                      (r.chainId = e),
                      (0, C.en)(
                        e !== eH || i === eq || i === eV,
                        "non-canonical legacy v",
                        "v",
                        t[6]
                      ),
                      (r.signature = U.P.from({
                        r: (0, N.U3)(t[7], 32),
                        s: (0, N.U3)(t[8], 32),
                        v: i,
                      }));
                  }
                  return r;
                })(t)
              );
            switch (t[0]) {
              case 1:
                return e2.from(
                  (function (e) {
                    let t = ej((0, N.Pw)(e).slice(1));
                    (0, C.en)(
                      Array.isArray(t) && (8 === t.length || 11 === t.length),
                      "invalid field count for transaction type: 1",
                      "data",
                      (0, N.Dv)(e)
                    );
                    let r = {
                      type: 1,
                      chainId: eY(t[0], "chainId"),
                      nonce: eQ(t[1], "nonce"),
                      gasPrice: eY(t[2], "gasPrice"),
                      gasLimit: eY(t[3], "gasLimit"),
                      to: eZ(t[4]),
                      value: eY(t[5], "value"),
                      data: (0, N.Dv)(t[6]),
                      accessList: eJ(t[7], "accessList"),
                    };
                    return 8 === t.length || e1(r, t.slice(8)), r;
                  })(t)
                );
              case 2:
                return e2.from(
                  (function (e) {
                    let t = ej((0, N.Pw)(e).slice(1));
                    (0, C.en)(
                      Array.isArray(t) && (9 === t.length || 12 === t.length),
                      "invalid field count for transaction type: 2",
                      "data",
                      (0, N.Dv)(e)
                    );
                    let r = {
                      type: 2,
                      chainId: eY(t[0], "chainId"),
                      nonce: eQ(t[1], "nonce"),
                      maxPriorityFeePerGas: eY(t[2], "maxPriorityFeePerGas"),
                      maxFeePerGas: eY(t[3], "maxFeePerGas"),
                      gasPrice: null,
                      gasLimit: eY(t[4], "gasLimit"),
                      to: eZ(t[5]),
                      value: eY(t[6], "value"),
                      data: (0, N.Dv)(t[7]),
                      accessList: eJ(t[8], "accessList"),
                    };
                    return 9 === t.length || e1(r, t.slice(9)), r;
                  })(t)
                );
              case 3:
                return e2.from(
                  (function (e) {
                    let t = ej((0, N.Pw)(e).slice(1)),
                      r = "3",
                      i = null;
                    if (4 === t.length && Array.isArray(t[0])) {
                      r = "3 (network format)";
                      let e = t[1],
                        n = t[2],
                        s = t[3];
                      (0, C.en)(
                        Array.isArray(e),
                        "invalid network format: blobs not an array",
                        "fields[1]",
                        e
                      ),
                        (0, C.en)(
                          Array.isArray(n),
                          "invalid network format: commitments not an array",
                          "fields[2]",
                          n
                        ),
                        (0, C.en)(
                          Array.isArray(s),
                          "invalid network format: proofs not an array",
                          "fields[3]",
                          s
                        ),
                        (0, C.en)(
                          e.length === n.length,
                          "invalid network format: blobs/commitments length mismatch",
                          "fields",
                          t
                        ),
                        (0, C.en)(
                          e.length === s.length,
                          "invalid network format: blobs/proofs length mismatch",
                          "fields",
                          t
                        ),
                        (i = []);
                      for (let r = 0; r < t[1].length; r++)
                        i.push({ data: e[r], commitment: n[r], proof: s[r] });
                      t = t[0];
                    }
                    (0, C.en)(
                      Array.isArray(t) && (11 === t.length || 14 === t.length),
                      `invalid field count for transaction type: ${r}`,
                      "data",
                      (0, N.Dv)(e)
                    );
                    let n = {
                      type: 3,
                      chainId: eY(t[0], "chainId"),
                      nonce: eQ(t[1], "nonce"),
                      maxPriorityFeePerGas: eY(t[2], "maxPriorityFeePerGas"),
                      maxFeePerGas: eY(t[3], "maxFeePerGas"),
                      gasPrice: null,
                      gasLimit: eY(t[4], "gasLimit"),
                      to: eZ(t[5]),
                      value: eY(t[6], "value"),
                      data: (0, N.Dv)(t[7]),
                      accessList: eJ(t[8], "accessList"),
                      maxFeePerBlobGas: eY(t[9], "maxFeePerBlobGas"),
                      blobVersionedHashes: t[10],
                    };
                    i && (n.blobs = i),
                      (0, C.en)(
                        null != n.to,
                        `invalid address for transaction type: ${r}`,
                        "data",
                        e
                      ),
                      (0, C.en)(
                        Array.isArray(n.blobVersionedHashes),
                        "invalid blobVersionedHashes: must be an array",
                        "data",
                        e
                      );
                    for (let t = 0; t < n.blobVersionedHashes.length; t++)
                      (0, C.en)(
                        (0, N.A7)(n.blobVersionedHashes[t], 32),
                        `invalid blobVersionedHash at index ${t}: must be length 32`,
                        "data",
                        e
                      );
                    return 11 === t.length || e1(n, t.slice(11)), n;
                  })(t)
                );
            }
            (0, C.hu)(
              !1,
              "unsupported transaction type",
              "UNSUPPORTED_OPERATION",
              { operation: "from" }
            );
          }
          let t = new e2();
          return (
            null != e.type && (t.type = e.type),
            null != e.to && (t.to = e.to),
            null != e.nonce && (t.nonce = e.nonce),
            null != e.gasLimit && (t.gasLimit = e.gasLimit),
            null != e.gasPrice && (t.gasPrice = e.gasPrice),
            null != e.maxPriorityFeePerGas &&
              (t.maxPriorityFeePerGas = e.maxPriorityFeePerGas),
            null != e.maxFeePerGas && (t.maxFeePerGas = e.maxFeePerGas),
            null != e.maxFeePerBlobGas &&
              (t.maxFeePerBlobGas = e.maxFeePerBlobGas),
            null != e.data && (t.data = e.data),
            null != e.value && (t.value = e.value),
            null != e.chainId && (t.chainId = e.chainId),
            null != e.signature && (t.signature = U.P.from(e.signature)),
            null != e.accessList && (t.accessList = e.accessList),
            null != e.blobVersionedHashes &&
              (t.blobVersionedHashes = e.blobVersionedHashes),
            null != e.kzg && (t.kzg = e.kzg),
            null != e.blobs && (t.blobs = e.blobs),
            null != e.hash &&
              ((0, C.en)(
                t.isSigned(),
                "unsigned transaction cannot define '.hash'",
                "tx",
                e
              ),
              (0, C.en)(t.hash === e.hash, "hash mismatch", "tx", e)),
            null != e.from &&
              ((0, C.en)(
                t.isSigned(),
                "unsigned transaction cannot define '.from'",
                "tx",
                e
              ),
              (0, C.en)(
                t.from.toLowerCase() === (e.from || "").toLowerCase(),
                "from mismatch",
                "tx",
                e
              )),
            t
          );
        }
      }
    },
    59369: function (e, t, r) {
      "use strict";
      r.d(t, {
        A7: function () {
          return o;
        },
        Dv: function () {
          return u;
        },
        M5: function () {
          return d;
        },
        Pw: function () {
          return s;
        },
        QB: function () {
          return p;
        },
        SK: function () {
          return m;
        },
        U3: function () {
          return g;
        },
        Zq: function () {
          return l;
        },
        h_: function () {
          return a;
        },
        zo: function () {
          return h;
        },
      });
      var i = r(35157);
      function n(e, t, r) {
        if (e instanceof Uint8Array) return r ? new Uint8Array(e) : e;
        if ("string" == typeof e && e.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
          let t = new Uint8Array((e.length - 2) / 2),
            r = 2;
          for (let i = 0; i < t.length; i++)
            (t[i] = parseInt(e.substring(r, r + 2), 16)), (r += 2);
          return t;
        }
        (0, i.en)(!1, "invalid BytesLike value", t || "value", e);
      }
      function s(e, t) {
        return n(e, t, !1);
      }
      function a(e, t) {
        return n(e, t, !0);
      }
      function o(e, t) {
        return (
          !!("string" == typeof e && e.match(/^0x[0-9A-Fa-f]*$/)) &&
          ("number" != typeof t || e.length === 2 + 2 * t) &&
          (!0 !== t || e.length % 2 == 0)
        );
      }
      function l(e) {
        return o(e, !0) || e instanceof Uint8Array;
      }
      let c = "0123456789abcdef";
      function u(e) {
        let t = s(e),
          r = "0x";
        for (let e = 0; e < t.length; e++) {
          let i = t[e];
          r += c[(240 & i) >> 4] + c[15 & i];
        }
        return r;
      }
      function h(e) {
        return "0x" + e.map((e) => u(e).substring(2)).join("");
      }
      function d(e) {
        return o(e, !0) ? (e.length - 2) / 2 : s(e).length;
      }
      function p(e, t, r) {
        let n = s(e);
        return (
          null != r &&
            r > n.length &&
            (0, i.hu)(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
              buffer: n,
              length: n.length,
              offset: r,
            }),
          u(n.slice(null == t ? 0 : t, null == r ? n.length : r))
        );
      }
      function f(e, t, r) {
        let n = s(e);
        (0, i.hu)(
          t >= n.length,
          "padding exceeds data length",
          "BUFFER_OVERRUN",
          { buffer: new Uint8Array(n), length: t, offset: t + 1 }
        );
        let a = new Uint8Array(t);
        return a.fill(0), r ? a.set(n, t - n.length) : a.set(n, 0), u(a);
      }
      function g(e, t) {
        return f(e, t, !0);
      }
      function m(e, t) {
        return f(e, t, !1);
      }
    },
    35157: function (e, t, r) {
      "use strict";
      r.d(t, {
        hu: function () {
          return l;
        },
        en: function () {
          return c;
        },
        fG: function () {
          return u;
        },
        fA: function () {
          return d;
        },
        NK: function () {
          return p;
        },
        Hl: function () {
          return a;
        },
        VZ: function () {
          return s;
        },
        wf: function () {
          return o;
        },
      });
      var i = r(69781);
      function n(e) {
        if (null == e) return "null";
        if (Array.isArray(e)) return "[ " + e.map(n).join(", ") + " ]";
        if (e instanceof Uint8Array) {
          let t = "0123456789abcdef",
            r = "0x";
          for (let i = 0; i < e.length; i++) r += t[e[i] >> 4] + t[15 & e[i]];
          return r;
        }
        if ("object" == typeof e && "function" == typeof e.toJSON)
          return n(e.toJSON());
        switch (typeof e) {
          case "boolean":
          case "symbol":
          case "number":
            return e.toString();
          case "bigint":
            return BigInt(e).toString();
          case "string":
            return JSON.stringify(e);
          case "object": {
            let t = Object.keys(e);
            return (
              t.sort(),
              "{ " + t.map((t) => `${n(t)}: ${n(e[t])}`).join(", ") + " }"
            );
          }
        }
        return "[ COULD NOT SERIALIZE ]";
      }
      function s(e, t) {
        return e && e.code === t;
      }
      function a(e) {
        return s(e, "CALL_EXCEPTION");
      }
      function o(e, t, r) {
        let s,
          a = e;
        {
          let i = [];
          if (r) {
            if ("message" in r || "code" in r || "name" in r)
              throw Error(`value will overwrite populated values: ${n(r)}`);
            for (let e in r) {
              if ("shortMessage" === e) continue;
              let t = r[e];
              i.push(e + "=" + n(t));
            }
          }
          i.push(`code=${t}`),
            i.push("version=6.13.5"),
            i.length && (e += " (" + i.join(", ") + ")");
        }
        switch (t) {
          case "INVALID_ARGUMENT":
            s = TypeError(e);
            break;
          case "NUMERIC_FAULT":
          case "BUFFER_OVERRUN":
            s = RangeError(e);
            break;
          default:
            s = Error(e);
        }
        return (
          (0, i.h)(s, { code: t }),
          r && Object.assign(s, r),
          null == s.shortMessage && (0, i.h)(s, { shortMessage: a }),
          s
        );
      }
      function l(e, t, r, i) {
        if (!e) throw o(t, r, i);
      }
      function c(e, t, r, i) {
        l(e, t, "INVALID_ARGUMENT", { argument: r, value: i });
      }
      function u(e, t, r) {
        null == r && (r = ""),
          r && (r = ": " + r),
          l(e >= t, "missing argument" + r, "MISSING_ARGUMENT", {
            count: e,
            expectedCount: t,
          }),
          l(e <= t, "too many arguments" + r, "UNEXPECTED_ARGUMENT", {
            count: e,
            expectedCount: t,
          });
      }
      let h = ["NFD", "NFC", "NFKD", "NFKC"].reduce((e, t) => {
        try {
          if ("test" !== "test".normalize(t)) throw Error("bad");
          if ("NFD" === t) {
            let e = String.fromCharCode(233).normalize("NFD"),
              t = String.fromCharCode(101, 769);
            if (e !== t) throw Error("broken");
          }
          e.push(t);
        } catch (e) {}
        return e;
      }, []);
      function d(e) {
        l(
          h.indexOf(e) >= 0,
          "platform missing String.prototype.normalize",
          "UNSUPPORTED_OPERATION",
          { operation: "String.prototype.normalize", info: { form: e } }
        );
      }
      function p(e, t, r) {
        if ((null == r && (r = ""), e !== t)) {
          let e = r,
            t = "new";
          r && ((e += "."), (t += " " + r)),
            l(
              !1,
              `private constructor; use ${e}from* methods`,
              "UNSUPPORTED_OPERATION",
              { operation: t }
            );
        }
      }
    },
    15968: function (e, t, r) {
      "use strict";
      r.d(t, {
        Z: function () {
          return n;
        },
      });
      var i = r(69781);
      class n {
        filter;
        emitter;
        #eV;
        constructor(e, t, r) {
          (this.#eV = t), (0, i.h)(this, { emitter: e, filter: r });
        }
        async removeListener() {
          null != this.#eV && (await this.emitter.off(this.filter, this.#eV));
        }
      }
    },
    81741: function (e, t, r) {
      "use strict";
      r.d(t, {
        gd: function () {
          return w;
        },
      });
      var i = r(59369),
        n = r(35157),
        s = r(69781),
        a = r(9478);
      function o(e) {
        return async function (e, t) {
          let r;
          (0, n.hu)(
            null == t || !t.cancelled,
            "request cancelled before sending",
            "CANCELLED"
          );
          let i = e.url.split(":")[0].toLowerCase();
          (0, n.hu)(
            "http" === i || "https" === i,
            `unsupported protocol ${i}`,
            "UNSUPPORTED_OPERATION",
            { info: { protocol: i }, operation: "request" }
          ),
            (0, n.hu)(
              "https" === i || !e.credentials || e.allowInsecureAuthentication,
              "insecure authorized connections unsupported",
              "UNSUPPORTED_OPERATION",
              { operation: "request" }
            );
          let s = null,
            a = new AbortController(),
            o = setTimeout(() => {
              (s = (0, n.wf)("request timeout", "TIMEOUT")), a.abort();
            }, e.timeout);
          t &&
            t.addListener(() => {
              (s = (0, n.wf)("request cancelled", "CANCELLED")), a.abort();
            });
          let l = {
            method: e.method,
            headers: new Headers(Array.from(e)),
            body: e.body || void 0,
            signal: a.signal,
          };
          try {
            r = await fetch(e.url, l);
          } catch (e) {
            if ((clearTimeout(o), s)) throw s;
            throw e;
          }
          clearTimeout(o);
          let c = {};
          r.headers.forEach((e, t) => {
            c[t.toLowerCase()] = e;
          });
          let u = await r.arrayBuffer(),
            h = null == u ? null : new Uint8Array(u);
          return {
            statusCode: r.status,
            statusMessage: r.statusText,
            headers: c,
            body: h,
          };
        };
      }
      o({});
      let l = o(),
        c = RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
        u = RegExp("^ipfs://(ipfs/)?(.*)$", "i"),
        h = !1;
      async function d(e, t) {
        try {
          var r;
          let t = e.match(c);
          if (!t) throw Error("invalid data");
          return new b(
            200,
            "OK",
            { "content-type": t[1] || "text/plain" },
            t[2]
              ? (function (e) {
                  let t = new Uint8Array((e = atob(e)).length);
                  for (let r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);
                  return (0, i.Pw)(t);
                })(t[3])
              : ((r = t[3]),
                (0, a.Y0)(
                  r.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) =>
                    String.fromCharCode(parseInt(t, 16))
                  )
                ))
          );
        } catch (t) {
          return new b(
            599,
            "BAD REQUEST (invalid data: URI)",
            {},
            null,
            new w(e)
          );
        }
      }
      function p(e) {
        return async function (t, r) {
          try {
            let r = t.match(u);
            if (!r) throw Error("invalid link");
            return new w(`${e}${r[2]}`);
          } catch (e) {
            return new b(
              599,
              "BAD REQUEST (invalid IPFS URI)",
              {},
              null,
              new w(t)
            );
          }
        };
      }
      let f = { data: d, ipfs: p("https://gateway.ipfs.io/ipfs/") },
        g = new WeakMap();
      class m {
        #eG;
        #eW;
        constructor(e) {
          (this.#eG = []),
            (this.#eW = !1),
            g.set(e, () => {
              if (!this.#eW) {
                for (let e of ((this.#eW = !0), this.#eG))
                  setTimeout(() => {
                    e();
                  }, 0);
                this.#eG = [];
              }
            });
        }
        addListener(e) {
          (0, n.hu)(
            !this.#eW,
            "singal already cancelled",
            "UNSUPPORTED_OPERATION",
            { operation: "fetchCancelSignal.addCancelListener" }
          ),
            this.#eG.push(e);
        }
        get cancelled() {
          return this.#eW;
        }
        checkSignal() {
          (0, n.hu)(!this.cancelled, "cancelled", "CANCELLED", {});
        }
      }
      function y(e) {
        if (null == e) throw Error("missing signal; should not happen");
        return e.checkSignal(), e;
      }
      class w {
        #eK;
        #eZ;
        #eJ;
        #eQ;
        #eY;
        #Z;
        #eX;
        #e0;
        #e1;
        #e2;
        #e3;
        #e5;
        #e8;
        #e4;
        #e6;
        get url() {
          return this.#Z;
        }
        set url(e) {
          this.#Z = String(e);
        }
        get body() {
          return null == this.#eX ? null : new Uint8Array(this.#eX);
        }
        set body(e) {
          if (null == e) (this.#eX = void 0), (this.#e0 = void 0);
          else if ("string" == typeof e)
            (this.#eX = (0, a.Y0)(e)), (this.#e0 = "text/plain");
          else if (e instanceof Uint8Array)
            (this.#eX = e), (this.#e0 = "application/octet-stream");
          else if ("object" == typeof e)
            (this.#eX = (0, a.Y0)(JSON.stringify(e))),
              (this.#e0 = "application/json");
          else throw Error("invalid body");
        }
        hasBody() {
          return null != this.#eX;
        }
        get method() {
          return this.#eQ ? this.#eQ : this.hasBody() ? "POST" : "GET";
        }
        set method(e) {
          null == e && (e = ""), (this.#eQ = String(e).toUpperCase());
        }
        get headers() {
          let e = Object.assign({}, this.#eJ);
          return (
            this.#e1 &&
              (e.authorization = `Basic ${(function (e) {
                let t = (0, i.Pw)(e),
                  r = "";
                for (let e = 0; e < t.length; e++)
                  r += String.fromCharCode(t[e]);
                return btoa(r);
              })((0, a.Y0)(this.#e1))}`),
            this.allowGzip && (e["accept-encoding"] = "gzip"),
            null == e["content-type"] &&
              this.#e0 &&
              (e["content-type"] = this.#e0),
            this.body && (e["content-length"] = String(this.body.length)),
            e
          );
        }
        getHeader(e) {
          return this.headers[e.toLowerCase()];
        }
        setHeader(e, t) {
          this.#eJ[String(e).toLowerCase()] = String(t);
        }
        clearHeaders() {
          this.#eJ = {};
        }
        [Symbol.iterator]() {
          let e = this.headers,
            t = Object.keys(e),
            r = 0;
          return {
            next: () => {
              if (r < t.length) {
                let i = t[r++];
                return { value: [i, e[i]], done: !1 };
              }
              return { value: void 0, done: !0 };
            },
          };
        }
        get credentials() {
          return this.#e1 || null;
        }
        setCredentials(e, t) {
          (0, n.en)(
            !e.match(/:/),
            "invalid basic authentication username",
            "username",
            "[REDACTED]"
          ),
            (this.#e1 = `${e}:${t}`);
        }
        get allowGzip() {
          return this.#eZ;
        }
        set allowGzip(e) {
          this.#eZ = !!e;
        }
        get allowInsecureAuthentication() {
          return !!this.#eK;
        }
        set allowInsecureAuthentication(e) {
          this.#eK = !!e;
        }
        get timeout() {
          return this.#eY;
        }
        set timeout(e) {
          (0, n.en)(e >= 0, "timeout must be non-zero", "timeout", e),
            (this.#eY = e);
        }
        get preflightFunc() {
          return this.#e2 || null;
        }
        set preflightFunc(e) {
          this.#e2 = e;
        }
        get processFunc() {
          return this.#e3 || null;
        }
        set processFunc(e) {
          this.#e3 = e;
        }
        get retryFunc() {
          return this.#e5 || null;
        }
        set retryFunc(e) {
          this.#e5 = e;
        }
        get getUrlFunc() {
          return this.#e6 || l;
        }
        set getUrlFunc(e) {
          this.#e6 = e;
        }
        constructor(e) {
          (this.#Z = String(e)),
            (this.#eK = !1),
            (this.#eZ = !0),
            (this.#eJ = {}),
            (this.#eQ = ""),
            (this.#eY = 3e5),
            (this.#e4 = { slotInterval: 250, maxAttempts: 12 }),
            (this.#e6 = null);
        }
        toString() {
          return `<FetchRequest method=${JSON.stringify(
            this.method
          )} url=${JSON.stringify(this.url)} headers=${JSON.stringify(
            this.headers
          )} body=${this.#eX ? (0, i.Dv)(this.#eX) : "null"}>`;
        }
        setThrottleParams(e) {
          null != e.slotInterval && (this.#e4.slotInterval = e.slotInterval),
            null != e.maxAttempts && (this.#e4.maxAttempts = e.maxAttempts);
        }
        async #e9(e, t, r, i, s) {
          if (e >= this.#e4.maxAttempts)
            return s.makeServerError("exceeded maximum retry limit");
          (0, n.hu)(v() <= t, "timeout", "TIMEOUT", {
            operation: "request.send",
            reason: "timeout",
            request: i,
          }),
            r > 0 && (await new Promise((e) => setTimeout(e, r)));
          let a = this.clone(),
            o = (a.url.split(":")[0] || "").toLowerCase();
          if (o in f) {
            let e = await f[o](a.url, y(i.#e8));
            if (e instanceof b) {
              let t = e;
              if (this.processFunc) {
                y(i.#e8);
                try {
                  t = await this.processFunc(a, t);
                } catch (e) {
                  (null == e.throttle || "number" != typeof e.stall) &&
                    t
                      .makeServerError("error in post-processing function", e)
                      .assertOk();
                }
              }
              return t;
            }
            a = e;
          }
          this.preflightFunc && (a = await this.preflightFunc(a));
          let l = await this.getUrlFunc(a, y(i.#e8)),
            c = new b(l.statusCode, l.statusMessage, l.headers, l.body, i);
          if (301 === c.statusCode || 302 === c.statusCode) {
            try {
              let r = c.headers.location || "";
              return a.redirect(r).#e9(e + 1, t, 0, i, c);
            } catch (e) {}
            return c;
          }
          if (
            429 === c.statusCode &&
            (null == this.retryFunc || (await this.retryFunc(a, c, e)))
          ) {
            let r = c.headers["retry-after"],
              n =
                this.#e4.slotInterval *
                Math.trunc(Math.random() * Math.pow(2, e));
            return (
              "string" == typeof r &&
                r.match(/^[1-9][0-9]*$/) &&
                (n = parseInt(r)),
              a.clone().#e9(e + 1, t, n, i, c)
            );
          }
          if (this.processFunc) {
            y(i.#e8);
            try {
              c = await this.processFunc(a, c);
            } catch (n) {
              (null == n.throttle || "number" != typeof n.stall) &&
                c
                  .makeServerError("error in post-processing function", n)
                  .assertOk();
              let r =
                this.#e4.slotInterval *
                Math.trunc(Math.random() * Math.pow(2, e));
              return (
                n.stall >= 0 && (r = n.stall), a.clone().#e9(e + 1, t, r, i, c)
              );
            }
          }
          return c;
        }
        send() {
          return (
            (0, n.hu)(
              null == this.#e8,
              "request already sent",
              "UNSUPPORTED_OPERATION",
              { operation: "fetchRequest.send" }
            ),
            (this.#e8 = new m(this)),
            this.#e9(
              0,
              v() + this.timeout,
              0,
              this,
              new b(0, "", {}, null, this)
            )
          );
        }
        cancel() {
          (0, n.hu)(
            null != this.#e8,
            "request has not been sent",
            "UNSUPPORTED_OPERATION",
            { operation: "fetchRequest.cancel" }
          );
          let e = g.get(this);
          if (!e) throw Error("missing signal; should not happen");
          e();
        }
        redirect(e) {
          let t = this.url.split(":")[0].toLowerCase(),
            r = e.split(":")[0].toLowerCase();
          (0, n.hu)(
            "GET" === this.method &&
              ("https" !== t || "http" !== r) &&
              e.match(/^https?:/),
            "unsupported redirect",
            "UNSUPPORTED_OPERATION",
            {
              operation: `redirect(${this.method} ${JSON.stringify(
                this.url
              )} => ${JSON.stringify(e)})`,
            }
          );
          let i = new w(e);
          return (
            (i.method = "GET"),
            (i.allowGzip = this.allowGzip),
            (i.timeout = this.timeout),
            (i.#eJ = Object.assign({}, this.#eJ)),
            this.#eX && (i.#eX = new Uint8Array(this.#eX)),
            (i.#e0 = this.#e0),
            i
          );
        }
        clone() {
          let e = new w(this.url);
          return (
            (e.#eQ = this.#eQ),
            this.#eX && (e.#eX = this.#eX),
            (e.#e0 = this.#e0),
            (e.#eJ = Object.assign({}, this.#eJ)),
            (e.#e1 = this.#e1),
            this.allowGzip && (e.allowGzip = !0),
            (e.timeout = this.timeout),
            this.allowInsecureAuthentication &&
              (e.allowInsecureAuthentication = !0),
            (e.#e2 = this.#e2),
            (e.#e3 = this.#e3),
            (e.#e5 = this.#e5),
            (e.#e4 = Object.assign({}, this.#e4)),
            (e.#e6 = this.#e6),
            e
          );
        }
        static lockConfig() {
          h = !0;
        }
        static getGateway(e) {
          return f[e.toLowerCase()] || null;
        }
        static registerGateway(e, t) {
          if ("http" === (e = e.toLowerCase()) || "https" === e)
            throw Error(`cannot intercept ${e}; use registerGetUrl`);
          if (h) throw Error("gateways locked");
          f[e] = t;
        }
        static registerGetUrl(e) {
          if (h) throw Error("gateways locked");
          l = e;
        }
        static createGetUrlFunc(e) {
          return o(e);
        }
        static createDataGateway() {
          return d;
        }
        static createIpfsGatewayFunc(e) {
          return p(e);
        }
      }
      class b {
        #e7;
        #te;
        #eJ;
        #eX;
        #X;
        #tt;
        toString() {
          return `<FetchResponse status=${this.statusCode} body=${
            this.#eX ? (0, i.Dv)(this.#eX) : "null"
          }>`;
        }
        get statusCode() {
          return this.#e7;
        }
        get statusMessage() {
          return this.#te;
        }
        get headers() {
          return Object.assign({}, this.#eJ);
        }
        get body() {
          return null == this.#eX ? null : new Uint8Array(this.#eX);
        }
        get bodyText() {
          try {
            return null == this.#eX ? "" : (0, a.ZN)(this.#eX);
          } catch (e) {
            (0, n.hu)(
              !1,
              "response body is not valid UTF-8 data",
              "UNSUPPORTED_OPERATION",
              { operation: "bodyText", info: { response: this } }
            );
          }
        }
        get bodyJson() {
          try {
            return JSON.parse(this.bodyText);
          } catch (e) {
            (0, n.hu)(
              !1,
              "response body is not valid JSON",
              "UNSUPPORTED_OPERATION",
              { operation: "bodyJson", info: { response: this } }
            );
          }
        }
        [Symbol.iterator]() {
          let e = this.headers,
            t = Object.keys(e),
            r = 0;
          return {
            next: () => {
              if (r < t.length) {
                let i = t[r++];
                return { value: [i, e[i]], done: !1 };
              }
              return { value: void 0, done: !0 };
            },
          };
        }
        constructor(e, t, r, i, n) {
          (this.#e7 = e),
            (this.#te = t),
            (this.#eJ = Object.keys(r).reduce(
              (e, t) => ((e[t.toLowerCase()] = String(r[t])), e),
              {}
            )),
            (this.#eX = null == i ? null : new Uint8Array(i)),
            (this.#X = n || null),
            (this.#tt = { message: "" });
        }
        makeServerError(e, t) {
          let r;
          e
            ? (r = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${e})`)
            : ((e = `${this.statusCode} ${this.statusMessage}`),
              (r = `CLIENT ESCALATED SERVER ERROR (${e})`));
          let i = new b(599, r, this.headers, this.body, this.#X || void 0);
          return (i.#tt = { message: e, error: t }), i;
        }
        throwThrottleError(e, t) {
          null == t
            ? (t = -1)
            : (0, n.en)(
                Number.isInteger(t) && t >= 0,
                "invalid stall timeout",
                "stall",
                t
              );
          let r = Error(e || "throttling requests");
          throw ((0, s.h)(r, { stall: t, throttle: !0 }), r);
        }
        getHeader(e) {
          return this.headers[e.toLowerCase()];
        }
        hasBody() {
          return null != this.#eX;
        }
        get request() {
          return this.#X;
        }
        ok() {
          return (
            "" === this.#tt.message &&
            this.statusCode >= 200 &&
            this.statusCode < 300
          );
        }
        assertOk() {
          if (this.ok()) return;
          let { message: e, error: t } = this.#tt;
          "" === e &&
            (e = `server response ${this.statusCode} ${this.statusMessage}`);
          let r = null;
          this.request && (r = this.request.url);
          let i = null;
          try {
            this.#eX && (i = (0, a.ZN)(this.#eX));
          } catch (e) {}
          (0, n.hu)(!1, e, "SERVER_ERROR", {
            request: this.request || "unknown request",
            response: this,
            error: t,
            info: {
              requestUrl: r,
              responseBody: i,
              responseStatus: `${this.statusCode} ${this.statusMessage}`,
            },
          });
        }
      }
      function v() {
        return new Date().getTime();
      }
    },
    45474: function (e, t, r) {
      "use strict";
      r.d(t, {
        $j: function () {
          return l;
        },
        B4: function () {
          return w;
        },
        Dx: function () {
          return f;
        },
        Gh: function () {
          return p;
        },
        He: function () {
          return g;
        },
        _Y: function () {
          return o;
        },
        m9: function () {
          return m;
        },
        ot: function () {
          return y;
        },
        sS: function () {
          return c;
        },
        yT: function () {
          return u;
        },
      });
      var i = r(59369),
        n = r(35157);
      let s = BigInt(0),
        a = BigInt(1);
      function o(e, t) {
        let r = h(e, "value"),
          i = BigInt(f(t, "width"));
        return ((0, n.hu)(r >> i === s, "overflow", "NUMERIC_FAULT", {
          operation: "fromTwos",
          fault: "overflow",
          value: e,
        }),
        r >> (i - a))
          ? -((~r & ((a << i) - a)) + a)
          : r;
      }
      function l(e, t) {
        let r = u(e, "value"),
          i = BigInt(f(t, "width")),
          o = a << (i - a);
        return r < s
          ? ((r = -r),
            (0, n.hu)(r <= o, "too low", "NUMERIC_FAULT", {
              operation: "toTwos",
              fault: "overflow",
              value: e,
            }),
            (~r & ((a << i) - a)) + a)
          : ((0, n.hu)(r < o, "too high", "NUMERIC_FAULT", {
              operation: "toTwos",
              fault: "overflow",
              value: e,
            }),
            r);
      }
      function c(e, t) {
        return h(e, "value") & ((a << BigInt(f(t, "bits"))) - a);
      }
      function u(e, t) {
        switch (typeof e) {
          case "bigint":
            return e;
          case "number":
            return (
              (0, n.en)(Number.isInteger(e), "underflow", t || "value", e),
              (0, n.en)(
                e >= -9007199254740991 && e <= 9007199254740991,
                "overflow",
                t || "value",
                e
              ),
              BigInt(e)
            );
          case "string":
            try {
              if ("" === e) throw Error("empty string");
              if ("-" === e[0] && "-" !== e[1]) return -BigInt(e.substring(1));
              return BigInt(e);
            } catch (r) {
              (0, n.en)(
                !1,
                `invalid BigNumberish string: ${r.message}`,
                t || "value",
                e
              );
            }
        }
        (0, n.en)(!1, "invalid BigNumberish value", t || "value", e);
      }
      function h(e, t) {
        let r = u(e, t);
        return (
          (0, n.hu)(
            r >= s,
            "unsigned value cannot be negative",
            "NUMERIC_FAULT",
            { fault: "overflow", operation: "getUint", value: e }
          ),
          r
        );
      }
      let d = "0123456789abcdef";
      function p(e) {
        if (e instanceof Uint8Array) {
          let t = "0x0";
          for (let r of e) t += d[r >> 4] + d[15 & r];
          return BigInt(t);
        }
        return u(e);
      }
      function f(e, t) {
        switch (typeof e) {
          case "bigint":
            return (
              (0, n.en)(
                e >= -9007199254740991 && e <= 9007199254740991,
                "overflow",
                t || "value",
                e
              ),
              Number(e)
            );
          case "number":
            return (
              (0, n.en)(Number.isInteger(e), "underflow", t || "value", e),
              (0, n.en)(
                e >= -9007199254740991 && e <= 9007199254740991,
                "overflow",
                t || "value",
                e
              ),
              e
            );
          case "string":
            try {
              if ("" === e) throw Error("empty string");
              return f(BigInt(e), t);
            } catch (r) {
              (0, n.en)(
                !1,
                `invalid numeric string: ${r.message}`,
                t || "value",
                e
              );
            }
        }
        (0, n.en)(!1, "invalid numeric value", t || "value", e);
      }
      function g(e) {
        return f(p(e));
      }
      function m(e, t) {
        let r = h(e, "value").toString(16);
        if (null == t) r.length % 2 && (r = "0" + r);
        else {
          let i = f(t, "width");
          for (
            (0, n.hu)(
              2 * i >= r.length,
              `value exceeds width (${i} bytes)`,
              "NUMERIC_FAULT",
              { operation: "toBeHex", fault: "overflow", value: e }
            );
            r.length < 2 * i;

          )
            r = "0" + r;
        }
        return "0x" + r;
      }
      function y(e) {
        let t = h(e, "value");
        if (t === s) return new Uint8Array([]);
        let r = t.toString(16);
        r.length % 2 && (r = "0" + r);
        let i = new Uint8Array(r.length / 2);
        for (let e = 0; e < i.length; e++) {
          let t = 2 * e;
          i[e] = parseInt(r.substring(t, t + 2), 16);
        }
        return i;
      }
      function w(e) {
        let t = (0, i.Dv)((0, i.Zq)(e) ? e : y(e)).substring(2);
        for (; t.startsWith("0"); ) t = t.substring(1);
        return "" === t && (t = "0"), "0x" + t;
      }
    },
    69781: function (e, t, r) {
      "use strict";
      async function i(e) {
        let t = Object.keys(e);
        return (await Promise.all(t.map((t) => Promise.resolve(e[t])))).reduce(
          (e, r, i) => ((e[t[i]] = r), e),
          {}
        );
      }
      function n(e, t, r) {
        for (let i in t) {
          let n = t[i],
            s = r ? r[i] : null;
          s &&
            (function (e, t, r) {
              let i = t.split("|").map((e) => e.trim());
              for (let r = 0; r < i.length; r++)
                switch (t) {
                  case "any":
                    return;
                  case "bigint":
                  case "boolean":
                  case "number":
                  case "string":
                    if (typeof e === t) return;
                }
              let n = Error(`invalid value for type ${t}`);
              throw (
                ((n.code = "INVALID_ARGUMENT"),
                (n.argument = `value.${r}`),
                (n.value = e),
                n)
              );
            })(n, s, i),
            Object.defineProperty(e, i, {
              enumerable: !0,
              value: n,
              writable: !1,
            });
        }
      }
      r.d(t, {
        h: function () {
          return n;
        },
        m: function () {
          return i;
        },
      });
    },
    48996: function (e, t, r) {
      "use strict";
      r.d(t, {
        e: function () {
          return a;
        },
      });
      var i = r(59369);
      function n(e) {
        let t = [];
        for (; e; ) t.unshift(255 & e), (e >>= 8);
        return t;
      }
      let s = "0123456789abcdef";
      function a(e) {
        let t = "0x";
        for (let r of (function e(t) {
          if (Array.isArray(t)) {
            let r = [];
            if (
              (t.forEach(function (t) {
                r = r.concat(e(t));
              }),
              r.length <= 55)
            )
              return r.unshift(192 + r.length), r;
            let i = n(r.length);
            return i.unshift(247 + i.length), i.concat(r);
          }
          let r = Array.prototype.slice.call((0, i.Pw)(t, "object"));
          if (1 === r.length && r[0] <= 127) return r;
          if (r.length <= 55) return r.unshift(128 + r.length), r;
          let s = n(r.length);
          return s.unshift(183 + s.length), s.concat(r);
        })(e))
          t += s[r >> 4] + s[15 & r];
        return t;
      }
    },
    9478: function (e, t, r) {
      "use strict";
      r.d(t, {
        Y0: function () {
          return o;
        },
        ZN: function () {
          return l;
        },
      });
      var i = r(59369),
        n = r(35157);
      function s(e, t, r, i, n) {
        if ("BAD_PREFIX" === e || "UNEXPECTED_CONTINUE" === e) {
          let e = 0;
          for (let i = t + 1; i < r.length && r[i] >> 6 == 2; i++) e++;
          return e;
        }
        return "OVERRUN" === e ? r.length - t - 1 : 0;
      }
      let a = Object.freeze({
        error: function (e, t, r, i, s) {
          (0, n.en)(!1, `invalid codepoint at offset ${t}; ${e}`, "bytes", r);
        },
        ignore: s,
        replace: function (e, t, r, i, a) {
          return "OVERLONG" === e
            ? ((0, n.en)(
                "number" == typeof a,
                "invalid bad code point for replacement",
                "badCodepoint",
                a
              ),
              i.push(a),
              0)
            : (i.push(65533), s(e, t, r, i, a));
        },
      });
      function o(e, t) {
        (0, n.en)("string" == typeof e, "invalid string value", "str", e),
          null != t && ((0, n.fA)(t), (e = e.normalize(t)));
        let r = [];
        for (let t = 0; t < e.length; t++) {
          let i = e.charCodeAt(t);
          if (i < 128) r.push(i);
          else if (i < 2048) r.push((i >> 6) | 192), r.push((63 & i) | 128);
          else if ((64512 & i) == 55296) {
            t++;
            let s = e.charCodeAt(t);
            (0, n.en)(
              t < e.length && (64512 & s) == 56320,
              "invalid surrogate pair",
              "str",
              e
            );
            let a = 65536 + ((1023 & i) << 10) + (1023 & s);
            r.push((a >> 18) | 240),
              r.push(((a >> 12) & 63) | 128),
              r.push(((a >> 6) & 63) | 128),
              r.push((63 & a) | 128);
          } else
            r.push((i >> 12) | 224),
              r.push(((i >> 6) & 63) | 128),
              r.push((63 & i) | 128);
        }
        return new Uint8Array(r);
      }
      function l(e, t) {
        return (function (e, t) {
          null == t && (t = a.error);
          let r = (0, i.Pw)(e, "bytes"),
            n = [],
            s = 0;
          for (; s < r.length; ) {
            let e = r[s++];
            if (e >> 7 == 0) {
              n.push(e);
              continue;
            }
            let i = null,
              a = null;
            if ((224 & e) == 192) (i = 1), (a = 127);
            else if ((240 & e) == 224) (i = 2), (a = 2047);
            else if ((248 & e) == 240) (i = 3), (a = 65535);
            else {
              (192 & e) == 128
                ? (s += t("UNEXPECTED_CONTINUE", s - 1, r, n))
                : (s += t("BAD_PREFIX", s - 1, r, n));
              continue;
            }
            if (s - 1 + i >= r.length) {
              s += t("OVERRUN", s - 1, r, n);
              continue;
            }
            let o = e & ((1 << (8 - i - 1)) - 1);
            for (let e = 0; e < i; e++) {
              let e = r[s];
              if ((192 & e) != 128) {
                (s += t("MISSING_CONTINUE", s, r, n)), (o = null);
                break;
              }
              (o = (o << 6) | (63 & e)), s++;
            }
            if (null !== o) {
              if (o > 1114111) {
                s += t("OUT_OF_RANGE", s - 1 - i, r, n, o);
                continue;
              }
              if (o >= 55296 && o <= 57343) {
                s += t("UTF16_SURROGATE", s - 1 - i, r, n, o);
                continue;
              }
              if (o <= a) {
                s += t("OVERLONG", s - 1 - i, r, n, o);
                continue;
              }
              n.push(o);
            }
          }
          return n;
        })(e, t)
          .map((e) =>
            e <= 65535
              ? String.fromCharCode(e)
              : String.fromCharCode(
                  (((e -= 65536) >> 10) & 1023) + 55296,
                  (1023 & e) + 56320
                )
          )
          .join("");
      }
    },
    25655: function (e, t, r) {
      "use strict";
      function i(e) {
        if (!Number.isSafeInteger(e) || e < 0)
          throw Error(`Wrong positive integer: ${e}`);
      }
      function n(e, ...t) {
        if (!(e instanceof Uint8Array)) throw Error("Expected Uint8Array");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            `Expected Uint8Array of length ${t}, not of length=${e.length}`
          );
      }
      function s(e) {
        if ("function" != typeof e || "function" != typeof e.create)
          throw Error("Hash should be wrapped by utils.wrapConstructor");
        i(e.outputLen), i(e.blockLen);
      }
      function a(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      function o(e, t) {
        n(e);
        let r = t.outputLen;
        if (e.length < r)
          throw Error(
            `digestInto() expects output buffer of length at least ${r}`
          );
      }
      r.d(t, {
        Gg: function () {
          return a;
        },
        J8: function () {
          return o;
        },
        Rx: function () {
          return i;
        },
        aI: function () {
          return n;
        },
        vp: function () {
          return s;
        },
      });
    },
    64450: function (e, t, r) {
      "use strict";
      r.d(t, {
        EP: function () {
          return o;
        },
        SD: function () {
          return c;
        },
        Vl: function () {
          return a;
        },
        gm: function () {
          return l;
        },
        mk: function () {
          return u;
        },
      });
      let i = BigInt(4294967296 - 1),
        n = BigInt(32);
      function s(e, t = !1) {
        return t
          ? { h: Number(e & i), l: Number((e >> n) & i) }
          : { h: 0 | Number((e >> n) & i), l: 0 | Number(e & i) };
      }
      function a(e, t = !1) {
        let r = new Uint32Array(e.length),
          i = new Uint32Array(e.length);
        for (let n = 0; n < e.length; n++) {
          let { h: a, l: o } = s(e[n], t);
          [r[n], i[n]] = [a, o];
        }
        return [r, i];
      }
      let o = (e, t, r) => (e << r) | (t >>> (32 - r)),
        l = (e, t, r) => (t << r) | (e >>> (32 - r)),
        c = (e, t, r) => (t << (r - 32)) | (e >>> (64 - r)),
        u = (e, t, r) => (e << (r - 32)) | (t >>> (64 - r));
      t.ZP = {
        fromBig: s,
        split: a,
        toBig: (e, t) => (BigInt(e >>> 0) << n) | BigInt(t >>> 0),
        shrSH: (e, t, r) => e >>> r,
        shrSL: (e, t, r) => (e << (32 - r)) | (t >>> r),
        rotrSH: (e, t, r) => (e >>> r) | (t << (32 - r)),
        rotrSL: (e, t, r) => (e << (32 - r)) | (t >>> r),
        rotrBH: (e, t, r) => (e << (64 - r)) | (t >>> (r - 32)),
        rotrBL: (e, t, r) => (e >>> (r - 32)) | (t << (64 - r)),
        rotr32H: (e, t) => t,
        rotr32L: (e, t) => e,
        rotlSH: o,
        rotlSL: l,
        rotlBH: c,
        rotlBL: u,
        add: function (e, t, r, i) {
          let n = (t >>> 0) + (i >>> 0);
          return { h: (e + r + ((n / 4294967296) | 0)) | 0, l: 0 | n };
        },
        add3L: (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0),
        add3H: (e, t, r, i) => (t + r + i + ((e / 4294967296) | 0)) | 0,
        add4L: (e, t, r, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0),
        add4H: (e, t, r, i, n) => (t + r + i + n + ((e / 4294967296) | 0)) | 0,
        add5H: (e, t, r, i, n, s) =>
          (t + r + i + n + s + ((e / 4294967296) | 0)) | 0,
        add5L: (e, t, r, i, n) =>
          (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0) + (n >>> 0),
      };
    },
    35891: function (e, t, r) {
      "use strict";
      r.d(t, {
        kb: function () {
          return u;
        },
        eV: function () {
          return c;
        },
        GL: function () {
          return a;
        },
        O6: function () {
          return d;
        },
        np: function () {
          return o;
        },
        O0: function () {
          return l;
        },
        Jq: function () {
          return s;
        },
        hE: function () {
          return h;
        },
      });
      let i =
          "object" == typeof globalThis && "crypto" in globalThis
            ? globalThis.crypto
            : void 0,
        n = (e) => e instanceof Uint8Array,
        s = (e) =>
          new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
        a = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength),
        o = (e, t) => (e << (32 - t)) | (e >>> t);
      if (68 !== new Uint8Array(new Uint32Array([287454020]).buffer)[0])
        throw Error("Non little-endian hardware is not supported");
      function l(e) {
        if (
          ("string" == typeof e &&
            (e = (function (e) {
              if ("string" != typeof e)
                throw Error(`utf8ToBytes expected string, got ${typeof e}`);
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          !n(e))
        )
          throw Error(`expected Uint8Array, got ${typeof e}`);
        return e;
      }
      function c(...e) {
        let t = new Uint8Array(e.reduce((e, t) => e + t.length, 0)),
          r = 0;
        return (
          e.forEach((e) => {
            if (!n(e)) throw Error("Uint8Array expected");
            t.set(e, r), (r += e.length);
          }),
          t
        );
      }
      class u {
        clone() {
          return this._cloneInto();
        }
      }
      function h(e) {
        let t = (t) => e().update(l(t)).digest(),
          r = e();
        return (
          (t.outputLen = r.outputLen),
          (t.blockLen = r.blockLen),
          (t.create = () => e()),
          t
        );
      }
      function d(e = 32) {
        if (i && "function" == typeof i.getRandomValues)
          return i.getRandomValues(new Uint8Array(e));
        throw Error("crypto.getRandomValues must be defined");
      }
    },
    81997: function (e, t, r) {
      "use strict";
      r.d(t, {
        Jb: function () {
          return N;
        },
        Ld: function () {
          return S;
        },
        YP: function () {
          return I;
        },
        _$LH: function () {
          return $;
        },
        dy: function () {
          return _;
        },
        sY: function () {
          return z;
        },
      });
      let i = globalThis,
        n = i.trustedTypes,
        s = n ? n.createPolicy("lit-html", { createHTML: (e) => e }) : void 0,
        a = "$lit$",
        o = `lit$${Math.random().toFixed(9).slice(2)}$`,
        l = "?" + o,
        c = `<${l}>`,
        u = document,
        h = () => u.createComment(""),
        d = (e) =>
          null === e || ("object" != typeof e && "function" != typeof e),
        p = Array.isArray,
        f = (e) => p(e) || "function" == typeof e?.[Symbol.iterator],
        g = "[ 	\n\f\r]",
        m = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
        y = /-->/g,
        w = />/g,
        b = RegExp(
          `>|${g}(?:([^\\s"'>=/]+)(${g}*=${g}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,
          "g"
        ),
        v = /'/g,
        E = /"/g,
        A = /^(?:script|style|textarea|title)$/i,
        C =
          (e) =>
          (t, ...r) => ({ _$litType$: e, strings: t, values: r }),
        _ = C(1),
        I = C(2),
        N = (C(3), Symbol.for("lit-noChange")),
        S = Symbol.for("lit-nothing"),
        T = new WeakMap(),
        P = u.createTreeWalker(u, 129);
      function O(e, t) {
        if (!p(e) || !e.hasOwnProperty("raw"))
          throw Error("invalid template strings array");
        return void 0 !== s ? s.createHTML(t) : t;
      }
      let x = (e, t) => {
        let r = e.length - 1,
          i = [],
          n,
          s = 2 === t ? "<svg>" : 3 === t ? "<math>" : "",
          l = m;
        for (let t = 0; t < r; t++) {
          let r = e[t],
            u,
            h,
            d = -1,
            p = 0;
          for (
            ;
            p < r.length && ((l.lastIndex = p), null !== (h = l.exec(r)));

          )
            (p = l.lastIndex),
              l === m
                ? "!--" === h[1]
                  ? (l = y)
                  : void 0 !== h[1]
                  ? (l = w)
                  : void 0 !== h[2]
                  ? (A.test(h[2]) && (n = RegExp("</" + h[2], "g")), (l = b))
                  : void 0 !== h[3] && (l = b)
                : l === b
                ? ">" === h[0]
                  ? ((l = n ?? m), (d = -1))
                  : void 0 === h[1]
                  ? (d = -2)
                  : ((d = l.lastIndex - h[2].length),
                    (u = h[1]),
                    (l = void 0 === h[3] ? b : '"' === h[3] ? E : v))
                : l === E || l === v
                ? (l = b)
                : l === y || l === w
                ? (l = m)
                : ((l = b), (n = void 0));
          let f = l === b && e[t + 1].startsWith("/>") ? " " : "";
          s +=
            l === m
              ? r + c
              : d >= 0
              ? (i.push(u), r.slice(0, d) + a + r.slice(d) + o + f)
              : r + o + (-2 === d ? t : f);
        }
        return [
          O(
            e,
            s +
              (e[r] || "<?>") +
              (2 === t ? "</svg>" : 3 === t ? "</math>" : "")
          ),
          i,
        ];
      };
      class k {
        constructor({ strings: e, _$litType$: t }, r) {
          let i;
          this.parts = [];
          let s = 0,
            c = 0,
            u = e.length - 1,
            d = this.parts,
            [p, f] = x(e, t);
          if (
            ((this.el = k.createElement(p, r)),
            (P.currentNode = this.el.content),
            2 === t || 3 === t)
          ) {
            let e = this.el.content.firstChild;
            e.replaceWith(...e.childNodes);
          }
          for (; null !== (i = P.nextNode()) && d.length < u; ) {
            if (1 === i.nodeType) {
              if (i.hasAttributes())
                for (let e of i.getAttributeNames())
                  if (e.endsWith(a)) {
                    let t = f[c++],
                      r = i.getAttribute(e).split(o),
                      n = /([.?@])?(.*)/.exec(t);
                    d.push({
                      type: 1,
                      index: s,
                      name: n[2],
                      strings: r,
                      ctor:
                        "." === n[1]
                          ? M
                          : "?" === n[1]
                          ? B
                          : "@" === n[1]
                          ? j
                          : L,
                    }),
                      i.removeAttribute(e);
                  } else
                    e.startsWith(o) &&
                      (d.push({ type: 6, index: s }), i.removeAttribute(e));
              if (A.test(i.tagName)) {
                let e = i.textContent.split(o),
                  t = e.length - 1;
                if (t > 0) {
                  i.textContent = n ? n.emptyScript : "";
                  for (let r = 0; r < t; r++)
                    i.append(e[r], h()),
                      P.nextNode(),
                      d.push({ type: 2, index: ++s });
                  i.append(e[t], h());
                }
              }
            } else if (8 === i.nodeType) {
              if (i.data === l) d.push({ type: 2, index: s });
              else {
                let e = -1;
                for (; -1 !== (e = i.data.indexOf(o, e + 1)); )
                  d.push({ type: 7, index: s }), (e += o.length - 1);
              }
            }
            s++;
          }
        }
        static createElement(e, t) {
          let r = u.createElement("template");
          return (r.innerHTML = e), r;
        }
      }
      function R(e, t, r = e, i) {
        if (t === N) return t;
        let n = void 0 !== i ? r._$Co?.[i] : r._$Cl,
          s = d(t) ? void 0 : t._$litDirective$;
        return (
          n?.constructor !== s &&
            (n?._$AO?.(!1),
            void 0 === s ? (n = void 0) : (n = new s(e))._$AT(e, r, i),
            void 0 !== i ? ((r._$Co ??= [])[i] = n) : (r._$Cl = n)),
          void 0 !== n && (t = R(e, n._$AS(e, t.values), n, i)),
          t
        );
      }
      class D {
        constructor(e, t) {
          (this._$AV = []),
            (this._$AN = void 0),
            (this._$AD = e),
            (this._$AM = t);
        }
        get parentNode() {
          return this._$AM.parentNode;
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        u(e) {
          let {
              el: { content: t },
              parts: r,
            } = this._$AD,
            i = (e?.creationScope ?? u).importNode(t, !0);
          P.currentNode = i;
          let n = P.nextNode(),
            s = 0,
            a = 0,
            o = r[0];
          for (; void 0 !== o; ) {
            if (s === o.index) {
              let t;
              2 === o.type
                ? (t = new U(n, n.nextSibling, this, e))
                : 1 === o.type
                ? (t = new o.ctor(n, o.name, o.strings, this, e))
                : 6 === o.type && (t = new F(n, this, e)),
                this._$AV.push(t),
                (o = r[++a]);
            }
            s !== o?.index && ((n = P.nextNode()), s++);
          }
          return (P.currentNode = u), i;
        }
        p(e) {
          let t = 0;
          for (let r of this._$AV)
            void 0 !== r &&
              (void 0 !== r.strings
                ? (r._$AI(e, r, t), (t += r.strings.length - 2))
                : r._$AI(e[t])),
              t++;
        }
      }
      class U {
        get _$AU() {
          return this._$AM?._$AU ?? this._$Cv;
        }
        constructor(e, t, r, i) {
          (this.type = 2),
            (this._$AH = S),
            (this._$AN = void 0),
            (this._$AA = e),
            (this._$AB = t),
            (this._$AM = r),
            (this.options = i),
            (this._$Cv = i?.isConnected ?? !0);
        }
        get parentNode() {
          let e = this._$AA.parentNode,
            t = this._$AM;
          return void 0 !== t && 11 === e?.nodeType && (e = t.parentNode), e;
        }
        get startNode() {
          return this._$AA;
        }
        get endNode() {
          return this._$AB;
        }
        _$AI(e, t = this) {
          d((e = R(this, e, t)))
            ? e === S || null == e || "" === e
              ? (this._$AH !== S && this._$AR(), (this._$AH = S))
              : e !== this._$AH && e !== N && this._(e)
            : void 0 !== e._$litType$
            ? this.$(e)
            : void 0 !== e.nodeType
            ? this.T(e)
            : f(e)
            ? this.k(e)
            : this._(e);
        }
        O(e) {
          return this._$AA.parentNode.insertBefore(e, this._$AB);
        }
        T(e) {
          this._$AH !== e && (this._$AR(), (this._$AH = this.O(e)));
        }
        _(e) {
          this._$AH !== S && d(this._$AH)
            ? (this._$AA.nextSibling.data = e)
            : this.T(u.createTextNode(e)),
            (this._$AH = e);
        }
        $(e) {
          let { values: t, _$litType$: r } = e,
            i =
              "number" == typeof r
                ? this._$AC(e)
                : (void 0 === r.el &&
                    (r.el = k.createElement(O(r.h, r.h[0]), this.options)),
                  r);
          if (this._$AH?._$AD === i) this._$AH.p(t);
          else {
            let e = new D(i, this),
              r = e.u(this.options);
            e.p(t), this.T(r), (this._$AH = e);
          }
        }
        _$AC(e) {
          let t = T.get(e.strings);
          return void 0 === t && T.set(e.strings, (t = new k(e))), t;
        }
        k(e) {
          p(this._$AH) || ((this._$AH = []), this._$AR());
          let t = this._$AH,
            r,
            i = 0;
          for (let n of e)
            i === t.length
              ? t.push(
                  (r = new U(this.O(h()), this.O(h()), this, this.options))
                )
              : (r = t[i]),
              r._$AI(n),
              i++;
          i < t.length &&
            (this._$AR(r && r._$AB.nextSibling, i), (t.length = i));
        }
        _$AR(e = this._$AA.nextSibling, t) {
          for (this._$AP?.(!1, !0, t); e && e !== this._$AB; ) {
            let t = e.nextSibling;
            e.remove(), (e = t);
          }
        }
        setConnected(e) {
          void 0 === this._$AM && ((this._$Cv = e), this._$AP?.(e));
        }
      }
      class L {
        get tagName() {
          return this.element.tagName;
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        constructor(e, t, r, i, n) {
          (this.type = 1),
            (this._$AH = S),
            (this._$AN = void 0),
            (this.element = e),
            (this.name = t),
            (this._$AM = i),
            (this.options = n),
            r.length > 2 || "" !== r[0] || "" !== r[1]
              ? ((this._$AH = Array(r.length - 1).fill(new String())),
                (this.strings = r))
              : (this._$AH = S);
        }
        _$AI(e, t = this, r, i) {
          let n = this.strings,
            s = !1;
          if (void 0 === n)
            (s = !d((e = R(this, e, t, 0))) || (e !== this._$AH && e !== N)) &&
              (this._$AH = e);
          else {
            let i, a;
            let o = e;
            for (e = n[0], i = 0; i < n.length - 1; i++)
              (a = R(this, o[r + i], t, i)) === N && (a = this._$AH[i]),
                (s ||= !d(a) || a !== this._$AH[i]),
                a === S ? (e = S) : e !== S && (e += (a ?? "") + n[i + 1]),
                (this._$AH[i] = a);
          }
          s && !i && this.j(e);
        }
        j(e) {
          e === S
            ? this.element.removeAttribute(this.name)
            : this.element.setAttribute(this.name, e ?? "");
        }
      }
      class M extends L {
        constructor() {
          super(...arguments), (this.type = 3);
        }
        j(e) {
          this.element[this.name] = e === S ? void 0 : e;
        }
      }
      class B extends L {
        constructor() {
          super(...arguments), (this.type = 4);
        }
        j(e) {
          this.element.toggleAttribute(this.name, !!e && e !== S);
        }
      }
      class j extends L {
        constructor(e, t, r, i, n) {
          super(e, t, r, i, n), (this.type = 5);
        }
        _$AI(e, t = this) {
          if ((e = R(this, e, t, 0) ?? S) === N) return;
          let r = this._$AH,
            i =
              (e === S && r !== S) ||
              e.capture !== r.capture ||
              e.once !== r.once ||
              e.passive !== r.passive,
            n = e !== S && (r === S || i);
          i && this.element.removeEventListener(this.name, this, r),
            n && this.element.addEventListener(this.name, this, e),
            (this._$AH = e);
        }
        handleEvent(e) {
          "function" == typeof this._$AH
            ? this._$AH.call(this.options?.host ?? this.element, e)
            : this._$AH.handleEvent(e);
        }
      }
      class F {
        constructor(e, t, r) {
          (this.element = e),
            (this.type = 6),
            (this._$AN = void 0),
            (this._$AM = t),
            (this.options = r);
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        _$AI(e) {
          R(this, e);
        }
      }
      let $ = {
          M: a,
          P: o,
          A: l,
          C: 1,
          L: x,
          R: D,
          D: f,
          V: R,
          I: U,
          H: L,
          N: B,
          U: j,
          B: M,
          F: F,
        },
        H = i.litHtmlPolyfillSupport;
      H?.(k, U), (i.litHtmlVersions ??= []).push("3.2.1");
      let z = (e, t, r) => {
        let i = r?.renderBefore ?? t,
          n = i._$litPart$;
        if (void 0 === n) {
          let e = r?.renderBefore ?? null;
          i._$litPart$ = n = new U(t.insertBefore(h(), e), e, void 0, r ?? {});
        }
        return n._$AI(e), n;
      };
    },
    31133: function (e, t, r) {
      "use strict";
      r.d(t, {
        oi: function () {
          return s;
        },
        iv: function () {
          return i.iv;
        },
        dy: function () {
          return n.dy;
        },
        YP: function () {
          return n.YP;
        },
        $m: function () {
          return i.$m;
        },
      });
      var i = r(93511),
        n = r(81997);
      class s extends i.fl {
        constructor() {
          super(...arguments),
            (this.renderOptions = { host: this }),
            (this._$Do = void 0);
        }
        createRenderRoot() {
          let e = super.createRenderRoot();
          return (this.renderOptions.renderBefore ??= e.firstChild), e;
        }
        update(e) {
          let t = this.render();
          this.hasUpdated ||
            (this.renderOptions.isConnected = this.isConnected),
            super.update(e),
            (this._$Do = (0, n.sY)(t, this.renderRoot, this.renderOptions));
        }
        connectedCallback() {
          super.connectedCallback(), this._$Do?.setConnected(!0);
        }
        disconnectedCallback() {
          super.disconnectedCallback(), this._$Do?.setConnected(!1);
        }
        render() {
          return n.Jb;
        }
      }
      (s._$litElement$ = !0),
        (s.finalized = !0),
        globalThis.litElementHydrateSupport?.({ LitElement: s });
      let a = globalThis.litElementPolyfillSupport;
      a?.({ LitElement: s }),
        (globalThis.litElementVersions ??= []).push("4.1.1");
    },
    15708: function (e, t, r) {
      "use strict";
      r.d(t, {
        CO: function () {
          return u;
        },
        Ld: function () {
          return c;
        },
        iH: function () {
          return h;
        },
        sj: function () {
          return l;
        },
      });
      var i = r(84716);
      let n = (e) => "object" == typeof e && null !== e,
        s = new WeakMap(),
        a = new WeakSet(),
        [o] = ((
          e = Object.is,
          t = (e, t) => new Proxy(e, t),
          r = (e) =>
            n(e) &&
            !a.has(e) &&
            (Array.isArray(e) || !(Symbol.iterator in e)) &&
            !(e instanceof WeakMap) &&
            !(e instanceof WeakSet) &&
            !(e instanceof Error) &&
            !(e instanceof Number) &&
            !(e instanceof Date) &&
            !(e instanceof String) &&
            !(e instanceof RegExp) &&
            !(e instanceof ArrayBuffer),
          o = (e) => {
            switch (e.status) {
              case "fulfilled":
                return e.value;
              case "rejected":
                throw e.reason;
              default:
                throw e;
            }
          },
          l = new WeakMap(),
          c = (e, t, r = o) => {
            let n = l.get(e);
            if ((null == n ? void 0 : n[0]) === t) return n[1];
            let u = Array.isArray(e)
              ? []
              : Object.create(Object.getPrototypeOf(e));
            return (
              (0, i.jc)(u, !0),
              l.set(e, [t, u]),
              Reflect.ownKeys(e).forEach((t) => {
                if (Object.getOwnPropertyDescriptor(u, t)) return;
                let n = Reflect.get(e, t),
                  { enumerable: o } = Reflect.getOwnPropertyDescriptor(e, t),
                  l = { value: n, enumerable: o, configurable: !0 };
                if (a.has(n)) (0, i.jc)(n, !1);
                else if (n instanceof Promise)
                  delete l.value, (l.get = () => r(n));
                else if (s.has(n)) {
                  let [e, t] = s.get(n);
                  l.value = c(e, t(), r);
                }
                Object.defineProperty(u, t, l);
              }),
              Object.preventExtensions(u)
            );
          },
          u = new WeakMap(),
          h = [1, 1],
          d = (o) => {
            if (!n(o)) throw Error("object required");
            let l = u.get(o);
            if (l) return l;
            let p = h[0],
              f = new Set(),
              g = (e, t = ++h[0]) => {
                p !== t && ((p = t), f.forEach((r) => r(e, t)));
              },
              m = h[1],
              y = (e = ++h[1]) => (
                m === e ||
                  f.size ||
                  ((m = e),
                  b.forEach(([t]) => {
                    let r = t[1](e);
                    r > p && (p = r);
                  })),
                p
              ),
              w = (e) => (t, r) => {
                let i = [...t];
                (i[1] = [e, ...i[1]]), g(i, r);
              },
              b = new Map(),
              v = (e, t) => {
                if (b.has(e)) throw Error("prop listener already exists");
                if (f.size) {
                  let r = t[3](w(e));
                  b.set(e, [t, r]);
                } else b.set(e, [t]);
              },
              E = (e) => {
                var t;
                let r = b.get(e);
                r && (b.delete(e), null == (t = r[1]) || t.call(r));
              },
              A = (e) => {
                f.add(e),
                  1 === f.size &&
                    b.forEach(([e, t], r) => {
                      if (t) throw Error("remove already exists");
                      let i = e[3](w(r));
                      b.set(r, [e, i]);
                    });
                let t = () => {
                  f.delete(e),
                    0 === f.size &&
                      b.forEach(([e, t], r) => {
                        t && (t(), b.set(r, [e]));
                      });
                };
                return t;
              },
              C = Array.isArray(o)
                ? []
                : Object.create(Object.getPrototypeOf(o)),
              _ = {
                deleteProperty(e, t) {
                  let r = Reflect.get(e, t);
                  E(t);
                  let i = Reflect.deleteProperty(e, t);
                  return i && g(["delete", [t], r]), i;
                },
                set(t, o, l, c) {
                  let h = Reflect.has(t, o),
                    p = Reflect.get(t, o, c);
                  if (h && (e(p, l) || (u.has(l) && e(p, u.get(l))))) return !0;
                  E(o), n(l) && (l = (0, i.o5)(l) || l);
                  let f = l;
                  if (l instanceof Promise)
                    l.then((e) => {
                      (l.status = "fulfilled"),
                        (l.value = e),
                        g(["resolve", [o], e]);
                    }).catch((e) => {
                      (l.status = "rejected"),
                        (l.reason = e),
                        g(["reject", [o], e]);
                    });
                  else {
                    !s.has(l) && r(l) && (f = d(l));
                    let e = !a.has(f) && s.get(f);
                    e && v(o, e);
                  }
                  return Reflect.set(t, o, f, c), g(["set", [o], l, p]), !0;
                },
              },
              I = t(C, _);
            u.set(o, I);
            let N = [C, y, c, A];
            return (
              s.set(I, N),
              Reflect.ownKeys(o).forEach((e) => {
                let t = Object.getOwnPropertyDescriptor(o, e);
                "value" in t &&
                  ((I[e] = o[e]), delete t.value, delete t.writable),
                  Object.defineProperty(C, e, t);
              }),
              I
            );
          }
        ) => [d, s, a, e, t, r, o, l, c, u, h])();
      function l(e = {}) {
        return o(e);
      }
      function c(e, t, r) {
        let i;
        let n = s.get(e);
        n || console.warn("Please use proxy object");
        let a = [],
          o = n[3],
          l = !1,
          c = o((e) => {
            if ((a.push(e), r)) {
              t(a.splice(0));
              return;
            }
            i ||
              (i = Promise.resolve().then(() => {
                (i = void 0), l && t(a.splice(0));
              }));
          });
        return (
          (l = !0),
          () => {
            (l = !1), c();
          }
        );
      }
      function u(e, t) {
        let r = s.get(e);
        r || console.warn("Please use proxy object");
        let [i, n, a] = r;
        return a(i, n(), t);
      }
      function h(e) {
        return a.add(e), e;
      }
    },
    55543: function (e, t, r) {
      "use strict";
      r.d(t, {
        VW: function () {
          return n;
        },
        Yr: function () {
          return s;
        },
      });
      var i = r(15708);
      function n(e, t, r, n) {
        let s = e[t];
        return (0, i.Ld)(
          e,
          () => {
            let i = e[t];
            Object.is(s, i) || r((s = i));
          },
          n
        );
      }
      function s(e) {
        let t = (0, i.sj)({
          data: Array.from(e || []),
          has(e) {
            return this.data.some((t) => t[0] === e);
          },
          set(e, t) {
            let r = this.data.find((t) => t[0] === e);
            return r ? (r[1] = t) : this.data.push([e, t]), this;
          },
          get(e) {
            var t;
            return null == (t = this.data.find((t) => t[0] === e))
              ? void 0
              : t[1];
          },
          delete(e) {
            let t = this.data.findIndex((t) => t[0] === e);
            return -1 !== t && (this.data.splice(t, 1), !0);
          },
          clear() {
            this.data.splice(0);
          },
          get size() {
            return this.data.length;
          },
          toJSON() {
            return new Map(this.data);
          },
          forEach(e) {
            this.data.forEach((t) => {
              e(t[1], t[0], this);
            });
          },
          keys() {
            return this.data.map((e) => e[0]).values();
          },
          values() {
            return this.data.map((e) => e[1]).values();
          },
          entries() {
            return new Map(this.data).entries();
          },
          get [Symbol.toStringTag]() {
            return "Map";
          },
          [Symbol.iterator]() {
            return this.entries();
          },
        });
        return (
          Object.defineProperties(t, {
            data: { enumerable: !1 },
            size: { enumerable: !1 },
            toJSON: { enumerable: !1 },
          }),
          Object.seal(t),
          t
        );
      }
      Symbol();
    },
    98173: function (e, t, r) {
      "use strict";
      r.d(t, {
        Zn: function () {
          return n;
        },
        ez: function () {
          return i;
        },
      });
      let i = { gwei: 9, wei: 18 },
        n = { ether: -9, wei: 9 };
    },
    81544: function (e, t, r) {
      "use strict";
      r.d(t, {
        G: function () {
          return s;
        },
      });
      let i = "2.25.0",
        n = {
          getDocsUrl: ({ docsBaseUrl: e, docsPath: t = "", docsSlug: r }) =>
            t ? `${e ?? "https://viem.sh"}${t}${r ? `#${r}` : ""}` : void 0,
          version: `viem@${i}`,
        };
      class s extends Error {
        constructor(e, t = {}) {
          let r =
              t.cause instanceof s
                ? t.cause.details
                : t.cause?.message
                ? t.cause.message
                : t.details,
            a = (t.cause instanceof s && t.cause.docsPath) || t.docsPath,
            o = n.getDocsUrl?.({ ...t, docsPath: a });
          super(
            [
              e || "An error occurred.",
              "",
              ...(t.metaMessages ? [...t.metaMessages, ""] : []),
              ...(o ? [`Docs: ${o}`] : []),
              ...(r ? [`Details: ${r}`] : []),
              ...(n.version ? [`Version: ${n.version}`] : []),
            ].join("\n"),
            t.cause ? { cause: t.cause } : void 0
          ),
            Object.defineProperty(this, "details", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "docsPath", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "metaMessages", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "shortMessage", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "version", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "BaseError",
            }),
            (this.details = r),
            (this.docsPath = a),
            (this.metaMessages = t.metaMessages),
            (this.name = t.name ?? this.name),
            (this.shortMessage = e),
            (this.version = i);
        }
        walk(e) {
          return (function e(t, r) {
            return r?.(t)
              ? t
              : t && "object" == typeof t && "cause" in t && void 0 !== t.cause
              ? e(t.cause, r)
              : r
              ? null
              : t;
          })(this, e);
        }
      }
    },
    47116: function (e, t, r) {
      "use strict";
      r.d(t, {
        $s: function () {
          return s;
        },
        mV: function () {
          return n;
        },
      });
      var i = r(81544);
      class n extends i.G {
        constructor({ offset: e, position: t, size: r }) {
          super(
            `Slice ${
              "start" === t ? "starting" : "ending"
            } at offset "${e}" is out-of-bounds (size: ${r}).`,
            { name: "SliceOffsetOutOfBoundsError" }
          );
        }
      }
      class s extends i.G {
        constructor({ size: e, targetSize: t, type: r }) {
          super(
            `${r.charAt(0).toUpperCase()}${r
              .slice(1)
              .toLowerCase()} size (${e}) exceeds padding size (${t}).`,
            { name: "SizeExceedsPaddingSizeError" }
          );
        }
      }
    },
    63152: function (e, t, r) {
      "use strict";
      r.d(t, {
        J5: function () {
          return n;
        },
        M6: function () {
          return s;
        },
      });
      var i = r(81544);
      class n extends i.G {
        constructor({ max: e, min: t, signed: r, size: i, value: n }) {
          super(
            `Number "${n}" is not in safe ${
              i ? `${8 * i}-bit ${r ? "signed" : "unsigned"} ` : ""
            }integer range ${e ? `(${t} to ${e})` : `(above ${t})`}`,
            { name: "IntegerOutOfRangeError" }
          );
        }
      }
      class s extends i.G {
        constructor({ givenSize: e, maxSize: t }) {
          super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`, {
            name: "SizeOverflowError",
          });
        }
      }
    },
    78125: function (e, t, r) {
      "use strict";
      r.d(t, {
        Hh: function () {
          return a;
        },
        M_: function () {
          return s;
        },
        cs: function () {
          return g;
        },
      });
      var i = r(29707),
        n = r(81544);
      class s extends n.G {
        constructor({ cause: e, message: t } = {}) {
          let r = t
            ?.replace("execution reverted: ", "")
            ?.replace("execution reverted", "");
          super(
            `Execution reverted ${
              r ? `with reason: ${r}` : "for an unknown reason"
            }.`,
            { cause: e, name: "ExecutionRevertedError" }
          );
        }
      }
      Object.defineProperty(s, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 3,
      }),
        Object.defineProperty(s, "nodeMessage", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: /execution reverted/,
        });
      class a extends n.G {
        constructor({ cause: e, maxFeePerGas: t } = {}) {
          super(
            `The fee cap (\`maxFeePerGas\`${
              t ? ` = ${(0, i.o)(t)} gwei` : ""
            }) cannot be higher than the maximum allowed value (2^256-1).`,
            { cause: e, name: "FeeCapTooHighError" }
          );
        }
      }
      Object.defineProperty(a, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value:
          /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/,
      });
      class o extends n.G {
        constructor({ cause: e, maxFeePerGas: t } = {}) {
          super(
            `The fee cap (\`maxFeePerGas\`${
              t ? ` = ${(0, i.o)(t)}` : ""
            } gwei) cannot be lower than the block base fee.`,
            { cause: e, name: "FeeCapTooLowError" }
          );
        }
      }
      Object.defineProperty(o, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value:
          /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/,
      });
      class l extends n.G {
        constructor({ cause: e, nonce: t } = {}) {
          super(
            `Nonce provided for the transaction ${
              t ? `(${t}) ` : ""
            }is higher than the next one expected.`,
            { cause: e, name: "NonceTooHighError" }
          );
        }
      }
      Object.defineProperty(l, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /nonce too high/,
      });
      class c extends n.G {
        constructor({ cause: e, nonce: t } = {}) {
          super(
            `Nonce provided for the transaction ${
              t ? `(${t}) ` : ""
            }is lower than the current nonce of the account.
Try increasing the nonce or find the latest nonce with \`getTransactionCount\`.`,
            { cause: e, name: "NonceTooLowError" }
          );
        }
      }
      Object.defineProperty(c, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /nonce too low|transaction already imported|already known/,
      });
      class u extends n.G {
        constructor({ cause: e, nonce: t } = {}) {
          super(
            `Nonce provided for the transaction ${
              t ? `(${t}) ` : ""
            }exceeds the maximum allowed nonce.`,
            { cause: e, name: "NonceMaxValueError" }
          );
        }
      }
      Object.defineProperty(u, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /nonce has max value/,
      });
      class h extends n.G {
        constructor({ cause: e } = {}) {
          super(
            "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.",
            {
              cause: e,
              metaMessages: [
                "This error could arise when the account does not have enough funds to:",
                " - pay for the total gas fee,",
                " - pay for the value to send.",
                " ",
                "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
                " - `gas` is the amount of gas needed for transaction to execute,",
                " - `gas fee` is the gas fee,",
                " - `value` is the amount of ether to send to the recipient.",
              ],
              name: "InsufficientFundsError",
            }
          );
        }
      }
      Object.defineProperty(h, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /insufficient funds|exceeds transaction sender account balance/,
      });
      class d extends n.G {
        constructor({ cause: e, gas: t } = {}) {
          super(
            `The amount of gas ${
              t ? `(${t}) ` : ""
            }provided for the transaction exceeds the limit allowed for the block.`,
            { cause: e, name: "IntrinsicGasTooHighError" }
          );
        }
      }
      Object.defineProperty(d, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /intrinsic gas too high|gas limit reached/,
      });
      class p extends n.G {
        constructor({ cause: e, gas: t } = {}) {
          super(
            `The amount of gas ${
              t ? `(${t}) ` : ""
            }provided for the transaction is too low.`,
            { cause: e, name: "IntrinsicGasTooLowError" }
          );
        }
      }
      Object.defineProperty(p, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /intrinsic gas too low/,
      });
      class f extends n.G {
        constructor({ cause: e }) {
          super("The transaction type is not supported for this chain.", {
            cause: e,
            name: "TransactionTypeNotSupportedError",
          });
        }
      }
      Object.defineProperty(f, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /transaction type not valid/,
      });
      class g extends n.G {
        constructor({
          cause: e,
          maxPriorityFeePerGas: t,
          maxFeePerGas: r,
        } = {}) {
          super(
            `The provided tip (\`maxPriorityFeePerGas\`${
              t ? ` = ${(0, i.o)(t)} gwei` : ""
            }) cannot be higher than the fee cap (\`maxFeePerGas\`${
              r ? ` = ${(0, i.o)(r)} gwei` : ""
            }).`,
            { cause: e, name: "TipAboveFeeCapError" }
          );
        }
      }
      Object.defineProperty(g, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value:
          /max priority fee per gas higher than max fee per gas|tip higher than fee cap/,
      });
    },
    93610: function (e, t, r) {
      "use strict";
      function i(e, { strict: t = !0 } = {}) {
        return (
          !!e &&
          "string" == typeof e &&
          (t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x"))
        );
      }
      r.d(t, {
        v: function () {
          return i;
        },
      });
    },
    8796: function (e, t, r) {
      "use strict";
      r.d(t, {
        vk: function () {
          return n;
        },
      });
      var i = r(47116);
      function n(e, { dir: t, size: r = 32 } = {}) {
        return "string" == typeof e
          ? (function (e, { dir: t, size: r = 32 } = {}) {
              if (null === r) return e;
              let n = e.replace("0x", "");
              if (n.length > 2 * r)
                throw new i.$s({
                  size: Math.ceil(n.length / 2),
                  targetSize: r,
                  type: "hex",
                });
              return `0x${n["right" === t ? "padEnd" : "padStart"](
                2 * r,
                "0"
              )}`;
            })(e, { dir: t, size: r })
          : (function (e, { dir: t, size: r = 32 } = {}) {
              if (null === r) return e;
              if (e.length > r)
                throw new i.$s({
                  size: e.length,
                  targetSize: r,
                  type: "bytes",
                });
              let n = new Uint8Array(r);
              for (let i = 0; i < r; i++) {
                let s = "right" === t;
                n[s ? i : r - i - 1] = e[s ? i : e.length - i - 1];
              }
              return n;
            })(e, { dir: t, size: r });
      }
    },
    20556: function (e, t, r) {
      "use strict";
      r.d(t, {
        d: function () {
          return n;
        },
      });
      var i = r(93610);
      function n(e) {
        return (0, i.v)(e, { strict: !1 })
          ? Math.ceil((e.length - 2) / 2)
          : e.length;
      }
    },
    72932: function (e, t, r) {
      "use strict";
      r.d(t, {
        Yf: function () {
          return s;
        },
        ly: function () {
          return o;
        },
        y_: function () {
          return a;
        },
      });
      var i = r(63152),
        n = r(20556);
      function s(e, { size: t }) {
        if ((0, n.d)(e) > t)
          throw new i.M6({ givenSize: (0, n.d)(e), maxSize: t });
      }
      function a(e, t = {}) {
        let { signed: r } = t;
        t.size && s(e, { size: t.size });
        let i = BigInt(e);
        if (!r) return i;
        let n = (e.length - 2) / 2;
        return i <= (1n << (8n * BigInt(n) - 1n)) - 1n
          ? i
          : i - BigInt(`0x${"f".padStart(2 * n, "f")}`) - 1n;
      }
      function o(e, t = {}) {
        return Number(a(e, t));
      }
    },
    59455: function (e, t, r) {
      "use strict";
      r.d(t, {
        $G: function () {
          return h;
        },
        NC: function () {
          return o;
        },
        ci: function () {
          return l;
        },
        eC: function () {
          return c;
        },
      });
      var i = r(63152),
        n = r(8796),
        s = r(72932);
      let a = Array.from({ length: 256 }, (e, t) =>
        t.toString(16).padStart(2, "0")
      );
      function o(e, t = {}) {
        return "number" == typeof e || "bigint" == typeof e
          ? c(e, t)
          : "string" == typeof e
          ? h(e, t)
          : "boolean" == typeof e
          ? (function (e, t = {}) {
              let r = `0x${Number(e)}`;
              return "number" == typeof t.size
                ? ((0, s.Yf)(r, { size: t.size }),
                  (0, n.vk)(r, { size: t.size }))
                : r;
            })(e, t)
          : l(e, t);
      }
      function l(e, t = {}) {
        let r = "";
        for (let t = 0; t < e.length; t++) r += a[e[t]];
        let i = `0x${r}`;
        return "number" == typeof t.size
          ? ((0, s.Yf)(i, { size: t.size }),
            (0, n.vk)(i, { dir: "right", size: t.size }))
          : i;
      }
      function c(e, t = {}) {
        let r;
        let { signed: s, size: a } = t,
          o = BigInt(e);
        a
          ? (r = s
              ? (1n << (8n * BigInt(a) - 1n)) - 1n
              : 2n ** (8n * BigInt(a)) - 1n)
          : "number" == typeof e && (r = BigInt(Number.MAX_SAFE_INTEGER));
        let l = "bigint" == typeof r && s ? -r - 1n : 0;
        if ((r && o > r) || o < l) {
          let t = "bigint" == typeof e ? "n" : "";
          throw new i.J5({
            max: r ? `${r}${t}` : void 0,
            min: `${l}${t}`,
            signed: s,
            size: a,
            value: `${e}${t}`,
          });
        }
        let c = `0x${(s && o < 0
          ? (1n << BigInt(8 * a)) + BigInt(o)
          : o
        ).toString(16)}`;
        return a ? (0, n.vk)(c, { size: a }) : c;
      }
      let u = new TextEncoder();
      function h(e, t = {}) {
        return l(u.encode(e), t);
      }
    },
    82061: function (e, t, r) {
      "use strict";
      r.d(t, {
        k: function () {
          return i;
        },
      });
      class i extends Map {
        constructor(e) {
          super(),
            Object.defineProperty(this, "maxSize", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.maxSize = e);
        }
        get(e) {
          let t = super.get(e);
          return (
            super.has(e) && void 0 !== t && (this.delete(e), super.set(e, t)), t
          );
        }
        set(e, t) {
          if ((super.set(e, t), this.maxSize && this.size > this.maxSize)) {
            let e = this.keys().next().value;
            e && this.delete(e);
          }
          return this;
        }
      }
    },
    29707: function (e, t, r) {
      "use strict";
      r.d(t, {
        o: function () {
          return s;
        },
      });
      var i = r(98173),
        n = r(39502);
      function s(e, t = "wei") {
        return (0, n.b)(e, i.Zn[t]);
      }
    },
    39502: function (e, t, r) {
      "use strict";
      function i(e, t) {
        let r = e.toString(),
          i = r.startsWith("-");
        i && (r = r.slice(1));
        let [n, s] = [
          (r = r.padStart(t, "0")).slice(0, r.length - t),
          r.slice(r.length - t),
        ];
        return (
          (s = s.replace(/(0+)$/, "")),
          `${i ? "-" : ""}${n || "0"}${s ? `.${s}` : ""}`
        );
      }
      r.d(t, {
        b: function () {
          return i;
        },
      });
    },
  },
]);
